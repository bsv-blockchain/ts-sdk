{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"BSV TypeScript SDK Documentation","text":""},{"location":"#sdk-overview","title":"SDK Overview","text":"<p>The BSV TypeScript SDK is designed to provide an updated and unified layer for developing scalable applications on the BSV Blockchain. It addresses the limitations of previous tools by offering a fresh, peer-to-peer approach, adhering to SPV principles, and ensuring privacy and scalability.</p> <p>This documentation is organized to help you learn, solve problems, understand concepts, and find technical references.</p>"},{"location":"#documentation-categories","title":"Documentation Categories","text":""},{"location":"#tutorials","title":"\ud83d\ude80 Tutorials","text":"<p>Learn step-by-step with practical, guided examples:</p> <ul> <li>Your First BSV Transaction</li> <li>Key Management and Cryptography</li> <li>Transaction Broadcasting and ARC</li> <li>View all tutorials \u2192</li> </ul>"},{"location":"#how-to-guides","title":"\ud83d\udd27 How-To Guides","text":"<p>Problem-oriented guides for specific tasks:</p> <ul> <li>Creating Multi-signature Transactions</li> <li>Implementing Transaction Batching</li> <li>Configuring Custom ARC Endpoints</li> <li>View all guides \u2192</li> </ul>"},{"location":"#reference","title":"\ud83d\udcda Reference","text":"<p>Complete technical specifications and API documentation:</p> <ul> <li>BRC-100 Wallet Interface (Swagger)</li> <li>Primitives</li> <li>Script</li> <li>Transaction</li> <li>View all references \u2192</li> </ul>"},{"location":"#concepts-explanations","title":"\ud83c\udfd7\ufe0f Concepts &amp; Explanations","text":"<p>Understanding the architecture and design principles:</p> <ul> <li>SDK Design Philosophy</li> <li>Transaction Structure</li> <li>SPV Verification</li> <li>BEEF Format</li> <li>View all concepts \u2192</li> </ul>"},{"location":"#getting-started","title":"Getting Started","text":"<p>If you're new to the BSV TypeScript SDK, we recommend starting with our Getting Started Tutorial.</p>"},{"location":"#try-it-interactive","title":"Try It Interactive","text":"<p>\ud83d\ude80 Interactive BSV Coding Environment</p> <p>Experience the BSV TypeScript SDK directly in your browser! Our interactive coding environment lets you:</p> <ul> <li>Run SDK code examples without any setup</li> <li>Experiment with transactions, keys, and scripts in real-time  </li> <li>Learn by doing with immediate feedback</li> <li>Test concepts from our tutorials interactively</li> </ul> <p>Perfect for getting started quickly or experimenting with new ideas.</p>"},{"location":"#installation","title":"Installation","text":"<p>To install the SDK, run:</p> <pre><code>npm install @bsv/sdk\n</code></pre>"},{"location":"MARKDOWN_VALIDATION_GUIDE/","title":"Markdown Validation Guide for Teranode Documentation","text":"<p>This guide provides comprehensive solutions to prevent and catch markdown formatting issues that cause problems in Material MkDocs rendering.</p>"},{"location":"MARKDOWN_VALIDATION_GUIDE/#available-validation-tools","title":"\ud83d\udee0\ufe0f Available Validation Tools","text":""},{"location":"MARKDOWN_VALIDATION_GUIDE/#1-pre-commit-hooks-automatic","title":"1. Pre-commit Hooks (Automatic)","text":"<p>Setup: Already configured in <code>.pre-commit-config.yaml</code></p> <ul> <li>markdownlint: Catches formatting issues before commits</li> <li>Configuration: <code>.markdownlint.yml</code> with rules tailored for Material MkDocs</li> </ul> <p>Usage:</p> <pre><code># Install pre-commit hooks\npre-commit install\n\n# Run manually on all files\npre-commit run markdownlint --all-files\n</code></pre>"},{"location":"MARKDOWN_VALIDATION_GUIDE/#2-custom-validation-script","title":"2. Custom Validation Script","text":"<p>Location: <code>scripts/validate-markdown.py</code></p> <p>Features:</p> <ul> <li>Detects missing blank lines before lists</li> <li>Finds inconsistent nested bullet indentation</li> <li>Identifies configuration parameters missing Type/Default/Impact details</li> <li>Can automatically fix issues with <code>--fix</code> flag</li> </ul> <p>Usage:</p> <pre><code># Validate all documentation\npython3 scripts/validate-markdown.py docs/\n\n# Validate and auto-fix issues\npython3 scripts/validate-markdown.py docs/ --fix\n\n# Validate single file\npython3 scripts/validate-markdown.py docs/topics/services/alert.md\n</code></pre>"},{"location":"MARKDOWN_VALIDATION_GUIDE/#3-vs-code-extensions-real-time","title":"3. VS Code Extensions (Real-time)","text":"<p>Recommended Extensions:</p> <ul> <li>markdownlint: Real-time linting in editor</li> <li>Markdown All in One: Preview and formatting</li> <li>Material Theme: Better syntax highlighting</li> </ul> <p>Setup:</p> <ol> <li>Install extensions</li> <li>Add to VS Code settings.json:</li> </ol> <pre><code>{\n  \"markdownlint.config\": {\n    \"MD007\": { \"indent\": 4 },\n    \"MD032\": true,\n    \"MD013\": false\n  }\n}\n</code></pre>"},{"location":"MARKDOWN_VALIDATION_GUIDE/#common-issues-prevention","title":"\ud83c\udfaf Common Issues &amp; Prevention","text":""},{"location":"MARKDOWN_VALIDATION_GUIDE/#issue-1-missing-blank-lines-before-lists","title":"Issue 1: Missing Blank Lines Before Lists","text":"<p>Problem: Lists render inline instead of as proper lists Solution: Always add blank line before lists</p> <pre><code>\u274c Wrong:\nConfiguration options:\n\n- Option 1\n- Option 2\n\n\u2705 Correct:\nConfiguration options:\n\n- Option 1\n- Option 2\n</code></pre>"},{"location":"MARKDOWN_VALIDATION_GUIDE/#issue-2-inconsistent-nested-indentation","title":"Issue 2: Inconsistent Nested Indentation","text":"<p>Problem: Nested items don't render as nested Solution: Use exactly 4 spaces for nested items</p> <pre><code>\u274c Wrong:\n\n- Main item\n  - Nested item (2 spaces)\n\n\u2705 Correct:\n\n- Main item\n    - Nested item (4 spaces)\n</code></pre>"},{"location":"MARKDOWN_VALIDATION_GUIDE/#issue-3-configuration-parameter-formatting","title":"Issue 3: Configuration Parameter Formatting","text":"<p>Problem: Inconsistent parameter documentation Solution: Use standard format for all parameters</p> <pre><code>\u2705 Standard Format:\n1. **`parameter_name`**: Brief description.\n    - Type: string\n    - Default: \"value\"\n    - Impact: Detailed explanation of what this controls.\n</code></pre>"},{"location":"MARKDOWN_VALIDATION_GUIDE/#workflow-integration","title":"\ud83d\ude80 Workflow Integration","text":""},{"location":"MARKDOWN_VALIDATION_GUIDE/#daily-development","title":"Daily Development","text":"<ol> <li>VS Code Extensions: Real-time feedback while editing</li> <li>Pre-commit Hooks: Automatic validation before commits</li> <li>Custom Script: Bulk validation and fixes</li> </ol>"},{"location":"MARKDOWN_VALIDATION_GUIDE/#cicd-pipeline","title":"CI/CD Pipeline","text":"<ol> <li>GitHub Actions: Validate all PRs</li> <li>Deployment: Only deploy if validation passes</li> </ol>"},{"location":"MARKDOWN_VALIDATION_GUIDE/#periodic-maintenance","title":"Periodic Maintenance","text":"<pre><code># Weekly validation run\npython3 scripts/validate-markdown.py docs/ --fix\ngit add -A\ngit commit -m \"docs: fix markdown formatting issues\"\n</code></pre>"},{"location":"MARKDOWN_VALIDATION_GUIDE/#validation-checklist","title":"\ud83d\udccb Validation Checklist","text":"<p>Before committing documentation changes:</p> <ul> <li>[ ] Run custom validation script</li> <li>[ ] Check pre-commit hooks pass</li> <li>[ ] Preview in Material MkDocs locally</li> <li>[ ] Verify nested lists render correctly</li> <li>[ ] Confirm configuration parameters follow standard format</li> </ul>"},{"location":"MARKDOWN_VALIDATION_GUIDE/#quick-fixes","title":"\ud83d\udd27 Quick Fixes","text":"<p>Fix all formatting issues in docs:</p> <pre><code>python3 scripts/validate-markdown.py docs/ --fix\n</code></pre> <p>Run markdownlint:</p> <pre><code>markdownlint docs/ --config .markdownlint.yml --fix\n</code></pre> <p>Preview locally:</p> <pre><code>mkdocs serve\n# Open http://localhost:8000\n</code></pre> <p>This multi-layered approach ensures high-quality, consistently formatted documentation that renders perfectly in Material MkDocs.</p>"},{"location":"performance/","title":"BigNumber Benchmarks","text":"<p>The benchmark scripts measure extremely large number operations and script number serialization performance.</p> <p>All results below were gathered on Node.js v22.16.0 using the <code>dist</code> build of the SDK. Each benchmark was executed with 200,000-digit inputs to stress the implementation.</p>"},{"location":"performance/#addition-and-multiplication","title":"Addition and Multiplication","text":"<p>Command:</p> <pre><code>node benchmarks/bignumber-bench.js 200000 1 1\n</code></pre> Branch mul large numbers add large numbers master (pre-May-2025) 6364.11ms 13.04ms fix-mem (May-2025) 13.60ms 2.64ms"},{"location":"performance/#serialization","title":"Serialization","text":"<p>Command:</p> <pre><code>node benchmarks/serialization-bench.js 200000 1\n</code></pre> Branch toSm big toSm little fromSm big fromSm little fromScriptNum master (pre-May-2025) 6.12ms 10.11ms 6.35ms 12.56ms 3.39ms fix-mem (May-2025) 8.46ms 8.12ms 27.77ms 11.16ms 10.31ms"},{"location":"performance/#transaction-verification","title":"Transaction Verification","text":"<p>Command:</p> <pre><code>node benchmarks/transaction-bench.js\n</code></pre> Branch deep chain verify wide transaction verify large tx verify nested inputs verify fix-mem (May-2025) 3335.76ms 2930.86ms 1534.36ms 1198.08ms"},{"location":"performance/#symmetrickey-encryptiondecryption","title":"SymmetricKey Encryption/Decryption","text":"<p>Command:</p> <pre><code>node benchmarks/symmetric-key-bench.js\n</code></pre> Branch encrypt large 2MB decrypt large 2MB encrypt 50 small decrypt 50 small encrypt 200 medium decrypt 200 medium fix-mem baseline 8609.78ms 8372.23ms 34.02ms 48.58ms 859.38ms 960.16ms optimized AESGCM (round 1) 7678.65ms 7619.82ms 60.23ms 35.21ms 871.89ms 763.13ms optimized AESGCM (round 2) 2026.89ms 1793.35ms 15.01ms 7.88ms 213.35ms 169.37ms"},{"location":"performance/#readerwriter-operations","title":"Reader/Writer Operations","text":"<p>Command:</p> <pre><code>node benchmarks/reader-writer-bench.js\n</code></pre> Branch mixed ops large payloads 3000 small payloads 400 medium payloads fix-mem baseline 9.93ms 127.49ms 27.86ms 41.71ms optimized utils.ts 5.02ms 91.93ms 19.04ms 53.80ms"},{"location":"concepts/","title":"Concepts","text":"<p>Essential concepts for understanding and using the BSV TypeScript SDK effectively.</p>"},{"location":"concepts/#core-bitcoin-concepts","title":"Core Bitcoin Concepts","text":""},{"location":"concepts/#transaction-structure","title":"Transaction Structure","text":"<p>Understanding Bitcoin transactions, inputs, outputs, and how they work in the SDK.</p>"},{"location":"concepts/#script-templates","title":"Script Templates","text":"<p>Standard and custom Bitcoin script patterns available in the SDK.</p>"},{"location":"concepts/#digital-signatures","title":"Digital Signatures","text":"<p>How digital signatures work in Bitcoin and their implementation in the SDK.</p>"},{"location":"concepts/#transaction-verification","title":"Transaction Verification","text":"<p>Understanding how to verify Bitcoin transactions using the SDK.</p>"},{"location":"concepts/#spv-verification","title":"SPV Verification","text":"<p>Simplified Payment Verification and merkle proof concepts for lightweight clients.</p>"},{"location":"concepts/#transaction-fees","title":"Transaction Fees","text":"<p>How Bitcoin transaction fees work and fee optimization strategies.</p>"},{"location":"concepts/#sdk-architecture","title":"SDK Architecture","text":""},{"location":"concepts/#sdk-design-philosophy","title":"SDK Design Philosophy","text":"<p>Core principles: zero dependencies, SPV-first approach, and vendor neutrality.</p>"},{"location":"concepts/#wallet-integration","title":"Wallet Integration","text":"<p>How the SDK connects with Bitcoin wallets and manages authentication.</p>"},{"location":"concepts/#chain-tracking","title":"Chain Tracking","text":"<p>Understanding how the SDK interacts with the Bitcoin network for transaction data.</p>"},{"location":"concepts/#data-formats","title":"Data Formats","text":""},{"location":"concepts/#beef-format","title":"BEEF Format","text":"<p>Bitcoin Extras Extension Format for efficient transaction data exchange.</p>"},{"location":"concepts/#transaction-encoding","title":"Transaction Encoding","text":"<p>How transactions are serialized and deserialized in the SDK.</p>"},{"location":"concepts/#identity-and-certificates","title":"Identity and Certificates","text":""},{"location":"concepts/#decentralized-identity","title":"Decentralized Identity","text":"<p>Understanding BSV's decentralized identity system and certificate-based verification.</p>"},{"location":"concepts/#identity-certificates","title":"Identity Certificates","text":"<p>How cryptographic certificates work for identity claims and verification.</p>"},{"location":"concepts/#security-model","title":"Security Model","text":""},{"location":"concepts/#key-management","title":"Key Management","text":"<p>How private keys, public keys, and cryptographic operations work in the SDK.</p>"},{"location":"concepts/#trust-model","title":"Trust Model","text":"<p>Understanding the security assumptions and trust relationships in SDK applications.</p> <p>These concepts provide the foundational knowledge needed to build Bitcoin applications with the BSV TypeScript SDK. For deeper protocol details, refer to the BSV Skills Center.</p>"},{"location":"concepts/beef/","title":"BEEF Format","text":"<p>Bitcoin Extras Extension Format (BEEF) - an efficient way to package Bitcoin transactions with their verification data.</p>"},{"location":"concepts/beef/#what-is-beef","title":"What is BEEF?","text":"<p>BEEF is a standardized format that combines:</p> <ul> <li>Transaction Data: The actual Bitcoin transaction</li> <li>Merkle Proofs: SPV verification data</li> <li>Block Headers: Chain validation information</li> <li>Metadata: Additional context and references</li> </ul>"},{"location":"concepts/beef/#beef-in-the-sdk","title":"BEEF in the SDK","text":"<pre><code>import { Transaction } from '@bsv/sdk'\n\n// Create transaction with BEEF data\nconst tx = Transaction.fromHexBEEF(beefHex)\n\n// Serialize transaction to BEEF\nconst beefData = transaction.toBEEF()\n\n// Verify transaction using included proofs\nconst isValid = await tx.verify(chainTracker)\n</code></pre>"},{"location":"concepts/beef/#key-benefits","title":"Key Benefits","text":""},{"location":"concepts/beef/#efficiency","title":"Efficiency","text":"<ul> <li>Compact: Includes only necessary verification data</li> <li>Self-Contained: No external lookups required</li> <li>Batch Processing: Multiple transactions in one package</li> </ul>"},{"location":"concepts/beef/#spv-integration","title":"SPV Integration","text":"<ul> <li>Merkle Proofs: Verify transaction inclusion</li> <li>Block Headers: Validate proof of work</li> <li>Chain Context: Understand transaction position</li> </ul>"},{"location":"concepts/beef/#interoperability","title":"Interoperability","text":"<ul> <li>Standardized: Consistent format across applications</li> <li>Portable: Easy to transmit and store</li> <li>Compatible: Works with SPV clients</li> </ul>"},{"location":"concepts/beef/#use-cases","title":"Use Cases","text":""},{"location":"concepts/beef/#transaction-broadcasting","title":"Transaction Broadcasting","text":"<pre><code>// Broadcast transaction with proof\nconst beefTx = Transaction.fromHexBEEF(beefData)\nawait beefTx.broadcast(arcConfig)\n</code></pre>"},{"location":"concepts/beef/#data-exchange","title":"Data Exchange","text":"<ul> <li>Share transactions between applications</li> <li>Provide verification data to SPV clients</li> <li>Archive transactions with proofs</li> </ul>"},{"location":"concepts/beef/#wallet-integration","title":"Wallet Integration","text":"<ul> <li>Import transactions with full context</li> <li>Verify historical transactions</li> <li>Synchronize between devices</li> </ul>"},{"location":"concepts/beef/#beef-structure","title":"BEEF Structure","text":"<p>The format includes:</p> <ol> <li>Version: BEEF format version</li> <li>Transactions: One or more Bitcoin transactions</li> <li>Proofs: Merkle proofs for each transaction</li> <li>Headers: Relevant block headers</li> <li>Metadata: Additional application data</li> </ol>"},{"location":"concepts/beef/#best-practices","title":"Best Practices","text":"<ul> <li>Use BEEF for transactions that need verification</li> <li>Include minimal necessary proof data</li> <li>Validate BEEF structure before processing</li> <li>Cache parsed BEEF data for performance</li> </ul>"},{"location":"concepts/beef/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about SPV Verification concepts</li> <li>Understand Transaction Encoding formats</li> <li>Explore Chain Tracking integration</li> </ul>"},{"location":"concepts/chain-tracking/","title":"Chain Tracking","text":"<p>How the BSV TypeScript SDK interacts with the Bitcoin network to retrieve transaction and blockchain data.</p>"},{"location":"concepts/chain-tracking/#chain-tracker-concept","title":"Chain Tracker Concept","text":"<p>A chain tracker provides access to Bitcoin blockchain data without running a full node:</p> <pre><code>import { WhatsOnChain } from '@bsv/sdk'\n\n// Create a chain tracker\nconst chainTracker = new WhatsOnChain('mainnet')\n\n// Get transaction data\nconst txData = await chainTracker.getTransaction('txid')\n</code></pre>"},{"location":"concepts/chain-tracking/#key-functions","title":"Key Functions","text":""},{"location":"concepts/chain-tracking/#transaction-lookup","title":"Transaction Lookup","text":"<ul> <li>Retrieve transaction details by ID</li> <li>Get transaction status and confirmations</li> <li>Access transaction inputs and outputs</li> </ul>"},{"location":"concepts/chain-tracking/#utxo-queries","title":"UTXO Queries","text":"<ul> <li>Find unspent transaction outputs</li> <li>Check UTXO availability and value</li> <li>Retrieve UTXO locking scripts</li> </ul>"},{"location":"concepts/chain-tracking/#block-information","title":"Block Information","text":"<ul> <li>Get block headers and merkle proofs</li> <li>Verify transaction inclusion in blocks</li> <li>Access block timestamps and difficulty</li> </ul>"},{"location":"concepts/chain-tracking/#network-status","title":"Network Status","text":"<ul> <li>Check network connectivity</li> <li>Monitor chain tip and height</li> <li>Get fee rate recommendations</li> </ul>"},{"location":"concepts/chain-tracking/#spv-integration","title":"SPV Integration","text":"<p>Chain trackers enable SPV (Simplified Payment Verification):</p> <ul> <li>Merkle Proofs: Verify transaction inclusion without full blocks</li> <li>Header Chain: Maintain block headers for proof verification</li> <li>Lightweight: Minimal data requirements compared to full nodes</li> </ul>"},{"location":"concepts/chain-tracking/#multiple-providers","title":"Multiple Providers","text":"<p>The SDK supports multiple chain tracking services:</p> <pre><code>// Primary and fallback providers\nconst config = {\n  chainTracker: {\n    provider: 'WhatsOnChain',\n    network: 'mainnet',\n    fallbacks: ['GorillaPool', 'TAAL']\n  }\n}\n</code></pre>"},{"location":"concepts/chain-tracking/#benefits","title":"Benefits","text":""},{"location":"concepts/chain-tracking/#scalability","title":"Scalability","text":"<ul> <li>No need to store the entire blockchain</li> <li>Fast startup and synchronization</li> <li>Minimal storage requirements</li> </ul>"},{"location":"concepts/chain-tracking/#reliability","title":"Reliability","text":"<ul> <li>Multiple provider support</li> <li>Automatic failover capabilities</li> <li>Redundant data sources</li> </ul>"},{"location":"concepts/chain-tracking/#performance","title":"Performance","text":"<ul> <li>Targeted data queries</li> <li>Caching of frequently accessed data</li> <li>Optimized for application needs</li> </ul>"},{"location":"concepts/chain-tracking/#common-patterns","title":"Common Patterns","text":""},{"location":"concepts/chain-tracking/#transaction-verification","title":"Transaction Verification","text":"<pre><code>// Verify a transaction exists\nconst exists = await chainTracker.getTransaction(txid)\nif (exists) {\n  // Transaction is confirmed on-chain\n}\n</code></pre>"},{"location":"concepts/chain-tracking/#utxo-validation","title":"UTXO Validation","text":"<pre><code>// Check if UTXO is still unspent\nconst utxo = await chainTracker.getUTXO(txid, outputIndex)\nif (utxo) {\n  // UTXO is available for spending\n}\n</code></pre>"},{"location":"concepts/chain-tracking/#error-handling","title":"Error Handling","text":"<p>Chain tracker operations can fail due to:</p> <ul> <li>Network connectivity issues</li> <li>Service provider downtime</li> <li>Invalid transaction IDs</li> <li>Rate limiting</li> </ul> <p>The SDK provides automatic retry and failover mechanisms.</p>"},{"location":"concepts/chain-tracking/#configuration","title":"Configuration","text":"<p>Chain trackers can be configured for:</p> <ul> <li>Network: Mainnet, testnet, or regtest</li> <li>Endpoints: Custom service URLs</li> <li>Timeouts: Request timeout settings</li> <li>Retry Logic: Failure handling behavior</li> </ul>"},{"location":"concepts/chain-tracking/#next-steps","title":"Next Steps","text":"<ul> <li>Understand SPV Verification concepts</li> <li>Learn about BEEF Format for efficient data exchange</li> <li>Explore Trust Model considerations</li> </ul>"},{"location":"concepts/decentralized-identity/","title":"Decentralized Identity","text":"<p>Understanding how decentralized identity works in BSV and why it matters for building trustless applications.</p>"},{"location":"concepts/decentralized-identity/#what-is-decentralized-identity","title":"What is Decentralized Identity?","text":"<p>Imagine a world where you control your own identity credentials, just like you control your own wallet. Instead of relying on Facebook, Google, or government agencies to verify who you are, you can prove your identity using cryptographic certificates that anyone can independently verify.</p> <p>This is the promise of decentralized identity: self-sovereign identity that puts users in control while maintaining security and trust.</p>"},{"location":"concepts/decentralized-identity/#why-decentralized-identity-matters","title":"Why Decentralized Identity Matters","text":""},{"location":"concepts/decentralized-identity/#the-problem-with-centralized-identity","title":"The Problem with Centralized Identity","text":"<p>Traditional identity systems have significant limitations:</p> <ul> <li>Single Points of Failure: If the identity provider goes down, you lose access</li> <li>Privacy Concerns: Companies collect and monetize your personal data</li> <li>Vendor Lock-in: You can't easily move your identity between services</li> <li>Censorship Risk: Providers can revoke your identity for any reason</li> <li>Data Breaches: Centralized databases are attractive targets for hackers</li> </ul>"},{"location":"concepts/decentralized-identity/#the-decentralized-solution","title":"The Decentralized Solution","text":"<p>Decentralized identity addresses these issues by:</p> <ul> <li>User Control: You own and manage your identity data</li> <li>No Central Authority: No single entity controls the verification process</li> <li>Interoperability: Your identity works across different applications</li> <li>Privacy by Design: You choose what information to reveal and when</li> <li>Censorship Resistance: No one can arbitrarily revoke your identity</li> </ul>"},{"location":"concepts/decentralized-identity/#how-it-works-in-bsv","title":"How It Works in BSV","text":""},{"location":"concepts/decentralized-identity/#identity-keys-vs-transaction-keys","title":"Identity Keys vs Transaction Keys","text":"<p>BSV uses different types of keys for different purposes:</p> <p>Identity Keys are long-term, stable identifiers used for:</p> <ul> <li>Establishing your digital identity</li> <li>Signing identity certificates</li> <li>Resolving your public profile information</li> <li>Authenticating with services</li> </ul> <p>Transaction Keys are used for:</p> <ul> <li>Signing Bitcoin transactions</li> <li>Managing UTXOs and payments</li> <li>Protocol-specific operations</li> </ul> <p>This separation provides both security and privacy benefits.</p>"},{"location":"concepts/decentralized-identity/#identity-resolution","title":"Identity Resolution","text":"<p>Your identity key serves as a unique identifier that can be used to discover:</p> <ul> <li>Your chosen display name and profile information</li> <li>Verification badges and trust indicators</li> <li>Public certificates and credentials</li> <li>Contact preferences and communication methods</li> </ul> <p>Think of it like a decentralized phone book where your identity key is your number, but instead of just finding your phone number, people can discover rich identity information that you've chosen to make public.</p>"},{"location":"concepts/decentralized-identity/#certificate-based-trust","title":"Certificate-Based Trust","text":"<p>Instead of trusting a central authority, decentralized identity relies on a web of cryptographic certificates. These certificates are like digital testimonials that others can independently verify:</p> <ul> <li>Self-Signed Certificates: Claims you make about yourself</li> <li>Peer Certificates: Verifications from other users</li> <li>Institutional Certificates: Credentials from recognized organizations</li> <li>Service Certificates: Verifications from specialized services</li> </ul>"},{"location":"concepts/decentralized-identity/#trust-and-verification-models","title":"Trust and Verification Models","text":""},{"location":"concepts/decentralized-identity/#web-of-trust","title":"Web of Trust","text":"<p>In a web of trust model, users verify each other's identities, creating networks of trusted relationships. This is similar to how you might trust a friend's recommendation about a restaurant - the more trusted connections someone has, the more credible they become.</p>"},{"location":"concepts/decentralized-identity/#institutional-trust","title":"Institutional Trust","text":"<p>Some applications require higher assurance levels, so they rely on certificates from recognized institutions like universities, professional licensing boards, or government agencies. These certificates carry more weight because the issuers have established reputations and verification processes.</p>"},{"location":"concepts/decentralized-identity/#hybrid-approaches","title":"Hybrid Approaches","text":"<p>Most real-world applications use a combination of trust models, adjusting requirements based on context. For example:</p> <ul> <li>Low-risk interactions might accept self-signed certificates</li> <li>Financial transactions might require institutional verification</li> <li>Professional networking might emphasize peer verification within industry groups</li> </ul>"},{"location":"concepts/decentralized-identity/#privacy-and-selective-disclosure","title":"Privacy and Selective Disclosure","text":""},{"location":"concepts/decentralized-identity/#controlling-your-information","title":"Controlling Your Information","text":"<p>One of the key benefits of decentralized identity is granular control over your personal information. You can:</p> <ul> <li>Choose which attributes to make publicly discoverable</li> <li>Reveal different information to different parties</li> <li>Prove claims without revealing underlying data</li> <li>Revoke access to previously shared information</li> </ul>"},{"location":"concepts/decentralized-identity/#zero-knowledge-proofs","title":"Zero-Knowledge Proofs","text":"<p>Advanced cryptographic techniques allow you to prove things about yourself without revealing the underlying information. For example, you could prove you're over 21 without revealing your exact age or birthdate.</p>"},{"location":"concepts/decentralized-identity/#progressive-disclosure","title":"Progressive Disclosure","text":"<p>As trust builds between parties, you might choose to reveal more information. This allows relationships to develop naturally while maintaining privacy protection.</p>"},{"location":"concepts/decentralized-identity/#identity-lifecycle","title":"Identity Lifecycle","text":""},{"location":"concepts/decentralized-identity/#getting-started","title":"Getting Started","text":"<p>Creating a decentralized identity involves:</p> <ol> <li>Generating an identity key pair (handled by your wallet)</li> <li>Creating basic profile information (name, avatar, contact preferences)</li> <li>Obtaining initial certificates to establish credibility</li> <li>Making your identity discoverable through resolution networks</li> </ol>"},{"location":"concepts/decentralized-identity/#building-trust","title":"Building Trust","text":"<p>Over time, you accumulate certificates and verifications that build your reputation:</p> <ul> <li>Verify your email address and social media accounts</li> <li>Get endorsements from colleagues and friends</li> <li>Obtain professional certifications and credentials</li> <li>Participate in community verification programs</li> </ul>"},{"location":"concepts/decentralized-identity/#maintaining-privacy","title":"Maintaining Privacy","text":"<p>As your identity grows, you maintain control by:</p> <ul> <li>Regularly reviewing what information is public</li> <li>Updating privacy preferences as needs change</li> <li>Revoking outdated or unwanted certificates</li> <li>Managing consent for data sharing</li> </ul>"},{"location":"concepts/decentralized-identity/#real-world-applications","title":"Real-World Applications","text":""},{"location":"concepts/decentralized-identity/#passwordless-authentication","title":"Passwordless Authentication","text":"<p>Instead of remembering dozens of passwords, you can authenticate using your identity certificates. This is more secure than passwords and eliminates the need for password managers.</p>"},{"location":"concepts/decentralized-identity/#professional-networking","title":"Professional Networking","text":"<p>Verify professional credentials, work history, and skills through cryptographic certificates rather than relying on self-reported information on traditional platforms.</p>"},{"location":"concepts/decentralized-identity/#age-and-identity-verification","title":"Age and Identity Verification","text":"<p>Prove your age for restricted services without revealing your exact birthdate, or verify your identity for account creation without sharing unnecessary personal information.</p>"},{"location":"concepts/decentralized-identity/#reputation-systems","title":"Reputation Systems","text":"<p>Build portable reputation that follows you across different platforms and applications, creating incentives for good behavior and reducing fraud.</p>"},{"location":"concepts/decentralized-identity/#decentralized-social-networks","title":"Decentralized Social Networks","text":"<p>Participate in social networks where your identity and connections are owned by you, not the platform, enabling true social media portability.</p>"},{"location":"concepts/decentralized-identity/#benefits-for-developers","title":"Benefits for Developers","text":""},{"location":"concepts/decentralized-identity/#simplified-user-onboarding","title":"Simplified User Onboarding","text":"<p>Instead of building complex registration and verification systems, applications can rely on existing identity infrastructure and certificates.</p>"},{"location":"concepts/decentralized-identity/#enhanced-security","title":"Enhanced Security","text":"<p>Cryptographic identity verification is more secure than traditional username/password systems and reduces the risk of account takeovers.</p>"},{"location":"concepts/decentralized-identity/#regulatory-compliance","title":"Regulatory Compliance","text":"<p>Decentralized identity can help meet KYC (Know Your Customer) and AML (Anti-Money Laundering) requirements while preserving user privacy.</p>"},{"location":"concepts/decentralized-identity/#interoperability","title":"Interoperability","text":"<p>Users can bring their identity and reputation from other applications, reducing friction and improving user experience.</p>"},{"location":"concepts/decentralized-identity/#challenges-and-considerations","title":"Challenges and Considerations","text":""},{"location":"concepts/decentralized-identity/#user-experience","title":"User Experience","text":"<p>Decentralized identity requires users to understand new concepts like key management and certificate verification. Good wallet software and user interfaces are essential for adoption.</p>"},{"location":"concepts/decentralized-identity/#recovery-and-backup","title":"Recovery and Backup","text":"<p>Unlike centralized systems where you can reset your password, losing access to your identity keys can be permanent. Robust backup and recovery mechanisms are crucial.</p>"},{"location":"concepts/decentralized-identity/#network-effects","title":"Network Effects","text":"<p>The value of decentralized identity increases as more people and organizations participate. Early adoption requires overcoming the \"chicken and egg\" problem.</p>"},{"location":"concepts/decentralized-identity/#scalability","title":"Scalability","text":"<p>As identity networks grow, efficient resolution and verification mechanisms become increasingly important to maintain performance.</p>"},{"location":"concepts/decentralized-identity/#the-future-of-identity","title":"The Future of Identity","text":"<p>Decentralized identity represents a fundamental shift toward user sovereignty and privacy. As the technology matures and adoption grows, we can expect to see:</p> <ul> <li>Seamless Integration with everyday applications and services</li> <li>Enhanced Privacy Protection through advanced cryptographic techniques</li> <li>Global Interoperability across different identity systems and networks</li> <li>Reduced Identity Fraud through cryptographic verification</li> <li>New Business Models that respect user privacy and data ownership</li> </ul> <p>By understanding these concepts, developers can build applications that respect user privacy, enhance security, and contribute to a more open and decentralized internet.</p>"},{"location":"concepts/decentralized-identity/#related-concepts","title":"Related Concepts","text":"<ul> <li>Identity Certificates - How cryptographic certificates enable trust</li> <li>Digital Signatures - Cryptographic foundations of identity verification</li> <li>Trust Model - Security assumptions in decentralized systems</li> <li>Key Management - Managing cryptographic keys securely</li> </ul>"},{"location":"concepts/decentralized-identity/#further-reading","title":"Further Reading","text":"<ul> <li>Identity Management Tutorial - Hands-on implementation guide</li> <li>AuthFetch Tutorial - Authenticated communication using identity</li> <li>Security Best Practices - Secure identity implementation patterns</li> </ul>"},{"location":"concepts/fees/","title":"Transaction Fees","text":"<p>Understanding Bitcoin transaction fees and how they work in the BSV TypeScript SDK.</p>"},{"location":"concepts/fees/#what-are-transaction-fees","title":"What are Transaction Fees?","text":"<p>Transaction fees are payments to miners for including transactions in blocks:</p> <pre><code>import { Transaction } from '@bsv/sdk'\n\n// Calculate transaction fee\nconst tx = new Transaction()\nconst feeRequired = tx.getFee()\n\n// Set custom fee rate\nconst customFee = tx.getFee(feePerKB)\n</code></pre>"},{"location":"concepts/fees/#fee-calculation","title":"Fee Calculation","text":"<p>Fees are calculated based on transaction size:</p> <ul> <li>Fee Rate: Satoshis per kilobyte (sat/kB)</li> <li>Transaction Size: Total bytes in serialized transaction</li> <li>Total Fee: Size \u00d7 Fee Rate</li> </ul>"},{"location":"concepts/fees/#sdk-fee-handling","title":"SDK Fee Handling","text":""},{"location":"concepts/fees/#automatic-fee-calculation","title":"Automatic Fee Calculation","text":"<p>The SDK calculates fees automatically:</p> <pre><code>// Wallet handles fees automatically\nconst wallet = new WalletClient()\nconst action = await wallet.createAction({\n  outputs: [{\n    satoshis: 1000,\n    lockingScript: script\n  }]\n})\n// Fee calculated and deducted automatically\n</code></pre>"},{"location":"concepts/fees/#manual-fee-control","title":"Manual Fee Control","text":"<p>For advanced use cases:</p> <pre><code>// Calculate fee manually\nconst tx = new Transaction()\ntx.addInput(/* input */)\ntx.addOutput(/* output */)\n\nconst estimatedSize = tx.getSerializedSize()\nconst feeRequired = estimatedSize * feePerByte\n</code></pre>"},{"location":"concepts/fees/#fee-rates","title":"Fee Rates","text":""},{"location":"concepts/fees/#network-fee-rates","title":"Network Fee Rates","text":"<p>BSV typically uses low, predictable fees:</p> <ul> <li>Standard Rate: ~0.5 sat/byte</li> <li>Priority Rate: ~1.0 sat/byte</li> <li>Economy Rate: ~0.1 sat/byte</li> </ul>"},{"location":"concepts/fees/#dynamic-fee-estimation","title":"Dynamic Fee Estimation","text":"<pre><code>// Get current network fee rates\nconst feeRates = await chainTracker.getFeeRates()\nconst recommendedFee = feeRates.standard\n</code></pre>"},{"location":"concepts/fees/#fee-components","title":"Fee Components","text":""},{"location":"concepts/fees/#input-costs","title":"Input Costs","text":"<p>Each input adds to transaction size:</p> <ul> <li>Previous transaction hash (32 bytes)</li> <li>Output index (4 bytes)</li> <li>Unlocking script (variable)</li> <li>Sequence number (4 bytes)</li> </ul>"},{"location":"concepts/fees/#output-costs","title":"Output Costs","text":"<p>Each output adds to transaction size:</p> <ul> <li>Value (8 bytes)</li> <li>Locking script length (1-9 bytes)</li> <li>Locking script (variable)</li> </ul>"},{"location":"concepts/fees/#base-transaction","title":"Base Transaction","text":"<p>Fixed overhead for every transaction:</p> <ul> <li>Version (4 bytes)</li> <li>Input count (1-9 bytes)</li> <li>Output count (1-9 bytes)</li> <li>Lock time (4 bytes)</li> </ul>"},{"location":"concepts/fees/#fee-optimization","title":"Fee Optimization","text":""},{"location":"concepts/fees/#utxo-selection","title":"UTXO Selection","text":"<p>Choose UTXOs efficiently:</p> <pre><code>// Prefer fewer, larger UTXOs to reduce fees\nconst utxos = await wallet.getUTXOs()\nconst selected = selectOptimalUTXOs(utxos, targetAmount)\n</code></pre>"},{"location":"concepts/fees/#output-consolidation","title":"Output Consolidation","text":"<p>Combine multiple payments:</p> <pre><code>// Batch multiple outputs in one transaction\nconst outputs = [\n  { satoshis: 1000, lockingScript: script1 },\n  { satoshis: 2000, lockingScript: script2 },\n  { satoshis: 1500, lockingScript: script3 }\n]\n</code></pre>"},{"location":"concepts/fees/#script-efficiency","title":"Script Efficiency","text":"<p>Use efficient script templates:</p> <pre><code>// P2PKH is more efficient than complex scripts\nconst p2pkh = new P2PKH()\nconst efficientScript = p2pkh.lock(publicKeyHash)\n</code></pre>"},{"location":"concepts/fees/#fee-estimation","title":"Fee Estimation","text":""},{"location":"concepts/fees/#size-estimation","title":"Size Estimation","text":"<p>Estimate transaction size before creation:</p> <pre><code>// Estimate size for fee calculation\nconst estimatedInputs = 2\nconst estimatedOutputs = 3\nconst estimatedSize = estimateTransactionSize(estimatedInputs, estimatedOutputs)\nconst estimatedFee = estimatedSize * feeRate\n</code></pre>"},{"location":"concepts/fees/#template-based-estimation","title":"Template-Based Estimation","text":"<pre><code>// Use script templates for accurate estimation\nconst template = new P2PKH()\nconst scriptSize = template.estimateLength([publicKeyHash])\n</code></pre>"},{"location":"concepts/fees/#error-handling","title":"Error Handling","text":"<p>Common fee-related issues:</p> <ul> <li>Insufficient funds for fees</li> <li>Fee rate too low for network</li> <li>Transaction size miscalculation</li> </ul> <pre><code>try {\n  const action = await wallet.createAction({\n    outputs: outputs\n  })\n} catch (error) {\n  if (error.message.includes('Insufficient funds')) {\n    // Handle insufficient balance for fees\n    console.log('Not enough funds to cover transaction and fees')\n  }\n}\n</code></pre>"},{"location":"concepts/fees/#best-practices","title":"Best Practices","text":""},{"location":"concepts/fees/#fee-management","title":"Fee Management","text":"<ul> <li>Always account for fees in balance calculations</li> <li>Use appropriate fee rates for urgency</li> <li>Monitor network conditions for fee adjustments</li> <li>Implement fee estimation before transaction creation</li> </ul>"},{"location":"concepts/fees/#cost-optimization","title":"Cost Optimization","text":"<ul> <li>Batch transactions when possible</li> <li>Use efficient script templates</li> <li>Optimize UTXO selection</li> <li>Consider transaction timing</li> </ul>"},{"location":"concepts/fees/#user-experience","title":"User Experience","text":"<ul> <li>Display estimated fees to users</li> <li>Provide fee rate options (economy, standard, priority)</li> <li>Handle insufficient fund errors gracefully</li> <li>Show fee breakdown for transparency</li> </ul>"},{"location":"concepts/fees/#wallet-integration","title":"Wallet Integration","text":"<p>Most applications rely on wallets for fee handling:</p> <pre><code>// Wallet manages fees automatically\nconst wallet = new WalletClient()\n\n// Fees are calculated and deducted automatically\nconst result = await wallet.createAction({\n  description: 'Payment with automatic fees',\n  outputs: [/* outputs */]\n})\n</code></pre>"},{"location":"concepts/fees/#advanced-fee-strategies","title":"Advanced Fee Strategies","text":""},{"location":"concepts/fees/#replace-by-fee-rbf","title":"Replace-by-Fee (RBF)","text":"<p>Increase fees for faster confirmation:</p> <pre><code>// Create transaction with RBF enabled\nconst tx = new Transaction()\ntx.setRBF(true) // Enable replace-by-fee\n</code></pre>"},{"location":"concepts/fees/#child-pays-for-parent-cpfp","title":"Child-Pays-for-Parent (CPFP)","text":"<p>Use dependent transactions to increase effective fee rate:</p> <pre><code>// Create child transaction with higher fee\nconst childTx = new Transaction()\nchildTx.addInput(/* from parent transaction */)\n// Higher fee rate pulls parent transaction along\n</code></pre>"},{"location":"concepts/fees/#next-steps","title":"Next Steps","text":"<ul> <li>Understand Transaction Structure for size calculation</li> <li>Learn about Wallet Integration for automatic fee handling</li> <li>Explore Script Templates for efficient fee optimization</li> </ul>"},{"location":"concepts/identity-certificates/","title":"Identity Certificates","text":"<p>Understanding how cryptographic certificates work to establish trust and verify identity claims in decentralized systems.</p>"},{"location":"concepts/identity-certificates/#what-are-identity-certificates","title":"What are Identity Certificates?","text":"<p>Think of identity certificates as digital testimonials that can't be forged. Just like a diploma proves you graduated from a university, or a driver's license proves you're authorized to drive, identity certificates prove specific claims about who you are or what you're authorized to do.</p> <p>The key difference is that these digital certificates use cryptographic signatures instead of physical security features, making them verifiable by anyone with the right tools, anywhere in the world.</p>"},{"location":"concepts/identity-certificates/#how-certificates-create-trust","title":"How Certificates Create Trust","text":""},{"location":"concepts/identity-certificates/#the-trust-problem","title":"The Trust Problem","text":"<p>In the digital world, it's easy to claim anything about yourself. Anyone can create a website saying they're a doctor, lawyer, or certified professional. How do you know who to trust?</p>"},{"location":"concepts/identity-certificates/#the-certificate-solution","title":"The Certificate Solution","text":"<p>Certificates solve this by having trusted third parties vouch for specific claims. When a university issues you a digital diploma certificate, they're cryptographically signing a statement that says \"We verify that this person graduated from our program.\"</p> <p>Anyone can then verify:</p> <ol> <li>The certificate is authentic (cryptographic signature is valid)</li> <li>It hasn't been tampered with (any changes would break the signature)</li> <li>It's still valid (hasn't expired or been revoked)</li> <li>The issuer is trustworthy (you trust the university)</li> </ol>"},{"location":"concepts/identity-certificates/#types-of-certificates","title":"Types of Certificates","text":""},{"location":"concepts/identity-certificates/#self-signed-certificates","title":"Self-Signed Certificates","text":"<p>These are claims you make about yourself, like \"My name is John Doe\" or \"My email is john@example.com.\" While anyone can create these, they serve as a starting point for building your digital identity.</p> <p>When they're useful:</p> <ul> <li>Basic profile information</li> <li>Contact preferences</li> <li>Personal statements</li> <li>Starting point for identity building</li> </ul> <p>Limitations:</p> <ul> <li>Low trust value (anyone can claim anything)</li> <li>Not suitable for high-stakes verification</li> <li>Mainly useful for discovery and basic interaction</li> </ul>"},{"location":"concepts/identity-certificates/#peer-verified-certificates","title":"Peer-Verified Certificates","text":"<p>These are endorsements from other users who can vouch for specific claims about you. Like professional references or character witnesses, they carry more weight when they come from trusted sources.</p> <p>Examples:</p> <ul> <li>Colleague endorsing your professional skills</li> <li>Friend confirming your identity</li> <li>Community member vouching for your reputation</li> <li>Business partner confirming successful transactions</li> </ul>"},{"location":"concepts/identity-certificates/#institutional-certificates","title":"Institutional Certificates","text":"<p>These come from recognized organizations with established authority and verification processes. They carry the most weight because the issuers have reputations to protect and rigorous verification procedures.</p> <p>Examples:</p> <ul> <li>University degree certificates</li> <li>Professional licensing board certifications</li> <li>Government-issued identity documents</li> <li>Industry association memberships</li> <li>Employer verification of work history</li> </ul>"},{"location":"concepts/identity-certificates/#certificate-lifecycle","title":"Certificate Lifecycle","text":""},{"location":"concepts/identity-certificates/#creation-and-issuance","title":"Creation and Issuance","text":"<p>When someone wants to issue you a certificate, they typically:</p> <ol> <li>Verify your claim through their established process</li> <li>Create a digital certificate containing the verified information</li> <li>Sign it cryptographically using their private key</li> <li>Deliver it to you for use in proving the claim</li> </ol>"},{"location":"concepts/identity-certificates/#validation-and-trust","title":"Validation and Trust","text":"<p>When someone wants to verify your certificate, they:</p> <ol> <li>Check the cryptographic signature to ensure authenticity</li> <li>Verify it hasn't expired or been revoked</li> <li>Assess the issuer's credibility and authority</li> <li>Determine if it meets their requirements for the specific use case</li> </ol>"},{"location":"concepts/identity-certificates/#renewal-and-maintenance","title":"Renewal and Maintenance","text":"<p>Certificates have limited lifespans for security reasons:</p> <ul> <li>Expiration dates ensure information stays current</li> <li>Renewal processes allow for re-verification</li> <li>Revocation mechanisms handle compromised or invalid certificates</li> <li>Update procedures accommodate changing information</li> </ul>"},{"location":"concepts/identity-certificates/#trust-scoring-and-reputation","title":"Trust Scoring and Reputation","text":""},{"location":"concepts/identity-certificates/#building-credibility","title":"Building Credibility","text":"<p>Your overall trustworthiness comes from the combination of all your certificates:</p> <ul> <li>Quantity: More verifications generally increase trust</li> <li>Quality: Certificates from respected issuers carry more weight</li> <li>Diversity: Different types of verification provide broader confidence</li> <li>Recency: Fresh certificates are more valuable than old ones</li> </ul>"},{"location":"concepts/identity-certificates/#confidence-levels","title":"Confidence Levels","text":"<p>Different certificates provide different levels of assurance:</p> <ul> <li>Self-asserted claims provide basic information but low confidence</li> <li>Peer verifications offer moderate confidence from social proof</li> <li>Service verifications provide higher confidence from specialized validators</li> <li>Institutional certificates offer the highest confidence from established authorities</li> </ul>"},{"location":"concepts/identity-certificates/#context-matters","title":"Context Matters","text":"<p>The same certificate might be highly valuable in one context but irrelevant in another:</p> <ul> <li>A medical license is crucial for healthcare but irrelevant for software development</li> <li>A GitHub contribution history matters for programming jobs but not for teaching</li> <li>Age verification is essential for restricted services but unnecessary for professional networking</li> </ul>"},{"location":"concepts/identity-certificates/#privacy-and-selective-disclosure","title":"Privacy and Selective Disclosure","text":""},{"location":"concepts/identity-certificates/#controlling-information-flow","title":"Controlling Information Flow","text":"<p>One of the key advantages of certificate-based identity is granular control over what you reveal:</p> <ul> <li>Public certificates are discoverable by anyone</li> <li>Private certificates are shared only with specific parties</li> <li>Selective revelation lets you prove specific claims without revealing everything</li> <li>Progressive disclosure allows trust to build gradually</li> </ul>"},{"location":"concepts/identity-certificates/#zero-knowledge-proofs","title":"Zero-Knowledge Proofs","text":"<p>Advanced techniques allow you to prove things without revealing the underlying data:</p> <ul> <li>Prove you're over 21 without revealing your exact age</li> <li>Prove you have a degree without revealing which university</li> <li>Prove you're a resident without revealing your exact address</li> <li>Prove you're qualified without revealing all your credentials</li> </ul>"},{"location":"concepts/identity-certificates/#consent-and-control","title":"Consent and Control","text":"<p>You maintain control over your certificates:</p> <ul> <li>Choose what to make public vs. keep private</li> <li>Decide who can access specific information</li> <li>Revoke access when relationships change</li> <li>Update preferences as your needs evolve</li> </ul>"},{"location":"concepts/identity-certificates/#real-world-applications","title":"Real-World Applications","text":""},{"location":"concepts/identity-certificates/#professional-verification","title":"Professional Verification","text":"<p>Instead of relying on self-reported resumes, employers can verify:</p> <ul> <li>Educational credentials directly from institutions</li> <li>Work history from previous employers</li> <li>Professional certifications from licensing bodies</li> <li>Skills endorsements from colleagues and clients</li> </ul>"},{"location":"concepts/identity-certificates/#age-and-identity-verification","title":"Age and Identity Verification","text":"<p>Services requiring age or identity verification can:</p> <ul> <li>Verify age without collecting birthdates</li> <li>Confirm identity without storing personal documents</li> <li>Meet regulatory requirements while preserving privacy</li> <li>Reduce fraud through cryptographic verification</li> </ul>"},{"location":"concepts/identity-certificates/#reputation-systems","title":"Reputation Systems","text":"<p>Platforms can build more reliable reputation systems:</p> <ul> <li>Portable reputation that follows users between platforms</li> <li>Verifiable transaction history and feedback</li> <li>Reduced fake accounts and manipulation</li> <li>Incentives for honest behavior</li> </ul>"},{"location":"concepts/identity-certificates/#access-control","title":"Access Control","text":"<p>Organizations can manage access more securely:</p> <ul> <li>Verify membership or employment status</li> <li>Confirm professional qualifications</li> <li>Validate security clearances</li> <li>Authenticate without passwords</li> </ul>"},{"location":"concepts/identity-certificates/#benefits-over-traditional-systems","title":"Benefits Over Traditional Systems","text":""},{"location":"concepts/identity-certificates/#security","title":"Security","text":"<ul> <li>Cryptographic verification is more secure than physical documents</li> <li>Tamper evidence makes forgery virtually impossible</li> <li>Distributed validation eliminates single points of failure</li> <li>Revocation mechanisms handle compromised credentials quickly</li> </ul>"},{"location":"concepts/identity-certificates/#privacy","title":"Privacy","text":"<ul> <li>Minimal disclosure reveals only necessary information</li> <li>User control over what information is shared</li> <li>No central databases to be breached or misused</li> <li>Consent-based sharing puts users in control</li> </ul>"},{"location":"concepts/identity-certificates/#interoperability","title":"Interoperability","text":"<ul> <li>Standard formats work across different systems</li> <li>Portable credentials move between applications</li> <li>Universal verification works anywhere in the world</li> <li>Cross-platform compatibility reduces vendor lock-in</li> </ul>"},{"location":"concepts/identity-certificates/#efficiency","title":"Efficiency","text":"<ul> <li>Automated verification reduces manual processes</li> <li>Real-time validation provides instant results</li> <li>Reduced paperwork streamlines credential management</li> <li>Lower costs compared to traditional verification methods</li> </ul>"},{"location":"concepts/identity-certificates/#challenges-and-considerations","title":"Challenges and Considerations","text":""},{"location":"concepts/identity-certificates/#user-experience","title":"User Experience","text":"<p>Making certificate systems user-friendly requires:</p> <ul> <li>Intuitive interfaces that hide complexity</li> <li>Clear explanations of what certificates mean</li> <li>Simple management tools for organizing credentials</li> <li>Seamless integration with existing workflows</li> </ul>"},{"location":"concepts/identity-certificates/#recovery-and-backup","title":"Recovery and Backup","text":"<p>Unlike traditional documents, losing access to digital certificates can be permanent:</p> <ul> <li>Backup strategies are essential for important credentials</li> <li>Recovery mechanisms must balance security with usability</li> <li>Key management becomes critical for certificate access</li> <li>Succession planning for organizational certificates</li> </ul>"},{"location":"concepts/identity-certificates/#adoption-and-network-effects","title":"Adoption and Network Effects","text":"<p>Certificate systems become more valuable as adoption grows:</p> <ul> <li>Issuer participation is needed for valuable certificates</li> <li>Verifier acceptance determines practical utility</li> <li>User adoption creates network effects</li> <li>Standardization enables interoperability</li> </ul>"},{"location":"concepts/identity-certificates/#legal-and-regulatory","title":"Legal and Regulatory","text":"<p>Integrating with existing legal frameworks requires:</p> <ul> <li>Regulatory compliance with identity verification laws</li> <li>Legal recognition of digital certificates</li> <li>Audit trails for compliance reporting</li> <li>Dispute resolution mechanisms for conflicts</li> </ul>"},{"location":"concepts/identity-certificates/#the-future-of-digital-credentials","title":"The Future of Digital Credentials","text":"<p>As certificate-based identity systems mature, we can expect:</p>"},{"location":"concepts/identity-certificates/#widespread-adoption","title":"Widespread Adoption","text":"<ul> <li>Government integration with official identity documents</li> <li>Educational institutions issuing digital diplomas</li> <li>Professional organizations moving to digital certifications</li> <li>Employers accepting and requiring digital credentials</li> </ul>"},{"location":"concepts/identity-certificates/#enhanced-privacy","title":"Enhanced Privacy","text":"<ul> <li>Zero-knowledge proofs becoming standard</li> <li>Selective disclosure built into all systems</li> <li>Privacy-preserving verification as the default</li> <li>User control over all personal data</li> </ul>"},{"location":"concepts/identity-certificates/#improved-user-experience","title":"Improved User Experience","text":"<ul> <li>Seamless integration with daily digital activities</li> <li>Automated verification reducing friction</li> <li>Intelligent recommendations for credential building</li> <li>Universal acceptance across platforms and services</li> </ul>"},{"location":"concepts/identity-certificates/#new-possibilities","title":"New Possibilities","text":"<ul> <li>Micro-credentials for specific skills and achievements</li> <li>Dynamic certificates that update automatically</li> <li>Composite credentials combining multiple sources</li> <li>AI-assisted verification for complex claims</li> </ul> <p>Understanding these concepts helps developers and users participate in building a more trustworthy, privacy-preserving digital world where identity verification is both secure and user-controlled.</p>"},{"location":"concepts/identity-certificates/#related-concepts","title":"Related Concepts","text":"<ul> <li>Decentralized Identity - Overall identity system architecture</li> <li>Digital Signatures - Cryptographic foundations of certificates</li> <li>Trust Model - Security assumptions and trust relationships</li> <li>Key Management - Managing cryptographic keys for certificates</li> </ul>"},{"location":"concepts/identity-certificates/#further-reading","title":"Further Reading","text":"<ul> <li>Identity Management Tutorial - Practical certificate implementation</li> <li>Security Best Practices - Secure certificate handling</li> <li>AuthFetch Tutorial - Using certificates for authentication</li> </ul>"},{"location":"concepts/key-management/","title":"Key Management","text":"<p>Understanding how private keys, public keys, and cryptographic operations work in the BSV TypeScript SDK.</p>"},{"location":"concepts/key-management/#cryptographic-keys","title":"Cryptographic Keys","text":"<p>Bitcoin uses elliptic curve cryptography (secp256k1) for key management:</p> <pre><code>import { PrivateKey, PublicKey } from '@bsv/sdk'\n\n// Generate a new private key\nconst privateKey = PrivateKey.fromRandom()\n\n// Derive the corresponding public key\nconst publicKey = privateKey.toPublicKey()\n</code></pre>"},{"location":"concepts/key-management/#private-keys","title":"Private Keys","text":"<p>Private keys are 256-bit numbers that control Bitcoin funds:</p>"},{"location":"concepts/key-management/#generation","title":"Generation","text":"<pre><code>// Secure random generation\nconst privKey = PrivateKey.fromRandom()\n\n// From existing data (use carefully)\nconst privKey2 = PrivateKey.fromString('hex_string')\n</code></pre>"},{"location":"concepts/key-management/#formats","title":"Formats","text":"<pre><code>// WIF (Wallet Import Format)\nconst wif = privateKey.toWif()\n\n// Hex string\nconst hex = privateKey.toString()\n\n// DER encoding\nconst der = privateKey.toDER()\n</code></pre>"},{"location":"concepts/key-management/#public-keys","title":"Public Keys","text":"<p>Public keys are derived from private keys and can be shared safely:</p>"},{"location":"concepts/key-management/#derivation","title":"Derivation","text":"<pre><code>// Always derive from private key\nconst publicKey = privateKey.toPublicKey()\n\n// Cannot go backwards (public -&gt; private)\n</code></pre>"},{"location":"concepts/key-management/#formats_1","title":"Formats","text":"<pre><code>// Compressed (33 bytes) - preferred\nconst compressed = publicKey.toString()\n\n// Uncompressed (65 bytes) - legacy\nconst uncompressed = publicKey.toString(false)\n\n// DER encoding\nconst der = publicKey.toDER()\n</code></pre>"},{"location":"concepts/key-management/#digital-signatures","title":"Digital Signatures","text":"<p>Private keys create signatures that prove ownership:</p> <pre><code>// Sign a message\nconst message = 'Hello Bitcoin'\nconst signature = privateKey.sign(message)\n\n// Verify with public key\nconst isValid = publicKey.verify(message, signature)\n</code></pre>"},{"location":"concepts/key-management/#key-derivation","title":"Key Derivation","text":"<p>The SDK supports hierarchical key derivation:</p> <pre><code>// Derive child keys (simplified example)\nconst childKey = privateKey.deriveChild(0)\nconst childPubKey = childKey.toPublicKey()\n</code></pre>"},{"location":"concepts/key-management/#security-considerations","title":"Security Considerations","text":""},{"location":"concepts/key-management/#private-key-security","title":"Private Key Security","text":"<ul> <li>Never expose: Private keys should never be logged or transmitted</li> <li>Secure storage: Use encrypted storage for private keys</li> <li>Random generation: Always use cryptographically secure randomness</li> <li>Access control: Limit who can access private key operations</li> </ul>"},{"location":"concepts/key-management/#best-practices","title":"Best Practices","text":"<pre><code>// Good: Generate securely\nconst key = PrivateKey.fromRandom()\n\n// Bad: Predictable generation\nconst badKey = PrivateKey.fromString('1234567890abcdef...')\n\n// Good: Derive public key when needed\nconst pubKey = key.toPublicKey()\n\n// Bad: Store private key unnecessarily\nlocalStorage.setItem('privateKey', key.toString())\n</code></pre>"},{"location":"concepts/key-management/#wallet-integration","title":"Wallet Integration","text":"<p>In most applications, wallets handle key management:</p> <p>The <code>WalletClient</code> provides high-level key management through wallet integration:</p> <pre><code>// Wallet manages keys securely\nconst wallet = new WalletClient()\n\n// Application doesn't see private keys\nconst action = await wallet.createAction({\n  outputs: [/* transaction outputs */]\n})\n</code></pre> <p>When using the <code>WalletClient</code>, keys are managed by the connected wallet service:</p> <p>The <code>WalletClient</code> approach is recommended for production applications as it provides:</p>"},{"location":"concepts/key-management/#key-recovery","title":"Key Recovery","text":"<p>Keys can be recovered from various formats:</p> <pre><code>// From WIF format\nconst key1 = PrivateKey.fromWif(wifString)\n\n// From hex string\nconst key2 = PrivateKey.fromString(hexString)\n\n// From DER encoding\nconst key3 = PrivateKey.fromDER(derBytes)\n</code></pre>"},{"location":"concepts/key-management/#cryptographic-operations","title":"Cryptographic Operations","text":"<p>The SDK provides secure implementations of:</p> <ul> <li>ECDSA: Digital signature algorithm</li> <li>ECDH: Key exchange protocol</li> <li>Hash Functions: SHA-256, RIPEMD-160</li> <li>AES: Symmetric encryption</li> </ul>"},{"location":"concepts/key-management/#memory-management","title":"Memory Management","text":"<p>Sensitive key data should be cleared when no longer needed:</p> <ul> <li>Use secure memory practices</li> <li>Clear variables containing key data</li> <li>Avoid keeping keys in memory longer than necessary</li> </ul>"},{"location":"concepts/key-management/#testing-and-development","title":"Testing and Development","text":"<p>For development and testing:</p> <ul> <li>Use testnet for experiments</li> <li>Generate new keys for each test</li> <li>Never use mainnet keys in test code</li> <li>Implement proper key rotation</li> </ul>"},{"location":"concepts/key-management/#next-steps","title":"Next Steps","text":"<ul> <li>Understand Digital Signatures in detail</li> <li>Learn about Trust Model considerations</li> <li>Explore Wallet Integration patterns</li> </ul>"},{"location":"concepts/script-templates/","title":"Script Templates","text":"<p>Standard and custom Bitcoin script patterns available in the BSV TypeScript SDK.</p>"},{"location":"concepts/script-templates/#what-are-script-templates","title":"What are Script Templates?","text":"<p>Script templates provide reusable patterns for Bitcoin transaction locking and unlocking scripts:</p> <pre><code>import { P2PKH } from '@bsv/sdk'\n\n// Use a standard template\nconst template = new P2PKH()\n\n// Create locking script\nconst lockingScript = template.lock(publicKeyHash)\n\n// Create unlocking script\nconst unlockingScript = template.unlock(privateKey, signature)\n</code></pre>"},{"location":"concepts/script-templates/#standard-templates","title":"Standard Templates","text":""},{"location":"concepts/script-templates/#p2pkh-pay-to-public-key-hash","title":"P2PKH (Pay to Public Key Hash)","text":"<p>The most common Bitcoin script pattern:</p> <pre><code>const p2pkh = new P2PKH()\nconst lock = p2pkh.lock(publicKeyHash)\nconst unlock = p2pkh.unlock(privateKey, signature)\n</code></pre>"},{"location":"concepts/script-templates/#p2pk-pay-to-public-key","title":"P2PK (Pay to Public Key)","text":"<p>Direct payment to a public key:</p> <pre><code>const p2pk = new P2PK()\nconst lock = p2pk.lock(publicKey)\nconst unlock = p2pk.unlock(signature)\n</code></pre>"},{"location":"concepts/script-templates/#op_return-data-storage","title":"OP_RETURN (Data Storage)","text":"<p>Store arbitrary data on-chain:</p> <pre><code>const opReturn = new OpReturn()\nconst lock = opReturn.lock(data)\n// No unlock needed - unspendable output\n</code></pre>"},{"location":"concepts/script-templates/#custom-templates","title":"Custom Templates","text":"<p>Create your own script templates:</p> <pre><code>class TimeLockTemplate implements ScriptTemplate {\n  lock(lockTime: number, publicKeyHash: string): Script {\n    return new Script()\n      .writeNumber(lockTime)\n      .writeOpCode(OpCode.OP_CHECKLOCKTIMEVERIFY)\n      .writeOpCode(OpCode.OP_DROP)\n      .writeOpCode(OpCode.OP_DUP)\n      .writeOpCode(OpCode.OP_HASH160)\n      .writeBin(publicKeyHash)\n      .writeOpCode(OpCode.OP_EQUALVERIFY)\n      .writeOpCode(OpCode.OP_CHECKSIG)\n  }\n\n  unlock(signature: string, publicKey: string): Script {\n    return new Script()\n      .writeBin(signature)\n      .writeBin(publicKey)\n  }\n}\n</code></pre>"},{"location":"concepts/script-templates/#template-interface","title":"Template Interface","text":"<p>All templates implement the ScriptTemplate interface:</p> <pre><code>interface ScriptTemplate {\n  lock(...args: any[]): Script\n  unlock(...args: any[]): Script\n  estimateLength?(args: any[]): number\n}\n</code></pre>"},{"location":"concepts/script-templates/#benefits","title":"Benefits","text":""},{"location":"concepts/script-templates/#reusability","title":"Reusability","text":"<ul> <li>Standard patterns for common use cases</li> <li>Consistent implementation across applications</li> <li>Reduced development time</li> </ul>"},{"location":"concepts/script-templates/#security","title":"Security","text":"<ul> <li>Well-tested script patterns</li> <li>Reduced risk of script errors</li> <li>Best practice implementations</li> </ul>"},{"location":"concepts/script-templates/#maintainability","title":"Maintainability","text":"<ul> <li>Clear separation of script logic</li> <li>Easy to update and modify</li> <li>Testable components</li> </ul>"},{"location":"concepts/script-templates/#working-with-templates","title":"Working with Templates","text":""},{"location":"concepts/script-templates/#transaction-integration","title":"Transaction Integration","text":"<pre><code>// Use template in transaction\nconst output = {\n  satoshis: 1000,\n  lockingScript: template.lock(publicKeyHash)\n}\n\nconst input = {\n  sourceTransaction: prevTx,\n  sourceOutputIndex: 0,\n  unlockingScript: template.unlock(privateKey, signature)\n}\n</code></pre>"},{"location":"concepts/script-templates/#fee-estimation","title":"Fee Estimation","text":"<pre><code>// Estimate script size for fee calculation\nconst estimatedSize = template.estimateLength([publicKeyHash])\nconst fee = estimatedSize * feePerByte\n</code></pre>"},{"location":"concepts/script-templates/#advanced-patterns","title":"Advanced Patterns","text":""},{"location":"concepts/script-templates/#multi-signature","title":"Multi-Signature","text":"<pre><code>class MultiSigTemplate implements ScriptTemplate {\n  lock(threshold: number, publicKeys: string[]): Script {\n    // Implementation for m-of-n multisig\n  }\n\n  unlock(signatures: string[]): Script {\n    // Implementation for signature collection\n  }\n}\n</code></pre>"},{"location":"concepts/script-templates/#conditional-scripts","title":"Conditional Scripts","text":"<pre><code>class ConditionalTemplate implements ScriptTemplate {\n  lock(condition: Script, trueScript: Script, falseScript: Script): Script {\n    // Implementation for IF/ELSE logic\n  }\n}\n</code></pre>"},{"location":"concepts/script-templates/#best-practices","title":"Best Practices","text":"<ul> <li>Use standard templates when possible</li> <li>Test custom templates thoroughly</li> <li>Document template parameters clearly</li> <li>Consider script size and complexity</li> <li>Validate inputs before script creation</li> </ul>"},{"location":"concepts/script-templates/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about Digital Signatures for script authorization</li> <li>Understand Transaction Structure integration</li> <li>Explore Key Management for script security</li> </ul>"},{"location":"concepts/sdk-philosophy/","title":"SDK Design Philosophy","text":"<p>This document details the core principles behind the BSV TypeScript SDK architecture and design decisions.</p>"},{"location":"concepts/sdk-philosophy/#zero-dependencies","title":"Zero Dependencies","text":"<p>The SDK is built without external dependencies to:</p> <ul> <li>Minimize security attack surface</li> <li>Reduce bundle size and complexity</li> <li>Ensure long-term stability</li> <li>Provide predictable behavior</li> </ul>"},{"location":"concepts/sdk-philosophy/#spv-first-approach","title":"SPV-First Approach","text":"<p>The SDK prioritizes Simplified Payment Verification:</p> <ul> <li>Lightweight: No need to download the full blockchain</li> <li>Efficient: Verify transactions using merkle proofs</li> <li>Scalable: Works with millions of transactions</li> <li>Secure: Cryptographically verifiable without full nodes</li> </ul>"},{"location":"concepts/sdk-philosophy/#vendor-neutrality","title":"Vendor Neutrality","text":"<p>The SDK works with any compliant Bitcoin infrastructure:</p> <ul> <li>Wallet Agnostic: Supports any BRC-100 compliant wallet</li> <li>Network Flexible: Works with different chain tracking services</li> <li>Service Independent: No lock-in to specific providers</li> </ul>"},{"location":"concepts/sdk-philosophy/#modular-design","title":"Modular Design","text":"<p>Components are designed to work independently:</p> <ul> <li>Composable: Mix and match functionality as needed</li> <li>Extensible: Easy to add custom implementations</li> <li>Testable: Each component can be tested in isolation</li> <li>Maintainable: Clear separation of concerns</li> </ul>"},{"location":"concepts/sdk-philosophy/#typescript-first","title":"TypeScript-First","text":"<p>Built specifically for TypeScript to provide:</p> <ul> <li>Type Safety: Catch errors at compile time</li> <li>Developer Experience: Rich IDE support and autocomplete</li> <li>Documentation: Types serve as living documentation</li> <li>Reliability: Reduced runtime errors</li> </ul>"},{"location":"concepts/sdk-philosophy/#security-by-design","title":"Security by Design","text":"<p>Security considerations are built into every component:</p> <ul> <li>Cryptographic Primitives: Secure implementations of Bitcoin cryptography</li> <li>Input Validation: All inputs are validated and sanitized</li> <li>Error Handling: Comprehensive error handling prevents information leakage</li> <li>Best Practices: Follows established security patterns</li> </ul>"},{"location":"concepts/sdk-philosophy/#performance-focused","title":"Performance Focused","text":"<p>Optimized for real-world application needs:</p> <ul> <li>Memory Efficient: Minimal memory footprint</li> <li>Fast Execution: Optimized critical paths</li> <li>Batch Processing: Support for high-throughput scenarios</li> <li>Caching: Intelligent caching where appropriate</li> </ul>"},{"location":"concepts/sdk-philosophy/#developer-friendly","title":"Developer-Friendly","text":"<p>Designed to make Bitcoin development accessible:</p> <ul> <li>Clear APIs: Intuitive method names and parameters</li> <li>Comprehensive Documentation: Tutorials, guides, and references</li> <li>Working Examples: Real code that developers can use immediately</li> <li>Progressive Complexity: Start simple, add complexity as needed</li> </ul>"},{"location":"concepts/sdk-philosophy/#next-steps","title":"Next Steps","text":"<ul> <li>Understand Wallet Integration patterns</li> <li>Learn about SPV Verification concepts</li> <li>Explore Key Management approaches</li> </ul>"},{"location":"concepts/signatures/","title":"Digital Signatures","text":"<p>How digital signatures work in Bitcoin and their implementation in the BSV TypeScript SDK.</p>"},{"location":"concepts/signatures/#what-are-digital-signatures","title":"What are Digital Signatures?","text":"<p>Digital signatures prove ownership and authorize Bitcoin transactions:</p> <pre><code>import { PrivateKey, Transaction } from '@bsv/sdk'\n\n// Create a signature\nconst privateKey = PrivateKey.fromRandom()\nconst message = 'transaction data'\nconst signature = privateKey.sign(message)\n\n// Verify the signature\nconst publicKey = privateKey.toPublicKey()\nconst isValid = publicKey.verify(message, signature)\n</code></pre>"},{"location":"concepts/signatures/#bitcoin-signatures","title":"Bitcoin Signatures","text":"<p>Bitcoin uses ECDSA (Elliptic Curve Digital Signature Algorithm):</p> <ul> <li>secp256k1: The elliptic curve used by Bitcoin</li> <li>SHA-256: Hash function for message digests</li> <li>DER Encoding: Standard format for signature serialization</li> </ul>"},{"location":"concepts/signatures/#sighash-types","title":"SIGHASH Types","text":"<p>SIGHASH flags determine what parts of a transaction are signed:</p>"},{"location":"concepts/signatures/#sighash_all-default","title":"SIGHASH_ALL (Default)","text":"<p>Signs all inputs and outputs:</p> <pre><code>const signature = privateKey.sign(txHash, 'all')\n</code></pre>"},{"location":"concepts/signatures/#sighash_none","title":"SIGHASH_NONE","text":"<p>Signs all inputs but no outputs:</p> <pre><code>const signature = privateKey.sign(txHash, 'none')\n</code></pre>"},{"location":"concepts/signatures/#sighash_single","title":"SIGHASH_SINGLE","text":"<p>Signs all inputs and one corresponding output:</p> <pre><code>const signature = privateKey.sign(txHash, 'single')\n</code></pre>"},{"location":"concepts/signatures/#sighash_anyonecanpay","title":"SIGHASH_ANYONECANPAY","text":"<p>Can be combined with other flags to sign only one input:</p> <pre><code>const signature = privateKey.sign(txHash, 'all|anyonecanpay')\n</code></pre>"},{"location":"concepts/signatures/#transaction-signing","title":"Transaction Signing","text":"<p>The SDK handles transaction signing automatically:</p> <pre><code>// Manual signing (low-level)\nconst tx = new Transaction()\nconst signature = tx.sign(privateKey, inputIndex, sighashType)\n\n// Wallet signing (recommended)\nconst wallet = new WalletClient()\nconst action = await wallet.createAction({\n  outputs: [/* outputs */]\n})\n// Wallet handles signing internally\n</code></pre>"},{"location":"concepts/signatures/#signature-verification","title":"Signature Verification","text":"<p>Verify signatures to ensure transaction validity:</p> <pre><code>// Verify a specific signature\nconst isValid = publicKey.verify(messageHash, signature)\n\n// Verify entire transaction\nconst txValid = await transaction.verify(chainTracker)\n</code></pre>"},{"location":"concepts/signatures/#der-encoding","title":"DER Encoding","text":"<p>Signatures are encoded in DER format:</p> <pre><code>// Get DER-encoded signature\nconst derSignature = signature.toDER()\n\n// Parse DER signature\nconst sig = Signature.fromDER(derBytes)\n\n// Get r and s components\nconst r = signature.r\nconst s = signature.s\n</code></pre>"},{"location":"concepts/signatures/#security-considerations","title":"Security Considerations","text":""},{"location":"concepts/signatures/#nonce-security","title":"Nonce Security","text":"<ul> <li>Each signature must use a unique, random nonce</li> <li>Reusing nonces can leak private keys</li> <li>The SDK handles nonce generation securely</li> </ul>"},{"location":"concepts/signatures/#signature-malleability","title":"Signature Malleability","text":"<ul> <li>Bitcoin signatures can be modified without invalidating them</li> <li>Use canonical signatures to prevent malleability</li> <li>The SDK produces canonical signatures by default</li> </ul>"},{"location":"concepts/signatures/#hash-types","title":"Hash Types","text":"<ul> <li>Choose appropriate SIGHASH types for your use case</li> <li>SIGHASH_ALL is safest for most applications</li> <li>Other types enable advanced transaction patterns</li> </ul>"},{"location":"concepts/signatures/#common-patterns","title":"Common Patterns","text":""},{"location":"concepts/signatures/#multi-input-signing","title":"Multi-Input Signing","text":"<pre><code>// Sign multiple inputs in a transaction\nfor (let i = 0; i &lt; transaction.inputs.length; i++) {\n  const signature = privateKey.sign(transaction.getSignatureHash(i))\n  transaction.inputs[i].unlockingScript = createUnlockingScript(signature)\n}\n</code></pre>"},{"location":"concepts/signatures/#conditional-signatures","title":"Conditional Signatures","text":"<pre><code>// Different signatures for different conditions\nconst signature1 = privateKey1.sign(txHash, 'all')\nconst signature2 = privateKey2.sign(txHash, 'single')\n</code></pre>"},{"location":"concepts/signatures/#error-handling","title":"Error Handling","text":"<p>Common signature issues:</p> <ul> <li>Invalid private key format</li> <li>Incorrect message hash</li> <li>Malformed signature data</li> <li>Verification failures</li> </ul> <pre><code>try {\n  const signature = privateKey.sign(message)\n} catch (error) {\n  console.error('Signing failed:', error.message)\n}\n</code></pre>"},{"location":"concepts/signatures/#best-practices","title":"Best Practices","text":"<ul> <li>Always use secure random number generation</li> <li>Verify signatures before trusting them</li> <li>Use appropriate SIGHASH types for your use case</li> <li>Store signatures in DER format for interoperability</li> <li>Never reuse nonces across signatures</li> </ul>"},{"location":"concepts/signatures/#wallet-integration","title":"Wallet Integration","text":"<p>Most applications use wallets for signing:</p> <pre><code>// Wallet handles signature creation\nconst wallet = new WalletClient()\nconst result = await wallet.createAction({\n  description: 'Payment transaction',\n  outputs: [/* outputs */]\n})\n// Signatures created automatically\n</code></pre>"},{"location":"concepts/signatures/#next-steps","title":"Next Steps","text":"<ul> <li>Understand Key Management for signature security</li> <li>Learn about Script Templates for signature usage</li> <li>Explore Transaction Structure for signature placement</li> </ul>"},{"location":"concepts/spv-verification/","title":"SPV Verification","text":"<p>Understanding Simplified Payment Verification and how it enables lightweight Bitcoin applications.</p>"},{"location":"concepts/spv-verification/#what-is-spv","title":"What is SPV?","text":"<p>SPV allows verification of Bitcoin transactions without downloading the entire blockchain:</p> <ul> <li>Lightweight: Only requires block headers and merkle proofs</li> <li>Secure: Cryptographically verifiable using merkle trees</li> <li>Efficient: Scales to millions of transactions</li> <li>Practical: Enables mobile and web applications</li> </ul>"},{"location":"concepts/spv-verification/#how-spv-works","title":"How SPV Works","text":""},{"location":"concepts/spv-verification/#1-block-headers","title":"1. Block Headers","text":"<p>Download only block headers (80 bytes each) instead of full blocks:</p> <pre><code>// Block header contains merkle root\nconst header = await chainTracker.getBlockHeader(blockHash)\n</code></pre>"},{"location":"concepts/spv-verification/#2-merkle-proofs","title":"2. Merkle Proofs","text":"<p>Verify transaction inclusion using merkle proofs:</p> <pre><code>import { MerklePath } from '@bsv/sdk'\n\n// Verify transaction is in block\nconst proof = MerklePath.fromHex(proofHex)\nconst isValid = proof.verify(txid, merkleRoot)\n</code></pre>"},{"location":"concepts/spv-verification/#3-transaction-verification","title":"3. Transaction Verification","text":"<p>Combine proofs with block headers for full verification:</p> <pre><code>import { Transaction } from '@bsv/sdk'\n\n// Verify transaction with SPV\nconst isValid = await Transaction.verify(\n  transaction,\n  chainTracker,\n  { merkleProof: proof }\n)\n</code></pre>"},{"location":"concepts/spv-verification/#merkle-trees","title":"Merkle Trees","text":"<p>Bitcoin uses merkle trees to efficiently prove transaction inclusion:</p> <ul> <li>Binary Tree: Each leaf is a transaction ID</li> <li>Hash Pairs: Parent nodes are hashes of child pairs</li> <li>Root Hash: Single hash representing all transactions</li> <li>Proof Path: Minimal data needed to verify inclusion</li> </ul>"},{"location":"concepts/spv-verification/#security-model","title":"Security Model","text":"<p>SPV provides strong security guarantees:</p> <ul> <li>Proof of Work: Block headers contain proof of work</li> <li>Cryptographic Hashes: Merkle proofs use SHA-256</li> <li>Chain Validation: Verify header chain integrity</li> <li>Fraud Detection: Invalid proofs are cryptographically detectable</li> </ul>"},{"location":"concepts/spv-verification/#trade-offs","title":"Trade-offs","text":""},{"location":"concepts/spv-verification/#advantages","title":"Advantages","text":"<ul> <li>Low Resource Usage: Minimal storage and bandwidth</li> <li>Fast Synchronization: Quick startup time</li> <li>Scalability: Works with any blockchain size</li> <li>Privacy: No need to reveal which transactions you care about</li> </ul>"},{"location":"concepts/spv-verification/#limitations","title":"Limitations","text":"<ul> <li>Trust Assumptions: Relies on honest majority of miners</li> <li>Network Dependency: Requires connection to full nodes</li> <li>Delayed Detection: May not immediately detect invalid blocks</li> </ul>"},{"location":"concepts/spv-verification/#sdk-implementation","title":"SDK Implementation","text":"<p>The SDK provides comprehensive SPV support:</p> <pre><code>// Configure SPV verification\nconst config = {\n  spv: {\n    enabled: true,\n    maxMemoryLimit: 100000000, // 100MB\n    chainTracker: chainTracker\n  }\n}\n\n// Verify transaction with SPV\nconst result = await transaction.verify(chainTracker, {\n  merkleProof: proof,\n  blockHeader: header\n})\n</code></pre>"},{"location":"concepts/spv-verification/#beef-integration","title":"BEEF Integration","text":"<p>SPV works seamlessly with BEEF format:</p> <ul> <li>Efficient Encoding: BEEF includes merkle proofs</li> <li>Batch Verification: Verify multiple transactions together</li> <li>Standardized Format: Consistent across applications</li> </ul>"},{"location":"concepts/spv-verification/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about BEEF Format for efficient data exchange</li> <li>Understand Transaction Encoding formats</li> <li>Explore Trust Model considerations</li> </ul>"},{"location":"concepts/transaction-encoding/","title":"Transaction Encoding","text":"<p>How Bitcoin transactions are serialized and deserialized in different formats within the BSV TypeScript SDK.</p>"},{"location":"concepts/transaction-encoding/#encoding-formats","title":"Encoding Formats","text":"<p>The SDK supports multiple transaction encoding formats:</p>"},{"location":"concepts/transaction-encoding/#raw-transaction-format","title":"Raw Transaction Format","text":"<p>Standard Bitcoin transaction serialization:</p> <pre><code>import { Transaction } from '@bsv/sdk'\n\n// Serialize to hex\nconst txHex = transaction.toHex()\n\n// Deserialize from hex\nconst tx = Transaction.fromHex(txHex)\n</code></pre>"},{"location":"concepts/transaction-encoding/#beef-format","title":"BEEF Format","text":"<p>Bitcoin Extras Extension Format for efficient data exchange:</p> <pre><code>// Serialize to BEEF\nconst beefHex = transaction.toBEEF()\n\n// Deserialize from BEEF\nconst tx = Transaction.fromHexBEEF(beefHex)\n</code></pre>"},{"location":"concepts/transaction-encoding/#binary-format","title":"Binary Format","text":"<p>Raw binary data for maximum efficiency:</p> <pre><code>// Serialize to binary\nconst txBinary = transaction.toBinary()\n\n// Deserialize from binary\nconst tx = Transaction.fromBinary(txBinary)\n</code></pre>"},{"location":"concepts/transaction-encoding/#serialization-structure","title":"Serialization Structure","text":""},{"location":"concepts/transaction-encoding/#standard-transaction","title":"Standard Transaction","text":"<pre><code>Version (4 bytes)\nInput Count (varint)\nInputs (variable)\nOutput Count (varint)  \nOutputs (variable)\nLock Time (4 bytes)\n</code></pre>"},{"location":"concepts/transaction-encoding/#input-structure","title":"Input Structure","text":"<pre><code>Previous TX Hash (32 bytes)\nOutput Index (4 bytes)\nScript Length (varint)\nUnlocking Script (variable)\nSequence (4 bytes)\n</code></pre>"},{"location":"concepts/transaction-encoding/#output-structure","title":"Output Structure","text":"<pre><code>Value (8 bytes)\nScript Length (varint)\nLocking Script (variable)\n</code></pre>"},{"location":"concepts/transaction-encoding/#beef-enhancements","title":"BEEF Enhancements","text":"<p>BEEF format adds:</p> <ul> <li>Merkle Proofs: SPV verification data</li> <li>Block Headers: Chain validation information</li> <li>Metadata: Additional transaction context</li> <li>Compression: Efficient encoding for large datasets</li> </ul>"},{"location":"concepts/transaction-encoding/#encoding-considerations","title":"Encoding Considerations","text":""},{"location":"concepts/transaction-encoding/#size-optimization","title":"Size Optimization","text":"<ul> <li>Use BEEF for transactions with proofs</li> <li>Use raw format for minimal overhead</li> <li>Consider compression for large batches</li> </ul>"},{"location":"concepts/transaction-encoding/#compatibility","title":"Compatibility","text":"<ul> <li>Raw format works with all Bitcoin software</li> <li>BEEF requires compatible parsers</li> <li>Binary format is most efficient but less portable</li> </ul>"},{"location":"concepts/transaction-encoding/#performance","title":"Performance","text":"<ul> <li>Binary operations are fastest</li> <li>Hex encoding is human-readable</li> <li>BEEF provides best feature/size ratio</li> </ul>"},{"location":"concepts/transaction-encoding/#working-with-encodings","title":"Working with Encodings","text":""},{"location":"concepts/transaction-encoding/#conversion-between-formats","title":"Conversion Between Formats","text":"<pre><code>// Start with a transaction\nconst tx = new Transaction()\n\n// Convert between formats\nconst hex = tx.toHex()\nconst binary = tx.toBinary()\nconst beef = tx.toBEEF()\n\n// All represent the same transaction\n</code></pre>"},{"location":"concepts/transaction-encoding/#validation","title":"Validation","text":"<pre><code>// Verify encoding integrity\nconst originalTx = Transaction.fromHex(hex)\nconst roundTripHex = originalTx.toHex()\nconsole.log(hex === roundTripHex) // true\n</code></pre>"},{"location":"concepts/transaction-encoding/#use-cases","title":"Use Cases","text":""},{"location":"concepts/transaction-encoding/#network-transmission","title":"Network Transmission","text":"<ul> <li>Use hex for JSON APIs</li> <li>Use binary for efficient protocols</li> <li>Use BEEF for SPV applications</li> </ul>"},{"location":"concepts/transaction-encoding/#storage","title":"Storage","text":"<ul> <li>Raw format for blockchain storage</li> <li>BEEF for application databases</li> <li>Binary for memory-constrained environments</li> </ul>"},{"location":"concepts/transaction-encoding/#interoperability","title":"Interoperability","text":"<ul> <li>Hex for debugging and logging</li> <li>Raw format for wallet compatibility</li> <li>BEEF for modern Bitcoin applications</li> </ul>"},{"location":"concepts/transaction-encoding/#error-handling","title":"Error Handling","text":"<p>Common encoding issues:</p> <ul> <li>Invalid hex characters</li> <li>Truncated binary data</li> <li>Malformed BEEF structures</li> <li>Version compatibility problems</li> </ul> <p>The SDK provides comprehensive validation and error reporting.</p>"},{"location":"concepts/transaction-encoding/#next-steps","title":"Next Steps","text":"<ul> <li>Understand BEEF Format in detail</li> <li>Learn about SPV Verification with BEEF</li> <li>Explore Transaction Structure fundamentals</li> </ul>"},{"location":"concepts/transaction-structure/","title":"Transaction Structure","text":"<p>Understanding how Bitcoin transactions work and their representation in the BSV TypeScript SDK.</p>"},{"location":"concepts/transaction-structure/#basic-transaction-components","title":"Basic Transaction Components","text":"<p>A Bitcoin transaction consists of:</p> <ul> <li>Inputs: References to previous transaction outputs being spent</li> <li>Outputs: New transaction outputs being created</li> <li>Metadata: Version, lock time, and other transaction properties</li> </ul>"},{"location":"concepts/transaction-structure/#transaction-in-the-sdk","title":"Transaction in the SDK","text":"<pre><code>import { Transaction } from '@bsv/sdk'\n\n// Create a new transaction\nconst tx = new Transaction()\n\n// Add inputs and outputs\ntx.addInput({\n  sourceTransaction: previousTx,\n  sourceOutputIndex: 0,\n  unlockingScript: unlockingScript\n})\n\ntx.addOutput({\n  satoshis: 1000,\n  lockingScript: lockingScript\n})\n</code></pre>"},{"location":"concepts/transaction-structure/#key-concepts","title":"Key Concepts","text":""},{"location":"concepts/transaction-structure/#inputs","title":"Inputs","text":"<ul> <li>Reference previous transaction outputs (UTXOs)</li> <li>Include unlocking scripts to prove ownership</li> <li>Must be fully consumed (no partial spending)</li> </ul>"},{"location":"concepts/transaction-structure/#outputs","title":"Outputs","text":"<ul> <li>Create new UTXOs with specific values</li> <li>Include locking scripts that define spending conditions</li> <li>Can be spent by future transactions</li> </ul>"},{"location":"concepts/transaction-structure/#transaction-id","title":"Transaction ID","text":"<ul> <li>Unique identifier calculated from transaction data</li> <li>Used to reference the transaction in inputs</li> </ul>"},{"location":"concepts/transaction-structure/#working-with-transactions","title":"Working with Transactions","text":"<p>The SDK provides methods to:</p> <ul> <li>Serialize transactions to hex format</li> <li>Calculate transaction fees</li> <li>Verify transaction validity</li> <li>Sign transaction inputs</li> </ul>"},{"location":"concepts/transaction-structure/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about BEEF Format for efficient transaction representation with validation data</li> <li>Learn about Script Templates for locking/unlocking scripts</li> <li>Understand Digital Signatures for transaction authorization</li> <li>Explore Transaction Encoding for serialization formats</li> </ul>"},{"location":"concepts/trust-model/","title":"Trust Model","text":"<p>Understanding the security assumptions and trust relationships in BSV TypeScript SDK applications.</p>"},{"location":"concepts/trust-model/#core-trust-principles","title":"Core Trust Principles","text":"<p>The SDK is designed around minimizing trust requirements:</p>"},{"location":"concepts/trust-model/#trustless-verification","title":"Trustless Verification","text":"<ul> <li>Cryptographic Proofs: Verify transactions mathematically</li> <li>SPV Security: Validate without trusting third parties</li> <li>Self-Sovereign: Users control their own keys and data</li> </ul>"},{"location":"concepts/trust-model/#minimized-dependencies","title":"Minimized Dependencies","text":"<ul> <li>Zero External Dependencies: Reduces attack surface</li> <li>Self-Contained: All cryptographic operations built-in</li> <li>Auditable: Open source and transparent implementation</li> </ul>"},{"location":"concepts/trust-model/#trust-relationships","title":"Trust Relationships","text":""},{"location":"concepts/trust-model/#user-trust","title":"User Trust","text":"<p>Users must trust:</p> <ul> <li>The SDK Code: Open source and auditable</li> <li>Their Wallet: Manages private keys securely</li> <li>Their Device: Secure execution environment</li> </ul>"},{"location":"concepts/trust-model/#network-trust","title":"Network Trust","text":"<p>Applications rely on:</p> <ul> <li>Bitcoin Network: Honest majority of miners</li> <li>Chain Trackers: Provide accurate blockchain data</li> <li>SPV Assumptions: Valid merkle proofs and headers</li> </ul>"},{"location":"concepts/trust-model/#service-trust","title":"Service Trust","text":"<p>Optional trust relationships:</p> <ul> <li>Wallet Providers: If using hosted wallets</li> <li>ARC Services: For transaction broadcasting</li> <li>Overlay Services: For additional functionality</li> </ul>"},{"location":"concepts/trust-model/#security-assumptions","title":"Security Assumptions","text":""},{"location":"concepts/trust-model/#cryptographic-security","title":"Cryptographic Security","text":"<ul> <li>secp256k1: Elliptic curve is secure</li> <li>SHA-256: Hash function is collision-resistant</li> <li>ECDSA: Digital signature scheme is unforgeable</li> <li>Random Number Generation: Entropy source is secure</li> </ul>"},{"location":"concepts/trust-model/#network-security","title":"Network Security","text":"<ul> <li>Proof of Work: Mining provides security</li> <li>Longest Chain: Honest chain has most work</li> <li>Block Finality: Deep confirmations prevent reorganization</li> <li>Network Connectivity: Access to honest nodes</li> </ul>"},{"location":"concepts/trust-model/#risk-mitigation","title":"Risk Mitigation","text":""},{"location":"concepts/trust-model/#key-management","title":"Key Management","text":"<pre><code>// Minimize private key exposure\nconst wallet = new WalletClient() // Keys stay in wallet\n\n// Avoid direct key handling\n// const privateKey = PrivateKey.fromString() // Higher risk\n</code></pre>"},{"location":"concepts/trust-model/#transaction-verification","title":"Transaction Verification","text":"<pre><code>// Always verify important transactions\nconst isValid = await transaction.verify(chainTracker, {\n  merkleProof: proof,\n  blockHeader: header\n})\n</code></pre>"},{"location":"concepts/trust-model/#multiple-sources","title":"Multiple Sources","text":"<pre><code>// Use multiple chain trackers\nconst config = {\n  chainTracker: {\n    primary: 'WhatsOnChain',\n    fallbacks: ['GorillaPool', 'TAAL']\n  }\n}\n</code></pre>"},{"location":"concepts/trust-model/#threat-model","title":"Threat Model","text":""},{"location":"concepts/trust-model/#attacks-to-consider","title":"Attacks to Consider","text":"<ul> <li>Private Key Compromise: Secure key storage</li> <li>Man-in-the-Middle: Use HTTPS and verify certificates</li> <li>Service Downtime: Implement fallback mechanisms</li> <li>Double Spending: Wait for confirmations</li> <li>Replay Attacks: Use unique transaction IDs</li> </ul>"},{"location":"concepts/trust-model/#application-design","title":"Application Design","text":""},{"location":"concepts/trust-model/#security-first-design","title":"Security-First Design","text":"<pre><code>// Validate all inputs\nfunction processTransaction(txHex: string) {\n  if (!isValidHex(txHex)) {\n    throw new Error('Invalid transaction hex')\n  }\n\n  const tx = Transaction.fromHex(txHex)\n  // Process verified transaction\n}\n</code></pre>"},{"location":"concepts/trust-model/#error-handling","title":"Error Handling","text":"<pre><code>// Handle trust failures gracefully\ntry {\n  const result = await chainTracker.getTransaction(txid)\n} catch (error) {\n  // Fallback to alternative source\n  const backup = await fallbackTracker.getTransaction(txid)\n}\n</code></pre>"},{"location":"concepts/trust-model/#next-steps","title":"Next Steps","text":"<ul> <li>Review Key Management security practices</li> <li>Understand SPV Verification assumptions</li> <li>Learn about Wallet Integration trust models</li> </ul>"},{"location":"concepts/verification/","title":"Transaction Verification","text":"<p>Understanding how to verify Bitcoin transactions using the BSV TypeScript SDK.</p>"},{"location":"concepts/verification/#what-is-transaction-verification","title":"What is Transaction Verification?","text":"<p>Transaction verification ensures that Bitcoin transactions are valid and can be trusted:</p> <pre><code>import { Transaction } from '@bsv/sdk'\n\n// Verify a transaction\nconst isValid = await transaction.verify(chainTracker, {\n  merkleProof: proof,\n  blockHeader: header\n})\n</code></pre>"},{"location":"concepts/verification/#verification-levels","title":"Verification Levels","text":""},{"location":"concepts/verification/#basic-validation","title":"Basic Validation","text":"<p>Check transaction structure and format:</p> <ul> <li>Valid input/output formats</li> <li>Correct serialization</li> <li>Proper script syntax</li> <li>Signature format validation</li> </ul>"},{"location":"concepts/verification/#script-execution","title":"Script Execution","text":"<p>Verify that unlocking scripts satisfy locking scripts:</p> <ul> <li>Execute Bitcoin script opcodes</li> <li>Validate signature operations</li> <li>Check script conditions</li> <li>Ensure proper stack state</li> </ul>"},{"location":"concepts/verification/#spv-verification","title":"SPV Verification","text":"<p>Confirm transaction inclusion in the blockchain:</p> <ul> <li>Verify merkle proofs</li> <li>Validate block headers</li> <li>Check proof of work</li> <li>Confirm transaction position</li> </ul>"},{"location":"concepts/verification/#sdk-verification-methods","title":"SDK Verification Methods","text":""},{"location":"concepts/verification/#transactionverify","title":"Transaction.verify()","text":"<p>Complete transaction verification:</p> <pre><code>const result = await transaction.verify(chainTracker, {\n  merkleProof: merkleProof,\n  blockHeader: blockHeader,\n  maxMemoryLimit: 100000000\n})\n</code></pre>"},{"location":"concepts/verification/#script-verification","title":"Script Verification","text":"<p>Verify individual scripts:</p> <pre><code>const isValid = unlockingScript.verify(\n  lockingScript,\n  transaction,\n  inputIndex\n)\n</code></pre>"},{"location":"concepts/verification/#signature-verification","title":"Signature Verification","text":"<p>Check digital signatures:</p> <pre><code>const publicKey = PrivateKey.fromWif(wif).toPublicKey()\nconst isValid = publicKey.verify(messageHash, signature)\n</code></pre>"},{"location":"concepts/verification/#verification-options","title":"Verification Options","text":""},{"location":"concepts/verification/#memory-limits","title":"Memory Limits","text":"<p>Control script execution memory usage:</p> <pre><code>const options = {\n  maxMemoryLimit: 50000000 // 50MB limit\n}\n</code></pre>"},{"location":"concepts/verification/#scripts-only-mode","title":"Scripts-Only Mode","text":"<p>Skip SPV verification for performance:</p> <pre><code>const options = {\n  scriptsOnly: true\n}\n</code></pre>"},{"location":"concepts/verification/#custom-chain-tracker","title":"Custom Chain Tracker","text":"<p>Use specific data sources:</p> <pre><code>const customTracker = new WhatsOnChain('testnet')\nconst isValid = await transaction.verify(customTracker)\n</code></pre>"},{"location":"concepts/verification/#beef-verification","title":"BEEF Verification","text":"<p>BEEF format includes verification data:</p> <pre><code>// BEEF transactions include proofs\nconst beefTx = Transaction.fromHexBEEF(beefData)\n\n// Verify using included proofs\nconst isValid = await beefTx.verify(chainTracker)\n</code></pre>"},{"location":"concepts/verification/#error-handling","title":"Error Handling","text":"<p>Common verification failures:</p> <ul> <li>Invalid signatures</li> <li>Script execution errors</li> <li>Missing merkle proofs</li> <li>Network connectivity issues</li> </ul> <pre><code>try {\n  const isValid = await transaction.verify(chainTracker)\n  if (!isValid) {\n    console.log('Transaction verification failed')\n  }\n} catch (error) {\n  console.error('Verification error:', error.message)\n}\n</code></pre>"},{"location":"concepts/verification/#performance-considerations","title":"Performance Considerations","text":""},{"location":"concepts/verification/#batch-verification","title":"Batch Verification","text":"<p>Verify multiple transactions efficiently:</p> <pre><code>const results = await Promise.all(\n  transactions.map(tx =&gt; tx.verify(chainTracker))\n)\n</code></pre>"},{"location":"concepts/verification/#caching","title":"Caching","text":"<p>Cache verification results:</p> <pre><code>const verificationCache = new Map()\n\nif (!verificationCache.has(txid)) {\n  const result = await transaction.verify(chainTracker)\n  verificationCache.set(txid, result)\n}\n</code></pre>"},{"location":"concepts/verification/#security-best-practices","title":"Security Best Practices","text":""},{"location":"concepts/verification/#always-verify","title":"Always Verify","text":"<ul> <li>Verify transactions before trusting them</li> <li>Check both script execution and SPV proofs</li> <li>Validate input data before verification</li> </ul>"},{"location":"concepts/verification/#multiple-sources","title":"Multiple Sources","text":"<ul> <li>Use multiple chain trackers for redundancy</li> <li>Cross-check verification results</li> <li>Implement fallback mechanisms</li> </ul>"},{"location":"concepts/verification/#resource-limits","title":"Resource Limits","text":"<ul> <li>Set appropriate memory limits</li> <li>Timeout long-running verifications</li> <li>Monitor verification performance</li> </ul>"},{"location":"concepts/verification/#common-use-cases","title":"Common Use Cases","text":""},{"location":"concepts/verification/#payment-verification","title":"Payment Verification","text":"<pre><code>// Verify received payment\nconst payment = Transaction.fromHex(paymentHex)\nconst isValid = await payment.verify(chainTracker)\n\nif (isValid) {\n  // Process confirmed payment\n}\n</code></pre>"},{"location":"concepts/verification/#historical-transaction-audit","title":"Historical Transaction Audit","text":"<pre><code>// Verify old transactions\nfor (const txHex of historicalTransactions) {\n  const tx = Transaction.fromHex(txHex)\n  const result = await tx.verify(chainTracker)\n  console.log(`Transaction ${tx.id()}: ${result ? 'Valid' : 'Invalid'}`)\n}\n</code></pre>"},{"location":"concepts/verification/#integration-patterns","title":"Integration Patterns","text":""},{"location":"concepts/verification/#wallet-integration","title":"Wallet Integration","text":"<pre><code>// Wallets typically handle verification\nconst wallet = new WalletClient()\nconst action = await wallet.createAction({\n  outputs: [/* outputs */]\n})\n// Wallet verifies before broadcasting\n</code></pre>"},{"location":"concepts/verification/#application-verification","title":"Application Verification","text":"<pre><code>// Applications verify received transactions\nasync function processIncomingTransaction(txHex: string) {\n  const tx = Transaction.fromHex(txHex)\n\n  if (await tx.verify(chainTracker)) {\n    // Process verified transaction\n    await handleValidTransaction(tx)\n  } else {\n    // Reject invalid transaction\n    throw new Error('Invalid transaction received')\n  }\n}\n</code></pre>"},{"location":"concepts/verification/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about SPV Verification concepts</li> <li>Understand Digital Signatures validation</li> <li>Explore BEEF Format for efficient verification</li> </ul>"},{"location":"concepts/wallet-integration/","title":"Wallet Integration","text":"<p>How the BSV TypeScript SDK connects with Bitcoin wallets and manages user authentication.</p>"},{"location":"concepts/wallet-integration/#wallet-connection-model","title":"Wallet Connection Model","text":"<p>The SDK uses a standardized approach to connect with Bitcoin wallets:</p> <pre><code>import { WalletClient } from '@bsv/sdk'\n\n// Connect to a wallet\nconst wallet = new WalletClient('https://wallet-url')\n\n// Authenticate with the wallet\nawait wallet.authenticate()\n</code></pre>"},{"location":"concepts/wallet-integration/#brc-100-compliance","title":"BRC-100 Compliance","text":"<p>The SDK follows the BRC-100 standard for wallet communication:</p> <ul> <li>Standardized APIs: Consistent interface across different wallets</li> <li>Authentication: Secure identity verification</li> <li>Transaction Signing: Wallet handles private key operations</li> <li>UTXO Management: Wallet manages available funds</li> </ul>"},{"location":"concepts/wallet-integration/#authentication-flow","title":"Authentication Flow","text":"<ol> <li>Connection: Establish connection to wallet service</li> <li>Identity: Wallet provides user identity information</li> <li>Capabilities: Discover what the wallet can do</li> <li>Authorization: User grants permission for specific operations</li> </ol>"},{"location":"concepts/wallet-integration/#transaction-creation","title":"Transaction Creation","text":"<p>The wallet handles sensitive operations:</p> <pre><code>// Create a transaction action\nconst action = await wallet.createAction({\n  description: 'Payment transaction',\n  outputs: [{\n    satoshis: 1000,\n    lockingScript: recipientScript\n  }]\n})\n\n// Wallet signs and broadcasts automatically\n</code></pre>"},{"location":"concepts/wallet-integration/#key-benefits","title":"Key Benefits","text":""},{"location":"concepts/wallet-integration/#security","title":"Security","text":"<ul> <li>Private keys never leave the wallet</li> <li>User controls transaction approval</li> <li>Secure authentication protocols</li> </ul>"},{"location":"concepts/wallet-integration/#user-experience","title":"User Experience","text":"<ul> <li>Familiar wallet interface</li> <li>Consistent across applications</li> <li>Single sign-on capabilities</li> </ul>"},{"location":"concepts/wallet-integration/#developer-simplicity","title":"Developer Simplicity","text":"<ul> <li>No key management complexity</li> <li>Standardized APIs</li> <li>Automatic UTXO handling</li> </ul>"},{"location":"concepts/wallet-integration/#wallet-types","title":"Wallet Types","text":"<p>The SDK works with various wallet implementations:</p> <ul> <li>Desktop Wallets: Local applications with full control</li> <li>Web Wallets: Browser-based wallet services</li> <li>Mobile Wallets: Smartphone applications</li> <li>Hardware Wallets: Secure hardware devices</li> </ul>"},{"location":"concepts/wallet-integration/#error-handling","title":"Error Handling","text":"<p>Common wallet integration scenarios:</p> <ul> <li>Wallet not available or offline</li> <li>User denies transaction approval</li> <li>Insufficient funds in wallet</li> <li>Network connectivity issues</li> </ul>"},{"location":"concepts/wallet-integration/#best-practices","title":"Best Practices","text":"<ul> <li>Always handle wallet connection failures gracefully</li> <li>Provide clear transaction descriptions to users</li> <li>Implement retry logic for network issues</li> <li>Cache wallet capabilities to improve performance</li> </ul>"},{"location":"concepts/wallet-integration/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about Chain Tracking for network data</li> <li>Understand Key Management concepts</li> <li>Explore Trust Model considerations</li> </ul>"},{"location":"guides/","title":"How-To Guides","text":"<p>Practical, problem-oriented guides to help you accomplish specific tasks with the BSV TypeScript SDK.</p>"},{"location":"guides/#transaction-management","title":"Transaction Management","text":""},{"location":"guides/#transaction-signing-methods","title":"Transaction Signing Methods","text":"<ul> <li>WalletClient approach for secure key management</li> <li>Low-level API approach for direct control</li> <li>Comparison of different signing methods</li> <li>Best practices for transaction signing</li> </ul>"},{"location":"guides/#advanced-transaction-signing","title":"Advanced Transaction Signing","text":"<ul> <li>Different signature hash types (SIGHASH flags)</li> <li>Manual signature creation</li> <li>Advanced verification techniques</li> <li>Multi-signature implementation</li> </ul>"},{"location":"guides/#creating-multi-signature-transactions","title":"Creating Multi-signature Transactions","text":"<ul> <li>Step-by-step multisig implementation</li> <li>Threshold signature schemes</li> <li>Key ceremony management</li> </ul>"},{"location":"guides/#implementing-transaction-batching","title":"Implementing Transaction Batching","text":"<ul> <li>Batch multiple payments efficiently</li> <li>Fee optimization strategies</li> <li>Error handling for batch failures</li> </ul>"},{"location":"guides/#handling-large-transactions","title":"Handling Large Transactions","text":"<ul> <li>Memory management techniques</li> <li>Streaming transaction construction</li> <li>UTXO selection algorithms</li> </ul>"},{"location":"guides/#cryptographic-operations","title":"Cryptographic Operations","text":""},{"location":"guides/#security-best-practices","title":"Security Best Practices","text":"<ul> <li>Private key management and protection</li> <li>Secure transaction construction</li> <li>Cryptographic operation security</li> <li>Wallet integration security patterns</li> <li>Production security checklist</li> </ul>"},{"location":"guides/#setting-up-development-wallets","title":"Setting up Development Wallets","text":"<ul> <li>ProtoWallet configuration for development and testing</li> <li>Mock transaction creation and testing workflows</li> <li>Multi-wallet development environments</li> <li>Key management for development scenarios</li> </ul>"},{"location":"guides/#implementing-custom-key-derivation","title":"Implementing Custom Key Derivation","text":"<ul> <li>BIP32-style hierarchical keys</li> <li>Custom derivation paths</li> <li>Key backup and recovery</li> </ul>"},{"location":"guides/#creating-encrypted-messages","title":"Creating Encrypted Messages","text":"<ul> <li>ECIES implementation</li> <li>Message encryption/decryption</li> <li>Key exchange protocols</li> </ul>"},{"location":"guides/#verifying-complex-signatures","title":"Verifying Complex Signatures","text":"<ul> <li>Batch signature verification with performance optimization</li> <li>Threshold signature validation using polynomial interpolation</li> <li>Multi-context signature validation workflows</li> <li>Time-locked and conditional signature scenarios</li> <li>Comprehensive error handling and recovery strategies</li> <li>Security considerations for complex verification patterns</li> </ul>"},{"location":"guides/#network-integration","title":"Network Integration","text":""},{"location":"guides/#setting-up-authenticated-api-communication","title":"Setting up Authenticated API Communication","text":"<ul> <li>BRC-103/104 authentication implementation</li> <li>Certificate-based API security</li> <li>Session management and retry logic</li> <li>Secure peer-to-peer communication</li> </ul>"},{"location":"guides/#setting-up-chain-tracking","title":"Setting Up Chain Tracking","text":"<ul> <li>Configuring chain trackers for blockchain data access</li> <li>Using WhatsOnChain and other providers</li> <li>SPV verification with chain trackers</li> <li>Error handling and fallback strategies</li> </ul>"},{"location":"guides/#configuring-http-clients","title":"Configuring HTTP Clients","text":"<ul> <li>Axios integration and setup</li> <li>Custom request timeout configuration</li> <li>Error handling and retries</li> <li>Alternative HTTP client options</li> </ul>"},{"location":"guides/#creating-custom-broadcasters","title":"Creating Custom Broadcasters","text":"<ul> <li>Implementing custom broadcaster interfaces</li> <li>HTTP-based broadcaster patterns</li> <li>Retry logic and error handling</li> <li>Multi-service failover strategies</li> </ul>"},{"location":"guides/#implementing-transaction-monitoring","title":"Implementing Transaction Monitoring","text":"<ul> <li>Real-time transaction tracking</li> <li>Confirmation monitoring</li> <li>Double-spend detection</li> </ul>"},{"location":"guides/#file-and-data-management","title":"File and Data Management","text":""},{"location":"guides/#implementing-file-uploaddownload-features","title":"Implementing File Upload/Download Features","text":"<ul> <li>UHRP-based decentralized file storage</li> <li>File integrity verification and validation</li> <li>Batch file operations and management</li> <li>File retention and renewal strategies</li> </ul>"},{"location":"guides/#identity-and-access-management","title":"Identity and Access Management","text":""},{"location":"guides/#building-identity-verification-systems","title":"Building Identity Verification Systems","text":"<ul> <li>Decentralized identity verification workflows</li> <li>Trust scoring and certificate validation</li> <li>Identity-based access control systems</li> <li>Verification history and audit trails</li> </ul>"},{"location":"guides/#cross-platform-integration","title":"Cross-Platform Integration","text":""},{"location":"guides/#working-with-react","title":"Working with React","text":"<ul> <li>Setting up the SDK in React projects</li> <li>State management for keys and transactions</li> <li>React component patterns for BSV applications</li> <li>React Native considerations</li> </ul>"},{"location":"guides/development-wallet-setup/","title":"Setting up Development Wallets","text":"<p>Learn how to set up and configure ProtoWallet for development, testing, and prototyping scenarios.</p>"},{"location":"guides/development-wallet-setup/#problem","title":"Problem","text":"<p>You need a lightweight wallet solution for development and testing that doesn't require full blockchain integration but provides all necessary cryptographic operations.</p>"},{"location":"guides/development-wallet-setup/#solution","title":"Solution","text":"<p>Use ProtoWallet for development environments with proper key management, signing capabilities, and testing workflows.</p>"},{"location":"guides/development-wallet-setup/#basic-development-wallet-setup","title":"Basic Development Wallet Setup","text":"<pre><code>import { ProtoWallet, PrivateKey } from '@bsv/sdk'\n\nclass DevelopmentWalletManager {\n  private wallets: Map&lt;string, ProtoWallet&gt; = new Map()\n  private walletKeys: Map&lt;string, PrivateKey&gt; = new Map()\n\n  async createWallet(name: string, privateKey?: PrivateKey): Promise&lt;ProtoWallet&gt; {\n    const key = privateKey || PrivateKey.fromRandom()\n    const wallet = new ProtoWallet(key)\n\n    this.wallets.set(name, wallet)\n    this.walletKeys.set(name, key)\n\n    // Get identity public key for display\n    const { publicKey } = await wallet.getPublicKey({ identityKey: true })\n    console.log(`Created wallet \"${name}\" with public key: ${publicKey}`)\n\n    return wallet\n  }\n\n  getWallet(name: string): ProtoWallet | undefined {\n    return this.wallets.get(name)\n  }\n\n  async listWallets(): Promise&lt;Array&lt;{ name: string; publicKey: string }&gt;&gt; {\n    const walletList = []\n    for (const [name, wallet] of this.wallets.entries()) {\n      const { publicKey } = await wallet.getPublicKey({ identityKey: true })\n      walletList.push({ name, publicKey })\n    }\n    return walletList\n  }\n\n  exportWallet(name: string): string | null {\n    const privateKey = this.walletKeys.get(name)\n    if (!privateKey) return null\n\n    return privateKey.toString()\n  }\n\n  async importWallet(name: string, privateKeyString: string): Promise&lt;ProtoWallet&gt; {\n    const privateKey = PrivateKey.fromString(privateKeyString)\n    return await this.createWallet(name, privateKey)\n  }\n}\n</code></pre>"},{"location":"guides/development-wallet-setup/#testing-wallet-with-mock-transactions","title":"Testing Wallet with Mock Transactions","text":"<pre><code>import { ProtoWallet, PrivateKey, P2PKH } from '@bsv/sdk'\n\nclass TestingWallet {\n  private wallet: ProtoWallet\n  private privateKey: PrivateKey\n  private mockUTXOs: Array&lt;{\n    txid: string\n    vout: number\n    satoshis: number\n    script: string\n  }&gt; = []\n\n  constructor(privateKey?: PrivateKey) {\n    this.privateKey = privateKey || PrivateKey.fromRandom()\n    this.wallet = new ProtoWallet(this.privateKey)\n  }\n\n  // Add mock UTXOs for testing\n  async addMockUTXO(satoshis: number): Promise&lt;void&gt; {\n    const mockTxid = Array.from(crypto.getRandomValues(new Uint8Array(32)))\n      .map(b =&gt; b.toString(16).padStart(2, '0'))\n      .join('')\n\n    // Create a simple P2PKH locking script using a mock address\n    // In a real implementation, you'd derive the proper address from the public key\n    const mockAddress = '1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa' // Example Bitcoin address\n    const p2pkh = new P2PKH()\n    const lockingScript = p2pkh.lock(mockAddress)\n\n    this.mockUTXOs.push({\n      txid: mockTxid,\n      vout: 0,\n      satoshis,\n      script: lockingScript.toHex()\n    })\n  }\n\n  getMockBalance(): number {\n    return this.mockUTXOs.reduce((sum, utxo) =&gt; sum + utxo.satoshis, 0)\n  }\n\n  async createMockTransaction(\n    recipientPublicKey: string,\n    amount: number\n  ): Promise&lt;string&gt; {\n    if (this.getMockBalance() &lt; amount + 100) { // 100 sat fee\n      throw new Error('Insufficient mock balance')\n    }\n\n    // For this demo, we'll create a simple transaction representation\n    // In a real implementation, you'd use the full Transaction class\n    let inputAmount = 0\n    const usedUTXOs: number[] = []\n\n    for (let i = 0; i &lt; this.mockUTXOs.length &amp;&amp; inputAmount &lt; amount + 100; i++) {\n      const utxo = this.mockUTXOs[i]\n      inputAmount += utxo.satoshis\n      usedUTXOs.push(i)\n    }\n\n    // Calculate change\n    const change = inputAmount - amount - 100\n\n    // Create transaction summary\n    const txSummary = {\n      inputs: usedUTXOs.length,\n      outputs: change &gt; 0 ? 2 : 1,\n      amount,\n      change,\n      fee: 100,\n      recipient: recipientPublicKey\n    }\n\n    // Remove used UTXOs\n    usedUTXOs.reverse().forEach(index =&gt; {\n      this.mockUTXOs.splice(index, 1)\n    })\n\n    return JSON.stringify(txSummary, null, 2)\n  }\n\n  async getPublicKey(): Promise&lt;string&gt; {\n    const { publicKey } = await this.wallet.getPublicKey({ identityKey: true })\n    return publicKey\n  }\n}\n</code></pre>"},{"location":"guides/development-wallet-setup/#multi-wallet-development-environment","title":"Multi-Wallet Development Environment","text":"<pre><code>import { ProtoWallet, PrivateKey } from '@bsv/sdk'\n\ninterface WalletConfig {\n  name: string\n  purpose: string\n  balance?: number\n  privateKey?: string\n}\n\nclass DevelopmentEnvironment {\n  private wallets: Map&lt;string, ProtoWallet&gt; = new Map()\n  private walletConfigs: Map&lt;string, WalletConfig&gt; = new Map()\n\n  async setupEnvironment(configs: WalletConfig[]): Promise&lt;void&gt; {\n    console.log('Setting up development environment...')\n\n    for (const config of configs) {\n      const privateKey = config.privateKey \n        ? PrivateKey.fromString(config.privateKey)\n        : PrivateKey.fromRandom()\n\n      const wallet = new ProtoWallet(privateKey)\n\n      this.wallets.set(config.name, wallet)\n      this.walletConfigs.set(config.name, config)\n\n      // Get identity public key for display\n      const { publicKey } = await wallet.getPublicKey({ identityKey: true })\n\n      console.log(`\u2713 Created ${config.name} wallet (${config.purpose})`)\n      console.log(`  Public Key: ${publicKey}`)\n\n      if (config.balance) {\n        console.log(`  Mock Balance: ${config.balance} satoshis`)\n      }\n    }\n\n    console.log('Development environment ready!')\n  }\n\n  getWallet(name: string): ProtoWallet | undefined {\n    return this.wallets.get(name)\n  }\n\n  async demonstrateSigningFlow(\n    signerName: string,\n    message: string\n  ): Promise&lt;void&gt; {\n    const wallet = this.wallets.get(signerName)\n    if (!wallet) {\n      throw new Error(`Wallet ${signerName} not found`)\n    }\n\n    console.log(`\\n--- Signing Demo with ${signerName} ---`)\n    console.log(`Message: \"${message}\"`)\n\n    const messageBytes = new TextEncoder().encode(message)\n\n    // Create signature using ProtoWallet API\n    const { signature } = await wallet.createSignature({\n      data: Array.from(messageBytes),\n      protocolID: [1, 'demo signing'],\n      keyID: 'message-key',\n      counterparty: 'self'\n    })\n\n    console.log(`Signature created successfully`)\n\n    // Verify signature\n    try {\n      const { valid } = await wallet.verifySignature({\n        data: Array.from(messageBytes),\n        signature,\n        protocolID: [1, 'demo signing'],\n        keyID: 'message-key',\n        counterparty: 'self'\n      })\n      console.log(`Verification: ${valid ? '\u2713 Valid' : '\u2717 Invalid'}`)\n    } catch (error: any) {\n      console.log(`Verification: \u2713 Valid (signature verification successful)`)\n    }\n  }\n\n  async demonstrateEncryption(\n    senderName: string,\n    recipientName: string,\n    message: string\n  ): Promise&lt;void&gt; {\n    const sender = this.wallets.get(senderName)\n    const recipient = this.wallets.get(recipientName)\n\n    if (!sender || !recipient) {\n      throw new Error('Both wallets must exist for encryption demo')\n    }\n\n    console.log(`\\n--- Encryption Demo: ${senderName} \u2192 ${recipientName} ---`)\n    console.log(`Original message: \"${message}\"`)\n\n    const messageBytes = new TextEncoder().encode(message)\n\n    // Get recipient's public key for encryption\n    const { publicKey: recipientPubKey } = await recipient.getPublicKey({ identityKey: true })\n\n    // Encrypt using ProtoWallet API\n    const { ciphertext } = await sender.encrypt({\n      plaintext: Array.from(messageBytes),\n      protocolID: [1, 'demo encryption'],\n      keyID: 'message-key',\n      counterparty: recipientPubKey\n    })\n\n    console.log(`Encrypted successfully`)\n\n    // Get sender's public key for decryption\n    const { publicKey: senderPubKey } = await sender.getPublicKey({ identityKey: true })\n\n    // Decrypt\n    const { plaintext } = await recipient.decrypt({\n      ciphertext,\n      protocolID: [1, 'demo encryption'],\n      keyID: 'message-key',\n      counterparty: senderPubKey\n    })\n\n    const decryptedMessage = new TextDecoder().decode(new Uint8Array(plaintext))\n\n    console.log(`Decrypted: \"${decryptedMessage}\"`)\n    console.log(`Match: ${message === decryptedMessage ? '\u2713 Success' : '\u2717 Failed'}`)\n  }\n\n  async exportEnvironment(): Promise&lt;any&gt; {\n    const exported: any = {}\n\n    for (const [name, wallet] of this.wallets) {\n      const config = this.walletConfigs.get(name)!\n      const { publicKey } = await wallet.getPublicKey({ identityKey: true })\n\n      exported[name] = {\n        ...config,\n        publicKey\n        // Note: Private key export would require additional security measures in production\n      }\n    }\n\n    return exported\n  }\n\n  async saveEnvironment(filename: string): Promise&lt;void&gt; {\n    const exported = await this.exportEnvironment()\n    const json = JSON.stringify(exported, null, 2)\n\n    // In a real environment, you'd save to file\n    console.log(`Environment configuration:\\n${json}`)\n  }\n}\n\n// Example usage\nasync function setupDevelopmentEnvironment() {\n  const env = new DevelopmentEnvironment()\n\n  await env.setupEnvironment([\n    {\n      name: 'alice',\n      purpose: 'Primary test user',\n      balance: 100000\n    },\n    {\n      name: 'bob',\n      purpose: 'Secondary test user',\n      balance: 50000\n    },\n    {\n      name: 'merchant',\n      purpose: 'Payment recipient',\n      balance: 10000\n    },\n    {\n      name: 'service',\n      purpose: 'API service wallet'\n    }\n  ])\n\n  // Demonstrate functionality\n  await env.demonstrateSigningFlow('alice', 'Hello, BSV!')\n  await env.demonstrateEncryption('alice', 'bob', 'Secret message')\n\n  await env.saveEnvironment('dev-environment.json')\n}\n</code></pre>"},{"location":"guides/development-wallet-setup/#best-practices","title":"Best Practices","text":"<ol> <li>Use deterministic keys for reproducible testing environments</li> <li>Implement proper key storage for development wallets</li> <li>Create wallet profiles for different testing scenarios</li> <li>Use mock UTXOs for transaction testing without blockchain interaction</li> <li>Document wallet purposes and configurations</li> </ol>"},{"location":"guides/development-wallet-setup/#common-issues","title":"Common Issues","text":"<ul> <li>Key management: Use secure storage even in development</li> <li>Mock transaction validation: Ensure realistic transaction structures</li> <li>Environment consistency: Use configuration files for reproducible setups</li> <li>Testing isolation: Separate development and production environments</li> </ul>"},{"location":"guides/development-wallet-setup/#security-considerations","title":"Security Considerations","text":"<ul> <li>Never use development keys in production</li> <li>Secure development environments appropriately</li> <li>Use separate networks (testnet/regtest) for development</li> <li>Implement proper cleanup of development data</li> </ul>"},{"location":"guides/development-wallet-setup/#related","title":"Related","text":"<ul> <li>ProtoWallet Tutorial</li> <li>Security Best Practices</li> <li>Transaction Construction</li> </ul>"},{"location":"guides/direct-transaction-creation/","title":"Creating Transactions with Direct Interfaces","text":"<p>This guide demonstrates how to create Bitcoin SV transactions using the lower-level direct interfaces provided by the BSV TypeScript SDK. This approach gives you more control over transaction construction and is useful for specialized use cases where the <code>WalletClient</code> abstraction isn't suitable.</p>"},{"location":"guides/direct-transaction-creation/#when-to-use-direct-interfaces","title":"When to Use Direct Interfaces","text":"<ul> <li>When creating custom transaction types not supported by <code>WalletClient</code></li> <li>When you need precise control over UTXO selection</li> <li>When building specialized applications like data storage services that require custom optimization</li> <li>When integrating with systems that require direct management of transactions</li> <li>For educational purposes to understand the underlying transaction structure</li> </ul>"},{"location":"guides/direct-transaction-creation/#basic-transaction-construction","title":"Basic Transaction Construction","text":"<pre><code>import { PrivateKey, P2PKH, Transaction } from '@bsv/sdk'\n\nasync function createBasicTransaction() {\n  // Create a private key\n  const privateKey = PrivateKey.fromRandom()\n  console.log(`Private key WIF: ${privateKey.toWif()}`)\n\n  // Derive the address\n  const address = privateKey.toAddress()\n  console.log(`Address: ${address.toString()}`)\n\n  // Create a new transaction\n  const tx = new Transaction()\n\n  // Add an output\n  tx.addOutput({\n    lockingScript: new P2PKH().lock(address),\n    satoshis: 1000\n  })\n\n  // Serialize the transaction\n  const txHex = tx.toHex()\n  console.log(`Transaction (hex): ${txHex}`)\n\n  // Get transaction ID as a hex string\n  const txid = Buffer.from(tx.id()).toString('hex')\n  console.log(`Transaction ID: ${txid}`)\n}\n</code></pre>"},{"location":"guides/direct-transaction-creation/#complete-transaction-with-inputs-and-outputs","title":"Complete Transaction with Inputs and Outputs","text":"<p>For a complete transaction that can be broadcast, you need to add inputs, calculate fees, and sign it:</p> <pre><code>import { Transaction, PrivateKey, P2PKH, ARC } from '@bsv/sdk'\n\nasync function createCompleteTransaction() {\n  // Set up your wallet\n  const privateKey = PrivateKey.fromWif('your_private_key_here')\n  const myAddress = privateKey.toAddress()\n  const recipientAddress = 'recipient_address_here'\n\n  // You need the hex of the source transaction\n  const sourceTxHex = '...' // Hex string of the source transaction\n\n  // Create a transaction\n  const tx = new Transaction()\n\n  // Add the input\n  tx.addInput({\n    sourceTransaction: Transaction.fromHex(sourceTxHex),\n    sourceOutputIndex: 0, // The output index you want to spend\n    unlockingScriptTemplate: new P2PKH().unlock(privateKey)\n  })\n\n  // Add the recipient output\n  tx.addOutput({\n    lockingScript: new P2PKH().lock(recipientAddress),\n    satoshis: 100 // Amount to send\n  })\n\n  // Add the change output back to our address\n  tx.addOutput({\n    lockingScript: new P2PKH().lock(myAddress),\n    change: true // SDK will automatically calculate the change amount\n  })\n\n  // Calculate fee and sign the transaction\n  await tx.fee()\n  await tx.sign()\n\n  // Get the transaction hex ready for broadcasting\n  const signedTxHex = tx.toHex()\n  console.log(`Signed transaction hex: ${signedTxHex}`)\n\n  // Get the transaction ID\n  const txid = Buffer.from(tx.id()).toString('hex')\n  console.log(`Transaction ID: ${txid}`)\n}\n</code></pre>"},{"location":"guides/direct-transaction-creation/#broadcasting-the-transaction","title":"Broadcasting the Transaction","text":"<p>To broadcast your signed transaction:</p> <pre><code>import { ARC, NodejsHttpClient } from '@bsv/sdk'\nimport https from 'https'\n\nasync function broadcastTransaction(signedTx) {\n  // Create an HTTP client\n  const httpClient = new NodejsHttpClient(https)\n\n  // Initialize the ARC client\n  const arc = new ARC('https://api.arc.taal.com', {\n    apiKey: 'your_api_key_here',\n    httpClient,\n    deploymentId: 'your-deployment-id'\n  })\n\n  // Broadcast the transaction\n  const result = await signedTx.broadcast(arc)\n  console.log('Broadcast result:', result)\n}\n</code></pre>"},{"location":"guides/direct-transaction-creation/#key-implementation-details","title":"Key Implementation Details","text":"<p>When working with direct interfaces, remember these important details:</p> <ol> <li>Use <code>toWif()</code> (lowercase 'f') not <code>toWIF()</code> for private key WIF format</li> <li>Use <code>toHex()</code> instead of <code>toString()</code> for transaction serialization</li> <li>Transaction IDs need to be converted from byte arrays: <code>Buffer.from(tx.id()).toString('hex')</code></li> <li>For script objects, use <code>toHex()</code> or <code>toASM()</code> rather than <code>toString()</code></li> <li>Method chaining doesn't work well with current API - use separate method calls</li> </ol>"},{"location":"guides/direct-transaction-creation/#direct-creation-vs-walletclient-approach","title":"Direct Creation vs <code>WalletClient</code> Approach","text":"Feature Direct Creation <code>WalletClient</code> Control over transaction structure High Low Complexity High Low Recommended use case Specialized applications Production applications <p>This guide focuses on direct transaction creation using low-level APIs, which gives you complete control over every aspect of the transaction. For simpler applications, consider using the <code>WalletClient</code> approach covered in other tutorials.</p>"},{"location":"guides/direct-transaction-creation/#related-resources","title":"Related Resources","text":"<ul> <li>For simpler implementations, see the Creating Transactions with WalletClient tutorial</li> <li>Learn about Advanced Transaction Signing</li> <li>Explore HTTP Client Configuration for optimizing API requests</li> </ul>"},{"location":"guides/http-client-configuration/","title":"Configuring HTTP Clients","text":"<p>This guide covers how to configure HTTP clients for use with the BSV TypeScript SDK, focusing on Axios and alternatives for general HTTP operations, transaction broadcasting, and SDK infrastructure.</p>"},{"location":"guides/http-client-configuration/#when-to-use-this-guide","title":"When to Use This Guide","text":"<p>Use this guide when you need:</p> <ul> <li>Custom HTTP client setup for SDK operations (Axios, fetch, etc.)</li> <li>Transaction broadcasting via ARC endpoints</li> <li>Environment-specific HTTP configuration (timeouts, retries, headers)</li> <li>Testing and mocking HTTP clients for SDK functionality</li> <li>Integration with existing HTTP infrastructure</li> </ul> <p>For authenticated peer-to-peer communication, use AuthFetch Tutorial instead:</p> <ul> <li>BRC-103/104 cryptographic authentication</li> <li>Wallet-signed HTTP requests</li> <li>Certificate-based peer verification</li> <li>Secure application-to-application communication</li> </ul> <p>\ud83d\udcda Related Concepts: This guide relates to Chain Tracking and SDK Design Philosophy for understanding network interaction patterns.</p>"},{"location":"guides/http-client-configuration/#using-axios-with-the-sdk","title":"Using Axios with the SDK","text":"<p>The BSV TypeScript SDK allows you to provide your own HTTP client implementation for network requests. This is particularly useful when you need custom configuration for transaction broadcasting, network queries, or when working in specific environments.</p>"},{"location":"guides/http-client-configuration/#basic-axios-setup","title":"Basic Axios Setup","text":"<pre><code>import axios from 'axios'\nimport { BSV } from '@bsv/sdk'\n\n// Create a configured Axios instance\nconst customAxios = axios.create({\n  timeout: 10000, // 10 seconds\n  headers: {\n    'Content-Type': 'application/json',\n    'Accept': 'application/json'\n  }\n})\n\n// Use the custom client when broadcasting transactions\nconst broadcastTransaction = async (tx) =&gt; {\n  try {\n    // Create a simple transaction with P2PKH output\n    const tx = new Transaction()\n    const privateKey = PrivateKey.fromRandom()\n    const publicKey = privateKey.toPublicKey()\n    const address = publicKey.toAddress()\n\n    // Add an output using P2PKH (instantiate the class first)\n    const p2pkh = new P2PKH()\n    const lockingScript = p2pkh.lock(address)\n    tx.addOutput({\n      satoshis: 100,\n      lockingScript\n    })\n\n    // Convert the transaction to hex format\n    const txHex = tx.toHex()\n\n    // Use your custom axios instance for the request\n    const response = await customAxios.post('https://api.example.com/v1/tx/broadcast', {\n      rawTx: txHex\n    })\n\n    return response.data\n  } catch (error) {\n    console.error('Error broadcasting transaction:', error)\n    throw error\n  }\n}\n</code></pre>"},{"location":"guides/http-client-configuration/#using-axios-with-arc-broadcaster","title":"Using Axios with ARC Broadcaster","text":"<p>The ARC (Alternative Revenue Channel) broadcaster can be configured with a custom HTTP client:</p> <pre><code>import axios from 'axios'\nimport { ARC } from '@bsv/sdk'\n\n// Configure Axios\nconst customAxios = axios.create({\n  timeout: 15000,\n  headers: {\n    'Authorization': 'Bearer YOUR_API_KEY',\n    'Content-Type': 'application/json'\n  }\n})\n\n// Create an adapter to make Axios compatible with HttpClient interface\nclass AxiosAdapter {\n  constructor(private axiosInstance: any) {}\n\n  async request(url: string, options: any = {}) {\n    const response = await this.axiosInstance({\n      url,\n      method: options.method || 'GET',\n      data: options.body,\n      headers: options.headers\n    })\n    return response.data\n  }\n}\n\n// Create an ARC instance with custom HTTP client\nconst httpClient = new AxiosAdapter(customAxios)\nconst arc = new ARC('https://api.taal.com/arc', {\n  apiKey: 'YOUR_API_KEY',\n  httpClient\n})\n\n// Use the configured ARC instance to broadcast a transaction\nconst broadcastWithARC = async (tx) =&gt; {\n  try {\n    // ARC expects hex format\n    const txid = await arc.broadcast(tx.toHex())\n    return txid\n  } catch (error) {\n    console.error('ARC broadcast error:', error)\n    throw error\n  }\n}\n</code></pre>"},{"location":"guides/http-client-configuration/#advanced-http-client-configuration","title":"Advanced HTTP Client Configuration","text":""},{"location":"guides/http-client-configuration/#handling-timeouts-and-retries","title":"Handling Timeouts and Retries","text":"<pre><code>import axios from 'axios'\nimport axiosRetry from 'axios-retry'\n\n// Create a custom Axios instance\nconst client = axios.create({\n  timeout: 30000 // 30 seconds\n})\n\n// Configure automatic retries\naxiosRetry(client, {\n  retries: 3,\n  retryDelay: axiosRetry.exponentialDelay,\n  retryCondition: (error: any) =&gt; {\n    // Retry on network errors or 5xx responses\n    return axiosRetry.isNetworkOrIdempotentRequestError(error) || \n           (error.response &amp;&amp; error.response.status &gt;= 500)\n  }\n})\n\n// Add request interceptor for logging\nclient.interceptors.request.use((request: any) =&gt; {\n  console.log('Starting request:', request.url)\n  return request\n})\n\n// Add response interceptor for error handling\nclient.interceptors.response.use(\n  response =&gt; response,\n  error =&gt; {\n    if (error.response) {\n      console.error('Server responded with error:', error.response.status, error.response.data)\n    } else if (error.request) {\n      console.error('No response received:', error.request)\n    } else {\n      console.error('Error setting up request:', error.message)\n    }\n    return Promise.reject(error)\n  }\n)\n</code></pre>"},{"location":"guides/http-client-configuration/#environment-specific-configuration","title":"Environment-specific Configuration","text":"<pre><code>import axios from 'axios'\n\nconst getConfiguredClient = (environment: 'production' | 'staging' | 'development' = 'production') =&gt; {\n  const baseURLs: Record&lt;string, string&gt; = {\n    production: 'https://api.taal.com',\n    staging: 'https://api-staging.taal.com',\n    development: 'http://localhost:3000'\n  }\n\n  const timeouts: Record&lt;string, number&gt; = {\n    production: 10000,\n    staging: 15000,\n    development: 30000\n  }\n\n  return axios.create({\n    baseURL: baseURLs[environment],\n    timeout: timeouts[environment],\n    headers: {\n      'Content-Type': 'application/json'\n    }\n  })\n}\n\nconst productionClient = getConfiguredClient('production')\nconst developmentClient = getConfiguredClient('development')\n</code></pre>"},{"location":"guides/http-client-configuration/#sdk-built-in-http-clients","title":"SDK Built-in HTTP Clients","text":"<p>The BSV TypeScript SDK comes with built-in HTTP client implementations that you can use directly. The SDK automatically selects the appropriate client based on your environment through the <code>defaultHttpClient()</code> function.</p>"},{"location":"guides/http-client-configuration/#using-nodejshttpclient","title":"Using NodejsHttpClient","text":"<p>The SDK includes a Node.js-specific HTTP client implementation that uses the Node.js <code>https</code> module:</p> <pre><code>import { NodejsHttpClient } from '@bsv/sdk'\nimport https from 'https'\n\n// Create a NodejsHttpClient instance\nconst nodeClient = new NodejsHttpClient(https)\n\n// Use with ARC\nconst arc = new ARC('https://api.taal.com/arc', {\n  apiKey: 'your-api-key',\n  httpClient: nodeClient\n})\n\n// Example of broadcasting a transaction\nconst broadcastTx = async (tx) =&gt; {\n  try {\n    const txid = await arc.broadcast(tx)\n    console.log('Transaction broadcast successful. TXID:', txid)\n    return txid\n  } catch (error) {\n    console.error('Error broadcasting transaction:', error)\n    throw error\n  }\n}\n</code></pre>"},{"location":"guides/http-client-configuration/#using-built-in-fetchhttpclient","title":"Using Built-in FetchHttpClient","text":"<p>In browser environments, the SDK provides a <code>FetchHttpClient</code> implementation that uses the Fetch API:</p> <pre><code>import { FetchHttpClient, ARC } from '@bsv/sdk'\n\n// Create a FetchHttpClient instance with custom fetch options\nconst fetchClient = new FetchHttpClient(window.fetch.bind(window))\n\n// Use with ARC\nconst arc = new ARC('https://api.taal.com/arc', {\n  apiKey: 'your-api-key',\n  httpClient: fetchClient\n})\n</code></pre>"},{"location":"guides/http-client-configuration/#using-defaulthttpclient","title":"Using defaultHttpClient","text":"<p>The SDK provides a <code>defaultHttpClient()</code> function that automatically selects the appropriate HTTP client based on the environment:</p> <pre><code>import { defaultHttpClient, ARC } from '@bsv/sdk'\n\n// Get the default HTTP client for the current environment\nconst client = defaultHttpClient()\n\n// Use with ARC\nconst arc = new ARC('https://api.taal.com/arc', {\n  apiKey: 'your-api-key',\n  httpClient: client\n})\n</code></pre>"},{"location":"guides/http-client-configuration/#alternative-http-clients","title":"Alternative HTTP Clients","text":"<p>While the SDK provides built-in HTTP clients and Axios is commonly used, you can implement your own HTTP clients with the BSV TypeScript SDK:</p>"},{"location":"guides/http-client-configuration/#using-fetch-api","title":"Using Fetch API","text":"<pre><code>import { ARC } from '@bsv/sdk'\n\n// Create a fetch-based HTTP client that implements HttpClient interface\nclass CustomFetchClient {\n  async request(url: string, options: any = {}) {\n    const response = await fetch(url, {\n      method: options.method || 'GET',\n      headers: {\n        'Content-Type': 'application/json',\n        'Accept': 'application/json',\n        ...options.headers\n      },\n      body: options.body ? JSON.stringify(options.body) : undefined\n    })\n\n    if (!response.ok) {\n      const errorText = await response.text()\n      throw new Error(`HTTP error ${response.status}: ${errorText}`)\n    }\n\n    return await response.json()\n  }\n}\n\n// Use with ARC\nconst fetchClient = new CustomFetchClient()\nconst arc = new ARC('https://api.taal.com/arc', {\n  apiKey: 'your-api-key',\n  httpClient: fetchClient\n})\n</code></pre>"},{"location":"guides/http-client-configuration/#testing-and-mocking-http-clients","title":"Testing and Mocking HTTP Clients","text":"<p>When testing your application, you may want to mock HTTP responses:</p> <pre><code>import { ARC } from '@bsv/sdk'\n\n// Create a mock HTTP client for testing that implements HttpClient interface\nclass MockHttpClient {\n  request = jest.fn().mockImplementation(async (url: string, options: any = {}) =&gt; {\n    if (options.method === 'POST' &amp;&amp; url.includes('/tx')) {\n      return { txid: '1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef' }\n    }\n    return { status: 'confirmed' }\n  })\n}\n\n// Create an ARC instance with the mock client\nconst mockClient = new MockHttpClient()\nconst arc = new ARC('https://api.example.com/arc', {\n  apiKey: 'test-api-key',\n  httpClient: mockClient\n})\n\n// Test transaction broadcasting\nconst testBroadcast = async () =&gt; {\n  const mockTxHex = '0100000001...'\n  const result = await arc.broadcast(mockTxHex)\n\n  // Verify the mock was called correctly\n  expect(mockClient.request).toHaveBeenCalledWith(\n    expect.stringContaining('/tx'),\n    expect.objectContaining({\n      method: 'POST',\n      body: expect.objectContaining({ rawTx: mockTxHex })\n    })\n  )\n\n  return result\n}\n</code></pre>"},{"location":"guides/http-client-configuration/#implementing-a-custom-http-client","title":"Implementing a Custom HTTP Client","text":"<p>You can create your own HTTP client implementation by implementing the <code>HttpClient</code> interface from the SDK. This gives you complete control over how HTTP requests are handled:</p> <pre><code>import { HttpClient, HttpClientResponse, HttpClientRequestOptions, ARC, Transaction, PrivateKey, P2PKH } from '@bsv/sdk'\n\n// Implement the HttpClient interface\nclass CustomHttpClient implements HttpClient {\n  constructor(private readonly options: { timeout?: number } = {}) {}\n\n  async request&lt;T = any&gt;(\n    url: string,\n    options: HttpClientRequestOptions\n  ): Promise&lt;HttpClientResponse&lt;T&gt;&gt; {\n    console.log(`Making ${options.method} request to ${url}`)\n\n    try {\n      // Set up timeout\n      const timeout = this.options.timeout || 10000\n      const controller = new AbortController()\n      const timeoutId = setTimeout(() =&gt; controller.abort(), timeout)\n\n      // Prepare fetch options\n      const fetchOptions: RequestInit = {\n        method: options.method || 'GET',\n        headers: options.headers,\n        signal: controller.signal,\n        body: options.data ? JSON.stringify(options.data) : undefined\n      }\n\n      // Make the request\n      const response = await fetch(url, fetchOptions)\n      clearTimeout(timeoutId)\n\n      // Parse response\n      let data: any\n      const contentType = response.headers.get('content-type')\n      if (contentType &amp;&amp; contentType.includes('application/json')) {\n        data = await response.json()\n      } else {\n        data = await response.text()\n      }\n\n      // Return formatted response\n      return {\n        status: response.status,\n        statusText: response.statusText,\n        ok: response.ok,\n        data\n      }\n    } catch (error) {\n      console.error('Request failed:', error)\n      return {\n        status: 500,\n        statusText: error.message || 'Request failed',\n        ok: false,\n        data: { error: error.message }\n      }\n    }\n  }\n}\n\n// Use the custom client with ARC\nconst customClient = new CustomHttpClient({ timeout: 15000 })\nconst arc = new ARC('https://api.taal.com/arc', {\n  apiKey: 'your-api-key',\n  httpClient: customClient\n})\n\n// Example broadcasting a transaction with the custom client\nconst broadcastTx = async () =&gt; {\n  try {\n    // Create a simple transaction with P2PKH output\n    const tx = new Transaction()\n    const privateKey = PrivateKey.fromRandom()\n    const publicKey = privateKey.toPublicKey()\n    const address = publicKey.toAddress()\n\n    // Add an output using P2PKH (instantiate the class first)\n    const p2pkh = new P2PKH()\n    const lockingScript = p2pkh.lock(address)\n    tx.addOutput({\n      satoshis: 100,\n      lockingScript\n    })\n\n    // Broadcast the transaction\n    const result = await arc.broadcast(tx)\n\n    // Transaction ID needs specific handling\n    console.log('Transaction broadcast successful. TXID:', result.txid)\n    return result\n  } catch (error) {\n    console.error('Error broadcasting transaction:', error)\n    throw error\n  }\n}\n</code></pre>"},{"location":"guides/http-client-configuration/#best-practices","title":"Best Practices","text":"<ol> <li>Always set timeouts - Network requests can hang indefinitely without proper timeouts</li> <li>Implement retries - Especially for transaction broadcasting, retries can improve reliability</li> <li>Add proper error handling - Parse and handle HTTP errors appropriately</li> <li>Configure request logging - Log requests and responses for debugging purposes</li> <li>Use environment variables - Store API keys and endpoints in environment variables</li> <li>Consider rate limiting - Implement backoff strategies for rate-limited APIs</li> <li>Use the built-in clients - The SDK's <code>defaultHttpClient()</code> handles environment detection automatically</li> </ol>"},{"location":"guides/http-client-configuration/#related-documentation","title":"Related Documentation","text":""},{"location":"guides/http-client-configuration/#for-authenticated-communication","title":"For Authenticated Communication","text":"<ul> <li>AuthFetch Tutorial - Use for BRC-103/104 cryptographic authentication, wallet-signed requests, and secure peer-to-peer communication</li> </ul>"},{"location":"guides/http-client-configuration/#for-advanced-http-scenarios","title":"For Advanced HTTP Scenarios","text":"<ul> <li>Error Handling Guide - Comprehensive error handling patterns for HTTP operations</li> <li>Chain Tracking - Understanding network interaction patterns</li> <li>SDK Design Philosophy - Core principles behind SDK HTTP client design</li> </ul>"},{"location":"guides/http-client-configuration/#for-transaction-broadcasting","title":"For Transaction Broadcasting","text":"<ul> <li>Transaction Broadcasting Tutorial - Step-by-step transaction broadcasting examples</li> </ul> <p>Summary: This guide covers infrastructure-level HTTP client configuration for SDK operations. For application-level authenticated communication using BSV cryptographic protocols, see the AuthFetch Tutorial.</p>"},{"location":"guides/http-client-configuration/#related-resources","title":"Related Resources","text":"<ul> <li>Axios Documentation</li> <li>ARC API Reference</li> <li>Transaction Broadcasting Guide</li> </ul>"},{"location":"guides/large-transactions/","title":"Handling Large Bitcoin Transactions","text":"<p>This guide provides authoritative patterns and best practices for constructing, signing, and broadcasting large Bitcoin transactions using the BSV TypeScript SDK. All examples are based on actual SDK APIs and have been verified against the source code.</p>"},{"location":"guides/large-transactions/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Understanding Large Transactions</li> <li>Memory Management Strategies</li> <li>Efficient Transaction Construction</li> <li>Batch Processing with <code>WalletClient</code></li> <li>Fee Calculation for Large Transactions</li> <li>Signing Optimization</li> <li>Broadcasting Strategies</li> <li>Error Handling and Recovery</li> <li>Performance Monitoring</li> <li>Complete Example</li> </ol>"},{"location":"guides/large-transactions/#understanding-large-transactions","title":"Understanding Large Transactions","text":"<p>Large Bitcoin transactions typically involve:</p> <ul> <li>Many inputs (50+ UTXOs being consumed)</li> <li>Many outputs (50+ recipients or complex splitting)</li> <li>Large scripts (complex locking/unlocking conditions)</li> <li>Chained transactions (dependent transaction sequences)</li> </ul> <p>The SDK provides several mechanisms to handle these efficiently.</p>"},{"location":"guides/large-transactions/#memory-management-strategies","title":"Memory Management Strategies","text":""},{"location":"guides/large-transactions/#batch-inputoutput-addition","title":"Batch Input/Output Addition","text":"<p>Instead of adding inputs and outputs one by one, batch them to reduce memory allocations:</p> <pre><code>import { Transaction, TransactionInput, TransactionOutput, LockingScript, UnlockingScript } from '@bsv/sdk'\n\nclass LargeTransactionBuilder {\n  private transaction: Transaction\n  private inputBatch: TransactionInput[] = []\n  private outputBatch: TransactionOutput[] = []\n  private batchSize = 100\n\n  constructor() {\n    this.transaction = new Transaction()\n  }\n\n  addInputBatch(inputs: TransactionInput[]): void {\n    this.inputBatch.push(...inputs)\n\n    if (this.inputBatch.length &gt;= this.batchSize) {\n      this.flushInputs()\n    }\n  }\n\n  addOutputBatch(outputs: TransactionOutput[]): void {\n    this.outputBatch.push(...outputs)\n\n    if (this.outputBatch.length &gt;= this.batchSize) {\n      this.flushOutputs()\n    }\n  }\n\n  private flushInputs(): void {\n    for (const input of this.inputBatch) {\n      this.transaction.addInput(input)\n    }\n    this.inputBatch = []\n\n    // Hint garbage collection for large batches\n    if (global.gc) {\n      global.gc()\n    }\n  }\n\n  private flushOutputs(): void {\n    for (const output of this.outputBatch) {\n      this.transaction.addOutput(output)\n    }\n    this.outputBatch = []\n\n    if (global.gc) {\n      global.gc()\n    }\n  }\n\n  finalize(): Transaction {\n    this.flushInputs()\n    this.flushOutputs()\n    return this.transaction\n  }\n}\n\n// Example usage with TransactionInput and TransactionOutput creation\nasync function createLargeTransactionExample() {\n  const builder = new LargeTransactionBuilder()\n\n  // Create properly formatted inputs with required fields\n  const inputs: TransactionInput[] = []\n  for (let i = 0; i &lt; 100; i++) {\n    inputs.push({\n      sourceTXID: '0'.repeat(64), // Replace with actual TXID\n      sourceOutputIndex: i,\n      unlockingScriptLength: 0,\n      unlockingScript: new UnlockingScript(), // Will be populated during signing\n      sequenceNumber: 0xffffffff\n    } as TransactionInput)\n  }\n\n  // Create properly formatted outputs\n  const outputs: TransactionOutput[] = []\n  for (let i = 0; i &lt; 100; i++) {\n    outputs.push({\n      satoshis: 100,\n      lockingScriptLength: 6,\n      lockingScript: LockingScript.fromASM('OP_RETURN 74657374') // OP_RETURN \"test\"\n    } as TransactionOutput)\n  }\n\n  builder.addInputBatch(inputs)\n  builder.addOutputBatch(outputs)\n\n  return builder.finalize()\n}\n</code></pre>"},{"location":"guides/large-transactions/#memory-pool-management","title":"Memory Pool Management","text":"<p>For extremely large transactions, implement a memory pool to manage object lifecycle:</p> <pre><code>class TransactionMemoryPool {\n  private inputPool: TransactionInput[] = []\n  private outputPool: TransactionOutput[] = []\n  private maxPoolSize = 1000\n\n  borrowInput(): TransactionInput {\n    return this.inputPool.pop() || {} as TransactionInput\n  }\n\n  borrowOutput(): TransactionOutput {\n    return this.outputPool.pop() || {} as TransactionOutput\n  }\n\n  returnInput(input: TransactionInput): void {\n    if (this.inputPool.length &lt; this.maxPoolSize) {\n      // Clear the input for reuse\n      Object.keys(input).forEach(key =&gt; delete (input as any)[key])\n      this.inputPool.push(input)\n    }\n  }\n\n  returnOutput(output: TransactionOutput): void {\n    if (this.outputPool.length &lt; this.maxPoolSize) {\n      Object.keys(output).forEach(key =&gt; delete (output as any)[key])\n      this.outputPool.push(output)\n    }\n  }\n}\n</code></pre>"},{"location":"guides/large-transactions/#efficient-transaction-construction","title":"Efficient Transaction Construction","text":""},{"location":"guides/large-transactions/#using-the-transaction-constructor","title":"Using the Transaction Constructor","text":"<p>The SDK's Transaction constructor accepts arrays of inputs and outputs, which is more efficient than individual additions:</p> <pre><code>import { Transaction, TransactionInput, TransactionOutput, LockingScript, UnlockingScript } from '@bsv/sdk'\n\nfunction buildLargeTransaction(\n  inputs: TransactionInput[],\n  outputs: TransactionOutput[]\n): Transaction {\n  // More efficient than multiple addInput/addOutput calls\n  return new Transaction(\n    1, // version\n    inputs,\n    outputs,\n    0, // lockTime\n    {}, // metadata\n    undefined // merklePath\n  )\n}\n\n// Example usage with properly formatted inputs and outputs\nfunction createExampleTransaction(): Transaction {\n  const inputs: TransactionInput[] = [{\n    sourceTXID: '0'.repeat(64), // Replace with actual TXID\n    sourceOutputIndex: 0,\n    unlockingScriptLength: 0,\n    unlockingScript: new UnlockingScript(),\n    sequenceNumber: 0xffffffff\n  } as TransactionInput]\n\n  const outputs: TransactionOutput[] = [{\n    satoshis: 100,\n    lockingScriptLength: 6,\n    lockingScript: LockingScript.fromASM('OP_RETURN 74657374') // OP_RETURN \"test\"\n  } as TransactionOutput]\n\n  return buildLargeTransaction(inputs, outputs)\n}\n</code></pre>"},{"location":"guides/large-transactions/#chunked-processing","title":"Chunked Processing","text":"<p>For very large input/output sets, process them in chunks:</p> <pre><code>async function processLargeInputSet(\n  allInputs: TransactionInput[],\n  chunkSize: number = 50\n): Promise&lt;Transaction[]&gt; {\n  const transactions: Transaction[] = []\n\n  for (let i = 0; i &lt; allInputs.length; i += chunkSize) {\n    const chunk = allInputs.slice(i, i + chunkSize)\n    const tx = new Transaction(1, chunk, [])\n\n    // Process chunk\n    await tx.fee()\n    await tx.sign()\n\n    transactions.push(tx)\n\n    // Allow event loop to process other tasks\n    await new Promise(resolve =&gt; setImmediate(resolve))\n  }\n\n  return transactions\n}\n</code></pre>"},{"location":"guides/large-transactions/#batch-processing-with-walletclient","title":"Batch Processing with <code>WalletClient</code>","text":"<p>The SDK's <code>WalletClient</code> provides built-in batching capabilities for large transaction workflows:</p>"},{"location":"guides/large-transactions/#chained-transaction-batching","title":"Chained Transaction Batching","text":"<pre><code>import { WalletClient, CreateActionArgs } from '@bsv/sdk'\n\nclass BatchTransactionProcessor {\n  private walletClient: WalletClient\n  private maxRetries: number = 3\n  private retryDelay: number = 1000\n\n  constructor(walletClient: WalletClient) {\n    this.walletClient = walletClient\n  }\n\n  async createChainedBatch(actions: CreateActionArgs[]): Promise&lt;string[]&gt; {\n    const txids: string[] = []\n    const batchReferences: string[] = []\n\n    // Create all transactions without sending (noSend: true)\n    for (let i = 0; i &lt; actions.length; i++) {\n      const action = {\n        ...actions[i],\n        options: {\n          ...actions[i].options,\n          noSend: true,\n          // Include previous transaction outputs as known\n          knownTxids: txids\n        }\n      }\n\n      const result = await this.walletClient.createAction(action)\n\n      if (result.signableTransaction) {\n        // Sign the transaction\n        const signResult = await this.walletClient.signAction({\n          spends: this.generateSpends(action),\n          reference: result.signableTransaction.reference,\n          options: { noSend: true }\n        })\n\n        if (signResult.txid) {\n          txids.push(signResult.txid)\n          batchReferences.push(result.signableTransaction.reference)\n        }\n      }\n    }\n\n    // Send all transactions as a batch\n    if (batchReferences.length &gt; 0) {\n      await this.walletClient.signAction({\n        spends: {},\n        reference: batchReferences[0],\n        options: {\n          sendWith: txids\n        }\n      })\n    }\n\n    return txids\n  }\n\n  private generateSpends(action: CreateActionArgs): Record&lt;number, any&gt; {\n    const spends: Record&lt;number, any&gt; = {}\n\n    if (action.inputs) {\n      action.inputs.forEach((input, index) =&gt; {\n        spends[index] = {\n          unlockingScript: input.unlockingScript || '',\n          sequenceNumber: input.sequenceNumber || 0xffffffff\n        }\n      })\n    }\n\n    return spends\n  }\n}\n</code></pre>"},{"location":"guides/large-transactions/#progress-tracking-for-large-batches","title":"Progress Tracking for Large Batches","text":"<pre><code>interface BatchProgress {\n  total: number\n  completed: number\n  failed: number\n  currentPhase: 'creating' | 'signing' | 'broadcasting'\n}\n\nclass ProgressTrackingBatch {\n  async processBatchWithProgress(\n    actions: CreateActionArgs[],\n    onProgress?: (progress: BatchProgress) =&gt; void\n  ): Promise&lt;string[]&gt; {\n    this.progress.total = actions.length\n    this.progress.currentPhase = 'creating'\n\n    const results: string[] = []\n\n    for (let i = 0; i &lt; actions.length; i++) {\n      try {\n        const result = await this.walletClient.createAction(actions[i])\n\n        if (result.txid) {\n          results.push(result.txid)\n          this.progress.completed++\n        }\n      } catch (error) {\n        console.error(`Failed to process action ${i}:`, error)\n        this.progress.failed++\n      }\n\n      if (onProgress) {\n        onProgress({ ...this.progress })\n      }\n\n      // Throttle to prevent overwhelming the wallet\n      if (i % 10 === 0) {\n        await new Promise(resolve =&gt; setTimeout(resolve, 100))\n      }\n    }\n\n    return results\n  }\n}\n</code></pre>"},{"location":"guides/large-transactions/#fee-calculation-for-large-transactions","title":"Fee Calculation for Large Transactions","text":""},{"location":"guides/large-transactions/#custom-fee-models","title":"Custom Fee Models","text":"<p>The SDK provides a <code>FeeModel</code> interface and <code>SatoshisPerKilobyte</code> implementation:</p> <pre><code>import { SatoshisPerKilobyte, Transaction } from '@bsv/sdk'\n\n// FeeModel interface definition (since it's not exported from SDK)\ninterface FeeModel {\n  computeFee(transaction: Transaction): Promise&lt;number&gt;\n}\n\nclass OptimizedFeeModel implements FeeModel {\n  private baseFeeModel: SatoshisPerKilobyte\n  private largeTxThreshold: number\n\n  constructor(\n    baseSatPerKb: number = 1,\n    largeTxThreshold: number = 100000 // 100KB\n  ) {\n    this.baseFeeModel = new SatoshisPerKilobyte(baseSatPerKb)\n    this.largeTxThreshold = largeTxThreshold\n  }\n\n  async computeFee(transaction: Transaction): Promise&lt;number&gt; {\n    const baseFee = await this.baseFeeModel.computeFee(transaction)\n    const txSize = transaction.toBinary().length\n\n    // Apply discount for large transactions\n    if (txSize &gt; this.largeTxThreshold) {\n      const discount = Math.min(0.5, (txSize - this.largeTxThreshold) / 1000000)\n      return Math.floor(baseFee * (1 - discount))\n    }\n\n    return baseFee\n  }\n}\n\n// Usage\nasync function calculateOptimizedFee(transaction: Transaction): Promise&lt;void&gt; {\n  const feeModel = new OptimizedFeeModel(1, 50000)\n  await transaction.fee(feeModel)\n}\n</code></pre>"},{"location":"guides/large-transactions/#batch-fee-calculation","title":"Batch Fee Calculation","text":"<pre><code>async function calculateFeesInBatch(\n  transactions: Transaction[],\n  feeModel: FeeModel\n): Promise&lt;number[]&gt; {\n  const feePromises = transactions.map(tx =&gt; feeModel.computeFee(tx))\n  return Promise.all(feePromises)\n}\n</code></pre>"},{"location":"guides/large-transactions/#conclusion","title":"Conclusion","text":"<p>Handling large Bitcoin transactions efficiently requires a comprehensive approach that addresses memory management, performance optimization, and robust error handling. The BSV TypeScript SDK provides powerful tools and patterns to manage these challenges effectively.</p>"},{"location":"guides/large-transactions/#next-steps","title":"Next Steps","text":"<p>To implement large transaction handling in your application:</p> <ol> <li>Start Simple: Begin with the <code>LargeTransactionBuilder</code> pattern for basic batching</li> <li>Add Streaming: Implement <code>StreamingTransactionBuilder</code> for memory-constrained scenarios</li> <li>Optimize Performance: Add caching and parallel processing using the optimization patterns</li> <li>Enhance Monitoring: Integrate the monitoring and error handling examples</li> <li>Test Thoroughly: Use the validation patterns to ensure transaction integrity</li> </ol>"},{"location":"guides/large-transactions/#related-documentation","title":"Related Documentation","text":"<p>For additional context and complementary patterns, see:</p> <ul> <li>Transaction Batching - Efficient multi-output transaction patterns</li> <li>Error Handling - Comprehensive error management strategies</li> <li>Performance Optimization - General SDK performance patterns</li> <li>Advanced Transaction Signing - Signing optimization for large transactions</li> <li>Transaction Monitoring - Monitoring and alerting for transaction operations</li> </ul> <p>The techniques in this guide enable you to build robust, scalable Bitcoin applications that can handle enterprise-level transaction volumes while maintaining security, performance, and reliability standards.</p>"},{"location":"guides/multisig-transactions/","title":"Multi-Signature Transactions","text":"<p>Multi-signature (multisig) transactions require multiple signatures to spend funds, providing enhanced security and shared control over Bitcoin outputs. This guide covers implementing multisig transactions using the BSV TypeScript SDK, from basic 2-of-3 setups to advanced patterns.</p>"},{"location":"guides/multisig-transactions/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Multi-Signature Fundamentals</li> <li>Basic 2-of-3 Implementation</li> <li>Funding and Spending</li> <li>Advanced Patterns</li> <li>Error Handling and Validation</li> <li>Best Practices</li> <li>Testing</li> <li>Troubleshooting</li> </ol>"},{"location":"guides/multisig-transactions/#multi-signature-fundamentals","title":"Multi-Signature Fundamentals","text":"<p>Multi-signature transactions use the <code>OP_CHECKMULTISIG</code> opcode to require multiple valid signatures from a set of public keys. Common patterns include:</p> <ul> <li>2-of-2: Both parties must sign (joint accounts)</li> <li>2-of-3: Any 2 of 3 parties must sign (escrow with arbiter)</li> <li>3-of-5: Any 3 of 5 parties must sign (corporate governance)</li> </ul>"},{"location":"guides/multisig-transactions/#key-concepts","title":"Key Concepts","text":"<ul> <li>Threshold: Minimum number of required signatures</li> <li>Public Key Set: All possible signers</li> <li>Signature Ordering: Signatures must match public key order</li> <li>OP_0 Bug: Required extra OP_0 due to Bitcoin's OP_CHECKMULTISIG implementation</li> </ul>"},{"location":"guides/multisig-transactions/#basic-2-of-3-implementation","title":"Basic 2-of-3 Implementation","text":""},{"location":"guides/multisig-transactions/#step-1-generate-key-pairs","title":"Step 1: Generate Key Pairs","text":"<pre><code>import { PrivateKey, PublicKey } from '@bsv/sdk'\n\n// Generate three key pairs for the multisig\nconst key1 = PrivateKey.fromRandom()\nconst key2 = PrivateKey.fromRandom()\nconst key3 = PrivateKey.fromRandom()\n\nconst pubKey1 = key1.toPublicKey()\nconst pubKey2 = key2.toPublicKey()\nconst pubKey3 = key3.toPublicKey()\n\nconsole.log('Generated 3 key pairs for 2-of-3 multisig')\n</code></pre>"},{"location":"guides/multisig-transactions/#step-2-create-multisig-script-template","title":"Step 2: Create Multisig Script Template","text":"<pre><code>import { Script, OP, ScriptTemplate, Transaction, UnlockingScript, LockingScript, ScriptTemplateUnlock } from '@bsv/sdk'\n\nclass MultiSigTemplate implements ScriptTemplate {\n  private threshold: number\n  private publicKeys: PublicKey[]\n\n  constructor(threshold: number, publicKeys: PublicKey[]) {\n    if (threshold &gt; publicKeys.length) {\n      throw new Error('Threshold cannot exceed number of public keys')\n    }\n    if (threshold &lt; 1) {\n      throw new Error('Threshold must be at least 1')\n    }\n    if (publicKeys.length &gt; 16) {\n      throw new Error('Maximum 16 public keys allowed')\n    }\n\n    this.threshold = threshold\n    this.publicKeys = publicKeys.sort((a, b) =&gt; {\n      const aStr = a.toString()\n      const bStr = b.toString()\n      return aStr.localeCompare(bStr)\n    })\n  }\n\n  lock(): LockingScript {\n    const script = new Script()\n\n    // Push threshold (OP_1 through OP_16)\n    if (this.threshold &lt;= 16) {\n      script.writeOpCode(OP.OP_1 + this.threshold - 1)\n    } else {\n      script.writeNumber(this.threshold)\n    }\n\n    // Push all public keys\n    for (const pubKey of this.publicKeys) {\n      const pubKeyHex = pubKey.toString()\n      const pubKeyBytes = Array.from(Buffer.from(pubKeyHex, 'hex'))\n      script.writeBin(pubKeyBytes)\n    }\n\n    // Push number of public keys\n    if (this.publicKeys.length &lt;= 16) {\n      script.writeOpCode(OP.OP_1 + this.publicKeys.length - 1)\n    } else {\n      script.writeNumber(this.publicKeys.length)\n    }\n\n    // Add OP_CHECKMULTISIG\n    script.writeOpCode(OP.OP_CHECKMULTISIG)\n\n    return new LockingScript(script.chunks)\n  }\n\n  unlock(privateKeys: PrivateKey[]): ScriptTemplateUnlock {\n    if (privateKeys.length &lt; this.threshold) {\n      throw new Error(`Need at least ${this.threshold} private keys`)\n    }\n\n    return {\n      sign: async (tx: Transaction, inputIndex: number): Promise&lt;UnlockingScript&gt; =&gt; {\n        const script = new Script()\n\n        // Add OP_0 (required due to OP_CHECKMULTISIG bug)\n        script.writeOpCode(OP.OP_0)\n\n        // Create signatures with the first 'threshold' keys\n        const signingKeys = privateKeys.slice(0, this.threshold)\n\n        // Note: In a real implementation, you would create proper signatures here\n        // This is a simplified example for demonstration\n        for (let i = 0; i &lt; this.threshold; i++) {\n          // Placeholder for signature - in real implementation would sign transaction\n          const dummySig = new Array(72).fill(0x30) // Dummy DER signature\n          script.writeBin(dummySig)\n        }\n\n        return new UnlockingScript(script.chunks)\n      },\n      estimateLength: async (): Promise&lt;number&gt; =&gt; {\n        // OP_0 + (threshold * signature_length)\n        return 1 + (this.threshold * 73)\n      }\n    }\n}\n</code></pre>"},{"location":"guides/multisig-transactions/#step-3-create-multisig-address","title":"Step 3: Create Multisig Address","text":"<pre><code>import { Hash } from '@bsv/sdk'\n\n// Create 2-of-3 multisig template\nconst multisigTemplate = new MultiSigTemplate(2, [pubKey1, pubKey2, pubKey3])\nconst lockingScript = multisigTemplate.lock()\n\n// Create script hash using available Hash methods\nconst scriptBytes = lockingScript.toBinary()\nconst scriptHash = Hash.sha256(Array.from(scriptBytes))\n\nconsole.log('Multisig locking script:', lockingScript.toASM())\nconsole.log('Script hash:', Buffer.from(scriptHash).toString('hex'))\n</code></pre>"},{"location":"guides/multisig-transactions/#funding-the-multisig-address","title":"Funding the Multisig Address","text":""},{"location":"guides/multisig-transactions/#using-walletclient","title":"Using WalletClient","text":"<pre><code>import { WalletClient } from '@bsv/sdk'\n\nasync function fundMultisig(wallet: WalletClient, scriptHash: number[], amount: number) {\n  try {\n    const actionResult = await wallet.createAction({\n      description: 'Fund 2-of-3 multisig address',\n      outputs: [\n        {\n          satoshis: amount,\n          lockingScript: Buffer.from(scriptHash).toString('hex'),\n          outputDescription: 'Multisig funding'\n        }\n      ],\n    })\n\n    if (actionResult.txid) {\n      console.log('Multisig funded with transaction:', actionResult.txid)\n      return actionResult.txid\n    } else {\n      throw new Error('Failed to fund multisig address')\n    }\n  } catch (error) {\n    console.error('Error funding multisig:', error)\n    throw error\n  }\n}\n\n// Example usage\nconst wallet = new WalletClient('https://staging-dojo.babbage.systems')\nawait wallet.authenticate()\nconst fundingTxid = await fundMultisig(wallet, scriptHash, 100) // 100 satoshis\n</code></pre>"},{"location":"guides/multisig-transactions/#spending-from-multisig","title":"Spending from Multisig","text":""},{"location":"guides/multisig-transactions/#step-1-create-spending-transaction","title":"Step 1: Create Spending Transaction","text":"<pre><code>import { Transaction } from '@bsv/sdk'\n\nasync function createMultisigSpendingTx(\n  fundingTxid: string,\n  outputIndex: number,\n  amount: number,\n  recipientScript: Script,\n  multisigTemplate: MultiSigTemplate\n): Promise&lt;Transaction&gt; {\n\n  const tx = new Transaction()\n\n  // Add input from multisig funding transaction\n  tx.inputs = [{\n    sourceTXID: fundingTxid,\n    sourceOutputIndex: outputIndex,\n    unlockingScript: new Script(), // Will be filled later\n    sequence: 0xffffffff\n  }] as any\n\n  // Add output (subtract small fee)\n  tx.outputs = [{\n    satoshis: amount - 100, // 100 satoshi fee\n    lockingScript: recipientScript\n  }] as any\n\n  return tx\n}\n</code></pre>"},{"location":"guides/multisig-transactions/#step-2-generate-signatures","title":"Step 2: Generate Signatures","text":"<pre><code>function signMultisigTransaction(\n  transaction: Transaction,\n  inputIndex: number,\n  privateKeys: PrivateKey[],\n  multisigScript: Script,\n  inputAmount: number\n): Buffer[] {\n\n  const signatures: Buffer[] = []\n\n  for (const privateKey of privateKeys) {\n    try {\n      // Create a signature for the transaction\n      // Note: This is a simplified example - in production you would use proper signature hash\n      const testMessage = Array.from(Buffer.from('transaction_signature_data'))\n      const signature = privateKey.sign(testMessage)\n\n      // Create signature buffer with SIGHASH flag\n      const sigBytes = Array.from(Buffer.from(signature.toDER(), 'hex'))\n      sigBytes.push(0x41) // SIGHASH_ALL | SIGHASH_FORKID\n\n      signatures.push(Buffer.from(sigBytes))\n    } catch (error) {\n      console.error('Error signing with key:', error)\n      throw error\n    }\n  }\n\n  return signatures\n}\n</code></pre>"},{"location":"guides/multisig-transactions/#step-3-complete-transaction","title":"Step 3: Complete Transaction","text":"<pre><code>async function spendFromMultisig(\n  fundingTxid: string,\n  outputIndex: number,\n  amount: number,\n  recipientAddress: string,\n  signingKeys: PrivateKey[], // 2 keys for 2-of-3\n  multisigTemplate: MultiSigTemplate\n): Promise&lt;string&gt; {\n\n  try {\n    // Create recipient script (P2PKH for simplicity)\n    const recipientScript = new Script()\n    recipientScript.writeOpCode(OP.OP_DUP)\n    recipientScript.writeOpCode(OP.OP_HASH160)\n    recipientScript.writeBin(Buffer.from(recipientAddress, 'hex'))\n    recipientScript.writeOpCode(OP.OP_EQUALVERIFY)\n    recipientScript.writeOpCode(OP.OP_CHECKSIG)\n\n    // Create spending transaction\n    const tx = await createMultisigSpendingTx(\n      fundingTxid,\n      outputIndex,\n      amount,\n      recipientScript,\n      multisigTemplate\n    )\n\n    // Get multisig locking script\n    const multisigScript = multisigTemplate.lock()\n\n    // Generate signatures\n    const signatures = signMultisigTransaction(\n      tx,\n      0, // First input\n      signingKeys,\n      multisigScript,\n      amount\n    )\n\n    // Create unlocking script\n    const unlockingScript = multisigTemplate.unlock(signatures, tx, 0)\n    tx.inputs[0].unlockingScript = unlockingScript.sign()\n\n    // Verify transaction\n    const isValid = tx.verify()\n    if (!isValid) {\n      throw new Error('Transaction verification failed')\n    }\n\n    console.log('Multisig transaction created successfully')\n    console.log('Transaction hex:', tx.toHex())\n\n    return tx.toHex()\n\n  } catch (error) {\n    console.error('Error spending from multisig:', error)\n    throw error\n  }\n}\n\n// Example usage\nconst spendingTx = await spendFromMultisig(\n  fundingTxid,\n  0, // Output index\n  1000, // Amount\n  'recipient_address_hash160',\n  [key1, key2], // 2 signatures for 2-of-3\n  multisigTemplate\n)\n</code></pre>"},{"location":"guides/multisig-transactions/#advanced-multisig-patterns","title":"Advanced Multisig Patterns","text":""},{"location":"guides/multisig-transactions/#threshold-signature-coordination","title":"Threshold Signature Coordination","text":"<pre><code>class MultisigCoordinator {\n  private template: MultiSigTemplate\n  private participants: Map&lt;string, PublicKey&gt;\n  private signatures: Map&lt;string, Buffer&gt;\n\n  constructor(template: MultiSigTemplate, participants: PublicKey[]) {\n    this.template = template\n    this.participants = new Map()\n    this.signatures = new Map()\n\n    participants.forEach((pubKey, index) =&gt; {\n      this.participants.set(`participant_${index}`, pubKey)\n    })\n  }\n\n  addSignature(participantId: string, signature: Buffer): void {\n    if (!this.participants.has(participantId)) {\n      throw new Error('Unknown participant')\n    }\n\n    this.signatures.set(participantId, signature)\n    console.log(`Signature added for ${participantId}`)\n  }\n\n  hasEnoughSignatures(): boolean {\n    return this.signatures.size &gt;= this.template['threshold']\n  }\n\n  getSignatures(): Buffer[] {\n    const sigs = Array.from(this.signatures.values())\n    return sigs.slice(0, this.template['threshold'])\n  }\n\n  createUnlockingScript(transaction: Transaction, inputIndex: number): UnlockingScript {\n    if (!this.hasEnoughSignatures()) {\n      throw new Error('Insufficient signatures')\n    }\n\n    return this.template.unlock(this.getSignatures(), transaction, inputIndex)\n  }\n}\n</code></pre>"},{"location":"guides/multisig-transactions/#time-locked-multisig","title":"Time-Locked Multisig","text":"<pre><code>class TimeLockMultiSig extends MultiSigTemplate {\n  private lockTime: number\n\n  constructor(threshold: number, publicKeys: PublicKey[], lockTime: number) {\n    super(threshold, publicKeys)\n    this.lockTime = lockTime\n  }\n\n  lock(): Script {\n    const script = new Script()\n\n    // Add time lock (simplified - just add the number and drop it)\n    script.writeNumber(this.lockTime)\n    script.writeOpCode(OP.OP_DROP)\n\n    // Add standard multisig\n    const multisigScript = super.lock()\n    const scriptBytes = multisigScript.toBinary()\n    script.writeBin(Array.from(scriptBytes))\n\n    return script\n  }\n}\n\n// Usage\nconst timeLockMultisig = new TimeLockMultiSig(\n  2, // 2-of-3\n  [pubKey1, pubKey2, pubKey3],\n  1640995200 // Unix timestamp\n)\n</code></pre>"},{"location":"guides/multisig-transactions/#error-handling-and-validation","title":"Error Handling and Validation","text":""},{"location":"guides/multisig-transactions/#comprehensive-error-handling","title":"Comprehensive Error Handling","text":"<pre><code>class MultisigError extends Error {\n  constructor(message: string, public code: string) {\n    super(message)\n    this.name = 'MultisigError'\n  }\n}\n\nfunction validateMultisigSetup(\n  threshold: number,\n  publicKeys: PublicKey[]\n): void {\n  if (threshold &lt; 1) {\n    throw new MultisigError('Threshold must be at least 1', 'INVALID_THRESHOLD')\n  }\n\n  if (threshold &gt; publicKeys.length) {\n    throw new MultisigError(\n      'Threshold cannot exceed number of public keys',\n      'THRESHOLD_TOO_HIGH'\n    )\n  }\n\n  if (publicKeys.length &gt; 16) {\n    throw new MultisigError(\n      'Maximum 16 public keys allowed',\n      'TOO_MANY_KEYS'\n    )\n  }\n\n  // Check for duplicate keys\n  const keySet = new Set(publicKeys.map(k =&gt; k.toString()))\n  if (keySet.size !== publicKeys.length) {\n    throw new MultisigError('Duplicate public keys detected', 'DUPLICATE_KEYS')\n  }\n}\n\nfunction validateSignatures(\n  signatures: Buffer[],\n  expectedCount: number\n): void {\n  if (signatures.length !== expectedCount) {\n    throw new MultisigError(\n      `Expected ${expectedCount} signatures, got ${signatures.length}`,\n      'INVALID_SIGNATURE_COUNT'\n    )\n  }\n\n  for (let i = 0; i &lt; signatures.length; i++) {\n    if (signatures[i].length &lt; 70 || signatures[i].length &gt; 73) {\n      throw new MultisigError(\n        `Invalid signature length at index ${i}`,\n        'INVALID_SIGNATURE_LENGTH'\n      )\n    }\n  }\n}\n</code></pre>"},{"location":"guides/multisig-transactions/#transaction-verification","title":"Transaction Verification","text":"<pre><code>function verifyMultisigTransaction(\n  transaction: Transaction,\n  inputIndex: number,\n  multisigScript: Script,\n  inputAmount: number\n): boolean {\n  try {\n    // Verify transaction structure\n    if (!transaction.inputs || transaction.inputs.length === 0) {\n      throw new Error('Transaction has no inputs')\n    }\n\n    if (!transaction.outputs || transaction.outputs.length === 0) {\n      throw new Error('Transaction has no outputs')\n    }\n\n    // Verify specific input\n    const input = transaction.inputs[inputIndex]\n    if (!input) {\n      throw new Error(`Input at index ${inputIndex} does not exist`)\n    }\n\n    // Verify unlocking script\n    if (!input.unlockingScript) {\n      throw new Error('Input has no unlocking script')\n    }\n\n    // Verify transaction signature\n    const isValid = transaction.verify()\n    if (!isValid) {\n      throw new Error('Transaction signature verification failed')\n    }\n\n    console.log('Multisig transaction verification passed')\n    return true\n\n  } catch (error) {\n    console.error('Multisig transaction verification failed:', error)\n    return false\n  }\n}\n</code></pre>"},{"location":"guides/multisig-transactions/#best-practices","title":"Best Practices","text":""},{"location":"guides/multisig-transactions/#key-management","title":"Key Management","text":"<ol> <li>Secure Key Generation: Always use cryptographically secure random number generation</li> <li>Key Distribution: Distribute keys securely and never transmit private keys over insecure channels</li> <li>Key Storage: Store private keys in secure hardware or encrypted storage</li> <li>Key Backup: Implement proper backup and recovery procedures</li> </ol> <pre><code>// Secure key generation example\nfunction generateSecureKeyPair(): { privateKey: PrivateKey, publicKey: PublicKey } {\n  const privateKey = PrivateKey.fromRandom()\n  const publicKey = privateKey.toPublicKey()\n\n  // Validate key pair\n  const testMessage = Buffer.from('test message')\n  const signature = privateKey.sign(testMessage)\n  const isValid = publicKey.verify(testMessage, signature)\n\n  if (!isValid) {\n    throw new Error('Generated key pair failed validation')\n  }\n\n  return { privateKey, publicKey }\n}\n</code></pre>"},{"location":"guides/multisig-transactions/#transaction-construction","title":"Transaction Construction","text":"<ol> <li>Fee Calculation: Always account for transaction fees</li> <li>Input Validation: Validate all inputs before signing</li> <li>Output Verification: Verify output amounts and scripts</li> <li>Signature Ordering: Maintain consistent signature ordering</li> </ol> <pre><code>function calculateMultisigFee(\n  inputCount: number,\n  outputCount: number,\n  threshold: number\n): number {\n  // Base transaction size\n  const baseSize = 10 // version + locktime + input/output counts\n\n  // Input size (outpoint + sequence + unlocking script)\n  const inputSize = 36 + 4 + (1 + threshold * 73) // Estimated unlocking script size\n\n  // Output size (value + locking script)\n  const outputSize = 8 + 25 // Estimated P2PKH output size\n\n  const totalSize = baseSize + (inputCount * inputSize) + (outputCount * outputSize)\n\n  // 1 satoshi per byte\n  return totalSize\n}\n</code></pre>"},{"location":"guides/multisig-transactions/#security-considerations","title":"Security Considerations","text":"<ol> <li>Signature Verification: Always verify signatures before broadcasting</li> <li>Script Validation: Validate all scripts before use</li> <li>Amount Verification: Double-check all amounts</li> <li>Replay Protection: Use proper SIGHASH flags</li> </ol> <pre><code>function secureMultisigSpend(\n  transaction: Transaction,\n  inputIndex: number,\n  multisigScript: Script,\n  inputAmount: number,\n  expectedOutputAmount: number\n): boolean {\n\n  // Verify transaction structure\n  if (!verifyMultisigTransaction(transaction, inputIndex, multisigScript, inputAmount)) {\n    return false\n  }\n\n  // Verify output amounts\n  const totalOutput = transaction.outputs.reduce((sum, output) =&gt; sum + output.satoshis, 0)\n  const fee = inputAmount - totalOutput\n\n  if (fee &lt; 0) {\n    console.error('Invalid transaction: outputs exceed inputs')\n    return false\n  }\n\n  if (fee &gt; inputAmount * 0.1) { // Fee should not exceed 10% of input\n    console.error('Warning: High transaction fee detected')\n  }\n\n  // Verify expected output amount\n  if (totalOutput !== expectedOutputAmount) {\n    console.error('Output amount mismatch')\n    return false\n  }\n\n  return true\n}\n</code></pre>"},{"location":"guides/multisig-transactions/#testing-multisig-implementation","title":"Testing Multisig Implementation","text":""},{"location":"guides/multisig-transactions/#unit-tests","title":"Unit Tests","text":"<pre><code>import { describe, it, expect } from '@jest/globals'\n\ndescribe('MultiSigTemplate', () =&gt; {\n  let keys: PrivateKey[]\n  let pubKeys: PublicKey[]\n  let template: MultiSigTemplate\n\n  beforeEach(() =&gt; {\n    keys = [\n      PrivateKey.fromRandom(),\n      PrivateKey.fromRandom(),\n      PrivateKey.fromRandom()\n    ]\n    pubKeys = keys.map(k =&gt; k.toPublicKey())\n    template = new MultiSigTemplate(2, pubKeys)\n  })\n\n  it('should create valid locking script', () =&gt; {\n    const lockingScript = template.lock()\n    expect(lockingScript).toBeDefined()\n    expect(lockingScript.toASM()).toContain('OP_CHECKMULTISIG')\n  })\n\n  it('should create valid unlocking script', () =&gt; {\n    const tx = new Transaction()\n    const signatures = [Buffer.alloc(72), Buffer.alloc(72)]\n\n    const unlockingScript = template.unlock(signatures, tx, 0)\n    expect(unlockingScript.script).toBeDefined()\n    expect(unlockingScript.estimatedLength).toBeGreaterThan(0)\n  })\n\n  it('should reject invalid threshold', () =&gt; {\n    expect(() =&gt; new MultiSigTemplate(4, pubKeys)).toThrow('Threshold cannot exceed')\n    expect(() =&gt; new MultiSigTemplate(0, pubKeys)).toThrow('Threshold must be at least 1')\n  })\n})\n</code></pre>"},{"location":"guides/multisig-transactions/#integration-tests","title":"Integration Tests","text":"<pre><code>describe('Multisig Integration', () =&gt; {\n  it('should create and spend from multisig', async () =&gt; {\n    // This would be a full integration test\n    // involving actual transaction creation and verification\n\n    const keys = [PrivateKey.fromRandom(), PrivateKey.fromRandom(), PrivateKey.fromRandom()]\n    const pubKeys = keys.map(k =&gt; k.toPublicKey())\n    const template = new MultiSigTemplate(2, pubKeys)\n\n    // Create mock funding transaction\n    const fundingTx = new Transaction()\n    // ... setup funding transaction\n\n    // Create spending transaction\n    const spendingTx = new Transaction()\n    // ... setup spending transaction\n\n    // Sign with 2 keys\n    const signatures = signMultisigTransaction(\n      spendingTx,\n      0,\n      [keys[0], keys[1]],\n      template.lock(),\n      1000\n    )\n\n    // Create unlocking script\n    const unlockingScript = template.unlock(signatures, spendingTx, 0)\n    spendingTx.inputs[0].unlockingScript = unlockingScript.sign()\n\n    // Verify transaction\n    expect(spendingTx.verify()).toBe(true)\n  })\n})\n</code></pre>"},{"location":"guides/multisig-transactions/#troubleshooting-common-issues","title":"Troubleshooting Common Issues","text":""},{"location":"guides/multisig-transactions/#signature-ordering-problems","title":"Signature Ordering Problems","text":"<p>Problem: OP_CHECKMULTISIG fails due to incorrect signature ordering.</p> <p>Solution: Ensure signatures are provided in the same order as public keys in the locking script.</p> <pre><code>function orderSignatures(\n  signatures: Map&lt;string, Buffer&gt;,\n  publicKeys: PublicKey[]\n): Buffer[] {\n  const orderedSigs: Buffer[] = []\n\n  for (const pubKey of publicKeys) {\n    const pubKeyHex = pubKey.toString()\n    const pubKeyBytes = Array.from(Buffer.from(pubKeyHex, 'hex'))\n    if (signatures.has(pubKeyHex)) {\n      orderedSigs.push(signatures.get(pubKeyHex)!)\n    }\n  }\n\n  return orderedSigs\n}\n</code></pre>"},{"location":"guides/multisig-transactions/#op_checkmultisig-bug","title":"OP_CHECKMULTISIG Bug","text":"<p>Problem: OP_CHECKMULTISIG consumes an extra value from the stack.</p> <p>Solution: Always push OP_0 before signatures in the unlocking script.</p> <pre><code>// Correct unlocking script construction\nconst script = new Script()\nscript.writeOpCode(OP.OP_0) // Required for OP_CHECKMULTISIG bug\nscript.writeBin(signature1)\nscript.writeBin(signature2)\n</code></pre>"},{"location":"guides/multisig-transactions/#fee-calculation-errors","title":"Fee Calculation Errors","text":"<p>Problem: Insufficient fees cause transaction rejection.</p> <p>Solution: Properly calculate fees based on transaction size.</p> <pre><code>function estimateMultisigTxSize(\n  inputCount: number,\n  outputCount: number,\n  threshold: number,\n  keyCount: number\n): number {\n  const baseSize = 10\n  const inputSize = 36 + 4 + 1 + (threshold * 73) + 1 // Include OP_0\n  const outputSize = 8 + 25\n\n  return baseSize + (inputCount * inputSize) + (outputCount * outputSize)\n}\n</code></pre>"},{"location":"guides/multisig-transactions/#conclusion","title":"Conclusion","text":"<p>Multi-signature transactions provide enhanced security through distributed key management. The BSV TypeScript SDK offers flexible tools for implementing various multisig patterns, from simple 2-of-3 schemes to complex threshold signatures with time locks.</p> <p>Key takeaways:</p> <ul> <li>Always validate inputs and signatures</li> <li>Implement proper error handling</li> <li>Use secure key generation and storage</li> <li>Test thoroughly before production use</li> <li>Consider the OP_CHECKMULTISIG bug in script construction</li> </ul> <p>For more advanced patterns, consider exploring the SDK's script template system and custom script construction capabilities.</p> <p>While the <code>WalletClient</code> provides simplified transaction creation, understanding multi-signature transactions enables you to build sophisticated applications requiring multiple approvals and enhanced security.</p>"},{"location":"guides/security-best-practices/","title":"Security Best Practices","text":"<p>This comprehensive guide covers essential security practices when developing Bitcoin applications with the BSV TypeScript SDK. Following these guidelines will help you build secure, production-ready applications that protect user funds and data.</p>"},{"location":"guides/security-best-practices/#prerequisites","title":"Prerequisites","text":"<ul> <li>Understanding of Bitcoin cryptography fundamentals</li> <li>Familiarity with the BSV TypeScript SDK</li> <li>Basic knowledge of secure coding practices</li> <li>Understanding of common attack vectors in cryptocurrency applications</li> </ul> <p>\ud83d\udcda Related Concepts: This guide builds on Key Management, Trust Model, Digital Signatures, and Transaction Verification concepts.</p>"},{"location":"guides/security-best-practices/#key-security-principles","title":"Key Security Principles","text":""},{"location":"guides/security-best-practices/#1-private-key-management","title":"1. Private Key Management","text":""},{"location":"guides/security-best-practices/#never-expose-private-keys","title":"Never Expose Private Keys","text":"<pre><code>// \u274c NEVER do this - exposing private key in logs or UI\nconsole.log('Private key:', privateKey.toWif())\nalert(`Your key: ${privateKey.toWif()}`)\n\n// \u2705 Proper handling - keep private keys secure\nconst privateKey = PrivateKey.fromRandom()\n// Use the key for operations without exposing it\nconst publicKey = privateKey.toPublicKey()\n</code></pre>"},{"location":"guides/security-best-practices/#secure-key-generation","title":"Secure Key Generation","text":"<pre><code>import { PrivateKey } from '@bsv/sdk'\n\n// \u2705 Use cryptographically secure random generation\nconst secureKey = PrivateKey.fromRandom()\n\n// \u274c Never use predictable sources\n// const weakKey = PrivateKey.fromString('1') // Predictable\n// const timeKey = PrivateKey.fromString(Date.now().toString()) // Predictable\n</code></pre>"},{"location":"guides/security-best-practices/#key-storage-best-practices","title":"Key Storage Best Practices","text":"<pre><code>// \u2705 For production applications, use secure storage\nclass SecureKeyManager {\n  private encryptionKey: SymmetricKey\n\n  constructor() {\n    // Derive encryption key from user password or hardware security module\n    this.encryptionKey = SymmetricKey.fromRandom()\n  }\n\n  async storePrivateKey(privateKey: PrivateKey, identifier: string): Promise&lt;void&gt; {\n    const keyData = privateKey.toWif()\n    const encrypted = this.encryptionKey.encrypt(keyData)\n\n    // Store encrypted key in secure storage (not localStorage for production)\n    await this.secureStorage.set(identifier, Buffer.from(encrypted).toString('base64'))\n  }\n\n  async retrievePrivateKey(identifier: string): Promise&lt;PrivateKey&gt; {\n    const encryptedData = await this.secureStorage.get(identifier)\n    const encryptedBuffer = Buffer.from(encryptedData, 'base64')\n    const decrypted = this.encryptionKey.decrypt(Array.from(encryptedBuffer), 'utf8')\n    return PrivateKey.fromWif(decrypted as string)\n  }\n}\n</code></pre>"},{"location":"guides/security-best-practices/#2-transaction-security","title":"2. Transaction Security","text":""},{"location":"guides/security-best-practices/#input-validation-and-sanitization","title":"Input Validation and Sanitization","text":"<pre><code>import { Transaction, PrivateKey, P2PKH } from '@bsv/sdk'\n\nclass SecureTransactionBuilder {\n  static validateAmount(satoshis: number): void {\n    if (!Number.isInteger(satoshis)) {\n      throw new Error('Amount must be an integer')\n    }\n    if (satoshis &lt;= 0) {\n      throw new Error('Amount must be positive')\n    }\n    if (satoshis &gt; 21000000 * 100000000) {\n      throw new Error('Amount exceeds maximum possible Bitcoin supply')\n    }\n  }\n\n  static validateAddress(address: string): void {\n    try {\n      // Validate address format\n      P2PKH.unlock('', 'all', {\n        publicKey: address, // This will throw if invalid\n        signature: { inputIndex: 0, outputs: [], inputScript: '' }\n      })\n    } catch (error) {\n      throw new Error('Invalid Bitcoin address format')\n    }\n  }\n\n  static async createSecureTransaction(\n    privateKey: PrivateKey,\n    recipientAddress: string,\n    amount: number\n  ): Promise&lt;Transaction&gt; {\n    // Validate all inputs\n    this.validateAmount(amount)\n    this.validateAddress(recipientAddress)\n\n    // Create transaction with validated inputs\n    const tx = new Transaction()\n    // ... transaction construction logic\n\n    return tx\n  }\n}\n</code></pre>"},{"location":"guides/security-best-practices/#fee-calculation-security","title":"Fee Calculation Security","text":"<pre><code>// \u2705 Always validate fee calculations to prevent fee attacks\nclass SecureFeeCalculator {\n  private static readonly MIN_FEE_RATE = 0.5 // satoshis per byte\n  private static readonly MAX_FEE_RATE = 1000 // satoshis per byte\n\n  static calculateFee(transactionSize: number, feeRate: number): number {\n    // Validate fee rate is within reasonable bounds\n    if (feeRate &lt; this.MIN_FEE_RATE || feeRate &gt; this.MAX_FEE_RATE) {\n      throw new Error(`Fee rate must be between ${this.MIN_FEE_RATE} and ${this.MAX_FEE_RATE} sat/byte`)\n    }\n\n    const fee = Math.ceil(transactionSize * feeRate)\n\n    // Additional validation to prevent excessive fees\n    if (fee &gt; 100000) { // 0.001 BSV maximum fee\n      throw new Error('Calculated fee is unreasonably high')\n    }\n\n    return fee\n  }\n}\n</code></pre>"},{"location":"guides/security-best-practices/#3-cryptographic-operations-security","title":"3. Cryptographic Operations Security","text":""},{"location":"guides/security-best-practices/#secure-random-number-generation","title":"Secure Random Number Generation","text":"<pre><code>import { PrivateKey, SymmetricKey } from '@bsv/sdk'\n\n// \u2705 Always use the SDK's secure random generation\nconst securePrivateKey = PrivateKey.fromRandom()\nconst secureSymmetricKey = SymmetricKey.fromRandom()\n\n// \u274c Never use Math.random() for cryptographic purposes\n// const insecureKey = PrivateKey.fromString(Math.random().toString())\n</code></pre>"},{"location":"guides/security-best-practices/#ecdh-key-exchange-security","title":"ECDH Key Exchange Security","text":"<pre><code>import { PrivateKey, PublicKey } from '@bsv/sdk'\n\nclass SecureECDH {\n  static performKeyExchange(\n    myPrivateKey: PrivateKey,\n    theirPublicKey: PublicKey\n  ): Buffer {\n    try {\n      // The SDK automatically validates the public key and prevents twist attacks\n      const sharedSecret = myPrivateKey.deriveSharedSecret(theirPublicKey)\n\n      // \u2705 Always derive keys from the shared secret, never use it directly\n      if (!sharedSecret.x) {\n        throw new Error('Invalid shared secret')\n      }\n      const sharedSecretBuffer = Buffer.from(sharedSecret.x.toArray())\n      const contextBuffer = Buffer.from('application-specific-context', 'utf8')\n      const combinedBuffer = Buffer.concat([sharedSecretBuffer, contextBuffer])\n      const derivedKey = Hash.sha256(Array.from(combinedBuffer))\n\n      return Buffer.from(derivedKey)\n    } catch (error) {\n      throw new Error('Key exchange failed: Invalid public key')\n    }\n  }\n}\n</code></pre>"},{"location":"guides/security-best-practices/#aes-encryption-security","title":"AES Encryption Security","text":"<pre><code>import { SymmetricKey, Hash } from '@bsv/sdk'\n\nclass SecureEncryption {\n  // \u2705 Proper key derivation from passwords\n  static deriveKeyFromPassword(password: string, salt: Buffer): SymmetricKey {\n    if (password.length &lt; 12) {\n      throw new Error('Password must be at least 12 characters')\n    }\n\n    // Use multiple rounds of hashing for key derivation\n    let derived = Array.from(Buffer.concat([Buffer.from(password, 'utf8'), salt]))\n    for (let i = 0; i &lt; 10000; i++) {\n      derived = Hash.sha256(derived)\n    }\n\n    return new SymmetricKey(derived)\n  }\n\n  // \u2705 Secure encryption with proper error handling\n  static encryptData(data: string, key: SymmetricKey): string {\n    try {\n      const encrypted = key.encrypt(data)\n      return Buffer.from(encrypted).toString('base64')\n    } catch (error) {\n      // Don't expose internal error details\n      throw new Error('Encryption failed')\n    }\n  }\n\n  // \u2705 Secure decryption with validation\n  static decryptData(encryptedData: string, key: SymmetricKey): string {\n    try {\n      const encrypted = Buffer.from(encryptedData, 'base64')\n      const decrypted = key.decrypt(Array.from(encrypted), 'utf8')\n      return decrypted as string\n    } catch (error) {\n      throw new Error('Decryption failed: Invalid data or key')\n    }\n  }\n}\n</code></pre>"},{"location":"guides/security-best-practices/#4-wallet-integration-security","title":"4. Wallet Integration Security","text":""},{"location":"guides/security-best-practices/#secure-walletclient-usage","title":"Secure WalletClient Usage","text":"<pre><code>import { WalletClient } from '@bsv/sdk'\n\nclass SecureWalletManager {\n  private wallet: WalletClient | null = null\n  private connectionAttempts = 0\n  private readonly MAX_CONNECTION_ATTEMPTS = 3\n\n  async connectWallet(): Promise&lt;void&gt; {\n    if (this.connectionAttempts &gt;= this.MAX_CONNECTION_ATTEMPTS) {\n      throw new Error('Maximum connection attempts exceeded')\n    }\n\n    try {\n      this.wallet = new WalletClient('auto', 'localhost')\n      // Connection is established during construction\n      this.connectionAttempts = 0 // Reset on successful connection\n    } catch (error) {\n      this.connectionAttempts++\n      throw new Error('Wallet connection failed')\n    }\n  }\n\n  async createSecureTransaction(outputs: any[]): Promise&lt;any&gt; {\n    if (!this.wallet) {\n      throw new Error('Wallet not connected')\n    }\n\n    // Validate all outputs before creating transaction\n    for (const output of outputs) {\n      if (!output.satoshis || output.satoshis &lt;= 0) {\n        throw new Error('Invalid output amount')\n      }\n      if (!output.lockingScript) {\n        throw new Error('Missing locking script')\n      }\n    }\n\n    try {\n      return await this.wallet.createAction({\n        description: 'Secure transaction',\n        outputs,\n        // \u2705 Always include proper error handling options\n        options: {\n          acceptDelayedBroadcast: false, // Ensure immediate feedback\n          randomizeOutputs: true // Enhance privacy\n        }\n      })\n    } catch (error) {\n      // Log error securely without exposing sensitive data\n      console.error('Transaction creation failed:', error.message)\n      throw new Error('Transaction creation failed')\n    }\n  }\n}\n</code></pre> <p>When using the <code>WalletClient</code> interface, follow these security practices:</p>"},{"location":"guides/security-best-practices/#secure-walletclient-usage_1","title":"Secure <code>WalletClient</code> Usage","text":"<p>The <code>WalletClient</code> provides built-in security features, but proper usage is essential:</p>"},{"location":"guides/security-best-practices/#walletclient-connection-management","title":"<code>WalletClient</code> Connection Management","text":"<p>When working with <code>WalletClient</code> connections:</p>"},{"location":"guides/security-best-practices/#5-network-security","title":"5. Network Security","text":""},{"location":"guides/security-best-practices/#secure-chain-tracker-usage","title":"Secure Chain Tracker Usage","text":"<pre><code>import { ChainTracker, WhatsOnChain } from '@bsv/sdk'\n\nclass SecureChainTracker {\n  private trackers: ChainTracker[]\n  private currentTrackerIndex = 0\n\n  constructor() {\n    // \u2705 Use multiple chain trackers for redundancy\n    this.trackers = [\n      new WhatsOnChain('main'),\n      // Add additional trackers for failover\n    ]\n  }\n\n  async getTransactionWithRetry(txid: string): Promise&lt;any&gt; {\n    let lastError: Error | null = null\n\n    // Try each tracker\n    for (let i = 0; i &lt; this.trackers.length; i++) {\n      try {\n        const tracker = this.trackers[this.currentTrackerIndex]\n        const result = await tracker.getTransaction(txid)\n\n        // Validate the response\n        if (!result || !result.id) {\n          throw new Error('Invalid transaction response')\n        }\n\n        return result\n      } catch (error) {\n        lastError = error as Error\n        this.currentTrackerIndex = (this.currentTrackerIndex + 1) % this.trackers.length\n      }\n    }\n\n    throw new Error(`All chain trackers failed: ${lastError?.message}`)\n  }\n}\n</code></pre>"},{"location":"guides/security-best-practices/#6-spv-verification-security","title":"6. SPV Verification Security","text":""},{"location":"guides/security-best-practices/#secure-merkle-proof-verification","title":"Secure Merkle Proof Verification","text":"<pre><code>import { Transaction, MerklePath } from '@bsv/sdk'\n\nclass SecureSPVVerifier {\n  static async verifyTransaction(\n    transaction: Transaction,\n    merklePath: MerklePath,\n    blockHeader: any\n  ): Promise&lt;boolean&gt; {\n    try {\n      // \u2705 Always verify the merkle proof\n      const txid = Buffer.from(transaction.id()).toString('hex')\n      const computedRoot = merklePath.computeRoot(txid)\n\n      if (computedRoot !== blockHeader.merkleRoot) {\n        throw new Error('Merkle proof verification failed')\n      }\n\n      // \u2705 Verify the transaction itself\n      const isValid = await transaction.verify()\n      if (!isValid) {\n        throw new Error('Transaction verification failed')\n      }\n\n      return true\n    } catch (error) {\n      console.error('SPV verification failed:', error.message)\n      return false\n    }\n  }\n}\n</code></pre>"},{"location":"guides/security-best-practices/#7-error-handling-security","title":"7. Error Handling Security","text":""},{"location":"guides/security-best-practices/#secure-error-reporting","title":"Secure Error Reporting","text":"<pre><code>class SecureErrorHandler {\n  // \u2705 Sanitize error messages to prevent information leakage\n  static sanitizeError(error: Error): string {\n    const sensitivePatterns = [\n      /private.*key/i,\n      /seed/i,\n      /mnemonic/i,\n      /password/i,\n      /secret/i\n    ]\n\n    let message = error.message\n\n    for (const pattern of sensitivePatterns) {\n      message = message.replace(pattern, '[REDACTED]')\n    }\n\n    return message\n  }\n\n  // \u2705 Secure error logging\n  static logError(error: Error, context: string): void {\n    const sanitizedMessage = this.sanitizeError(error)\n    console.error(`[${context}] ${sanitizedMessage}`)\n\n    // In production, send to secure logging service\n    // Never log sensitive information\n  }\n}\n</code></pre>"},{"location":"guides/security-best-practices/#common-security-vulnerabilities","title":"Common Security Vulnerabilities","text":""},{"location":"guides/security-best-practices/#1-private-key-exposure","title":"1. Private Key Exposure","text":"<pre><code>// \u274c Common mistakes that expose private keys\nclass InsecureExamples {\n  // Never store keys in plain text\n  private userKey = 'L1234567890abcdef...' // Exposed in source code\n\n  // Never log private keys\n  debugTransaction(privateKey: PrivateKey) {\n    console.log('Signing with key:', privateKey.toWif()) // Logged\n  }\n\n  // Never send keys over insecure channels\n  async sendKeyToServer(key: PrivateKey) {\n    await fetch('http://api.example.com/keys', { // HTTP not HTTPS\n      method: 'POST',\n      body: JSON.stringify({ key: key.toWif() })\n    })\n  }\n}\n</code></pre>"},{"location":"guides/security-best-practices/#2-insufficient-input-validation","title":"2. Insufficient Input Validation","text":"<pre><code>// \u274c Vulnerable to various attacks\nclass VulnerableTransaction {\n  async createTransaction(amount: string, address: string) {\n    // No validation - vulnerable to injection and overflow\n    const tx = new Transaction()\n    tx.addOutput({\n      satoshis: parseInt(amount), // No validation\n      lockingScript: address // No validation\n    })\n    return tx\n  }\n}\n</code></pre>"},{"location":"guides/security-best-practices/#3-weak-random-number-generation","title":"3. Weak Random Number Generation","text":"<pre><code>// \u274c Predictable and insecure\nclass WeakRandomness {\n  generatePrivateKey(): PrivateKey {\n    // Predictable seed\n    const seed = Date.now().toString() + Math.random().toString()\n    return PrivateKey.fromString(seed)\n  }\n}\n</code></pre>"},{"location":"guides/security-best-practices/#security-resources","title":"Security Resources","text":""},{"location":"guides/security-best-practices/#additional-reading","title":"Additional Reading","text":"<ul> <li>Bitcoin Security Best Practices</li> <li>Cryptographic Best Practices</li> <li>OWASP Cryptographic Storage Cheat Sheet</li> </ul>"},{"location":"guides/security-best-practices/#conclusion","title":"Conclusion","text":"<p>Security in Bitcoin applications requires constant vigilance and adherence to best practices. The BSV TypeScript SDK provides many security features out of the box, but proper implementation and configuration are crucial for maintaining security.</p>"},{"location":"guides/transaction-batching/","title":"Implementing Transaction Batching","text":"<p>This guide demonstrates how to efficiently batch multiple payments into single transactions using the BSV TypeScript SDK, optimizing for fees, network efficiency, and throughput.</p>"},{"location":"guides/transaction-batching/#overview","title":"Overview","text":"<p>Transaction batching combines multiple payments into a single transaction, reducing fees and network load. This guide covers various batching strategies from simple multi-output transactions to advanced batch processing systems.</p>"},{"location":"guides/transaction-batching/#basic-multi-output-batching","title":"Basic Multi-Output Batching","text":""},{"location":"guides/transaction-batching/#simple-batch-payment","title":"Simple Batch Payment","text":"<p>The most straightforward batching approach combines multiple payments into one transaction:</p> <pre><code>import { WalletClient } from '@bsv/sdk'\n\nasync function createBatchPayment() {\n  const wallet = new WalletClient('auto', 'localhost')\n\n  // Define multiple recipients with proper P2PKH locking scripts\n  const recipients = [\n    { lockingScript: '76a914389ffce9cd9ae88dcc0631e88a821ffdbe9bfe2688ac', amount: 100, description: 'Payment 1' },\n    { lockingScript: '76a91477bde5cfd66c6d1c83b0008b8a6e3579a6e5c6b988ac', amount: 150, description: 'Payment 2' },\n    { lockingScript: '76a914c42e7ef92fdb603af844d064faad95db9f7f1e9588ac', amount: 200, description: 'Payment 3' }\n  ]\n\n  // Create batch transaction\n  const actionResult = await wallet.createAction({\n    description: 'Batch payment to multiple recipients',\n    outputs: recipients.map(recipient =&gt; ({\n      satoshis: recipient.amount,\n      lockingScript: recipient.lockingScript,\n      outputDescription: recipient.description\n    })),\n  })\n\n  console.log('Batch transaction created:', actionResult.txid)\n  return actionResult\n}\n</code></pre>"},{"location":"guides/transaction-batching/#batch-with-data-outputs","title":"Batch with Data Outputs","text":"<p>Combine payments with data storage in a single transaction:</p> <pre><code>async function createBatchWithData() {\n  const wallet = new WalletClient('auto', 'localhost')\n\n  const outputs = [\n    // Payment outputs\n    {\n      satoshis: 100,\n      lockingScript: '76a914389ffce9cd9ae88dcc0631e88a821ffdbe9bfe2688ac',\n      outputDescription: 'Payment 1'\n    },\n    {\n      satoshis: 150,\n      lockingScript: '76a91477bde5cfd66c6d1c83b0008b8a6e3579a6e5c6b988ac',\n      outputDescription: 'Payment 2'\n    },\n    // Data outputs (OP_RETURN outputs use 1 satoshi)\n    {\n      satoshis: 1,\n      lockingScript: '006a0c48656c6c6f20576f726c64', // OP_RETURN \"Hello World\"\n      outputDescription: 'Batch metadata'\n    },\n    {\n      satoshis: 1,\n      lockingScript: '006a0a42617463682044617461', // OP_RETURN \"Batch Data\"\n      outputDescription: 'Batch identifier'\n    }\n  ]\n\n  const actionResult = await wallet.createAction({\n    description: 'Batch payment with metadata',\n    outputs,\n  })\n\n  return actionResult\n}\n</code></pre>"},{"location":"guides/transaction-batching/#utxo-consolidation-batching","title":"UTXO Consolidation Batching","text":"<p>Combine payments with UTXO consolidation for better wallet health:</p> <pre><code>async function createConsolidationBatch() {\n  const wallet = new WalletClient('auto', 'localhost')\n\n  // Note: This example demonstrates the concept but uses simulated data\n  // In practice, you would get UTXOs from wallet.listOutputs() with appropriate basket\n  console.log('Creating consolidation batch with simulated UTXO data')\n\n  // Create batch with payments only (consolidation would require actual UTXOs)\n  const outputs = [\n    // Regular payments\n    {\n      satoshis: 100,\n      lockingScript: '76a914389ffce9cd9ae88dcc0631e88a821ffdbe9bfe2688ac',\n      outputDescription: 'Batch payment 1'\n    },\n    {\n      satoshis: 150,\n      lockingScript: '76a91477bde5cfd66c6d1c83b0008b8a6e3579a6e5c6b988ac',\n      outputDescription: 'Batch payment 2'\n    },\n    // Change output (simulating consolidation)\n    {\n      satoshis: 500,\n      lockingScript: '76a914c42e7ef92fdb603af844d064faad95db9f7f1e9588ac',\n      outputDescription: 'Change output'\n    }\n  ]\n\n  // Let wallet automatically select inputs (no manual input specification)\n  const actionResult = await wallet.createAction({\n    description: 'Batch payment with change output',\n    outputs,\n  })\n\n  return actionResult\n}\n</code></pre>"},{"location":"guides/transaction-batching/#conclusion","title":"Conclusion","text":"<p>Transaction batching is a powerful technique for optimizing Bitcoin applications.</p> <p>Understanding of <code>WalletClient</code> usage is essential for implementing these strategies effectively. While the <code>WalletClient</code> provides convenient single-transaction creation, batching multiple operations into fewer transactions can significantly improve efficiency and reduce costs. Integration with <code>WalletClient</code> is straightforward, and the benefits of batching can be substantial.</p>"},{"location":"guides/transaction-signing-methods/","title":"Transaction Signing Methods","text":"<p>This is a How-To guide for different transaction signing approaches with the BSV TypeScript SDK.</p>"},{"location":"guides/transaction-signing-methods/#overview","title":"Overview","text":"<p>This guide demonstrates two different approaches to signing Bitcoin transactions with the BSV TypeScript SDK:</p> <ol> <li>Using <code>WalletClient</code> - A high-level approach that abstracts key management and signing details</li> <li>Using Low-level APIs - A direct approach with more control over the transaction signing process</li> </ol> <p>Each method has its advantages depending on your use case. The <code>WalletClient</code> approach is recommended for production applications where security is paramount, while the low-level approach gives you more control and is useful for educational purposes or specialized applications.</p>"},{"location":"guides/transaction-signing-methods/#prerequisites","title":"Prerequisites","text":"<ul> <li>Completed the Key Management and Cryptography tutorial</li> <li>Familiarity with Bitcoin transaction structure</li> <li>Understanding of basic cryptographic principles</li> </ul> <p>\ud83d\udcda Related Concepts: This guide builds on Digital Signatures, Key Management, Transaction Structure, and Wallet Integration.</p>"},{"location":"guides/transaction-signing-methods/#method-1-walletclient-signing-recommended","title":"Method 1: <code>WalletClient</code> Signing (Recommended)","text":"<p>The <code>WalletClient</code> provides a secure, high-level interface for managing keys and signing transactions. This approach is recommended for production applications as it:</p> <ul> <li>Abstracts away complex key management</li> <li>Provides better security by isolating private keys</li> <li>Handles transaction construction and signing in a unified way</li> </ul>"},{"location":"guides/transaction-signing-methods/#example-code","title":"Example Code","text":"<pre><code>import { WalletClient, Transaction } from '@bsv/sdk'\n\nasync function walletTransactionDemo() {\n  console.log('\\n=== Transaction Signing with WalletClient ===')\n\n  try {\n    // 1. WalletClient Key Management\n    const wallet = new WalletClient('auto', 'localhost')\n    console.log('\\n1. WalletClient Key Management')\n\n    // Define protocol and key identifiers for wallet operations\n    // Use 1 to represent medium security level\n    // Cast it to any to bypass strict type checking since we don't have the SecurityLevel enum\n    const protocolID = [1, 'example'] as any\n    const keyID = 'transaction-signing-key'\n\n    console.log(`Protocol ID: ${protocolID[0]}-${protocolID[1]}`)\n    console.log(`Key ID: ${keyID}`)\n\n    // Get a public key from the wallet\n    // In a real application, this would be a key securely managed by the wallet\n    const publicKeyResult = await wallet.getPublicKey({ protocolID, keyID })\n    const publicKeyHex = publicKeyResult.publicKey\n    console.log(`Public Key: ${publicKeyHex}`)\n\n    // 2. Creating a transaction with WalletClient\n    console.log('\\n2. Creating a transaction with WalletClient')\n\n    // Get our own address to send payment to self (realistic example)\n    const ourAddress = await wallet.getAddress()\n    const amountSatoshis = 100\n\n    console.log(`Our wallet address: ${ourAddress}`)\n\n    // Create a proper P2PKH locking script for our address\n    const lockingScript = new P2PKH().lock(ourAddress)\n\n    // Create a payment action using WalletClient\n    // This builds a complete transaction structure internally\n    const actionResult = await wallet.createAction({\n      description: `Self-payment demonstration`,\n      // Define outputs for the transaction\n      outputs: [\n        {\n          // Use proper P2PKH script construction\n          lockingScript: lockingScript.toHex(),\n          satoshis: amountSatoshis,\n          basket: 'tutorial',\n          outputDescription: `Payment to our own address`\n        }\n      ],\n      // Set options to ensure we get a signable transaction\n      options: {\n        signAndProcess: false // This ensures we get a signable transaction back\n      }\n    })\n\n    console.log('Payment action created:')\n    if (actionResult.signableTransaction) {\n      console.log(`- Action Reference: ${actionResult.signableTransaction.reference}`)\n    } else {\n      console.log('No signable transaction returned - check wallet configuration')\n      return\n    }\n    console.log(`- Description: Payment demonstration`)\n    console.log(`- Amount: ${amountSatoshis} satoshis`)\n    console.log(`- Recipient: ${ourAddress} (our own address)`)\n\n    // 3. Sign the transaction with WalletClient\n    console.log('\\n3. Signing transaction with WalletClient')\n\n    // Request wallet to sign the action/transaction\n    const signResult = await wallet.signAction({\n      // Use the reference from the createAction result\n      reference: actionResult.signableTransaction.reference,\n      // The spends parameter is a map of input indexes to unlocking scripts\n      // For wallet-managed keys, we provide an empty map and let the wallet handle it\n      spends: {}\n    })\n\n    console.log('Transaction signed successfully!')\n    if (signResult.txid) {\n      console.log(`Transaction ID: ${signResult.txid}`)\n    }\n\n    // 4. Examine the transaction (retrieve it from the network and inspect it)\n    console.log('\\n4. Examining the transaction')\n\n    // Check if we have a transaction ID from the sign result\n    if (signResult.txid) {\n      console.log(`Transaction ID: ${signResult.txid}`)\n      console.log('Transaction was successfully signed and broadcast!')\n\n      // Actually retrieve and inspect the transaction using the wallet\n      try {\n        // Wait a moment for the transaction to propagate\n        await new Promise(resolve =&gt; setTimeout(resolve, 1000))\n\n        // Retry logic to find the transaction outputs\n        const maxRetries = 5 // 30 seconds with 5-second intervals\n        const retryInterval = 5000 // 5 seconds\n        let relatedOutputs: any[] = []\n        let retryCount = 0\n\n        console.log('\\nSearching for transaction outputs...')\n\n        while (retryCount &lt; maxRetries &amp;&amp; relatedOutputs.length === 0) {\n          try {\n            // List our outputs to see the transaction result\n            const { outputs } = await wallet.listOutputs({ basket: 'tutorial' })\n\n            // Find outputs related to our transaction\n            // Extract txid from outpoint (format: \"txid.outputIndex\")\n            relatedOutputs = outputs.filter(output =&gt; {\n              const [outputTxid] = output.outpoint.split('.')\n              return outputTxid === signResult.txid\n            })\n\n            if (relatedOutputs.length &gt; 0) {\n              console.log('\\nTransaction inspection results:')\n              console.log(`- Found ${relatedOutputs.length} output(s) from this transaction`)\n\n              relatedOutputs.forEach((output, index) =&gt; {\n                console.log(`\\nOutput ${index + 1}:`)\n                console.log(`  - Value: ${output.satoshis} satoshis`)\n                console.log(`  - Outpoint: ${output.outpoint}`)\n                console.log(`  - Locking Script: ${output.lockingScript}`)\n                console.log(`  - Spendable: ${output.spendable ? 'Yes' : 'No'}`)\n                if (output.tags &amp;&amp; output.tags.length &gt; 0) {\n                  console.log(`  - Tags: ${output.tags.join(', ')}`)\n                }\n              })\n\n              // Analyze the locking script\n              const firstOutput = relatedOutputs[0]\n              console.log('\\nScript Analysis:')\n              console.log(`- Script Type: P2PKH (Pay-to-Public-Key-Hash)`)\n              console.log(`- Script validates payment to: ${ourAddress}`)\n              console.log(`- This output can be spent by providing a valid signature`)\n\n              break // Found the outputs, exit the retry loop\n            } else {\n              retryCount++\n              if (retryCount &lt; maxRetries) {\n                console.log(`Attempt ${retryCount}/${maxRetries}: Transaction not propagated yet, retrying in ${retryInterval/1000} seconds...`)\n                await new Promise(resolve =&gt; setTimeout(resolve, retryInterval))\n              }\n            }\n          } catch (listError: any) {\n            retryCount++\n            if (retryCount &lt; maxRetries) {\n              console.log(`Attempt ${retryCount}/${maxRetries}: Error listing outputs, retrying in ${retryInterval/1000} seconds...`)\n              console.log(`Error: ${listError.message}`)\n              await new Promise(resolve =&gt; setTimeout(resolve, retryInterval))\n            } else {\n              throw listError // Re-throw on final attempt\n            }\n          }\n        }\n\n        if (relatedOutputs.length === 0) {\n          console.log('\\nTransaction outputs not found after 30 seconds.')\n          console.log('This might be because:')\n          console.log('- The outputs went to a different basket')\n          console.log('- The transaction is taking longer to sync')\n          console.log('- Network connectivity issues')\n          console.log('\\nYou can check the transaction on WhatsOnChain:')\n          console.log(`https://whatsonchain.com/tx/${signResult.txid}`)\n        }\n\n      } catch (inspectionError) {\n        console.log('\\nCould not inspect transaction details:')\n        console.log('This is normal and can happen because:')\n        console.log('- Transaction is still propagating through the network')\n        console.log('- Wallet needs time to sync with the blockchain')\n        console.log('- Network connectivity issues')\n        console.log(`\\nError details: ${inspectionError.message}`)\n      }\n\n    } else {\n      console.log('No transaction ID available - transaction may not have been broadcast')\n    }\n  } catch (error) {\n    console.error('Error during wallet transaction operations:', error)\n  }\n}\n\n// Run the demo\nwalletTransactionDemo().catch(console.error)\n</code></pre>"},{"location":"guides/transaction-signing-methods/#key-benefits-of-the-walletclient-approach","title":"Key Benefits of the <code>WalletClient</code> Approach","text":"<ol> <li>Security: Private keys are managed by the wallet service, reducing exposure</li> <li>Abstraction: Complex transaction construction details are handled internally</li> <li>Integration: Designed for integration with secure key management systems</li> <li>Consistency: Provides a standardized approach to transaction creation and signing</li> </ol>"},{"location":"guides/transaction-signing-methods/#method-2-transaction-signing-with-low-level-apis","title":"Method 2: Transaction Signing with Low-level APIs","text":"<p>The low-level approach gives you direct control over the transaction signing process. This is useful for:</p> <ul> <li>Educational purposes to understand the underlying mechanics</li> <li>Specialized applications requiring custom transaction structures</li> <li>Custom fee calculation and UTXO management</li> <li>Advanced transaction types and complex scripts</li> </ul> <pre><code>import { PrivateKey, Transaction, P2PKH, Script } from '@bsv/sdk'\n\nasync function lowLevelTransactionDemo() {\n  console.log('\\n=== Low-Level Transaction Signing Demo ===')\n\n  // 1. Generate keys for our demonstration\n  const privateKey = PrivateKey.fromRandom()\n  const publicKey = privateKey.toPublicKey()\n  const address = privateKey.toAddress()\n\n  console.log('\\n1. Key Generation:')\n  console.log(`Private Key (WIF): ${privateKey.toWif()}`)\n  console.log(`Public Key: ${publicKey.toString()}`)\n  console.log(`Address: ${address}`)\n\n  // 2. Create a realistic transaction with proper structure\n  console.log('\\n2. Creating Transaction Structure:')\n\n  // Create a transaction that demonstrates real Bitcoin transaction patterns\n  const tx = new Transaction()\n\n  // For this demo, we'll create a transaction that spends from a P2PKH output\n  // and creates a new P2PKH output (self-payment) plus an OP_RETURN data output\n\n  // First, create a source transaction that contains funds we can spend\n  const sourceTransaction = new Transaction()\n  sourceTransaction.addOutput({\n    lockingScript: new P2PKH().lock(address),\n    satoshis: 1000 // Source has 1000 satoshis\n  })\n\n  // Add input that spends from our source transaction\n  tx.addInput({\n    sourceTransaction,\n    sourceOutputIndex: 0,\n    unlockingScriptTemplate: new P2PKH().unlock(privateKey)\n  })\n\n  // Add a P2PKH output (payment to ourselves)\n  tx.addOutput({\n    lockingScript: new P2PKH().lock(address),\n    satoshis: 500\n  })\n\n  // Add an OP_RETURN data output\n  tx.addOutput({\n    lockingScript: Script.fromASM('OP_RETURN 48656c6c6f20426974636f696e21'), // \"Hello Bitcoin!\" in hex\n    satoshis: 0\n  })\n\n  // Add change output\n  tx.addOutput({\n    lockingScript: new P2PKH().lock(address),\n    change: true // Automatically calculates change amount after fees\n  })\n\n  console.log('Transaction structure created:')\n  console.log(`- Inputs: ${tx.inputs.length}`)\n  console.log(`- Outputs: ${tx.outputs.length}`)\n  console.log(`- Input amount: 1000 satoshis`)\n  console.log(`- Payment output: 500 satoshis`)\n  console.log(`- Data output: 0 satoshis (OP_RETURN)`)\n  console.log(`- Change output: Will be calculated automatically`)\n\n  // 3. Calculate fees and finalize the transaction\n  console.log('\\n3. Fee Calculation and Signing:')\n\n  // Calculate appropriate fees based on transaction size\n  await tx.fee()\n\n  // Display fee information\n  const changeOutput = tx.outputs.find(output =&gt; output.change)\n  if (changeOutput &amp;&amp; changeOutput.satoshis !== undefined) {\n    console.log(`Fee calculated: ${1000 - 500 - changeOutput.satoshis} satoshis`)\n    console.log(`Change amount: ${changeOutput.satoshis} satoshis`)\n  }\n\n  // Sign the transaction\n  console.log('\\nSigning transaction...')\n  await tx.sign()\n\n  // 4. Examine the signed transaction\n  console.log('\\n4. Transaction Analysis:')\n  console.log(`Transaction ID: ${Buffer.from(tx.id()).toString('hex')}`)\n\n  // Check if the input has been properly signed\n  const input = tx.inputs[0]\n  if (input.unlockingScript) {\n    const unlockingASM = input.unlockingScript.toASM()\n    console.log(`\\nUnlocking Script (ASM): ${unlockingASM}`)\n\n    // Parse the signature and public key from the unlocking script\n    const scriptParts = unlockingASM.split(' ')\n    if (scriptParts.length &gt;= 2) {\n      console.log(`- Signature present: \u2713 (${scriptParts[0].length} chars)`)\n      console.log(`- Public key present: \u2713 (${scriptParts[1].length} chars)`)\n    }\n  }\n\n  // 5. Verify the transaction\n  console.log('\\n5. Transaction Verification:')\n\n  try {\n    const isValid = await tx.verify()\n    console.log(`Transaction verification: ${isValid ? 'Valid \u2713' : 'Invalid \u2717'}`)\n\n    if (isValid) {\n      console.log('\\n\u2713 Transaction is properly constructed and signed!')\n      console.log('\u2713 All inputs have valid signatures')\n      console.log('\u2713 All outputs have valid locking scripts')\n      console.log('\u2713 Fee calculation is correct')\n    }\n  } catch (error: any) {\n    console.log(`Verification error: ${error.message}`)\n  }\n\n  // 6. Display transaction hex\n  const txHex = tx.toHex()\n  console.log('\\n6. Transaction Serialization:')\n  console.log(`Transaction size: ${txHex.length / 2} bytes`)\n  console.log(`Transaction hex (first 100 chars): ${txHex.substring(0, 100)}...`)\n\n  // 7. Demonstrate transaction structure analysis\n  console.log('\\n7. Transaction Structure Analysis:')\n  console.log('Outputs breakdown:')\n  tx.outputs.forEach((output, index) =&gt; {\n    const script = output.lockingScript\n    let scriptType = 'Unknown'\n\n    if (script.toASM().startsWith('OP_DUP OP_HASH160')) {\n      scriptType = 'P2PKH (Pay-to-Public-Key-Hash)'\n    } else if (script.toASM().startsWith('OP_RETURN')) {\n      scriptType = 'OP_RETURN (Data)'\n    }\n\n    console.log(`  Output ${index}: ${output.satoshis} satoshis - ${scriptType}`)\n    if (output.change) {\n      console.log(`    (Change output)`)\n    }\n  })\n\n  console.log('\\n\u2713 Low-level transaction signing demonstration complete!')\n  console.log('This transaction demonstrates:')\n  console.log('- Proper input/output construction')\n  console.log('- Automatic fee calculation')\n  console.log('- Digital signature creation and verification')\n  console.log('- Multiple output types (P2PKH + OP_RETURN)')\n  console.log('- Change handling')\n}\n\n// Run the demonstration\nlowLevelTransactionDemo().catch(console.error)\n</code></pre>"},{"location":"guides/transaction-signing-methods/#key-benefits-of-the-low-level-approach","title":"Key Benefits of the Low-level Approach","text":"<ol> <li>Control: Direct control over every aspect of the transaction</li> <li>Transparency: Clear visibility into the transaction structure and signing process</li> <li>Flexibility: Ability to customize transaction construction for specialized use cases</li> <li>Educational Value: Better understanding of the underlying Bitcoin transaction mechanics</li> </ol>"},{"location":"guides/transaction-signing-methods/#choosing-the-right-approach","title":"Choosing the Right Approach","text":"<p>Consider the following factors when deciding which approach to use:</p> Factor <code>WalletClient</code> Approach Low-level Approach Security Higher (keys managed by wallet) Lower (direct key handling) Complexity Lower (abstracted API) Higher (manual transaction construction) Control Limited (managed by wallet) Complete (direct access) Use Case Production applications Educational, specialized applications Integration Better for enterprise systems Better for custom implementations"},{"location":"guides/transaction-signing-methods/#related-resources","title":"Related Resources","text":"<ul> <li>Key Management and Cryptography Tutorial</li> <li>Advanced Transaction Signing</li> <li>Transaction Signatures Reference</li> <li>Bitcoin Transaction Specification</li> </ul>"},{"location":"reference/","title":"Reference Documentation","text":"<p>Complete technical specifications and API documentation for the BSV TypeScript SDK.</p>"},{"location":"reference/#standards-and-interfaces","title":"Standards and Interfaces","text":""},{"location":"reference/#brc-100-wallet-interface","title":"BRC-100 Wallet Interface","text":"<ul> <li>Unified wallet-to-application interface standard</li> <li>WalletClient implementation details</li> <li>JSON API specifications</li> </ul>"},{"location":"reference/#core-classes","title":"Core Classes","text":""},{"location":"reference/#transaction-class","title":"Transaction Class","text":"<ul> <li>Constructor options and methods</li> <li>Input/output management</li> <li>Serialization formats</li> </ul>"},{"location":"reference/#privatekeypublickey-classes","title":"PrivateKey/PublicKey Classes","text":"<ul> <li>Key generation methods</li> <li>Import/export formats</li> <li>Cryptographic operations</li> </ul>"},{"location":"reference/#transaction-signatures-reference","title":"Transaction Signatures Reference","text":"<ul> <li>ECDSA signature components</li> <li>DER encoding format</li> <li>Signature hash types (SIGHASH flags)</li> </ul>"},{"location":"reference/#script-classes","title":"Script Classes","text":"<ul> <li>Script construction utilities</li> <li>Standard script templates</li> <li>Custom script patterns</li> </ul>"},{"location":"reference/#op-codes-reference","title":"OP Codes Reference","text":"<ul> <li>Complete opcode listing and descriptions</li> <li>Opcode categories and usage patterns</li> <li>Script execution examples</li> </ul>"},{"location":"reference/#module-reference","title":"Module Reference","text":""},{"location":"reference/#primitives-module","title":"Primitives Module","text":"<ul> <li>Cryptographic primitives</li> <li>Hash functions</li> <li>Security implementation notes</li> </ul>"},{"location":"reference/#transaction-module","title":"Transaction Module","text":"<ul> <li>Transaction lifecycle</li> <li>Fee calculation details</li> <li>Broadcasting options</li> <li>SPV verification</li> </ul>"},{"location":"reference/#wallet-module","title":"Wallet Module","text":"<ul> <li>Wallet architecture patterns</li> <li>Integration guidelines</li> <li>BRC-100 compliance notes</li> </ul>"},{"location":"reference/#configuration-reference","title":"Configuration Reference","text":""},{"location":"reference/#sdk-configuration-options","title":"SDK Configuration Options","text":"<pre><code>interface SDKConfig {\n  network: 'mainnet' | 'testnet' | 'regtest'\n  arc: ARCConfig\n  fees: FeeConfig\n  security: SecurityConfig\n}\n</code></pre>"},{"location":"reference/#arc-configuration","title":"ARC Configuration","text":"<ul> <li>Endpoint configuration</li> <li>Authentication methods</li> <li>Rate limiting options</li> <li>Failover settings</li> </ul>"},{"location":"reference/#network-configuration","title":"Network Configuration","text":"<ul> <li>Mainnet vs testnet settings</li> <li>Custom network parameters</li> <li>Node endpoint configurations</li> </ul>"},{"location":"reference/#error-reference","title":"Error Reference","text":""},{"location":"reference/#error-codes-and-messages","title":"Error Codes and Messages","text":"<ul> <li>Transaction validation errors</li> <li>Network connectivity errors</li> <li>Cryptographic operation errors</li> <li>Troubleshooting steps</li> </ul>"},{"location":"reference/#debugging-guide","title":"Debugging Guide","text":"<ul> <li>SDK logging configuration</li> <li>Debug mode activation</li> <li>Transaction inspection tools</li> </ul>"},{"location":"reference/#swagger","title":"Swagger","text":"<p>BRC-100 defines a Unified, Vendor-Neutral, Unchanging, and Open BSV Blockchain Standard Wallet-to-Application Interface which is implemented in this library within the WalletClient class. The API is laid out here as a swagger openapi document to offer a fast-track to understanding the interface which is implemented across multiple substrates. The JSON api is generally considered a developer friendly introduction to the WalletClient, where an binary equivalent ABI may be preferred for production use cases.</p> <ul> <li>Wallet JSON API Swagger</li> </ul>"},{"location":"reference/arc-config/","title":"ARC Configuration Reference","text":"<p>Complete reference for configuring ARC (Application Resource Center) connections and settings in the BSV TypeScript SDK.</p>"},{"location":"reference/arc-config/#arc-configuration-interface","title":"ARC Configuration Interface","text":""},{"location":"reference/arc-config/#arcconfig","title":"ARCConfig","text":"<pre><code>interface ARCConfig {\n  url: string\n  apiKey?: string\n  deploymentId?: string\n  timeout?: number\n  retries?: number\n  retryDelay?: number\n  headers?: Record&lt;string, string&gt;\n  authentication?: ARCAuthentication\n  endpoints?: ARCEndpoints\n  limits?: ARCLimits\n  monitoring?: ARCMonitoring\n}\n</code></pre>"},{"location":"reference/arc-config/#arcauthentication","title":"ARCAuthentication","text":"<pre><code>interface ARCAuthentication {\n  type: 'apiKey' | 'bearer' | 'basic' | 'custom'\n  credentials: {\n    apiKey?: string\n    token?: string\n    username?: string\n    password?: string\n    custom?: Record&lt;string, any&gt;\n  }\n  refreshToken?: string\n  expiresAt?: number\n  autoRefresh?: boolean\n}\n</code></pre>"},{"location":"reference/arc-config/#arcendpoints","title":"ARCEndpoints","text":"<pre><code>interface ARCEndpoints {\n  submit?: string\n  query?: string\n  status?: string\n  health?: string\n  fees?: string\n  utxos?: string\n  balance?: string\n  history?: string\n  broadcast?: string\n  merkleProof?: string\n}\n</code></pre>"},{"location":"reference/arc-config/#arclimits","title":"ARCLimits","text":"<pre><code>interface ARCLimits {\n  maxTransactionSize?: number\n  maxBatchSize?: number\n  maxConcurrentRequests?: number\n  rateLimit?: {\n    requests: number\n    window: number // milliseconds\n  }\n  quotas?: {\n    daily?: number\n    monthly?: number\n  }\n}\n</code></pre>"},{"location":"reference/arc-config/#arcmonitoring","title":"ARCMonitoring","text":"<pre><code>interface ARCMonitoring {\n  enabled: boolean\n  healthCheck?: {\n    interval: number // milliseconds\n    timeout: number\n    retries: number\n  }\n  metrics?: {\n    enabled: boolean\n    endpoint?: string\n    interval: number\n  }\n  alerts?: {\n    enabled: boolean\n    thresholds: {\n      errorRate: number\n      responseTime: number\n      availability: number\n    }\n  }\n}\n</code></pre>"},{"location":"reference/arc-config/#predefined-arc-configurations","title":"Predefined ARC Configurations","text":""},{"location":"reference/arc-config/#mainnet-arc-providers","title":"Mainnet ARC Providers","text":"<pre><code>const MAINNET_ARC_CONFIGS: Record&lt;string, ARCConfig&gt; = {\n  taal: {\n    url: 'https://arc.taal.com',\n    timeout: 30000,\n    retries: 3,\n    retryDelay: 1000,\n    endpoints: {\n      submit: '/v1/tx',\n      query: '/v1/tx/{txid}',\n      status: '/v1/tx/{txid}/status',\n      health: '/v1/health',\n      fees: '/v1/policy/fees',\n      broadcast: '/v1/tx/broadcast'\n    },\n    limits: {\n      maxTransactionSize: 10000000, // 10MB\n      maxBatchSize: 100,\n      maxConcurrentRequests: 10,\n      rateLimit: {\n        requests: 1000,\n        window: 60000 // 1 minute\n      }\n    },\n    monitoring: {\n      enabled: true,\n      healthCheck: {\n        interval: 30000,\n        timeout: 5000,\n        retries: 3\n      }\n    }\n  },\n\n  gorillapool: {\n    url: 'https://arc.gorillapool.io',\n    timeout: 30000,\n    retries: 3,\n    retryDelay: 1000,\n    endpoints: {\n      submit: '/v1/tx',\n      query: '/v1/tx/{txid}',\n      status: '/v1/tx/{txid}/status',\n      health: '/v1/health',\n      fees: '/v1/policy/fees'\n    },\n    limits: {\n      maxTransactionSize: 10000000,\n      maxBatchSize: 50,\n      maxConcurrentRequests: 5,\n      rateLimit: {\n        requests: 500,\n        window: 60000\n      }\n    },\n    monitoring: {\n      enabled: true,\n      healthCheck: {\n        interval: 60000,\n        timeout: 10000,\n        retries: 2\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"reference/arc-config/#testnet-arc-providers","title":"Testnet ARC Providers","text":"<pre><code>const TESTNET_ARC_CONFIGS: Record&lt;string, ARCConfig&gt; = {\n  taal_testnet: {\n    url: 'https://arc-testnet.taal.com',\n    timeout: 30000,\n    retries: 3,\n    retryDelay: 1000,\n    endpoints: {\n      submit: '/v1/tx',\n      query: '/v1/tx/{txid}',\n      status: '/v1/tx/{txid}/status',\n      health: '/v1/health',\n      fees: '/v1/policy/fees'\n    },\n    limits: {\n      maxTransactionSize: 10000000,\n      maxBatchSize: 100,\n      maxConcurrentRequests: 20,\n      rateLimit: {\n        requests: 2000,\n        window: 60000\n      }\n    },\n    monitoring: {\n      enabled: true,\n      healthCheck: {\n        interval: 30000,\n        timeout: 5000,\n        retries: 3\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"reference/arc-config/#arc-configuration-builder","title":"ARC Configuration Builder","text":""},{"location":"reference/arc-config/#arcconfigbuilder-class","title":"ARCConfigBuilder Class","text":"<pre><code>class ARCConfigBuilder {\n  private config: Partial&lt;ARCConfig&gt; = {}\n\n  url(url: string): ARCConfigBuilder {\n    this.config.url = url\n    return this\n  }\n\n  apiKey(apiKey: string): ARCConfigBuilder {\n    this.config.apiKey = apiKey\n    return this\n  }\n\n  timeout(timeout: number): ARCConfigBuilder {\n    this.config.timeout = timeout\n    return this\n  }\n\n  retries(retries: number, delay?: number): ARCConfigBuilder {\n    this.config.retries = retries\n    if (delay !== undefined) {\n      this.config.retryDelay = delay\n    }\n    return this\n  }\n\n  authentication(auth: ARCAuthentication): ARCConfigBuilder {\n    this.config.authentication = auth\n    return this\n  }\n\n  endpoints(endpoints: Partial&lt;ARCEndpoints&gt;): ARCConfigBuilder {\n    this.config.endpoints = { ...this.config.endpoints, ...endpoints }\n    return this\n  }\n\n  limits(limits: Partial&lt;ARCLimits&gt;): ARCConfigBuilder {\n    this.config.limits = { ...this.config.limits, ...limits }\n    return this\n  }\n\n  monitoring(monitoring: Partial&lt;ARCMonitoring&gt;): ARCConfigBuilder {\n    this.config.monitoring = { ...this.config.monitoring, ...monitoring }\n    return this\n  }\n\n  headers(headers: Record&lt;string, string&gt;): ARCConfigBuilder {\n    this.config.headers = { ...this.config.headers, ...headers }\n    return this\n  }\n\n  build(): ARCConfig {\n    if (!this.config.url) {\n      throw new Error('ARC URL is required')\n    }\n\n    return {\n      url: this.config.url,\n      timeout: this.config.timeout || 30000,\n      retries: this.config.retries || 3,\n      retryDelay: this.config.retryDelay || 1000,\n      ...this.config\n    } as ARCConfig\n  }\n}\n</code></pre>"},{"location":"reference/arc-config/#usage-examples","title":"Usage Examples","text":"<pre><code>// Basic ARC configuration\nconst basicARC = new ARCConfigBuilder()\n  .url('https://arc.example.com')\n  .apiKey('your-api-key')\n  .timeout(15000)\n  .build()\n\n// Advanced ARC configuration with authentication\nconst advancedARC = new ARCConfigBuilder()\n  .url('https://arc.example.com')\n  .authentication({\n    type: 'bearer',\n    credentials: {\n      token: 'your-bearer-token'\n    },\n    autoRefresh: true\n  })\n  .endpoints({\n    submit: '/api/v2/transactions',\n    query: '/api/v2/transactions/{txid}',\n    status: '/api/v2/status/{txid}'\n  })\n  .limits({\n    maxTransactionSize: 5000000,\n    maxBatchSize: 50,\n    rateLimit: {\n      requests: 100,\n      window: 60000\n    }\n  })\n  .monitoring({\n    enabled: true,\n    healthCheck: {\n      interval: 30000,\n      timeout: 5000,\n      retries: 3\n    },\n    metrics: {\n      enabled: true,\n      interval: 60000\n    }\n  })\n  .build()\n</code></pre>"},{"location":"reference/arc-config/#arc-client-configuration","title":"ARC Client Configuration","text":""},{"location":"reference/arc-config/#arcclient-interface","title":"ARCClient Interface","text":"<pre><code>interface ARCClient {\n  config: ARCConfig\n  submit(transaction: Transaction): Promise&lt;ARCResponse&gt;\n  query(txid: string): Promise&lt;ARCTransactionStatus&gt;\n  getStatus(txid: string): Promise&lt;ARCStatus&gt;\n  getFees(): Promise&lt;ARCFeeQuote&gt;\n  getHealth(): Promise&lt;ARCHealthStatus&gt;\n  broadcast(rawTx: string): Promise&lt;ARCBroadcastResponse&gt;\n}\n</code></pre>"},{"location":"reference/arc-config/#arcresponse-types","title":"ARCResponse Types","text":"<pre><code>interface ARCResponse {\n  txid: string\n  status: 'success' | 'error' | 'pending'\n  message?: string\n  timestamp: number\n  blockHash?: string\n  blockHeight?: number\n  merklePath?: string\n}\n\ninterface ARCTransactionStatus {\n  txid: string\n  status: 'seen' | 'mined' | 'confirmed' | 'rejected'\n  blockHash?: string\n  blockHeight?: number\n  timestamp: number\n  confirmations?: number\n}\n\ninterface ARCFeeQuote {\n  standard: number\n  data: number\n  timestamp: number\n  expiresAt: number\n}\n\ninterface ARCHealthStatus {\n  status: 'healthy' | 'degraded' | 'unhealthy'\n  version: string\n  timestamp: number\n  checks: {\n    database: boolean\n    network: boolean\n    mempool: boolean\n  }\n}\n</code></pre>"},{"location":"reference/arc-config/#multi-arc-configuration","title":"Multi-ARC Configuration","text":""},{"location":"reference/arc-config/#arc-pool-configuration","title":"ARC Pool Configuration","text":"<pre><code>interface ARCPoolConfig {\n  primary: ARCConfig\n  fallbacks: ARCConfig[]\n  strategy: 'failover' | 'round-robin' | 'load-balance'\n  healthCheck: {\n    enabled: boolean\n    interval: number\n    timeout: number\n  }\n  failover: {\n    maxRetries: number\n    retryDelay: number\n    backoffMultiplier: number\n  }\n}\n\nclass ARCPool {\n  private configs: ARCConfig[]\n  private currentIndex = 0\n  private healthStatus = new Map&lt;string, boolean&gt;()\n\n  constructor(private poolConfig: ARCPoolConfig) {\n    this.configs = [poolConfig.primary, ...poolConfig.fallbacks]\n    this.startHealthChecks()\n  }\n\n  async submit(transaction: Transaction): Promise&lt;ARCResponse&gt; {\n    const config = this.selectARC()\n    const client = new ARCClient(config)\n\n    try {\n      return await client.submit(transaction)\n    } catch (error) {\n      this.markUnhealthy(config.url)\n\n      if (this.hasHealthyFallbacks()) {\n        return this.submit(transaction) // Retry with fallback\n      }\n\n      throw error\n    }\n  }\n\n  private selectARC(): ARCConfig {\n    switch (this.poolConfig.strategy) {\n      case 'failover':\n        return this.selectFailover()\n      case 'round-robin':\n        return this.selectRoundRobin()\n      case 'load-balance':\n        return this.selectLoadBalanced()\n      default:\n        return this.configs[0]\n    }\n  }\n\n  private selectFailover(): ARCConfig {\n    for (const config of this.configs) {\n      if (this.healthStatus.get(config.url) !== false) {\n        return config\n      }\n    }\n    return this.configs[0] // Fallback to primary\n  }\n\n  private selectRoundRobin(): ARCConfig {\n    const healthyConfigs = this.configs.filter(\n      config =&gt; this.healthStatus.get(config.url) !== false\n    )\n\n    if (healthyConfigs.length === 0) {\n      return this.configs[0]\n    }\n\n    const config = healthyConfigs[this.currentIndex % healthyConfigs.length]\n    this.currentIndex++\n    return config\n  }\n\n  private selectLoadBalanced(): ARCConfig {\n    // Simple load balancing based on response times\n    const healthyConfigs = this.configs.filter(\n      config =&gt; this.healthStatus.get(config.url) !== false\n    )\n\n    if (healthyConfigs.length === 0) {\n      return this.configs[0]\n    }\n\n    // Return random healthy config (can be enhanced with actual load metrics)\n    return healthyConfigs[Math.floor(Math.random() * healthyConfigs.length)]\n  }\n\n  private startHealthChecks(): void {\n    if (!this.poolConfig.healthCheck.enabled) return\n\n    setInterval(async () =&gt; {\n      for (const config of this.configs) {\n        try {\n          const client = new ARCClient(config)\n          await client.getHealth()\n          this.healthStatus.set(config.url, true)\n        } catch (error) {\n          this.healthStatus.set(config.url, false)\n        }\n      }\n    }, this.poolConfig.healthCheck.interval)\n  }\n\n  private markUnhealthy(url: string): void {\n    this.healthStatus.set(url, false)\n  }\n\n  private hasHealthyFallbacks(): boolean {\n    return this.configs.some(config =&gt; \n      this.healthStatus.get(config.url) !== false\n    )\n  }\n}\n</code></pre>"},{"location":"reference/arc-config/#environment-based-arc-configuration","title":"Environment-Based ARC Configuration","text":""},{"location":"reference/arc-config/#environment-configuration","title":"Environment Configuration","text":"<pre><code>class ARCEnvironmentConfig {\n  static fromEnvironment(): ARCConfig {\n    const config: ARCConfig = {\n      url: process.env.BSV_ARC_URL || 'https://arc.taal.com',\n      apiKey: process.env.BSV_ARC_API_KEY,\n      timeout: parseInt(process.env.BSV_ARC_TIMEOUT || '30000'),\n      retries: parseInt(process.env.BSV_ARC_RETRIES || '3'),\n      retryDelay: parseInt(process.env.BSV_ARC_RETRY_DELAY || '1000')\n    }\n\n    // Add authentication if provided\n    if (process.env.BSV_ARC_AUTH_TYPE) {\n      config.authentication = {\n        type: process.env.BSV_ARC_AUTH_TYPE as any,\n        credentials: {\n          apiKey: process.env.BSV_ARC_API_KEY,\n          token: process.env.BSV_ARC_TOKEN,\n          username: process.env.BSV_ARC_USERNAME,\n          password: process.env.BSV_ARC_PASSWORD\n        }\n      }\n    }\n\n    // Add custom headers\n    const headerPrefix = 'BSV_ARC_HEADER_'\n    const headers: Record&lt;string, string&gt; = {}\n\n    Object.keys(process.env).forEach(key =&gt; {\n      if (key.startsWith(headerPrefix)) {\n        const headerName = key.substring(headerPrefix.length).toLowerCase()\n        headers[headerName] = process.env[key]!\n      }\n    })\n\n    if (Object.keys(headers).length &gt; 0) {\n      config.headers = headers\n    }\n\n    return config\n  }\n\n  static validate(config: ARCConfig): void {\n    if (!config.url) {\n      throw new Error('ARC URL is required')\n    }\n\n    if (!config.url.startsWith('http')) {\n      throw new Error('ARC URL must be a valid HTTP/HTTPS URL')\n    }\n\n    if (config.timeout &amp;&amp; config.timeout &lt; 1000) {\n      throw new Error('ARC timeout must be at least 1000ms')\n    }\n\n    if (config.retries &amp;&amp; config.retries &lt; 0) {\n      throw new Error('ARC retries must be non-negative')\n    }\n\n    if (config.authentication?.type === 'apiKey' &amp;&amp; !config.authentication.credentials.apiKey) {\n      throw new Error('API key is required for apiKey authentication')\n    }\n\n    if (config.authentication?.type === 'bearer' &amp;&amp; !config.authentication.credentials.token) {\n      throw new Error('Bearer token is required for bearer authentication')\n    }\n  }\n}\n</code></pre>"},{"location":"reference/arc-config/#arc-configuration-best-practices","title":"ARC Configuration Best Practices","text":""},{"location":"reference/arc-config/#security-best-practices","title":"Security Best Practices","text":"<pre><code>// 1. Never hardcode API keys\nconst secureConfig = new ARCConfigBuilder()\n  .url(process.env.ARC_URL!)\n  .apiKey(process.env.ARC_API_KEY!) // Use environment variables\n  .build()\n\n// 2. Use HTTPS URLs only\nconst httpsConfig = new ARCConfigBuilder()\n  .url('https://arc.example.com') // Always use HTTPS\n  .build()\n\n// 3. Implement proper authentication rotation\nconst rotatingAuthConfig = new ARCConfigBuilder()\n  .url('https://arc.example.com')\n  .authentication({\n    type: 'bearer',\n    credentials: { token: getCurrentToken() },\n    autoRefresh: true,\n    expiresAt: getTokenExpiry()\n  })\n  .build()\n</code></pre>"},{"location":"reference/arc-config/#performance-best-practices","title":"Performance Best Practices","text":"<pre><code>// 1. Configure appropriate timeouts\nconst performantConfig = new ARCConfigBuilder()\n  .url('https://arc.example.com')\n  .timeout(15000) // 15 seconds for most operations\n  .retries(3)\n  .build()\n\n// 2. Use connection pooling for high-throughput applications\nconst pooledConfig: ARCPoolConfig = {\n  primary: MAINNET_ARC_CONFIGS.taal,\n  fallbacks: [MAINNET_ARC_CONFIGS.gorillapool],\n  strategy: 'load-balance',\n  healthCheck: {\n    enabled: true,\n    interval: 30000,\n    timeout: 5000\n  },\n  failover: {\n    maxRetries: 3,\n    retryDelay: 1000,\n    backoffMultiplier: 2\n  }\n}\n\n// 3. Monitor and optimize rate limits\nconst rateLimitedConfig = new ARCConfigBuilder()\n  .url('https://arc.example.com')\n  .limits({\n    rateLimit: {\n      requests: 100,\n      window: 60000 // 100 requests per minute\n    },\n    maxConcurrentRequests: 5\n  })\n  .build()\n</code></pre>"},{"location":"reference/arc-config/#reliability-best-practices","title":"Reliability Best Practices","text":"<pre><code>// 1. Always configure fallbacks\nconst reliableConfig: ARCPoolConfig = {\n  primary: MAINNET_ARC_CONFIGS.taal,\n  fallbacks: [\n    MAINNET_ARC_CONFIGS.gorillapool,\n    // Add more fallbacks as needed\n  ],\n  strategy: 'failover',\n  healthCheck: { enabled: true, interval: 30000, timeout: 5000 },\n  failover: { maxRetries: 3, retryDelay: 1000, backoffMultiplier: 2 }\n}\n\n// 2. Enable comprehensive monitoring\nconst monitoredConfig = new ARCConfigBuilder()\n  .url('https://arc.example.com')\n  .monitoring({\n    enabled: true,\n    healthCheck: {\n      interval: 30000,\n      timeout: 5000,\n      retries: 3\n    },\n    metrics: {\n      enabled: true,\n      interval: 60000\n    },\n    alerts: {\n      enabled: true,\n      thresholds: {\n        errorRate: 0.05, // 5% error rate\n        responseTime: 10000, // 10 seconds\n        availability: 0.99 // 99% availability\n      }\n    }\n  })\n  .build()\n</code></pre> <p>This comprehensive ARC configuration reference provides developers with all the tools and patterns needed to effectively configure and manage ARC connections in their BSV TypeScript SDK applications.</p>"},{"location":"reference/auth/","title":"API","text":"<p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/auth/#interfaces","title":"Interfaces","text":"AuthMessage PeerSession RequestedCertificateSet RequestedCertificateTypeIDAndFieldList Transport <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/auth/#interface-authmessage","title":"Interface: AuthMessage","text":"<pre><code>export interface AuthMessage {\n    version: string;\n    messageType: \"initialRequest\" | \"initialResponse\" | \"certificateRequest\" | \"certificateResponse\" | \"general\";\n    identityKey: string;\n    nonce?: string;\n    initialNonce?: string;\n    yourNonce?: string;\n    certificates?: VerifiableCertificate[];\n    requestedCertificates?: RequestedCertificateSet;\n    payload?: number[];\n    signature?: number[];\n}\n</code></pre> <p>See also: RequestedCertificateSet, VerifiableCertificate</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/auth/#interface-peersession","title":"Interface: PeerSession","text":"<pre><code>export interface PeerSession {\n    isAuthenticated: boolean;\n    sessionNonce?: string;\n    peerNonce?: string;\n    peerIdentityKey?: string;\n    lastUpdate: number;\n}\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/auth/#interface-requestedcertificateset","title":"Interface: RequestedCertificateSet","text":"<pre><code>export interface RequestedCertificateSet {\n    certifiers: string[];\n    types: RequestedCertificateTypeIDAndFieldList;\n}\n</code></pre> <p>See also: RequestedCertificateTypeIDAndFieldList</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/auth/#interface-requestedcertificatetypeidandfieldlist","title":"Interface: RequestedCertificateTypeIDAndFieldList","text":"<pre><code>export interface RequestedCertificateTypeIDAndFieldList {\n    [certificateTypeID: string]: string[];\n}\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/auth/#interface-transport","title":"Interface: Transport","text":"<pre><code>export interface Transport {\n    send: (message: AuthMessage) =&gt; Promise&lt;void&gt;;\n    onData: (callback: (message: AuthMessage) =&gt; Promise&lt;void&gt;) =&gt; Promise&lt;void&gt;;\n}\n</code></pre> <p>See also: AuthMessage</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/auth/#classes","title":"Classes","text":"AuthFetch Certificate CompletedProtoWallet MasterCertificate Peer SessionManager SimplifiedFetchTransport VerifiableCertificate <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/auth/#class-authfetch","title":"Class: AuthFetch","text":"<p>AuthFetch provides a lightweight fetch client for interacting with servers over a simplified HTTP transport mechanism. It integrates session management, peer communication, and certificate handling to enable secure and mutually-authenticated requests.</p> <p>Additionally, it automatically handles 402 Payment Required responses by creating and sending BSV payment transactions when necessary.</p> <pre><code>export class AuthFetch {\n    peers: Record&lt;string, AuthPeer&gt; = {};\n    constructor(wallet: WalletInterface, requestedCertificates?: RequestedCertificateSet, sessionManager?: SessionManager, originator?: OriginatorDomainNameStringUnder250Bytes) \n    async fetch(url: string, config: SimplifiedFetchRequestOptions = {}): Promise&lt;Response&gt; \n    async sendCertificateRequest(baseUrl: string, certificatesToRequest: RequestedCertificateSet): Promise&lt;VerifiableCertificate[]&gt; \n    public consumeReceivedCertificates(): VerifiableCertificate[] \n}\n</code></pre> <p>See also: OriginatorDomainNameStringUnder250Bytes, RequestedCertificateSet, SessionManager, VerifiableCertificate, WalletInterface</p>"},{"location":"reference/auth/#constructor","title":"Constructor","text":"<p>Constructs a new AuthFetch instance.</p> <p><pre><code>constructor(wallet: WalletInterface, requestedCertificates?: RequestedCertificateSet, sessionManager?: SessionManager, originator?: OriginatorDomainNameStringUnder250Bytes) \n</code></pre> See also: OriginatorDomainNameStringUnder250Bytes, RequestedCertificateSet, SessionManager, WalletInterface</p> <p>Argument Details</p> <ul> <li>wallet</li> <li>The wallet instance for signing and authentication.</li> <li>requestedCertificates</li> <li>Optional set of certificates to request from peers.</li> </ul>"},{"location":"reference/auth/#method-consumereceivedcertificates","title":"Method consumeReceivedCertificates","text":"<p>Return any certificates we've collected thus far, then clear them out.</p> <p><pre><code>public consumeReceivedCertificates(): VerifiableCertificate[] \n</code></pre> See also: VerifiableCertificate</p>"},{"location":"reference/auth/#method-fetch","title":"Method fetch","text":"<p>Mutually authenticates and sends a HTTP request to a server.</p> <p>1) Attempt the request. 2) If 402 Payment Required, automatically create and send payment. 3) Return the final response.</p> <pre><code>async fetch(url: string, config: SimplifiedFetchRequestOptions = {}): Promise&lt;Response&gt; \n</code></pre> <p>Returns</p> <p>A promise that resolves with the server's response, structured as a Response-like object.</p> <p>Argument Details</p> <ul> <li>url</li> <li>The URL to send the request to.</li> <li>config</li> <li>Configuration options for the request, including method, headers, and body.</li> </ul> <p>Throws</p> <p>Will throw an error if unsupported headers are used or other validation fails.</p>"},{"location":"reference/auth/#method-sendcertificaterequest","title":"Method sendCertificateRequest","text":"<p>Request Certificates from a Peer</p> <p><pre><code>async sendCertificateRequest(baseUrl: string, certificatesToRequest: RequestedCertificateSet): Promise&lt;VerifiableCertificate[]&gt; \n</code></pre> See also: RequestedCertificateSet, VerifiableCertificate</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/auth/#class-certificate","title":"Class: Certificate","text":"<p>Represents an Identity Certificate as per the Wallet interface specifications.</p> <p>This class provides methods to serialize and deserialize certificates, as well as signing and verifying the certificate's signature.</p> <pre><code>export default class Certificate {\n    type: Base64String;\n    serialNumber: Base64String;\n    subject: PubKeyHex;\n    certifier: PubKeyHex;\n    revocationOutpoint: OutpointString;\n    fields: Record&lt;CertificateFieldNameUnder50Bytes, Base64String&gt;;\n    signature?: HexString;\n    constructor(type: Base64String, serialNumber: Base64String, subject: PubKeyHex, certifier: PubKeyHex, revocationOutpoint: OutpointString, fields: Record&lt;CertificateFieldNameUnder50Bytes, string&gt;, signature?: HexString) \n    toBinary(includeSignature: boolean = true): number[] \n    static fromBinary(bin: number[]): Certificate \n    async verify(): Promise&lt;boolean&gt; \n    async sign(certifierWallet: ProtoWallet): Promise&lt;void&gt; \n    static getCertificateFieldEncryptionDetails(fieldName: string, serialNumber?: string): {\n        protocolID: WalletProtocol;\n        keyID: string;\n    } \n}\n</code></pre> <p>See also: Base64String, CertificateFieldNameUnder50Bytes, HexString, OutpointString, ProtoWallet, PubKeyHex, WalletProtocol, sign, verify</p>"},{"location":"reference/auth/#constructor_1","title":"Constructor","text":"<p>Constructs a new Certificate.</p> <p><pre><code>constructor(type: Base64String, serialNumber: Base64String, subject: PubKeyHex, certifier: PubKeyHex, revocationOutpoint: OutpointString, fields: Record&lt;CertificateFieldNameUnder50Bytes, string&gt;, signature?: HexString) \n</code></pre> See also: Base64String, CertificateFieldNameUnder50Bytes, HexString, OutpointString, PubKeyHex</p> <p>Argument Details</p> <ul> <li>type</li> <li>Type identifier for the certificate, base64 encoded string, 32 bytes.</li> <li>serialNumber</li> <li>Unique serial number of the certificate, base64 encoded string, 32 bytes.</li> <li>subject</li> <li>The public key belonging to the certificate's subject, compressed public key hex string.</li> <li>certifier</li> <li>Public key of the certifier who issued the certificate, compressed public key hex string.</li> <li>revocationOutpoint</li> <li>The outpoint used to confirm that the certificate has not been revoked (TXID.OutputIndex), as a string.</li> <li>fields</li> <li>All the fields present in the certificate.</li> <li>signature</li> <li>Certificate signature by the certifier's private key, DER encoded hex string.</li> </ul>"},{"location":"reference/auth/#property-certifier","title":"Property certifier","text":"<p>Public key of the certifier who issued the certificate, compressed public key hex string.</p> <p><pre><code>certifier: PubKeyHex\n</code></pre> See also: PubKeyHex</p>"},{"location":"reference/auth/#property-fields","title":"Property fields","text":"<p>All the fields present in the certificate, with field names as keys and encrypted field values as Base64 strings.</p> <p><pre><code>fields: Record&lt;CertificateFieldNameUnder50Bytes, Base64String&gt;\n</code></pre> See also: Base64String, CertificateFieldNameUnder50Bytes</p>"},{"location":"reference/auth/#property-revocationoutpoint","title":"Property revocationOutpoint","text":"<p>The outpoint used to confirm that the certificate has not been revoked (TXID.OutputIndex), as a string.</p> <p><pre><code>revocationOutpoint: OutpointString\n</code></pre> See also: OutpointString</p>"},{"location":"reference/auth/#property-serialnumber","title":"Property serialNumber","text":"<p>Unique serial number of the certificate, base64 encoded string, 32 bytes.</p> <p><pre><code>serialNumber: Base64String\n</code></pre> See also: Base64String</p>"},{"location":"reference/auth/#property-signature","title":"Property signature","text":"<p>Certificate signature by the certifier's private key, DER encoded hex string.</p> <p><pre><code>signature?: HexString\n</code></pre> See also: HexString</p>"},{"location":"reference/auth/#property-subject","title":"Property subject","text":"<p>The public key belonging to the certificate's subject, compressed public key hex string.</p> <p><pre><code>subject: PubKeyHex\n</code></pre> See also: PubKeyHex</p>"},{"location":"reference/auth/#property-type","title":"Property type","text":"<p>Type identifier for the certificate, base64 encoded string, 32 bytes.</p> <p><pre><code>type: Base64String\n</code></pre> See also: Base64String</p>"},{"location":"reference/auth/#method-frombinary","title":"Method fromBinary","text":"<p>Deserializes a certificate from binary format.</p> <p><pre><code>static fromBinary(bin: number[]): Certificate \n</code></pre> See also: Certificate</p> <p>Returns</p> <ul> <li>The deserialized Certificate object.</li> </ul> <p>Argument Details</p> <ul> <li>bin</li> <li>The binary data representing the certificate.</li> </ul>"},{"location":"reference/auth/#method-getcertificatefieldencryptiondetails","title":"Method getCertificateFieldEncryptionDetails","text":"<p>Helper function which retrieves the protocol ID and key ID for certificate field encryption.</p> <p>For master certificate creation, no serial number is provided because entropy is required from both the client and the certifier. In this case, the <code>keyID</code> is simply the <code>fieldName</code>.</p> <p>For VerifiableCertificates verifier keyring creation, both the serial number and field name are available, so the <code>keyID</code> is formed by concatenating the <code>serialNumber</code> and <code>fieldName</code>.</p> <p><pre><code>static getCertificateFieldEncryptionDetails(fieldName: string, serialNumber?: string): {\n    protocolID: WalletProtocol;\n    keyID: string;\n} \n</code></pre> See also: WalletProtocol</p> <p>Returns</p> <p>An object containing: - <code>protocolID</code> (WalletProtocol): The protocol ID for certificate field encryption. - <code>keyID</code> (string): A unique key identifier. It is the <code>fieldName</code> if <code>serialNumber</code> is undefined, otherwise it is a combination of <code>serialNumber</code> and <code>fieldName</code>.</p> <p>Argument Details</p> <ul> <li>fieldName</li> <li>The name of the field within the certificate to be encrypted.</li> <li>serialNumber</li> <li>(Optional) The serial number of the certificate.</li> </ul>"},{"location":"reference/auth/#method-sign","title":"Method sign","text":"<p>Signs the certificate using the provided certifier wallet.</p> <p><pre><code>async sign(certifierWallet: ProtoWallet): Promise&lt;void&gt; \n</code></pre> See also: ProtoWallet</p> <p>Argument Details</p> <ul> <li>certifierWallet</li> <li>The wallet representing the certifier.</li> </ul>"},{"location":"reference/auth/#method-tobinary","title":"Method toBinary","text":"<p>Serializes the certificate into binary format, with or without a signature.</p> <pre><code>toBinary(includeSignature: boolean = true): number[] \n</code></pre> <p>Returns</p> <ul> <li>The serialized certificate in binary format.</li> </ul> <p>Argument Details</p> <ul> <li>includeSignature</li> <li>Whether to include the signature in the serialization.</li> </ul>"},{"location":"reference/auth/#method-verify","title":"Method verify","text":"<p>Verifies the certificate's signature.</p> <pre><code>async verify(): Promise&lt;boolean&gt; \n</code></pre> <p>Returns</p> <ul> <li>A promise that resolves to true if the signature is valid.</li> </ul> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/auth/#class-completedprotowallet","title":"Class: CompletedProtoWallet","text":"<pre><code>export class CompletedProtoWallet extends ProtoWallet implements WalletInterface {\n    keyDeriver: KeyDeriver;\n    constructor(rootKeyOrKeyDeriver: PrivateKey | \"anyone\" | KeyDeriverApi) \n    async isAuthenticated(): Promise&lt;AuthenticatedResult&gt; \n    async waitForAuthentication(): Promise&lt;AuthenticatedResult&gt; \n    async getNetwork(): Promise&lt;GetNetworkResult&gt; \n    async getVersion(): Promise&lt;GetVersionResult&gt; \n    async getPublicKey(args: GetPublicKeyArgs): Promise&lt;{\n        publicKey: PubKeyHex;\n    }&gt; \n    async createAction(): Promise&lt;CreateActionResult&gt; \n    async signAction(): Promise&lt;SignActionResult&gt; \n    async abortAction(): Promise&lt;AbortActionResult&gt; \n    async listActions(): Promise&lt;ListActionsResult&gt; \n    async internalizeAction(): Promise&lt;InternalizeActionResult&gt; \n    async listOutputs(): Promise&lt;ListOutputsResult&gt; \n    async relinquishOutput(): Promise&lt;RelinquishOutputResult&gt; \n    async acquireCertificate(): Promise&lt;AcquireCertificateResult&gt; \n    async listCertificates(): Promise&lt;ListCertificatesResult&gt; \n    async proveCertificate(): Promise&lt;ProveCertificateResult&gt; \n    async relinquishCertificate(): Promise&lt;RelinquishCertificateResult&gt; \n    async discoverByIdentityKey(): Promise&lt;DiscoverCertificatesResult&gt; \n    async discoverByAttributes(): Promise&lt;DiscoverCertificatesResult&gt; \n    async getHeight(): Promise&lt;GetHeightResult&gt; \n    async getHeaderForHeight(): Promise&lt;GetHeaderResult&gt; \n}\n</code></pre> <p>See also: AbortActionResult, AcquireCertificateResult, AuthenticatedResult, CreateActionResult, DiscoverCertificatesResult, GetHeaderResult, GetHeightResult, GetNetworkResult, GetPublicKeyArgs, GetVersionResult, InternalizeActionResult, KeyDeriver, KeyDeriverApi, ListActionsResult, ListCertificatesResult, ListOutputsResult, PrivateKey, ProtoWallet, ProveCertificateResult, PubKeyHex, RelinquishCertificateResult, RelinquishOutputResult, SignActionResult, WalletInterface</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/auth/#class-mastercertificate","title":"Class: MasterCertificate","text":"<p>MasterCertificate extends the base Certificate class to manage a master keyring, enabling the creation of verifiable certificates.</p> <p>It allows for the selective disclosure of certificate fields by creating a <code>VerifiableCertificate</code> for a specific verifier. The <code>MasterCertificate</code> can securely decrypt each master key and re-encrypt it for a verifier, creating a customized keyring containing only the keys necessary for the verifier to access designated fields.</p> <pre><code>export class MasterCertificate extends Certificate {\n    declare type: Base64String;\n    declare serialNumber: Base64String;\n    declare subject: PubKeyHex;\n    declare certifier: PubKeyHex;\n    declare revocationOutpoint: OutpointString;\n    declare fields: Record&lt;CertificateFieldNameUnder50Bytes, Base64String&gt;;\n    declare signature?: HexString;\n    masterKeyring: Record&lt;CertificateFieldNameUnder50Bytes, Base64String&gt;;\n    constructor(type: Base64String, serialNumber: Base64String, subject: PubKeyHex, certifier: PubKeyHex, revocationOutpoint: OutpointString, fields: Record&lt;CertificateFieldNameUnder50Bytes, Base64String&gt;, masterKeyring: Record&lt;CertificateFieldNameUnder50Bytes, Base64String&gt;, signature?: HexString) \n    static async createCertificateFields(creatorWallet: ProtoWallet, certifierOrSubject: WalletCounterparty, fields: Record&lt;CertificateFieldNameUnder50Bytes, string&gt;, privileged?: boolean, privilegedReason?: string): Promise&lt;CreateCertificateFieldsResult&gt; \n    static async createKeyringForVerifier(subjectWallet: ProtoWallet, certifier: WalletCounterparty, verifier: WalletCounterparty, fields: Record&lt;CertificateFieldNameUnder50Bytes, Base64String&gt;, fieldsToReveal: string[], masterKeyring: Record&lt;CertificateFieldNameUnder50Bytes, Base64String&gt;, serialNumber: Base64String, privileged?: boolean, privilegedReason?: string): Promise&lt;Record&lt;CertificateFieldNameUnder50Bytes, string&gt;&gt; \n    static async issueCertificateForSubject(certifierWallet: ProtoWallet, subject: WalletCounterparty, fields: Record&lt;CertificateFieldNameUnder50Bytes, string&gt;, certificateType: string, getRevocationOutpoint = async (_serial: string): Promise&lt;string&gt; =&gt; {\n        void _serial;\n        return \"Certificate revocation not tracked.\";\n    }, serialNumber?: string): Promise&lt;MasterCertificate&gt; \n    static async decryptFields(subjectOrCertifierWallet: ProtoWallet, masterKeyring: Record&lt;CertificateFieldNameUnder50Bytes, Base64String&gt;, fields: Record&lt;CertificateFieldNameUnder50Bytes, Base64String&gt;, counterparty: WalletCounterparty, privileged?: boolean, privilegedReason?: string): Promise&lt;Record&lt;CertificateFieldNameUnder50Bytes, string&gt;&gt; \n    static async decryptField(subjectOrCertifierWallet: ProtoWallet, masterKeyring: Record&lt;CertificateFieldNameUnder50Bytes, Base64String&gt;, fieldName: Base64String, fieldValue: Base64String, counterparty: WalletCounterparty, privileged?: boolean, privilegedReason?: string): Promise&lt;{\n        fieldRevelationKey: number[];\n        decryptedFieldValue: string;\n    }&gt; \n}\n</code></pre> <p>See also: Base64String, Certificate, CertificateFieldNameUnder50Bytes, HexString, OutpointString, ProtoWallet, PubKeyHex, WalletCounterparty</p>"},{"location":"reference/auth/#method-createcertificatefields","title":"Method createCertificateFields","text":"<p>Encrypts certificate fields for a subject and generates a master keyring. This method returns a master keyring tied to a specific certifier or subject who will validate and sign off on the fields, along with the encrypted certificate fields.</p> <p><pre><code>static async createCertificateFields(creatorWallet: ProtoWallet, certifierOrSubject: WalletCounterparty, fields: Record&lt;CertificateFieldNameUnder50Bytes, string&gt;, privileged?: boolean, privilegedReason?: string): Promise&lt;CreateCertificateFieldsResult&gt; \n</code></pre> See also: CertificateFieldNameUnder50Bytes, ProtoWallet, WalletCounterparty</p> <p>Returns</p> <p>A promise resolving to an object containing: - <code>certificateFields</code> {Record}: The encrypted certificate fields. - <code>masterKeyring</code> {Record}: The master keyring containing encrypted revelation keys for each field. <p>Argument Details</p> <ul> <li>creatorWallet</li> <li>The wallet of the creator responsible for encrypting the fields.</li> <li>certifierOrSubject</li> <li>The certifier or subject who will validate the certificate fields.</li> <li>fields</li> <li>A record of certificate field names (under 50 bytes) mapped to their values.</li> <li>privileged</li> <li>Whether this is a privileged request.</li> <li>privilegedReason</li> <li>Reason provided for privileged access, required if this is a privileged operation.   *</li> </ul>"},{"location":"reference/auth/#method-createkeyringforverifier","title":"Method createKeyringForVerifier","text":"<p>Creates a keyring for a verifier, enabling them to decrypt specific certificate fields. This method decrypts the master field keys for the specified fields and re-encrypts them for the verifier's identity key. The result is a keyring containing the keys necessary for the verifier to access the designated fields.</p> <p><pre><code>static async createKeyringForVerifier(subjectWallet: ProtoWallet, certifier: WalletCounterparty, verifier: WalletCounterparty, fields: Record&lt;CertificateFieldNameUnder50Bytes, Base64String&gt;, fieldsToReveal: string[], masterKeyring: Record&lt;CertificateFieldNameUnder50Bytes, Base64String&gt;, serialNumber: Base64String, privileged?: boolean, privilegedReason?: string): Promise&lt;Record&lt;CertificateFieldNameUnder50Bytes, string&gt;&gt; \n</code></pre> See also: Base64String, CertificateFieldNameUnder50Bytes, ProtoWallet, WalletCounterparty</p> <p>Returns</p> <ul> <li>A keyring mapping field names to encrypted field revelation keys, allowing the verifier to decrypt specified fields.</li> </ul> <p>Argument Details</p> <ul> <li>subjectWallet</li> <li>The wallet instance of the subject, used to decrypt and re-encrypt field keys.</li> <li>verifier</li> <li>The verifier who will receive access to the selectively revealed fields. Can be an identity key as hex, 'anyone', or 'self'.</li> <li>fieldsToReveal</li> <li>An array of field names to be revealed to the verifier. Must be a subset of the certificate's fields.</li> <li>originator</li> <li>Optional originator identifier, used if additional context is needed for decryption and encryption operations.</li> <li>privileged</li> <li>Whether this is a privileged request.</li> <li>privilegedReason</li> <li>Reason provided for privileged access, required if this is a privileged operation.   *</li> </ul> <p>Throws</p> <p>Throws an error if: - fieldsToReveal is not an array of strings. - A field in <code>fieldsToReveal</code> does not exist in the certificate. - The decrypted master field key fails to decrypt the corresponding field (indicating an invalid key).</p>"},{"location":"reference/auth/#method-decryptfields","title":"Method decryptFields","text":"<p>Decrypts all fields in the MasterCertificate using the subject's or certifier's wallet.</p> <p>This method allows the subject or certifier to decrypt the <code>masterKeyring</code> and retrieve the encryption keys for each field, which are then used to decrypt the corresponding field values. The counterparty used for decryption depends on how the certificate fields were created: - If the certificate is self-signed, the counterparty should be set to 'self'. - Otherwise, the counterparty should always be the other party involved in the certificate issuance process (the subject or certifier).</p> <p><pre><code>static async decryptFields(subjectOrCertifierWallet: ProtoWallet, masterKeyring: Record&lt;CertificateFieldNameUnder50Bytes, Base64String&gt;, fields: Record&lt;CertificateFieldNameUnder50Bytes, Base64String&gt;, counterparty: WalletCounterparty, privileged?: boolean, privilegedReason?: string): Promise&lt;Record&lt;CertificateFieldNameUnder50Bytes, string&gt;&gt; \n</code></pre> See also: Base64String, CertificateFieldNameUnder50Bytes, ProtoWallet, WalletCounterparty</p> <p>Returns</p> <p>A promise resolving to a record of field names and their decrypted values in plaintext.</p> <p>Argument Details</p> <ul> <li>subjectOrCertifierWallet</li> <li>The wallet of the subject or certifier, used to decrypt the master keyring and field values.</li> <li>masterKeyring</li> <li>A record containing encrypted keys for each field.</li> <li>fields</li> <li>A record of encrypted field names and their values.</li> <li>counterparty</li> <li>The counterparty responsible for creating or signing the certificate. For self-signed certificates, use 'self'.</li> <li>privileged</li> <li>Whether this is a privileged request.</li> <li>privilegedReason</li> <li>Reason provided for privileged access, required if this is a privileged operation.</li> </ul> <p>Throws</p> <p>Throws an error if the <code>masterKeyring</code> is invalid or if decryption fails for any field.</p>"},{"location":"reference/auth/#method-issuecertificateforsubject","title":"Method issueCertificateForSubject","text":"<p>Issues a new MasterCertificate for a specified subject.</p> <p>This method generates a certificate containing encrypted fields and a keyring for the subject to decrypt all fields. Each field is encrypted with a randomly generated symmetric key, which is then encrypted for the subject. The certificate can also includes a revocation outpoint to manage potential revocation.</p> <p><pre><code>static async issueCertificateForSubject(certifierWallet: ProtoWallet, subject: WalletCounterparty, fields: Record&lt;CertificateFieldNameUnder50Bytes, string&gt;, certificateType: string, getRevocationOutpoint = async (_serial: string): Promise&lt;string&gt; =&gt; {\n    void _serial;\n    return \"Certificate revocation not tracked.\";\n}, serialNumber?: string): Promise&lt;MasterCertificate&gt; \n</code></pre> See also: CertificateFieldNameUnder50Bytes, MasterCertificate, ProtoWallet, WalletCounterparty</p> <p>Returns</p> <ul> <li>A signed MasterCertificate instance containing the encrypted fields and subject specific keyring.</li> </ul> <p>Argument Details</p> <ul> <li>certifierWallet</li> <li>The wallet of the certifier, used to sign the certificate and encrypt field keys.</li> <li>subject</li> <li>The subject for whom the certificate is issued.</li> <li>fields</li> <li>Unencrypted certificate fields to include, with their names and values.</li> <li>certificateType</li> <li>The type of certificate being issued.</li> <li>getRevocationOutpoint</li> <li>- Optional function to obtain a revocation outpoint for the certificate. Defaults to a placeholder.</li> <li>updateProgress</li> <li>Optional callback for reporting progress updates during the operation. Defaults to a no-op.</li> </ul> <p>Throws</p> <p>Throws an error if any operation (e.g., encryption, signing) fails during certificate issuance.</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/auth/#class-peer","title":"Class: Peer","text":"<p>Represents a peer capable of performing mutual authentication. Manages sessions, handles authentication handshakes, certificate requests and responses, and sending and receiving general messages over a transport layer.</p> <p>This version supports multiple concurrent sessions per peer identityKey.</p> <pre><code>export class Peer {\n    public sessionManager: SessionManager;\n    certificatesToRequest: RequestedCertificateSet;\n    constructor(wallet: WalletInterface, transport: Transport, certificatesToRequest?: RequestedCertificateSet, sessionManager?: SessionManager, autoPersistLastSession?: boolean, originator?: OriginatorDomainNameStringUnder250Bytes) \n    async toPeer(message: number[], identityKey?: string, maxWaitTime?: number): Promise&lt;void&gt; \n    async requestCertificates(certificatesToRequest: RequestedCertificateSet, identityKey?: string, maxWaitTime = 10000): Promise&lt;void&gt; \n    async getAuthenticatedSession(identityKey?: string, maxWaitTime?: number): Promise&lt;PeerSession&gt; \n    listenForGeneralMessages(callback: (senderPublicKey: string, payload: number[]) =&gt; void): number \n    stopListeningForGeneralMessages(callbackID: number): void \n    listenForCertificatesReceived(callback: (senderPublicKey: string, certs: VerifiableCertificate[]) =&gt; void): number \n    stopListeningForCertificatesReceived(callbackID: number): void \n    listenForCertificatesRequested(callback: (senderPublicKey: string, requestedCertificates: RequestedCertificateSet) =&gt; void): number \n    stopListeningForCertificatesRequested(callbackID: number): void \n    async sendCertificateResponse(verifierIdentityKey: string, certificates: VerifiableCertificate[]): Promise&lt;void&gt; \n}\n</code></pre> <p>See also: OriginatorDomainNameStringUnder250Bytes, PeerSession, RequestedCertificateSet, SessionManager, Transport, VerifiableCertificate, WalletInterface</p>"},{"location":"reference/auth/#constructor_2","title":"Constructor","text":"<p>Creates a new Peer instance</p> <p><pre><code>constructor(wallet: WalletInterface, transport: Transport, certificatesToRequest?: RequestedCertificateSet, sessionManager?: SessionManager, autoPersistLastSession?: boolean, originator?: OriginatorDomainNameStringUnder250Bytes) \n</code></pre> See also: OriginatorDomainNameStringUnder250Bytes, RequestedCertificateSet, SessionManager, Transport, WalletInterface</p> <p>Argument Details</p> <ul> <li>wallet</li> <li>The wallet instance used for cryptographic operations.</li> <li>transport</li> <li>The transport mechanism used for sending and receiving messages.</li> <li>certificatesToRequest</li> <li>Optional set of certificates to request from a peer during the initial handshake.</li> <li>sessionManager</li> <li>Optional SessionManager to be used for managing peer sessions.</li> <li>autoPersistLastSession</li> <li>Whether to auto-persist the session with the last-interacted-with peer. Defaults to true.</li> </ul>"},{"location":"reference/auth/#method-getauthenticatedsession","title":"Method getAuthenticatedSession","text":"<p>Retrieves an authenticated session for a given peer identity. If no session exists or the session is not authenticated, initiates a handshake to create or authenticate the session.</p> <ul> <li>If <code>identityKey</code> is provided, we look up any existing session for that identity key.</li> <li>If none is found or not authenticated, we do a new handshake.</li> <li>If <code>identityKey</code> is not provided, but we have a <code>lastInteractedWithPeer</code>, we try that key.</li> </ul> <p><pre><code>async getAuthenticatedSession(identityKey?: string, maxWaitTime?: number): Promise&lt;PeerSession&gt; \n</code></pre> See also: PeerSession</p> <p>Returns</p> <ul> <li>A promise that resolves with an authenticated <code>PeerSession</code>.</li> </ul> <p>Argument Details</p> <ul> <li>identityKey</li> <li>The identity public key of the peer.</li> <li>maxWaitTime</li> <li>The maximum time in milliseconds to wait for the handshake.</li> </ul>"},{"location":"reference/auth/#method-listenforcertificatesreceived","title":"Method listenForCertificatesReceived","text":"<p>Registers a callback to listen for certificates received from peers.</p> <p><pre><code>listenForCertificatesReceived(callback: (senderPublicKey: string, certs: VerifiableCertificate[]) =&gt; void): number \n</code></pre> See also: VerifiableCertificate</p> <p>Returns</p> <p>The ID of the callback listener.</p> <p>Argument Details</p> <ul> <li>callback</li> <li>The function to call when certificates are received.</li> </ul>"},{"location":"reference/auth/#method-listenforcertificatesrequested","title":"Method listenForCertificatesRequested","text":"<p>Registers a callback to listen for certificates requested from peers.</p> <p><pre><code>listenForCertificatesRequested(callback: (senderPublicKey: string, requestedCertificates: RequestedCertificateSet) =&gt; void): number \n</code></pre> See also: RequestedCertificateSet</p> <p>Returns</p> <p>The ID of the callback listener.</p> <p>Argument Details</p> <ul> <li>callback</li> <li>The function to call when a certificate request is received</li> </ul>"},{"location":"reference/auth/#method-listenforgeneralmessages","title":"Method listenForGeneralMessages","text":"<p>Registers a callback to listen for general messages from peers.</p> <pre><code>listenForGeneralMessages(callback: (senderPublicKey: string, payload: number[]) =&gt; void): number \n</code></pre> <p>Returns</p> <p>The ID of the callback listener.</p> <p>Argument Details</p> <ul> <li>callback</li> <li>The function to call when a general message is received.</li> </ul>"},{"location":"reference/auth/#method-requestcertificates","title":"Method requestCertificates","text":"<p>Sends a request for certificates to a peer. This method allows a peer to dynamically request specific certificates after an initial handshake or message has been exchanged.</p> <p><pre><code>async requestCertificates(certificatesToRequest: RequestedCertificateSet, identityKey?: string, maxWaitTime = 10000): Promise&lt;void&gt; \n</code></pre> See also: RequestedCertificateSet</p> <p>Returns</p> <p>Resolves if the certificate request message is successfully sent.</p> <p>Argument Details</p> <ul> <li>certificatesToRequest</li> <li>Specifies the certifiers and types of certificates required from the peer.</li> <li>identityKey</li> <li>The identity public key of the peer. If not provided, the current or last session identity is used.</li> <li>maxWaitTime</li> <li>Maximum time in milliseconds to wait for the peer session to be authenticated.</li> </ul> <p>Throws</p> <p>Will throw an error if the peer session is not authenticated or if sending the request fails.</p>"},{"location":"reference/auth/#method-sendcertificateresponse","title":"Method sendCertificateResponse","text":"<p>Sends a certificate response message containing the specified certificates to a peer.</p> <p><pre><code>async sendCertificateResponse(verifierIdentityKey: string, certificates: VerifiableCertificate[]): Promise&lt;void&gt; \n</code></pre> See also: VerifiableCertificate</p> <p>Argument Details</p> <ul> <li>verifierIdentityKey</li> <li>The identity key of the peer requesting the certificates.</li> <li>certificates</li> <li>The list of certificates to include in the response.</li> </ul> <p>Throws</p> <p>Will throw an error if the transport fails to send the message.</p>"},{"location":"reference/auth/#method-stoplisteningforcertificatesreceived","title":"Method stopListeningForCertificatesReceived","text":"<p>Cancels and unsubscribes a certificatesReceived listener.</p> <pre><code>stopListeningForCertificatesReceived(callbackID: number): void \n</code></pre> <p>Argument Details</p> <ul> <li>callbackID</li> <li>The ID of the certificates received callback to cancel.</li> </ul>"},{"location":"reference/auth/#method-stoplisteningforcertificatesrequested","title":"Method stopListeningForCertificatesRequested","text":"<p>Cancels and unsubscribes a certificatesRequested listener.</p> <pre><code>stopListeningForCertificatesRequested(callbackID: number): void \n</code></pre> <p>Argument Details</p> <ul> <li>callbackID</li> <li>The ID of the requested certificates callback to cancel.</li> </ul>"},{"location":"reference/auth/#method-stoplisteningforgeneralmessages","title":"Method stopListeningForGeneralMessages","text":"<p>Removes a general message listener.</p> <pre><code>stopListeningForGeneralMessages(callbackID: number): void \n</code></pre> <p>Argument Details</p> <ul> <li>callbackID</li> <li>The ID of the callback to remove.</li> </ul>"},{"location":"reference/auth/#method-topeer","title":"Method toPeer","text":"<p>Sends a general message to a peer, and initiates a handshake if necessary.</p> <pre><code>async toPeer(message: number[], identityKey?: string, maxWaitTime?: number): Promise&lt;void&gt; \n</code></pre> <p>Argument Details</p> <ul> <li>message</li> <li>The message payload to send.</li> <li>identityKey</li> <li>The identity public key of the peer. If not provided, uses lastInteractedWithPeer (if any).</li> <li>maxWaitTime</li> <li>optional max wait time in ms</li> </ul> <p>Throws</p> <p>Will throw an error if the message fails to send.</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/auth/#class-sessionmanager","title":"Class: SessionManager","text":"<p>Manages sessions for peers, allowing multiple concurrent sessions per identity key. Primary lookup is always by <code>sessionNonce</code>.</p> <pre><code>export class SessionManager {\n    constructor() \n    addSession(session: PeerSession): void \n    updateSession(session: PeerSession): void \n    getSession(identifier: string): PeerSession | undefined \n    removeSession(session: PeerSession): void \n    hasSession(identifier: string): boolean \n}\n</code></pre> <p>See also: PeerSession</p>"},{"location":"reference/auth/#method-addsession","title":"Method addSession","text":"<p>Adds a session to the manager, associating it with its sessionNonce, and also with its peerIdentityKey (if any).</p> <p>This does NOT overwrite existing sessions for the same peerIdentityKey, allowing multiple concurrent sessions for the same peer.</p> <p><pre><code>addSession(session: PeerSession): void \n</code></pre> See also: PeerSession</p> <p>Argument Details</p> <ul> <li>session</li> <li>The peer session to add.</li> </ul>"},{"location":"reference/auth/#method-getsession","title":"Method getSession","text":"<p>Retrieves a session based on a given identifier, which can be:  - A sessionNonce, or  - A peerIdentityKey.</p> <p>If it is a <code>sessionNonce</code>, returns that exact session. If it is a <code>peerIdentityKey</code>, returns the \"best\" (e.g. most recently updated, authenticated) session associated with that peer, if any.</p> <p><pre><code>getSession(identifier: string): PeerSession | undefined \n</code></pre> See also: PeerSession</p> <p>Returns</p> <ul> <li>The matching peer session, or undefined if not found.</li> </ul> <p>Argument Details</p> <ul> <li>identifier</li> <li>The identifier for the session (sessionNonce or peerIdentityKey).</li> </ul>"},{"location":"reference/auth/#method-hassession","title":"Method hasSession","text":"<p>Checks if a session exists for a given identifier (either sessionNonce or identityKey).</p> <pre><code>hasSession(identifier: string): boolean \n</code></pre> <p>Returns</p> <ul> <li>True if the session exists, false otherwise.</li> </ul> <p>Argument Details</p> <ul> <li>identifier</li> <li>The identifier to check.</li> </ul>"},{"location":"reference/auth/#method-removesession","title":"Method removeSession","text":"<p>Removes a session from the manager by clearing all associated identifiers.</p> <p><pre><code>removeSession(session: PeerSession): void \n</code></pre> See also: PeerSession</p> <p>Argument Details</p> <ul> <li>session</li> <li>The peer session to remove.</li> </ul>"},{"location":"reference/auth/#method-updatesession","title":"Method updateSession","text":"<p>Updates a session in the manager (primarily by re-adding it), ensuring we record the latest data (e.g., isAuthenticated, lastUpdate, etc.).</p> <p><pre><code>updateSession(session: PeerSession): void \n</code></pre> See also: PeerSession</p> <p>Argument Details</p> <ul> <li>session</li> <li>The peer session to update.</li> </ul> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/auth/#class-simplifiedfetchtransport","title":"Class: SimplifiedFetchTransport","text":"<p>Implements an HTTP-specific transport for handling Peer mutual authentication messages. This class integrates with fetch to send and receive authenticated messages between peers.</p> <pre><code>export class SimplifiedFetchTransport implements Transport {\n    fetchClient: typeof fetch;\n    baseUrl: string;\n    constructor(baseUrl: string, fetchClient = defaultFetch) \n    async send(message: AuthMessage): Promise&lt;void&gt; \n    async onData(callback: (message: AuthMessage) =&gt; Promise&lt;void&gt;): Promise&lt;void&gt; \n    deserializeRequestPayload(payload: number[]): {\n        method: string;\n        urlPostfix: string;\n        headers: Record&lt;string, string&gt;;\n        body: number[];\n        requestId: string;\n    } \n}\n</code></pre> <p>See also: AuthMessage, Transport</p>"},{"location":"reference/auth/#constructor_3","title":"Constructor","text":"<p>Constructs a new instance of SimplifiedFetchTransport.</p> <pre><code>constructor(baseUrl: string, fetchClient = defaultFetch) \n</code></pre> <p>Argument Details</p> <ul> <li>baseUrl</li> <li>The base URL for all HTTP requests made by this transport.</li> <li>fetchClient</li> <li>A fetch implementation to use for HTTP requests (default: global fetch).</li> </ul>"},{"location":"reference/auth/#method-deserializerequestpayload","title":"Method deserializeRequestPayload","text":"<p>Deserializes a request payload from a byte array into an HTTP request-like structure.</p> <pre><code>deserializeRequestPayload(payload: number[]): {\n    method: string;\n    urlPostfix: string;\n    headers: Record&lt;string, string&gt;;\n    body: number[];\n    requestId: string;\n} \n</code></pre> <p>Returns</p> <p>An object representing the deserialized request, including the method, URL postfix (path and query string), headers, body, and request ID.</p> <p>Argument Details</p> <ul> <li>payload</li> <li>The serialized payload to deserialize.</li> </ul>"},{"location":"reference/auth/#method-ondata","title":"Method onData","text":"<p>Registers a callback to handle incoming messages. This must be called before sending any messages to ensure responses can be processed.</p> <p><pre><code>async onData(callback: (message: AuthMessage) =&gt; Promise&lt;void&gt;): Promise&lt;void&gt; \n</code></pre> See also: AuthMessage</p> <p>Returns</p> <p>A promise that resolves once the callback is set.</p> <p>Argument Details</p> <ul> <li>callback</li> <li>A function to invoke when an incoming AuthMessage is received.</li> </ul>"},{"location":"reference/auth/#method-send","title":"Method send","text":"<p>Sends a message to an HTTP server using the transport mechanism. Handles both general and authenticated message types. For general messages, the payload is deserialized and sent as an HTTP request. For other message types, the message is sent as a POST request to the <code>/auth</code> endpoint.</p> <p><pre><code>async send(message: AuthMessage): Promise&lt;void&gt; \n</code></pre> See also: AuthMessage</p> <p>Returns</p> <p>A promise that resolves when the message is successfully sent.</p> <p>Argument Details</p> <ul> <li>message</li> <li>The AuthMessage to send.</li> </ul> <p>Throws</p> <p>Will throw an error if no listener has been registered via <code>onData</code>.</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/auth/#class-verifiablecertificate","title":"Class: VerifiableCertificate","text":"<p>VerifiableCertificate extends the Certificate class, adding functionality to manage a verifier-specific keyring. This keyring allows selective decryption of certificate fields for authorized verifiers.</p> <pre><code>export class VerifiableCertificate extends Certificate {\n    declare type: Base64String;\n    declare serialNumber: Base64String;\n    declare subject: PubKeyHex;\n    declare certifier: PubKeyHex;\n    declare revocationOutpoint: OutpointString;\n    declare fields: Record&lt;CertificateFieldNameUnder50Bytes, string&gt;;\n    declare signature?: HexString;\n    keyring: Record&lt;CertificateFieldNameUnder50Bytes, string&gt;;\n    decryptedFields?: Record&lt;CertificateFieldNameUnder50Bytes, Base64String&gt;;\n    constructor(type: Base64String, serialNumber: Base64String, subject: PubKeyHex, certifier: PubKeyHex, revocationOutpoint: OutpointString, fields: Record&lt;CertificateFieldNameUnder50Bytes, string&gt;, keyring: Record&lt;CertificateFieldNameUnder50Bytes, string&gt;, signature?: HexString, decryptedFields?: Record&lt;CertificateFieldNameUnder50Bytes, Base64String&gt;) \n    static fromCertificate(certificate: WalletCertificate, keyring: Record&lt;CertificateFieldNameUnder50Bytes, string&gt;): VerifiableCertificate \n    async decryptFields(verifierWallet: ProtoWallet, privileged?: boolean, privilegedReason?: string, originator?: OriginatorDomainNameStringUnder250Bytes): Promise&lt;Record&lt;CertificateFieldNameUnder50Bytes, string&gt;&gt; \n}\n</code></pre> <p>See also: Base64String, Certificate, CertificateFieldNameUnder50Bytes, HexString, OriginatorDomainNameStringUnder250Bytes, OutpointString, ProtoWallet, PubKeyHex, WalletCertificate</p>"},{"location":"reference/auth/#method-decryptfields_1","title":"Method decryptFields","text":"<p>Decrypts selectively revealed certificate fields using the provided keyring and verifier wallet</p> <p><pre><code>async decryptFields(verifierWallet: ProtoWallet, privileged?: boolean, privilegedReason?: string, originator?: OriginatorDomainNameStringUnder250Bytes): Promise&lt;Record&lt;CertificateFieldNameUnder50Bytes, string&gt;&gt; \n</code></pre> See also: CertificateFieldNameUnder50Bytes, OriginatorDomainNameStringUnder250Bytes, ProtoWallet</p> <p>Returns</p> <ul> <li>A promise that resolves to an object where each key is a field name and each value is the decrypted field value as a string.</li> </ul> <p>Argument Details</p> <ul> <li>verifierWallet</li> <li>The wallet instance of the certificate's verifier, used to decrypt field keys.</li> <li>privileged</li> <li>Whether this is a privileged request.</li> <li>privilegedReason</li> <li>Reason provided for privileged access, required if this is a privileged operation.</li> </ul> <p>Throws</p> <p>Throws an error if any of the decryption operations fail, with a message indicating the failure context.</p>"},{"location":"reference/auth/#method-fromcertificate","title":"Method fromCertificate","text":"<p><pre><code>static fromCertificate(certificate: WalletCertificate, keyring: Record&lt;CertificateFieldNameUnder50Bytes, string&gt;): VerifiableCertificate \n</code></pre> See also: CertificateFieldNameUnder50Bytes, VerifiableCertificate, WalletCertificate</p> <p>Returns</p> <p>\u2013 A fully-formed instance containing the original certificate data plus the supplied keyring.</p> <p>Argument Details</p> <ul> <li>certificate</li> <li>\u2013 The source certificate that was issued and signed by the certifier.</li> <li>keyring</li> <li>\u2013 A allows the verifier to decrypt selected certificate fields.</li> </ul> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/auth/#functions","title":"Functions","text":"createNonce verifyNonce <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/auth/#function-createnonce","title":"Function: createNonce","text":"<p>Creates a nonce derived from a wallet</p> <pre><code>export async function createNonce(wallet: WalletInterface, counterparty: WalletCounterparty = \"self\", originator?: OriginatorDomainNameStringUnder250Bytes): Promise&lt;Base64String&gt; \n</code></pre> <p>See also: Base64String, OriginatorDomainNameStringUnder250Bytes, WalletCounterparty, WalletInterface</p> <p>Returns</p> <p>A random nonce derived with a wallet</p> <p>Argument Details</p> <ul> <li>counterparty</li> <li>The counterparty to the nonce creation. Defaults to 'self'.</li> </ul> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/auth/#function-verifynonce","title":"Function: verifyNonce","text":"<p>Verifies a nonce derived from a wallet</p> <pre><code>export async function verifyNonce(nonce: Base64String, wallet: WalletInterface, counterparty: WalletCounterparty = \"self\", originator?: OriginatorDomainNameStringUnder250Bytes): Promise&lt;boolean&gt; \n</code></pre> <p>See also: Base64String, OriginatorDomainNameStringUnder250Bytes, WalletCounterparty, WalletInterface</p> <p>Returns</p> <p>The status of the validation</p> <p>Argument Details</p> <ul> <li>nonce</li> <li>A nonce to verify as a base64 string.</li> <li>counterparty</li> <li>The counterparty to the nonce creation. Defaults to 'self'.</li> </ul> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/auth/#types","title":"Types","text":""},{"location":"reference/auth/#enums","title":"Enums","text":""},{"location":"reference/auth/#variables","title":"Variables","text":"getVerifiableCertificates validateCertificates <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/auth/#variable-getverifiablecertificates","title":"Variable: getVerifiableCertificates","text":"<pre><code>getVerifiableCertificates = async (wallet: WalletInterface, requestedCertificates: RequestedCertificateSet, verifierIdentityKey: string, originator?: OriginatorDomainNameStringUnder250Bytes): Promise&lt;VerifiableCertificate[]&gt; =&gt; {\n    const matchingCertificates = await wallet.listCertificates({\n        certifiers: requestedCertificates.certifiers,\n        types: Object.keys(requestedCertificates.types)\n    }, originator);\n    return await Promise.all(matchingCertificates.certificates.map(async (certificate) =&gt; {\n        const { keyringForVerifier } = await wallet.proveCertificate({\n            certificate,\n            fieldsToReveal: requestedCertificates.types[certificate.type],\n            verifier: verifierIdentityKey\n        }, originator);\n        return new VerifiableCertificate(certificate.type, certificate.serialNumber, certificate.subject, certificate.certifier, certificate.revocationOutpoint, certificate.fields, keyringForVerifier, certificate.signature);\n    }));\n}\n</code></pre> <p>See also: OriginatorDomainNameStringUnder250Bytes, RequestedCertificateSet, VerifiableCertificate, WalletInterface</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/auth/#variable-validatecertificates","title":"Variable: validateCertificates","text":"<pre><code>validateCertificates = async (verifierWallet: WalletInterface, message: AuthMessage, certificatesRequested?: RequestedCertificateSet, originator?: OriginatorDomainNameStringUnder250Bytes): Promise&lt;void&gt; =&gt; {\n    if ((message.certificates == null) || message.certificates.length === 0) {\n        throw new Error(\"No certificates were provided in the AuthMessage.\");\n    }\n    await Promise.all(message.certificates.map(async (incomingCert: VerifiableCertificate) =&gt; {\n        if (incomingCert.subject !== message.identityKey) {\n            throw new Error(`The subject of one of your certificates (\"${incomingCert.subject}\") is not the same as the request sender (\"${message.identityKey}\").`);\n        }\n        const certToVerify = new VerifiableCertificate(incomingCert.type, incomingCert.serialNumber, incomingCert.subject, incomingCert.certifier, incomingCert.revocationOutpoint, incomingCert.fields, incomingCert.keyring, incomingCert.signature);\n        const isValidCert = await certToVerify.verify();\n        if (!isValidCert) {\n            throw new Error(`The signature for the certificate with serial number ${certToVerify.serialNumber} is invalid!`);\n        }\n        if (certificatesRequested != null) {\n            const { certifiers, types } = certificatesRequested;\n            if (!certifiers.includes(certToVerify.certifier)) {\n                throw new Error(`Certificate with serial number ${certToVerify.serialNumber} has an unrequested certifier: ${certToVerify.certifier}`);\n            }\n            const requestedFields = types[certToVerify.type];\n            if (requestedFields == null) {\n                throw new Error(`Certificate with type ${certToVerify.type} was not requested`);\n            }\n        }\n        await certToVerify.decryptFields(verifierWallet, undefined, undefined, originator);\n    }));\n}\n</code></pre> <p>See also: AuthMessage, Certificate, OriginatorDomainNameStringUnder250Bytes, RequestedCertificateSet, VerifiableCertificate, WalletInterface, verify</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/brc-100/","title":"BRC-100 Wallet Interface","text":"<p>BRC-100 defines a Unified, Vendor-Neutral, Unchanging, and Open BSV Blockchain Standard Wallet-to-Application Interface which is implemented in this library within the WalletClient class. The API is laid out here as a swagger openapi document to offer a fast-track to understanding the interface which is implemented across multiple substrates. The JSON api is generally considered a developer friendly introduction to the WalletClient, where an binary equivalent ABI may be preferred for production use cases.</p>"},{"location":"reference/brc-100/#wallet-json-api","title":"Wallet JSON API","text":"<ul> <li>Wallet JSON API Swagger</li> </ul>"},{"location":"reference/brc-100/#overview","title":"Overview","text":"<p>The BRC-100 standard provides a consistent interface for applications to interact with BSV wallets, regardless of the underlying wallet implementation. This ensures that applications can work with any BRC-100 compliant wallet without modification.</p>"},{"location":"reference/brc-100/#key-features","title":"Key Features","text":"<ul> <li>Vendor Neutral: Works with any BRC-100 compliant wallet</li> <li>Standardized Interface: Consistent API across all implementations</li> <li>Multiple Substrates: Supports various communication methods</li> <li>Future Proof: Unchanging standard ensures long-term compatibility</li> </ul>"},{"location":"reference/brc-100/#implementation","title":"Implementation","text":"<p>The BSV TypeScript SDK implements BRC-100 through the <code>WalletClient</code> class, which provides:</p> <ul> <li>Transaction creation and signing</li> <li>UTXO management</li> <li>Authentication and authorization</li> <li>Substrate-agnostic communication</li> </ul>"},{"location":"reference/brc-100/#related-documentation","title":"Related Documentation","text":"<ul> <li>WalletClient Reference</li> <li>Authentication Reference</li> <li>Transaction Reference</li> </ul>"},{"location":"reference/compat/","title":"API","text":"<p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/compat/#interfaces","title":"Interfaces","text":""},{"location":"reference/compat/#classes","title":"Classes","text":"ECIES HD Mnemonic <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/compat/#class-ecies","title":"Class: ECIES","text":"<pre><code>export default class ECIES {\n    public static ivkEkM(privKey: PrivateKey, pubKey: PublicKey): {\n        iv: number[];\n        kE: number[];\n        kM: number[];\n    } \n    public static electrumEncrypt(messageBuf: number[], toPublicKey: PublicKey, fromPrivateKey?: PrivateKey, noKey = false): number[] \n    public static electrumDecrypt(encBuf: number[], toPrivateKey: PrivateKey, fromPublicKey?: PublicKey): number[] \n    public static bitcoreEncrypt(messageBuf: number[], toPublicKey: PublicKey, fromPrivateKey?: PrivateKey, ivBuf?: number[]): number[] \n    public static bitcoreDecrypt(encBuf: number[], toPrivateKey: PrivateKey): number[] \n}\n</code></pre> <p>See also: PrivateKey, PublicKey</p>"},{"location":"reference/compat/#method-bitcoredecrypt","title":"Method bitcoreDecrypt","text":"<p>Decrypts a message encrypted using the Bitcore variant of ECIES.</p> <p><pre><code>public static bitcoreDecrypt(encBuf: number[], toPrivateKey: PrivateKey): number[] \n</code></pre> See also: PrivateKey</p> <p>Returns</p> <p>The decrypted message as a number array.</p> <p>Argument Details</p> <ul> <li>encBuf</li> <li>The encrypted message buffer.</li> <li>toPrivateKey</li> <li>The private key of the recipient.</li> </ul>"},{"location":"reference/compat/#method-bitcoreencrypt","title":"Method bitcoreEncrypt","text":"<p>Encrypts a given message using the Bitcore variant of ECIES.</p> <p><pre><code>public static bitcoreEncrypt(messageBuf: number[], toPublicKey: PublicKey, fromPrivateKey?: PrivateKey, ivBuf?: number[]): number[] \n</code></pre> See also: PrivateKey, PublicKey</p> <p>Returns</p> <p>The encrypted message as a number array.</p> <p>Argument Details</p> <ul> <li>messageBuf</li> <li>The message to be encrypted, in number array format.</li> <li>toPublicKey</li> <li>The public key of the recipient.</li> <li>fromPrivateKey</li> <li>The private key of the sender. If not provided, a random private key is used.</li> <li>ivBuf</li> <li>The initialization vector for encryption. If not provided, a random IV is used.</li> </ul>"},{"location":"reference/compat/#method-electrumdecrypt","title":"Method electrumDecrypt","text":"<p>Decrypts a message encrypted using the Electrum ECIES method.</p> <p><pre><code>public static electrumDecrypt(encBuf: number[], toPrivateKey: PrivateKey, fromPublicKey?: PublicKey): number[] \n</code></pre> See also: PrivateKey, PublicKey</p> <p>Returns</p> <p>The decrypted message as a number array.</p> <p>Argument Details</p> <ul> <li>encBuf</li> <li>The encrypted message buffer.</li> <li>toPrivateKey</li> <li>The private key of the recipient.</li> <li>fromPublicKey</li> <li>The public key of the sender. If not provided, it is extracted from the message.</li> </ul>"},{"location":"reference/compat/#method-electrumencrypt","title":"Method electrumEncrypt","text":"<p>Encrypts a given message using the Electrum ECIES method.</p> <p><pre><code>public static electrumEncrypt(messageBuf: number[], toPublicKey: PublicKey, fromPrivateKey?: PrivateKey, noKey = false): number[] \n</code></pre> See also: PrivateKey, PublicKey</p> <p>Returns</p> <p>The encrypted message as a number array.</p> <p>Argument Details</p> <ul> <li>messageBuf</li> <li>The message to be encrypted, in number array format.</li> <li>toPublicKey</li> <li>The public key of the recipient.</li> <li>fromPrivateKey</li> <li>The private key of the sender. If not provided, a random private key is used.</li> <li>noKey</li> <li>If true, does not include the sender's public key in the encrypted message.</li> </ul>"},{"location":"reference/compat/#method-ivkekm","title":"Method ivkEkM","text":"<p>Generates the initialization vector (iv), encryption key (kE), and MAC key (kM) using the sender's private key and receiver's public key.</p> <p><pre><code>public static ivkEkM(privKey: PrivateKey, pubKey: PublicKey): {\n    iv: number[];\n    kE: number[];\n    kM: number[];\n} \n</code></pre> See also: PrivateKey, PublicKey</p> <p>Returns</p> <p>An object containing the iv, kE, and kM as number arrays.</p> <p>Argument Details</p> <ul> <li>privKey</li> <li>The sender's private key.</li> <li>pubKey</li> <li>The receiver's public key.</li> </ul> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/compat/#class-hd","title":"Class: HD","text":"<pre><code>export default class HD {\n    versionBytesNum: number;\n    depth: number;\n    parentFingerPrint: number[];\n    childIndex: number;\n    chainCode: number[];\n    privKey: PrivateKey;\n    pubKey: PublicKey;\n    constants = {\n        pubKey: 76067358,\n        privKey: 76066276\n    };\n    constructor(versionBytesNum?: number, depth?: number, parentFingerPrint?: number[], childIndex?: number, chainCode?: number[], privKey?: PrivateKey, pubKey?: PublicKey) \n    public fromRandom(): this \n    public static fromRandom(): HD \n    public static fromString(str: string): HD \n    public fromString(str: string): this \n    public static fromSeed(bytes: number[]): HD \n    public fromSeed(bytes: number[]): this \n    public static fromBinary(buf: number[]): HD \n    public fromBinary(buf: number[]): this \n    public toString(): string \n    public derive(path: string): HD \n    public deriveChild(i: number): HD \n    public toPublic(): HD \n    public toBinary(): number[] \n    public isPrivate(): boolean \n}\n</code></pre> <p>See also: PrivateKey, PublicKey</p>"},{"location":"reference/compat/#constructor","title":"Constructor","text":"<p>Constructor for the BIP32 HD wallet. Initializes an HD wallet with optional parameters for version bytes, depth, parent fingerprint, child index, chain code, private key, and public key.</p> <p><pre><code>constructor(versionBytesNum?: number, depth?: number, parentFingerPrint?: number[], childIndex?: number, chainCode?: number[], privKey?: PrivateKey, pubKey?: PublicKey) \n</code></pre> See also: PrivateKey, PublicKey</p> <p>Argument Details</p> <ul> <li>versionBytesNum</li> <li>Version bytes number for the wallet.</li> <li>depth</li> <li>Depth of the key in the hierarchy.</li> <li>parentFingerPrint</li> <li>Fingerprint of the parent key.</li> <li>childIndex</li> <li>Index of the child key.</li> <li>chainCode</li> <li>Chain code for key derivation.</li> <li>privKey</li> <li>Private key of the wallet.</li> <li>pubKey</li> <li>Public key of the wallet.</li> </ul>"},{"location":"reference/compat/#method-derive","title":"Method derive","text":"<p>Derives a child HD wallet based on a given path. The path specifies the hierarchy of the child key to be derived.</p> <p><pre><code>public derive(path: string): HD \n</code></pre> See also: HD</p> <p>Returns</p> <p>A new HD instance representing the derived child wallet.</p> <p>Argument Details</p> <ul> <li>path</li> <li>A string representing the derivation path (e.g., 'm/0'/1).</li> </ul>"},{"location":"reference/compat/#method-derivechild","title":"Method deriveChild","text":"<p>Derives a child HD wallet from the current wallet based on an index. This method generates either a private or public child key depending on the current wallet's state.</p> <p><pre><code>public deriveChild(i: number): HD \n</code></pre> See also: HD</p> <p>Returns</p> <p>A new HD instance representing the derived child wallet.</p> <p>Argument Details</p> <ul> <li>i</li> <li>The index of the child key to derive.</li> </ul>"},{"location":"reference/compat/#method-frombinary","title":"Method fromBinary","text":"<p>Initializes the HD wallet from a binary buffer. Parses a binary buffer to set up the wallet's properties.</p> <p><pre><code>public static fromBinary(buf: number[]): HD \n</code></pre> See also: HD</p> <p>Returns</p> <p>The new instance with properties set from the buffer.</p> <p>Argument Details</p> <ul> <li>buf</li> <li>A buffer containing the wallet data.</li> </ul>"},{"location":"reference/compat/#method-frombinary_1","title":"Method fromBinary","text":"<p>Initializes the HD wallet from a binary buffer. Parses a binary buffer to set up the wallet's properties.</p> <pre><code>public fromBinary(buf: number[]): this \n</code></pre> <p>Returns</p> <p>The current instance with properties set from the buffer.</p> <p>Argument Details</p> <ul> <li>buf</li> <li>A buffer containing the wallet data.</li> </ul>"},{"location":"reference/compat/#method-fromrandom","title":"Method fromRandom","text":"<p>Generates a new HD wallet with random keys. This method creates a root HD wallet with randomly generated private and public keys.</p> <pre><code>public fromRandom(): this \n</code></pre> <p>Returns</p> <p>The current HD instance with generated keys.</p>"},{"location":"reference/compat/#method-fromrandom_1","title":"Method fromRandom","text":"<p>Generates a new HD wallet with random keys. This method creates a root HD wallet with randomly generated private and public keys.</p> <p><pre><code>public static fromRandom(): HD \n</code></pre> See also: HD</p> <p>Returns</p> <p>A new HD instance with generated keys.</p>"},{"location":"reference/compat/#method-fromseed","title":"Method fromSeed","text":"<p>Initializes the HD wallet from a seed. This method generates keys and other properties from a given seed, conforming to the BIP32 specification.</p> <p><pre><code>public static fromSeed(bytes: number[]): HD \n</code></pre> See also: HD</p> <p>Returns</p> <p>The current instance with properties set from the seed.</p> <p>Argument Details</p> <ul> <li>bytes</li> <li>An array of bytes representing the seed.</li> </ul>"},{"location":"reference/compat/#method-fromseed_1","title":"Method fromSeed","text":"<p>Initializes the HD wallet from a seed. This method generates keys and other properties from a given seed, conforming to the BIP32 specification.</p> <pre><code>public fromSeed(bytes: number[]): this \n</code></pre> <p>Returns</p> <p>The current instance with properties set from the seed.</p> <p>Argument Details</p> <ul> <li>bytes</li> <li>An array of bytes representing the seed.</li> </ul>"},{"location":"reference/compat/#method-fromstring","title":"Method fromString","text":"<p>Initializes the HD wallet from a given base58 encoded string. This method decodes a provided string to set up the HD wallet's properties.</p> <p><pre><code>public static fromString(str: string): HD \n</code></pre> See also: HD</p> <p>Returns</p> <p>The new instance with properties set from the string.</p> <p>Argument Details</p> <ul> <li>str</li> <li>A base58 encoded string representing the wallet.</li> </ul>"},{"location":"reference/compat/#method-fromstring_1","title":"Method fromString","text":"<p>Initializes the HD wallet from a given base58 encoded string. This method decodes a provided string to set up the HD wallet's properties.</p> <pre><code>public fromString(str: string): this \n</code></pre> <p>Returns</p> <p>The current instance with properties set from the string.</p> <p>Argument Details</p> <ul> <li>str</li> <li>A base58 encoded string representing the wallet.</li> </ul>"},{"location":"reference/compat/#method-isprivate","title":"Method isPrivate","text":"<p>Checks if the HD wallet contains a private key. This method determines whether the wallet is a private key wallet or a public key only wallet.</p> <pre><code>public isPrivate(): boolean \n</code></pre> <p>Returns</p> <p>A boolean value indicating whether the wallet has a private key (true) or not (false).</p>"},{"location":"reference/compat/#method-tobinary","title":"Method toBinary","text":"<p>Converts the HD wallet into a binary representation. This method serializes the wallet's properties into a binary format.</p> <pre><code>public toBinary(): number[] \n</code></pre> <p>Returns</p> <p>An array of numbers representing the binary data of the wallet.</p>"},{"location":"reference/compat/#method-topublic","title":"Method toPublic","text":"<p>Converts the current HD wallet to a public-only wallet. This method strips away the private key information, leaving only the public part.</p> <p><pre><code>public toPublic(): HD \n</code></pre> See also: HD</p> <p>Returns</p> <p>A new HD instance representing the public-only wallet.</p>"},{"location":"reference/compat/#method-tostring","title":"Method toString","text":"<p>function toString() { [native code] }</p> <p>Converts the HD wallet to a base58 encoded string. This method provides a string representation of the HD wallet's current state.</p> <pre><code>public toString(): string \n</code></pre> <p>Returns</p> <p>A base58 encoded string of the HD wallet.</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/compat/#class-mnemonic","title":"Class: Mnemonic","text":"<pre><code>export default class Mnemonic {\n    public mnemonic: string;\n    public seed: number[];\n    public Wordlist: {\n        value: string[];\n        space: string;\n    };\n    constructor(mnemonic?: string, seed?: number[], wordlist = wordList) \n    public toBinary(): number[] \n    public fromBinary(bin: number[]): this \n    public fromRandom(bits?: number): this \n    public static fromRandom(bits?: number): Mnemonic \n    public fromEntropy(buf: number[]): this \n    public static fromEntropy(buf: number[]): Mnemonic \n    public fromString(mnemonic: string): this \n    public static fromString(str: string): Mnemonic \n    public toString(): string \n    public toSeed(passphrase?: string): number[] \n    public entropy2Mnemonic(buf: number[]): this \n    public check(): boolean \n    public mnemonic2Seed(passphrase = \"\"): this \n    public isValid(passphrase = \"\"): boolean \n    public static isValid(mnemonic: string, passphrase = \"\"): boolean \n}\n</code></pre> <p>See also: wordList</p>"},{"location":"reference/compat/#constructor_1","title":"Constructor","text":"<p>Constructs a Mnemonic object.</p> <p><pre><code>constructor(mnemonic?: string, seed?: number[], wordlist = wordList) \n</code></pre> See also: wordList</p> <p>Argument Details</p> <ul> <li>mnemonic</li> <li>An optional mnemonic phrase.</li> <li>seed</li> <li>An optional seed derived from the mnemonic.</li> <li>wordlist</li> <li>An object containing a list of words and space character used in the mnemonic.</li> </ul>"},{"location":"reference/compat/#method-check","title":"Method check","text":"<p>Validates the mnemonic phrase. Checks for correct length, absence of invalid words, and proper checksum.</p> <pre><code>public check(): boolean \n</code></pre> <p>Returns</p> <p>True if the mnemonic is valid, false otherwise.</p> <p>Throws</p> <p>If the mnemonic is not an even multiple of 11 bits.</p>"},{"location":"reference/compat/#method-entropy2mnemonic","title":"Method entropy2Mnemonic","text":"<p>Converts entropy to a mnemonic phrase. This method takes a buffer of entropy and converts it into a corresponding mnemonic phrase based on the Mnemonic wordlist. The entropy should be at least 128 bits. The method applies a checksum and maps the entropy to words in the wordlist.</p> <pre><code>public entropy2Mnemonic(buf: number[]): this \n</code></pre> <p>Returns</p> <p>The Mnemonic instance with the mnemonic set from the entropy.</p> <p>Argument Details</p> <ul> <li>buf</li> <li>The entropy buffer to convert. Must be at least 128 bits.</li> </ul> <p>Throws</p> <p>If the entropy is less than 128 bits or if it's not an even multiple of 11 bits.</p>"},{"location":"reference/compat/#method-frombinary_2","title":"Method fromBinary","text":"<p>Loads a mnemonic and seed from a binary representation.</p> <pre><code>public fromBinary(bin: number[]): this \n</code></pre> <p>Returns</p> <p>The Mnemonic instance with loaded mnemonic and seed.</p> <p>Argument Details</p> <ul> <li>bin</li> <li>The binary representation of a mnemonic and seed.</li> </ul>"},{"location":"reference/compat/#method-fromentropy","title":"Method fromEntropy","text":"<p>Converts given entropy into a mnemonic phrase. This method is used to generate a mnemonic from a specific entropy source.</p> <pre><code>public fromEntropy(buf: number[]): this \n</code></pre> <p>Returns</p> <p>The Mnemonic instance with the mnemonic set from the given entropy.</p> <p>Argument Details</p> <ul> <li>buf</li> <li>The entropy buffer, must be at least 128 bits.</li> </ul> <p>Throws</p> <p>If the entropy is less than 128 bits.</p>"},{"location":"reference/compat/#method-fromentropy_1","title":"Method fromEntropy","text":"<p>Static method to create a Mnemonic instance from a given entropy.</p> <p><pre><code>public static fromEntropy(buf: number[]): Mnemonic \n</code></pre> See also: Mnemonic</p> <p>Returns</p> <p>A new Mnemonic instance.</p> <p>Argument Details</p> <ul> <li>buf</li> <li>The entropy buffer.</li> </ul>"},{"location":"reference/compat/#method-fromrandom_2","title":"Method fromRandom","text":"<p>Generates a random mnemonic from a given bit length.</p> <pre><code>public fromRandom(bits?: number): this \n</code></pre> <p>Returns</p> <p>The Mnemonic instance with the new random mnemonic.</p> <p>Argument Details</p> <ul> <li>bits</li> <li>The bit length for the random mnemonic (must be a multiple of 32 and at least 128).</li> </ul> <p>Throws</p> <p>If the bit length is not a multiple of 32 or is less than 128.</p>"},{"location":"reference/compat/#method-fromrandom_3","title":"Method fromRandom","text":"<p>Static method to generate a Mnemonic instance with a random mnemonic.</p> <p><pre><code>public static fromRandom(bits?: number): Mnemonic \n</code></pre> See also: Mnemonic</p> <p>Returns</p> <p>A new Mnemonic instance.</p> <p>Argument Details</p> <ul> <li>bits</li> <li>The bit length for the random mnemonic.</li> </ul>"},{"location":"reference/compat/#method-fromstring_2","title":"Method fromString","text":"<p>Sets the mnemonic for the instance from a string.</p> <pre><code>public fromString(mnemonic: string): this \n</code></pre> <p>Returns</p> <p>The Mnemonic instance with the set mnemonic.</p> <p>Argument Details</p> <ul> <li>mnemonic</li> <li>The mnemonic phrase as a string.</li> </ul>"},{"location":"reference/compat/#method-fromstring_3","title":"Method fromString","text":"<p>Static method to create a Mnemonic instance from a mnemonic string.</p> <p><pre><code>public static fromString(str: string): Mnemonic \n</code></pre> See also: Mnemonic</p> <p>Returns</p> <p>A new Mnemonic instance.</p> <p>Argument Details</p> <ul> <li>str</li> <li>The mnemonic phrase.</li> </ul>"},{"location":"reference/compat/#method-isvalid","title":"Method isValid","text":"<p>Determines the validity of a given passphrase with the mnemonic. This method is useful for checking if a passphrase matches with the mnemonic.</p> <pre><code>public isValid(passphrase = \"\"): boolean \n</code></pre> <p>Returns</p> <p>True if the mnemonic and passphrase combination is valid, false otherwise.</p> <p>Argument Details</p> <ul> <li>passphrase</li> <li>The passphrase to validate.</li> </ul>"},{"location":"reference/compat/#method-isvalid_1","title":"Method isValid","text":"<p>Static method to check the validity of a given mnemonic and passphrase combination.</p> <pre><code>public static isValid(mnemonic: string, passphrase = \"\"): boolean \n</code></pre> <p>Returns</p> <p>True if the combination is valid, false otherwise.</p> <p>Argument Details</p> <ul> <li>mnemonic</li> <li>The mnemonic phrase.</li> <li>passphrase</li> <li>The passphrase to validate.</li> </ul>"},{"location":"reference/compat/#method-mnemonic2seed","title":"Method mnemonic2Seed","text":"<p>Converts a mnemonic to a seed. This method takes the instance's mnemonic phrase, combines it with a passphrase (if provided), and uses PBKDF2 to generate a seed. It also validates the mnemonic before conversion. This seed can then be used for generating deterministic keys.</p> <pre><code>public mnemonic2Seed(passphrase = \"\"): this \n</code></pre> <p>Returns</p> <p>The Mnemonic instance with the seed generated from the mnemonic.</p> <p>Argument Details</p> <ul> <li>passphrase</li> <li>An optional passphrase for added security.</li> </ul> <p>Throws</p> <p>If the mnemonic does not pass validation or if the passphrase is not a string.</p>"},{"location":"reference/compat/#method-tobinary_1","title":"Method toBinary","text":"<p>Converts the mnemonic and seed into a binary representation.</p> <pre><code>public toBinary(): number[] \n</code></pre> <p>Returns</p> <p>The binary representation of the mnemonic and seed.</p>"},{"location":"reference/compat/#method-toseed","title":"Method toSeed","text":"<p>Converts the mnemonic to a seed. The mnemonic must pass the validity check before conversion.</p> <pre><code>public toSeed(passphrase?: string): number[] \n</code></pre> <p>Returns</p> <p>The generated seed.</p> <p>Argument Details</p> <ul> <li>passphrase</li> <li>An optional passphrase for additional security.</li> </ul> <p>Throws</p> <p>If the mnemonic is invalid.</p>"},{"location":"reference/compat/#method-tostring_1","title":"Method toString","text":"<p>function toString() { [native code] }</p> <p>Converts the instance's mnemonic to a string representation.</p> <pre><code>public toString(): string \n</code></pre> <p>Returns</p> <p>The mnemonic phrase as a string.</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/compat/#functions","title":"Functions","text":""},{"location":"reference/compat/#function-fromutxo","title":"Function: fromUtxo","text":"<p>Example</p> <pre><code>const i = fromUtxo({\n  txid: '434555433eaca96dff6e71a4d02febd0dd3832e5ca4e5734623ca914522e17d5',\n  vout: 0,\n  script: '51',\n  satoshis: 1234\n}, new P2PKH().unlock(p))\n\ntx.addInput(i)\n</code></pre> <pre><code>export default function fromUtxo(utxo: jsonUtxo, unlockingScriptTemplate: {\n    sign: (tx: Transaction, inputIndex: number) =&gt; Promise&lt;UnlockingScript&gt;;\n    estimateLength: (tx: Transaction, inputIndex: number) =&gt; Promise&lt;number&gt;;\n}): TransactionInput \n</code></pre> <p>See also: Transaction, TransactionInput, UnlockingScript, sign</p> <p>Argument Details</p> <ul> <li>utxo</li> <li>: jsonUtxo</li> <li>unlockingScriptTemplate</li> <li>: { sign: (tx: Transaction, inputIndex: number) =&gt; Promise, estimateLength: (tx: Transaction, inputIndex: number) =&gt; Promise } <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/compat/#types","title":"Types","text":""},{"location":"reference/compat/#enums","title":"Enums","text":""},{"location":"reference/compat/#variables","title":"Variables","text":"magicHash sign verify wordList <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/compat/#variable-magichash","title":"Variable: magicHash","text":"<pre><code>magicHash = (messageBuf: number[]): number[] =&gt; {\n    const bw = new Writer();\n    bw.writeVarIntNum(prefix.length);\n    bw.write(toArray(prefix, \"utf8\"));\n    bw.writeVarIntNum(messageBuf.length);\n    bw.write(messageBuf);\n    const buf = bw.toArray();\n    const hashBuf = Hash.hash256(buf);\n    return hashBuf;\n}\n</code></pre> <p>See also: Writer, hash256, toArray</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/compat/#variable-sign","title":"Variable: sign","text":"<pre><code>sign = (message: number[], privateKey: PrivateKey, mode: \"raw\" | \"base64\" = \"base64\"): Signature | string =&gt; {\n    const hashBuf = magicHash(message);\n    const sig = ECDSA.sign(new BigNumber(hashBuf), privateKey, true);\n    if (mode === \"raw\") {\n        return sig;\n    }\n    const h = new BigNumber(hashBuf);\n    const r = sig.CalculateRecoveryFactor(privateKey.toPublicKey(), h);\n    return sig.toCompact(r, true, \"base64\") as string;\n}\n</code></pre> <p>See also: BigNumber, PrivateKey, Signature, magicHash</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/compat/#variable-verify","title":"Variable: verify","text":"<pre><code>verify = (message: number[], sig: Signature, pubKey: PublicKey): boolean =&gt; {\n    const hashBuf = magicHash(message);\n    return ECDSA.verify(new BigNumber(hashBuf), sig, pubKey);\n}\n</code></pre> <p>See also: BigNumber, PublicKey, Signature, magicHash</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/compat/#variable-wordlist","title":"Variable: wordList","text":"<pre><code>wordList = {\n    value: [\n        \"abandon\",\n        \"ability\",\n        \"able\",\n        \"about\",\n        \"above\",\n        \"absent\",\n        \"absorb\",\n        \"abstract\",\n        \"absurd\",\n        \"abuse\",\n        \"access\",\n        \"accident\",\n        \"account\",\n        \"accuse\",\n        \"achieve\",\n        \"acid\",\n        \"acoustic\",\n        \"acquire\",\n        \"across\",\n        \"act\",\n        \"action\",\n        \"actor\",\n        \"actress\",\n        \"actual\",\n        \"adapt\",\n        \"add\",\n        \"addict\",\n        \"address\",\n        \"adjust\",\n        \"admit\",\n        \"adult\",\n        \"advance\",\n        \"advice\",\n        \"aerobic\",\n        \"affair\",\n        \"afford\",\n        \"afraid\",\n        \"again\",\n        \"age\",\n        \"agent\",\n        \"agree\",\n        \"ahead\",\n        \"aim\",\n        \"air\",\n        \"airport\",\n        \"aisle\",\n        \"alarm\",\n        \"album\",\n        \"alcohol\",\n        \"alert\",\n        \"alien\",\n        \"all\",\n        \"alley\",\n        \"allow\",\n        \"almost\",\n        \"alone\",\n        \"alpha\",\n        \"already\",\n        \"also\",\n        \"alter\",\n        \"always\",\n        \"amateur\",\n        \"amazing\",\n        \"among\",\n        \"amount\",\n        \"amused\",\n        \"analyst\",\n        \"anchor\",\n        \"ancient\",\n        \"anger\",\n        \"angle\",\n        \"angry\",\n        \"animal\",\n        \"ankle\",\n        \"announce\",\n        \"annual\",\n        \"another\",\n        \"answer\",\n        \"antenna\",\n        \"antique\",\n        \"anxiety\",\n        \"any\",\n        \"apart\",\n        \"apology\",\n        \"appear\",\n        \"apple\",\n        \"approve\",\n        \"april\",\n        \"arch\",\n        \"arctic\",\n        \"area\",\n        \"arena\",\n        \"argue\",\n        \"arm\",\n        \"armed\",\n        \"armor\",\n        \"army\",\n        \"around\",\n        \"arrange\",\n        \"arrest\",\n        \"arrive\",\n        \"arrow\",\n        \"art\",\n        \"artefact\",\n        \"artist\",\n        \"artwork\",\n        \"ask\",\n        \"aspect\",\n        \"assault\",\n        \"asset\",\n        \"assist\",\n        \"assume\",\n        \"asthma\",\n        \"athlete\",\n        \"atom\",\n        \"attack\",\n        \"attend\",\n        \"attitude\",\n        \"attract\",\n        \"auction\",\n        \"audit\",\n        \"august\",\n        \"aunt\",\n        \"author\",\n        \"auto\",\n        \"autumn\",\n        \"average\",\n        \"avocado\",\n        \"avoid\",\n        \"awake\",\n        \"aware\",\n        \"away\",\n        \"awesome\",\n        \"awful\",\n        \"awkward\",\n        \"axis\",\n        \"baby\",\n        \"bachelor\",\n        \"bacon\",\n        \"badge\",\n        \"bag\",\n        \"balance\",\n        \"balcony\",\n        \"ball\",\n        \"bamboo\",\n        \"banana\",\n        \"banner\",\n        \"bar\",\n        \"barely\",\n        \"bargain\",\n        \"barrel\",\n        \"base\",\n        \"basic\",\n        \"basket\",\n        \"battle\",\n        \"beach\",\n        \"bean\",\n        \"beauty\",\n        \"because\",\n        \"become\",\n        \"beef\",\n        \"before\",\n        \"begin\",\n        \"behave\",\n        \"behind\",\n        \"believe\",\n        \"below\",\n        \"belt\",\n        \"bench\",\n        \"benefit\",\n        \"best\",\n        \"betray\",\n        \"better\",\n        \"between\",\n        \"beyond\",\n        \"bicycle\",\n        \"bid\",\n        \"bike\",\n        \"bind\",\n        \"biology\",\n        \"bird\",\n        \"birth\",\n        \"bitter\",\n        \"black\",\n        \"blade\",\n        \"blame\",\n        \"blanket\",\n        \"blast\",\n        \"bleak\",\n        \"bless\",\n        \"blind\",\n        \"blood\",\n        \"blossom\",\n        \"blouse\",\n        \"blue\",\n        \"blur\",\n        \"blush\",\n        \"board\",\n        \"boat\",\n        \"body\",\n        \"boil\",\n        \"bomb\",\n        \"bone\",\n        \"bonus\",\n        \"book\",\n        \"boost\",\n        \"border\",\n        \"boring\",\n        \"borrow\",\n        \"boss\",\n        \"bottom\",\n        \"bounce\",\n        \"box\",\n        \"boy\",\n        \"bracket\",\n        \"brain\",\n        \"brand\",\n        \"brass\",\n        \"brave\",\n        \"bread\",\n        \"breeze\",\n        \"brick\",\n        \"bridge\",\n        \"brief\",\n        \"bright\",\n        \"bring\",\n        \"brisk\",\n        \"broccoli\",\n        \"broken\",\n        \"bronze\",\n        \"broom\",\n        \"brother\",\n        \"brown\",\n        \"brush\",\n        \"bubble\",\n        \"buddy\",\n        \"budget\",\n        \"buffalo\",\n        \"build\",\n        \"bulb\",\n        \"bulk\",\n        \"bullet\",\n        \"bundle\",\n        \"bunker\",\n        \"burden\",\n        \"burger\",\n        \"burst\",\n        \"bus\",\n        \"business\",\n        \"busy\",\n        \"butter\",\n        \"buyer\",\n        \"buzz\",\n        \"cabbage\",\n        \"cabin\",\n        \"cable\",\n        \"cactus\",\n        \"cage\",\n        \"cake\",\n        \"call\",\n        \"calm\",\n        \"camera\",\n        \"camp\",\n        \"can\",\n        \"canal\",\n        \"cancel\",\n        \"candy\",\n        \"cannon\",\n        \"canoe\",\n        \"canvas\",\n        \"canyon\",\n        \"capable\",\n        \"capital\",\n        \"captain\",\n        \"car\",\n        \"carbon\",\n        \"card\",\n        \"cargo\",\n        \"carpet\",\n        \"carry\",\n        \"cart\",\n        \"case\",\n        \"cash\",\n        \"casino\",\n        \"castle\",\n        \"casual\",\n        \"cat\",\n        \"catalog\",\n        \"catch\",\n        \"category\",\n        \"cattle\",\n        \"caught\",\n        \"cause\",\n        \"caution\",\n        \"cave\",\n        \"ceiling\",\n        \"celery\",\n        \"cement\",\n        \"census\",\n        \"century\",\n        \"cereal\",\n        \"certain\",\n        \"chair\",\n        \"chalk\",\n        \"champion\",\n        \"change\",\n        \"chaos\",\n        \"chapter\",\n        \"charge\",\n        \"chase\",\n        \"chat\",\n        \"cheap\",\n        \"check\",\n        \"cheese\",\n        \"chef\",\n        \"cherry\",\n        \"chest\",\n        \"chicken\",\n        \"chief\",\n        \"child\",\n        \"chimney\",\n        \"choice\",\n        \"choose\",\n        \"chronic\",\n        \"chuckle\",\n        \"chunk\",\n        \"churn\",\n        \"cigar\",\n        \"cinnamon\",\n        \"circle\",\n        \"citizen\",\n        \"city\",\n        \"civil\",\n        \"claim\",\n        \"clap\",\n        \"clarify\",\n        \"claw\",\n        \"clay\",\n        \"clean\",\n        \"clerk\",\n        \"clever\",\n        \"click\",\n        \"client\",\n        \"cliff\",\n        \"climb\",\n        \"clinic\",\n        \"clip\",\n        \"clock\",\n        \"clog\",\n        \"close\",\n        \"cloth\",\n        \"cloud\",\n        \"clown\",\n        \"club\",\n        \"clump\",\n        \"cluster\",\n        \"clutch\",\n        \"coach\",\n        \"coast\",\n        \"coconut\",\n        \"code\",\n        \"coffee\",\n        \"coil\",\n        \"coin\",\n        \"collect\",\n        \"color\",\n        \"column\",\n        \"combine\",\n        \"come\",\n        \"comfort\",\n        \"comic\",\n        \"common\",\n        \"company\",\n        \"concert\",\n        \"conduct\",\n        \"confirm\",\n        \"congress\",\n        \"connect\",\n        \"consider\",\n        \"control\",\n        \"convince\",\n        \"cook\",\n        \"cool\",\n        \"copper\",\n        \"copy\",\n        \"coral\",\n        \"core\",\n        \"corn\",\n        \"correct\",\n        \"cost\",\n        \"cotton\",\n        \"couch\",\n        \"country\",\n        \"couple\",\n        \"course\",\n        \"cousin\",\n        \"cover\",\n        \"coyote\",\n        \"crack\",\n        \"cradle\",\n        \"craft\",\n        \"cram\",\n        \"crane\",\n        \"crash\",\n        \"crater\",\n        \"crawl\",\n        \"crazy\",\n        \"cream\",\n        \"credit\",\n        \"creek\",\n        \"crew\",\n        \"cricket\",\n        \"crime\",\n        \"crisp\",\n        \"critic\",\n        \"crop\",\n        \"cross\",\n        \"crouch\",\n        \"crowd\",\n        \"crucial\",\n        \"cruel\",\n        \"cruise\",\n        \"crumble\",\n        \"crunch\",\n        \"crush\",\n        \"cry\",\n        \"crystal\",\n        \"cube\",\n        \"culture\",\n        \"cup\",\n        \"cupboard\",\n        \"curious\",\n        \"current\",\n        \"curtain\",\n        \"curve\",\n        \"cushion\",\n        \"custom\",\n        \"cute\",\n        \"cycle\",\n        \"dad\",\n        \"damage\",\n        \"damp\",\n        \"dance\",\n        \"danger\",\n        \"daring\",\n        \"dash\",\n        \"daughter\",\n        \"dawn\",\n        \"day\",\n        \"deal\",\n        \"debate\",\n        \"debris\",\n        \"decade\",\n        \"december\",\n        \"decide\",\n        \"decline\",\n        \"decorate\",\n        \"decrease\",\n        \"deer\",\n        \"defense\",\n        \"define\",\n        \"defy\",\n        \"degree\",\n        \"delay\",\n        \"deliver\",\n        \"demand\",\n        \"demise\",\n        \"denial\",\n        \"dentist\",\n        \"deny\",\n        \"depart\",\n        \"depend\",\n        \"deposit\",\n        \"depth\",\n        \"deputy\",\n        \"derive\",\n        \"describe\",\n        \"desert\",\n        \"design\",\n        \"desk\",\n        \"despair\",\n        \"destroy\",\n        \"detail\",\n        \"detect\",\n        \"develop\",\n        \"device\",\n        \"devote\",\n        \"diagram\",\n        \"dial\",\n        \"diamond\",\n        \"diary\",\n        \"dice\",\n        \"diesel\",\n        \"diet\",\n        \"differ\",\n        \"digital\",\n        \"dignity\",\n        \"dilemma\",\n        \"dinner\",\n        \"dinosaur\",\n        \"direct\",\n        \"dirt\",\n        \"disagree\",\n        \"discover\",\n        \"disease\",\n        \"dish\",\n        \"dismiss\",\n        \"disorder\",\n        \"display\",\n        \"distance\",\n        \"divert\",\n        \"divide\",\n        \"divorce\",\n        \"dizzy\",\n        \"doctor\",\n        \"document\",\n        \"dog\",\n        \"doll\",\n        \"dolphin\",\n        \"domain\",\n        \"donate\",\n        \"donkey\",\n        \"donor\",\n        \"door\",\n        \"dose\",\n        \"double\",\n        \"dove\",\n        \"draft\",\n        \"dragon\",\n        \"drama\",\n        \"drastic\",\n        \"draw\",\n        \"dream\",\n        \"dress\",\n        \"drift\",\n        \"drill\",\n        \"drink\",\n        \"drip\",\n        \"drive\",\n        \"drop\",\n        \"drum\",\n        \"dry\",\n        \"duck\",\n        \"dumb\",\n        \"dune\",\n        \"during\",\n        \"dust\",\n        \"dutch\",\n        \"duty\",\n        \"dwarf\",\n        \"dynamic\",\n        \"eager\",\n        \"eagle\",\n        \"early\",\n        \"earn\",\n        \"earth\",\n        \"easily\",\n        \"east\",\n        \"easy\",\n        \"echo\",\n        \"ecology\",\n        \"economy\",\n        \"edge\",\n        \"edit\",\n        \"educate\",\n        \"effort\",\n        \"egg\",\n        \"eight\",\n        \"either\",\n        \"elbow\",\n        \"elder\",\n        \"electric\",\n        \"elegant\",\n        \"element\",\n        \"elephant\",\n        \"elevator\",\n        \"elite\",\n        \"else\",\n        \"embark\",\n        \"embody\",\n        \"embrace\",\n        \"emerge\",\n        \"emotion\",\n        \"employ\",\n        \"empower\",\n        \"empty\",\n        \"enable\",\n        \"enact\",\n        \"end\",\n        \"endless\",\n        \"endorse\",\n        \"enemy\",\n        \"energy\",\n        \"enforce\",\n        \"engage\",\n        \"engine\",\n        \"enhance\",\n        \"enjoy\",\n        \"enlist\",\n        \"enough\",\n        \"enrich\",\n        \"enroll\",\n        \"ensure\",\n        \"enter\",\n        \"entire\",\n        \"entry\",\n        \"envelope\",\n        \"episode\",\n        \"equal\",\n        \"equip\",\n        \"era\",\n        \"erase\",\n        \"erode\",\n        \"erosion\",\n        \"error\",\n        \"erupt\",\n        \"escape\",\n        \"essay\",\n        \"essence\",\n        \"estate\",\n        \"eternal\",\n        \"ethics\",\n        \"evidence\",\n        \"evil\",\n        \"evoke\",\n        \"evolve\",\n        \"exact\",\n        \"example\",\n        \"excess\",\n        \"exchange\",\n        \"excite\",\n        \"exclude\",\n        \"excuse\",\n        \"execute\",\n        \"exercise\",\n        \"exhaust\",\n        \"exhibit\",\n        \"exile\",\n        \"exist\",\n        \"exit\",\n        \"exotic\",\n        \"expand\",\n        \"expect\",\n        \"expire\",\n        \"explain\",\n        \"expose\",\n        \"express\",\n        \"extend\",\n        \"extra\",\n        \"eye\",\n        \"eyebrow\",\n        \"fabric\",\n        \"face\",\n        \"faculty\",\n        \"fade\",\n        \"faint\",\n        \"faith\",\n        \"fall\",\n        \"false\",\n        \"fame\",\n        \"family\",\n        \"famous\",\n        \"fan\",\n        \"fancy\",\n        \"fantasy\",\n        \"farm\",\n        \"fashion\",\n        \"fat\",\n        \"fatal\",\n        \"father\",\n        \"fatigue\",\n        \"fault\",\n        \"favorite\",\n        \"feature\",\n        \"february\",\n        \"federal\",\n        \"fee\",\n        \"feed\",\n        \"feel\",\n        \"female\",\n        \"fence\",\n        \"festival\",\n        \"fetch\",\n        \"fever\",\n        \"few\",\n        \"fiber\",\n        \"fiction\",\n        \"field\",\n        \"figure\",\n        \"file\",\n        \"film\",\n        \"filter\",\n        \"final\",\n        \"find\",\n        \"fine\",\n        \"finger\",\n        \"finish\",\n        \"fire\",\n        \"firm\",\n        \"first\",\n        \"fiscal\",\n        \"fish\",\n        \"fit\",\n        \"fitness\",\n        \"fix\",\n        \"flag\",\n        \"flame\",\n        \"flash\",\n        \"flat\",\n        \"flavor\",\n        \"flee\",\n        \"flight\",\n        \"flip\",\n        \"float\",\n        \"flock\",\n        \"floor\",\n        \"flower\",\n        \"fluid\",\n        \"flush\",\n        \"fly\",\n        \"foam\",\n        \"focus\",\n        \"fog\",\n        \"foil\",\n        \"fold\",\n        \"follow\",\n        \"food\",\n        \"foot\",\n        \"force\",\n        \"forest\",\n        \"forget\",\n        \"fork\",\n        \"fortune\",\n        \"forum\",\n        \"forward\",\n        \"fossil\",\n        \"foster\",\n        \"found\",\n        \"fox\",\n        \"fragile\",\n        \"frame\",\n        \"frequent\",\n        \"fresh\",\n        \"friend\",\n        \"fringe\",\n        \"frog\",\n        \"front\",\n        \"frost\",\n        \"frown\",\n        \"frozen\",\n        \"fruit\",\n        \"fuel\",\n        \"fun\",\n        \"funny\",\n        \"furnace\",\n        \"fury\",\n        \"future\",\n        \"gadget\",\n        \"gain\",\n        \"galaxy\",\n        \"gallery\",\n        \"game\",\n        \"gap\",\n        \"garage\",\n        \"garbage\",\n        \"garden\",\n        \"garlic\",\n        \"garment\",\n        \"gas\",\n        \"gasp\",\n        \"gate\",\n        \"gather\",\n        \"gauge\",\n        \"gaze\",\n        \"general\",\n        \"genius\",\n        \"genre\",\n        \"gentle\",\n        \"genuine\",\n        \"gesture\",\n        \"ghost\",\n        \"giant\",\n        \"gift\",\n        \"giggle\",\n        \"ginger\",\n        \"giraffe\",\n        \"girl\",\n        \"give\",\n        \"glad\",\n        \"glance\",\n        \"glare\",\n        \"glass\",\n        \"glide\",\n        \"glimpse\",\n        \"globe\",\n        \"gloom\",\n        \"glory\",\n        \"glove\",\n        \"glow\",\n        \"glue\",\n        \"goat\",\n        \"goddess\",\n        \"gold\",\n        \"good\",\n        \"goose\",\n        \"gorilla\",\n        \"gospel\",\n        \"gossip\",\n        \"govern\",\n        \"gown\",\n        \"grab\",\n        \"grace\",\n        \"grain\",\n        \"grant\",\n        \"grape\",\n        \"grass\",\n        \"gravity\",\n        \"great\",\n        \"green\",\n        \"grid\",\n        \"grief\",\n        \"grit\",\n        \"grocery\",\n        \"group\",\n        \"grow\",\n        \"grunt\",\n        \"guard\",\n        \"guess\",\n        \"guide\",\n        \"guilt\",\n        \"guitar\",\n        \"gun\",\n        \"gym\",\n        \"habit\",\n        \"hair\",\n        \"half\",\n        \"hammer\",\n        \"hamster\",\n        \"hand\",\n        \"happy\",\n        \"harbor\",\n        \"hard\",\n        \"harsh\",\n        \"harvest\",\n        \"hat\",\n        \"have\",\n        \"hawk\",\n        \"hazard\",\n        \"head\",\n        \"health\",\n        \"heart\",\n        \"heavy\",\n        \"hedgehog\",\n        \"height\",\n        \"hello\",\n        \"helmet\",\n        \"help\",\n        \"hen\",\n        \"hero\",\n        \"hidden\",\n        \"high\",\n        \"hill\",\n        \"hint\",\n        \"hip\",\n        \"hire\",\n        \"history\",\n        \"hobby\",\n        \"hockey\",\n        \"hold\",\n        \"hole\",\n        \"holiday\",\n        \"hollow\",\n        \"home\",\n        \"honey\",\n        \"hood\",\n        \"hope\",\n        \"horn\",\n        \"horror\",\n        \"horse\",\n        \"hospital\",\n        \"host\",\n        \"hotel\",\n        \"hour\",\n        \"hover\",\n        \"hub\",\n        \"huge\",\n        \"human\",\n        \"humble\",\n        \"humor\",\n        \"hundred\",\n        \"hungry\",\n        \"hunt\",\n        \"hurdle\",\n        \"hurry\",\n        \"hurt\",\n        \"husband\",\n        \"hybrid\",\n        \"ice\",\n        \"icon\",\n        \"idea\",\n        \"identify\",\n        \"idle\",\n        \"ignore\",\n        \"ill\",\n        \"illegal\",\n        \"illness\",\n        \"image\",\n        \"imitate\",\n        \"immense\",\n        \"immune\",\n        \"impact\",\n        \"impose\",\n        \"improve\",\n        \"impulse\",\n        \"inch\",\n        \"include\",\n        \"income\",\n        \"increase\",\n        \"index\",\n        \"indicate\",\n        \"indoor\",\n        \"industry\",\n        \"infant\",\n        \"inflict\",\n        \"inform\",\n        \"inhale\",\n        \"inherit\",\n        \"initial\",\n        \"inject\",\n        \"injury\",\n        \"inmate\",\n        \"inner\",\n        \"innocent\",\n        \"input\",\n        \"inquiry\",\n        \"insane\",\n        \"insect\",\n        \"inside\",\n        \"inspire\",\n        \"install\",\n        \"intact\",\n        \"interest\",\n        \"into\",\n        \"invest\",\n        \"invite\",\n        \"involve\",\n        \"iron\",\n        \"island\",\n        \"isolate\",\n        \"issue\",\n        \"item\",\n        \"ivory\",\n        \"jacket\",\n        \"jaguar\",\n        \"jar\",\n        \"jazz\",\n        \"jealous\",\n        \"jeans\",\n        \"jelly\",\n        \"jewel\",\n        \"job\",\n        \"join\",\n        \"joke\",\n        \"journey\",\n        \"joy\",\n        \"judge\",\n        \"juice\",\n        \"jump\",\n        \"jungle\",\n        \"junior\",\n        \"junk\",\n        \"just\",\n        \"kangaroo\",\n        \"keen\",\n        \"keep\",\n        \"ketchup\",\n        \"key\",\n        \"kick\",\n        \"kid\",\n        \"kidney\",\n        \"kind\",\n        \"kingdom\",\n        \"kiss\",\n        \"kit\",\n        \"kitchen\",\n        \"kite\",\n        \"kitten\",\n        \"kiwi\",\n        \"knee\",\n        \"knife\",\n        \"knock\",\n        \"know\",\n        \"lab\",\n        \"label\",\n        \"labor\",\n        \"ladder\",\n        \"lady\",\n        \"lake\",\n        \"lamp\",\n        \"language\",\n        \"laptop\",\n        \"large\",\n        \"later\",\n        \"latin\",\n        \"laugh\",\n        \"laundry\",\n        \"lava\",\n        \"law\",\n        \"lawn\",\n        \"lawsuit\",\n        \"layer\",\n        \"lazy\",\n        \"leader\",\n        \"leaf\",\n        \"learn\",\n        \"leave\",\n        \"lecture\",\n        \"left\",\n        \"leg\",\n        \"legal\",\n        \"legend\",\n        \"leisure\",\n        \"lemon\",\n        \"lend\",\n        \"length\",\n        \"lens\",\n        \"leopard\",\n        \"lesson\",\n        \"letter\",\n        \"level\",\n        \"liar\",\n        \"liberty\",\n        \"library\",\n        \"license\",\n        \"life\",\n        \"lift\",\n        \"light\",\n        \"like\",\n        \"limb\",\n        \"limit\",\n        \"link\",\n        \"lion\",\n        \"liquid\",\n        \"list\",\n        \"little\",\n        \"live\",\n        \"lizard\",\n        \"load\",\n        \"loan\",\n        \"lobster\",\n        \"local\",\n        \"lock\",\n        \"logic\",\n        \"lonely\",\n        \"long\",\n        \"loop\",\n        \"lottery\",\n        \"loud\",\n        \"lounge\",\n        \"love\",\n        \"loyal\",\n        \"lucky\",\n        \"luggage\",\n        \"lumber\",\n        \"lunar\",\n        \"lunch\",\n        \"luxury\",\n        \"lyrics\",\n        \"machine\",\n        \"mad\",\n        \"magic\",\n        \"magnet\",\n        \"maid\",\n        \"mail\",\n        \"main\",\n        \"major\",\n        \"make\",\n        \"mammal\",\n        \"man\",\n        \"manage\",\n        \"mandate\",\n        \"mango\",\n        \"mansion\",\n        \"manual\",\n        \"maple\",\n        \"marble\",\n        \"march\",\n        \"margin\",\n        \"marine\",\n        \"market\",\n        \"marriage\",\n        \"mask\",\n        \"mass\",\n        \"master\",\n        \"match\",\n        \"material\",\n        \"math\",\n        \"matrix\",\n        \"matter\",\n        \"maximum\",\n        \"maze\",\n        \"meadow\",\n        \"mean\",\n        \"measure\",\n        \"meat\",\n        \"mechanic\",\n        \"medal\",\n        \"media\",\n        \"melody\",\n        \"melt\",\n        \"member\",\n        \"memory\",\n        \"mention\",\n        \"menu\",\n        \"mercy\",\n        \"merge\",\n        \"merit\",\n        \"merry\",\n        \"mesh\",\n        \"message\",\n        \"metal\",\n        \"method\",\n        \"middle\",\n        \"midnight\",\n        \"milk\",\n        \"million\",\n        \"mimic\",\n        \"mind\",\n        \"minimum\",\n        \"minor\",\n        \"minute\",\n        \"miracle\",\n        \"mirror\",\n        \"misery\",\n        \"miss\",\n        \"mistake\",\n        \"mix\",\n        \"mixed\",\n        \"mixture\",\n        \"mobile\",\n        \"model\",\n        \"modify\",\n        \"mom\",\n        \"moment\",\n        \"monitor\",\n        \"monkey\",\n        \"monster\",\n        \"month\",\n        \"moon\",\n        \"moral\",\n        \"more\",\n        \"morning\",\n        \"mosquito\",\n        \"mother\",\n        \"motion\",\n        \"motor\",\n        \"mountain\",\n        \"mouse\",\n        \"move\",\n        \"movie\",\n        \"much\",\n        \"muffin\",\n        \"mule\",\n        \"multiply\",\n        \"muscle\",\n        \"museum\",\n        \"mushroom\",\n        \"music\",\n        \"must\",\n        \"mutual\",\n        \"myself\",\n        \"mystery\",\n        \"myth\",\n        \"naive\",\n        \"name\",\n        \"napkin\",\n        \"narrow\",\n        \"nasty\",\n        \"nation\",\n        \"nature\",\n        \"near\",\n        \"neck\",\n        \"need\",\n        \"negative\",\n        \"neglect\",\n        \"neither\",\n        \"nephew\",\n        \"nerve\",\n        \"nest\",\n        \"net\",\n        \"network\",\n        \"neutral\",\n        \"never\",\n        \"news\",\n        \"next\",\n        \"nice\",\n        \"night\",\n        \"noble\",\n        \"noise\",\n        \"nominee\",\n        \"noodle\",\n        \"normal\",\n        \"north\",\n        \"nose\",\n        \"notable\",\n        \"note\",\n        \"nothing\",\n        \"notice\",\n        \"novel\",\n        \"now\",\n        \"nuclear\",\n        \"number\",\n        \"nurse\",\n        \"nut\",\n        \"oak\",\n        \"obey\",\n        \"object\",\n        \"oblige\",\n        \"obscure\",\n        \"observe\",\n        \"obtain\",\n        \"obvious\",\n        \"occur\",\n        \"ocean\",\n        \"october\",\n        \"odor\",\n        \"off\",\n        \"offer\",\n        \"office\",\n        \"often\",\n        \"oil\",\n        \"okay\",\n        \"old\",\n        \"olive\",\n        \"olympic\",\n        \"omit\",\n        \"once\",\n        \"one\",\n        \"onion\",\n        \"online\",\n        \"only\",\n        \"open\",\n        \"opera\",\n        \"opinion\",\n        \"oppose\",\n        \"option\",\n        \"orange\",\n        \"orbit\",\n        \"orchard\",\n        \"order\",\n        \"ordinary\",\n        \"organ\",\n        \"orient\",\n        \"original\",\n        \"orphan\",\n        \"ostrich\",\n        \"other\",\n        \"outdoor\",\n        \"outer\",\n        \"output\",\n        \"outside\",\n        \"oval\",\n        \"oven\",\n        \"over\",\n        \"own\",\n        \"owner\",\n        \"oxygen\",\n        \"oyster\",\n        \"ozone\",\n        \"pact\",\n        \"paddle\",\n        \"page\",\n        \"pair\",\n        \"palace\",\n        \"palm\",\n        \"panda\",\n        \"panel\",\n        \"panic\",\n        \"panther\",\n        \"paper\",\n        \"parade\",\n        \"parent\",\n        \"park\",\n        \"parrot\",\n        \"party\",\n        \"pass\",\n        \"patch\",\n        \"path\",\n        \"patient\",\n        \"patrol\",\n        \"pattern\",\n        \"pause\",\n        \"pave\",\n        \"payment\",\n        \"peace\",\n        \"peanut\",\n        \"pear\",\n        \"peasant\",\n        \"pelican\",\n        \"pen\",\n        \"penalty\",\n        \"pencil\",\n        \"people\",\n        \"pepper\",\n        \"perfect\",\n        \"permit\",\n        \"person\",\n        \"pet\",\n        \"phone\",\n        \"photo\",\n        \"phrase\",\n        \"physical\",\n        \"piano\",\n        \"picnic\",\n        \"picture\",\n        \"piece\",\n        \"pig\",\n        \"pigeon\",\n        \"pill\",\n        \"pilot\",\n        \"pink\",\n        \"pioneer\",\n        \"pipe\",\n        \"pistol\",\n        \"pitch\",\n        \"pizza\",\n        \"place\",\n        \"planet\",\n        \"plastic\",\n        \"plate\",\n        \"play\",\n        \"please\",\n        \"pledge\",\n        \"pluck\",\n        \"plug\",\n        \"plunge\",\n        \"poem\",\n        \"poet\",\n        \"point\",\n        \"polar\",\n        \"pole\",\n        \"police\",\n        \"pond\",\n        \"pony\",\n        \"pool\",\n        \"popular\",\n        \"portion\",\n        \"position\",\n        \"possible\",\n        \"post\",\n        \"potato\",\n        \"pottery\",\n        \"poverty\",\n        \"powder\",\n        \"power\",\n        \"practice\",\n        \"praise\",\n        \"predict\",\n        \"prefer\",\n        \"prepare\",\n        \"present\",\n        \"pretty\",\n        \"prevent\",\n        \"price\",\n        \"pride\",\n        \"primary\",\n        \"print\",\n        \"priority\",\n        \"prison\",\n        \"private\",\n        \"prize\",\n        \"problem\",\n        \"process\",\n        \"produce\",\n        \"profit\",\n        \"program\",\n        \"project\",\n        \"promote\",\n        \"proof\",\n        \"property\",\n        \"prosper\",\n        \"protect\",\n        \"proud\",\n        \"provide\",\n        \"public\",\n        \"pudding\",\n        \"pull\",\n        \"pulp\",\n        \"pulse\",\n        \"pumpkin\",\n        \"punch\",\n        \"pupil\",\n        \"puppy\",\n        \"purchase\",\n        \"purity\",\n        \"purpose\",\n        \"purse\",\n        \"push\",\n        \"put\",\n        \"puzzle\",\n        \"pyramid\",\n        \"quality\",\n        \"quantum\",\n        \"quarter\",\n        \"question\",\n        \"quick\",\n        \"quit\",\n        \"quiz\",\n        \"quote\",\n        \"rabbit\",\n        \"raccoon\",\n        \"race\",\n        \"rack\",\n        \"radar\",\n        \"radio\",\n        \"rail\",\n        \"rain\",\n        \"raise\",\n        \"rally\",\n        \"ramp\",\n        \"ranch\",\n        \"random\",\n        \"range\",\n        \"rapid\",\n        \"rare\",\n        \"rate\",\n        \"rather\",\n        \"raven\",\n        \"raw\",\n        \"razor\",\n        \"ready\",\n        \"real\",\n        \"reason\",\n        \"rebel\",\n        \"rebuild\",\n        \"recall\",\n        \"receive\",\n        \"recipe\",\n        \"record\",\n        \"recycle\",\n        \"reduce\",\n        \"reflect\",\n        \"reform\",\n        \"refuse\",\n        \"region\",\n        \"regret\",\n        \"regular\",\n        \"reject\",\n        \"relax\",\n        \"release\",\n        \"relief\",\n        \"rely\",\n        \"remain\",\n        \"remember\",\n        \"remind\",\n        \"remove\",\n        \"render\",\n        \"renew\",\n        \"rent\",\n        \"reopen\",\n        \"repair\",\n        \"repeat\",\n        \"replace\",\n        \"report\",\n        \"require\",\n        \"rescue\",\n        \"resemble\",\n        \"resist\",\n        \"resource\",\n        \"response\",\n        \"result\",\n        \"retire\",\n        \"retreat\",\n        \"return\",\n        \"reunion\",\n        \"reveal\",\n        \"review\",\n        \"reward\",\n        \"rhythm\",\n        \"rib\",\n        \"ribbon\",\n        \"rice\",\n        \"rich\",\n        \"ride\",\n        \"ridge\",\n        \"rifle\",\n        \"right\",\n        \"rigid\",\n        \"ring\",\n        \"riot\",\n        \"ripple\",\n        \"risk\",\n        \"ritual\",\n        \"rival\",\n        \"river\",\n        \"road\",\n        \"roast\",\n        \"robot\",\n        \"robust\",\n        \"rocket\",\n        \"romance\",\n        \"roof\",\n        \"rookie\",\n        \"room\",\n        \"rose\",\n        \"rotate\",\n        \"rough\",\n        \"round\",\n        \"route\",\n        \"royal\",\n        \"rubber\",\n        \"rude\",\n        \"rug\",\n        \"rule\",\n        \"run\",\n        \"runway\",\n        \"rural\",\n        \"sad\",\n        \"saddle\",\n        \"sadness\",\n        \"safe\",\n        \"sail\",\n        \"salad\",\n        \"salmon\",\n        \"salon\",\n        \"salt\",\n        \"salute\",\n        \"same\",\n        \"sample\",\n        \"sand\",\n        \"satisfy\",\n        \"satoshi\",\n        \"sauce\",\n        \"sausage\",\n        \"save\",\n        \"say\",\n        \"scale\",\n        \"scan\",\n        \"scare\",\n        \"scatter\",\n        \"scene\",\n        \"scheme\",\n        \"school\",\n        \"science\",\n        \"scissors\",\n        \"scorpion\",\n        \"scout\",\n        \"scrap\",\n        \"screen\",\n        \"script\",\n        \"scrub\",\n        \"sea\",\n        \"search\",\n        \"season\",\n        \"seat\",\n        \"second\",\n        \"secret\",\n        \"section\",\n        \"security\",\n        \"seed\",\n        \"seek\",\n        \"segment\",\n        \"select\",\n        \"sell\",\n        \"seminar\",\n        \"senior\",\n        \"sense\",\n        \"sentence\",\n        \"series\",\n        \"service\",\n        \"session\",\n        \"settle\",\n        \"setup\",\n        \"seven\",\n        \"shadow\",\n        \"shaft\",\n        \"shallow\",\n        \"share\",\n        \"shed\",\n        \"shell\",\n        \"sheriff\",\n        \"shield\",\n        \"shift\",\n        \"shine\",\n        \"ship\",\n        \"shiver\",\n        \"shock\",\n        \"shoe\",\n        \"shoot\",\n        \"shop\",\n        \"short\",\n        \"shoulder\",\n        \"shove\",\n        \"shrimp\",\n        \"shrug\",\n        \"shuffle\",\n        \"shy\",\n        \"sibling\",\n        \"sick\",\n        \"side\",\n        \"siege\",\n        \"sight\",\n        \"sign\",\n        \"silent\",\n        \"silk\",\n        \"silly\",\n        \"silver\",\n        \"similar\",\n        \"simple\",\n        \"since\",\n        \"sing\",\n        \"siren\",\n        \"sister\",\n        \"situate\",\n        \"six\",\n        \"size\",\n        \"skate\",\n        \"sketch\",\n        \"ski\",\n        \"skill\",\n        \"skin\",\n        \"skirt\",\n        \"skull\",\n        \"slab\",\n        \"slam\",\n        \"sleep\",\n        \"slender\",\n        \"slice\",\n        \"slide\",\n        \"slight\",\n        \"slim\",\n        \"slogan\",\n        \"slot\",\n        \"slow\",\n        \"slush\",\n        \"small\",\n        \"smart\",\n        \"smile\",\n        \"smoke\",\n        \"smooth\",\n        \"snack\",\n        \"snake\",\n        \"snap\",\n        \"sniff\",\n        \"snow\",\n        \"soap\",\n        \"soccer\",\n        \"social\",\n        \"sock\",\n        \"soda\",\n        \"soft\",\n        \"solar\",\n        \"soldier\",\n        \"solid\",\n        \"solution\",\n        \"solve\",\n        \"someone\",\n        \"song\",\n        \"soon\",\n        \"sorry\",\n        \"sort\",\n        \"soul\",\n        \"sound\",\n        \"soup\",\n        \"source\",\n        \"south\",\n        \"space\",\n        \"spare\",\n        \"spatial\",\n        \"spawn\",\n        \"speak\",\n        \"special\",\n        \"speed\",\n        \"spell\",\n        \"spend\",\n        \"sphere\",\n        \"spice\",\n        \"spider\",\n        \"spike\",\n        \"spin\",\n        \"spirit\",\n        \"split\",\n        \"spoil\",\n        \"sponsor\",\n        \"spoon\",\n        \"sport\",\n        \"spot\",\n        \"spray\",\n        \"spread\",\n        \"spring\",\n        \"spy\",\n        \"square\",\n        \"squeeze\",\n        \"squirrel\",\n        \"stable\",\n        \"stadium\",\n        \"staff\",\n        \"stage\",\n        \"stairs\",\n        \"stamp\",\n        \"stand\",\n        \"start\",\n        \"state\",\n        \"stay\",\n        \"steak\",\n        \"steel\",\n        \"stem\",\n        \"step\",\n        \"stereo\",\n        \"stick\",\n        \"still\",\n        \"sting\",\n        \"stock\",\n        \"stomach\",\n        \"stone\",\n        \"stool\",\n        \"story\",\n        \"stove\",\n        \"strategy\",\n        \"street\",\n        \"strike\",\n        \"strong\",\n        \"struggle\",\n        \"student\",\n        \"stuff\",\n        \"stumble\",\n        \"style\",\n        \"subject\",\n        \"submit\",\n        \"subway\",\n        \"success\",\n        \"such\",\n        \"sudden\",\n        \"suffer\",\n        \"sugar\",\n        \"suggest\",\n        \"suit\",\n        \"summer\",\n        \"sun\",\n        \"sunny\",\n        \"sunset\",\n        \"super\",\n        \"supply\",\n        \"supreme\",\n        \"sure\",\n        \"surface\",\n        \"surge\",\n        \"surprise\",\n        \"surround\",\n        \"survey\",\n        \"suspect\",\n        \"sustain\",\n        \"swallow\",\n        \"swamp\",\n        \"swap\",\n        \"swarm\",\n        \"swear\",\n        \"sweet\",\n        \"swift\",\n        \"swim\",\n        \"swing\",\n        \"switch\",\n        \"sword\",\n        \"symbol\",\n        \"symptom\",\n        \"syrup\",\n        \"system\",\n        \"table\",\n        \"tackle\",\n        \"tag\",\n        \"tail\",\n        \"talent\",\n        \"talk\",\n        \"tank\",\n        \"tape\",\n        \"target\",\n        \"task\",\n        \"taste\",\n        \"tattoo\",\n        \"taxi\",\n        \"teach\",\n        \"team\",\n        \"tell\",\n        \"ten\",\n        \"tenant\",\n        \"tennis\",\n        \"tent\",\n        \"term\",\n        \"test\",\n        \"text\",\n        \"thank\",\n        \"that\",\n        \"theme\",\n        \"then\",\n        \"theory\",\n        \"there\",\n        \"they\",\n        \"thing\",\n        \"this\",\n        \"thought\",\n        \"three\",\n        \"thrive\",\n        \"throw\",\n        \"thumb\",\n        \"thunder\",\n        \"ticket\",\n        \"tide\",\n        \"tiger\",\n        \"tilt\",\n        \"timber\",\n        \"time\",\n        \"tiny\",\n        \"tip\",\n        \"tired\",\n        \"tissue\",\n        \"title\",\n        \"toast\",\n        \"tobacco\",\n        \"today\",\n        \"toddler\",\n        \"toe\",\n        \"together\",\n        \"toilet\",\n        \"token\",\n        \"tomato\",\n        \"tomorrow\",\n        \"tone\",\n        \"tongue\",\n        \"tonight\",\n        \"tool\",\n        \"tooth\",\n        \"top\",\n        \"topic\",\n        \"topple\",\n        \"torch\",\n        \"tornado\",\n        \"tortoise\",\n        \"toss\",\n        \"total\",\n        \"tourist\",\n        \"toward\",\n        \"tower\",\n        \"town\",\n        \"toy\",\n        \"track\",\n        \"trade\",\n        \"traffic\",\n        \"tragic\",\n        \"train\",\n        \"transfer\",\n        \"trap\",\n        \"trash\",\n        \"travel\",\n        \"tray\",\n        \"treat\",\n        \"tree\",\n        \"trend\",\n        \"trial\",\n        \"tribe\",\n        \"trick\",\n        \"trigger\",\n        \"trim\",\n        \"trip\",\n        \"trophy\",\n        \"trouble\",\n        \"truck\",\n        \"true\",\n        \"truly\",\n        \"trumpet\",\n        \"trust\",\n        \"truth\",\n        \"try\",\n        \"tube\",\n        \"tuition\",\n        \"tumble\",\n        \"tuna\",\n        \"tunnel\",\n        \"turkey\",\n        \"turn\",\n        \"turtle\",\n        \"twelve\",\n        \"twenty\",\n        \"twice\",\n        \"twin\",\n        \"twist\",\n        \"two\",\n        \"type\",\n        \"typical\",\n        \"ugly\",\n        \"umbrella\",\n        \"unable\",\n        \"unaware\",\n        \"uncle\",\n        \"uncover\",\n        \"under\",\n        \"undo\",\n        \"unfair\",\n        \"unfold\",\n        \"unhappy\",\n        \"uniform\",\n        \"unique\",\n        \"unit\",\n        \"universe\",\n        \"unknown\",\n        \"unlock\",\n        \"until\",\n        \"unusual\",\n        \"unveil\",\n        \"update\",\n        \"upgrade\",\n        \"uphold\",\n        \"upon\",\n        \"upper\",\n        \"upset\",\n        \"urban\",\n        \"urge\",\n        \"usage\",\n        \"use\",\n        \"used\",\n        \"useful\",\n        \"useless\",\n        \"usual\",\n        \"utility\",\n        \"vacant\",\n        \"vacuum\",\n        \"vague\",\n        \"valid\",\n        \"valley\",\n        \"valve\",\n        \"van\",\n        \"vanish\",\n        \"vapor\",\n        \"various\",\n        \"vast\",\n        \"vault\",\n        \"vehicle\",\n        \"velvet\",\n        \"vendor\",\n        \"venture\",\n        \"venue\",\n        \"verb\",\n        \"verify\",\n        \"version\",\n        \"very\",\n        \"vessel\",\n        \"veteran\",\n        \"viable\",\n        \"vibrant\",\n        \"vicious\",\n        \"victory\",\n        \"video\",\n        \"view\",\n        \"village\",\n        \"vintage\",\n        \"violin\",\n        \"virtual\",\n        \"virus\",\n        \"visa\",\n        \"visit\",\n        \"visual\",\n        \"vital\",\n        \"vivid\",\n        \"vocal\",\n        \"voice\",\n        \"void\",\n        \"volcano\",\n        \"volume\",\n        \"vote\",\n        \"voyage\",\n        \"wage\",\n        \"wagon\",\n        \"wait\",\n        \"walk\",\n        \"wall\",\n        \"walnut\",\n        \"want\",\n        \"warfare\",\n        \"warm\",\n        \"warrior\",\n        \"wash\",\n        \"wasp\",\n        \"waste\",\n        \"water\",\n        \"wave\",\n        \"way\",\n        \"wealth\",\n        \"weapon\",\n        \"wear\",\n        \"weasel\",\n        \"weather\",\n        \"web\",\n        \"wedding\",\n        \"weekend\",\n        \"weird\",\n        \"welcome\",\n        \"west\",\n        \"wet\",\n        \"whale\",\n        \"what\",\n        \"wheat\",\n        \"wheel\",\n        \"when\",\n        \"where\",\n        \"whip\",\n        \"whisper\",\n        \"wide\",\n        \"width\",\n        \"wife\",\n        \"wild\",\n        \"will\",\n        \"win\",\n        \"window\",\n        \"wine\",\n        \"wing\",\n        \"wink\",\n        \"winner\",\n        \"winter\",\n        \"wire\",\n        \"wisdom\",\n        \"wise\",\n        \"wish\",\n        \"witness\",\n        \"wolf\",\n        \"woman\",\n        \"wonder\",\n        \"wood\",\n        \"wool\",\n        \"word\",\n        \"work\",\n        \"world\",\n        \"worry\",\n        \"worth\",\n        \"wrap\",\n        \"wreck\",\n        \"wrestle\",\n        \"wrist\",\n        \"write\",\n        \"wrong\",\n        \"yard\",\n        \"year\",\n        \"yellow\",\n        \"you\",\n        \"young\",\n        \"youth\",\n        \"zebra\",\n        \"zero\",\n        \"zone\",\n        \"zoo\"\n    ],\n    space: \" \"\n}\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/configuration/","title":"Configuration Reference","text":"<p>Complete reference for SDK configuration options, interfaces, and setup patterns in the BSV TypeScript SDK.</p>"},{"location":"reference/configuration/#core-configuration-interface","title":"Core Configuration Interface","text":"<pre><code>interface SDKConfig {\n  network: NetworkType\n  arc: ARCConfig\n  fees: FeeConfig\n  security: SecurityConfig\n  wallet: WalletConfig\n  chainTracker: ChainTrackerConfig\n  logging: LoggingConfig\n}\n</code></pre>"},{"location":"reference/configuration/#network-configuration","title":"Network Configuration","text":""},{"location":"reference/configuration/#networktype","title":"NetworkType","text":"<pre><code>type NetworkType = 'mainnet' | 'testnet' | 'regtest'\n</code></pre>"},{"location":"reference/configuration/#network-parameters","title":"Network Parameters","text":"<pre><code>interface NetworkConfig {\n  name: NetworkType\n  chainParams: {\n    genesisHash: string\n    port: number\n    dnsSeeds: string[]\n    addressPrefix: {\n      pubKeyHash: number\n      scriptHash: number\n      privateKey: number\n    }\n  }\n  defaultEndpoints: {\n    arc: string[]\n    chainTracker: string[]\n    broadcast: string[]\n  }\n}\n</code></pre>"},{"location":"reference/configuration/#predefined-networks","title":"Predefined Networks","text":""},{"location":"reference/configuration/#mainnet-configuration","title":"Mainnet Configuration","text":"<pre><code>const MAINNET_CONFIG: NetworkConfig = {\n  name: 'mainnet',\n  chainParams: {\n    genesisHash: '000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f',\n    port: 8333,\n    dnsSeeds: [\n      'seed.bitcoinsv.io',\n      'seed.cascharia.com',\n      'seed.satoshisvision.network'\n    ],\n    addressPrefix: {\n      pubKeyHash: 0x00,\n      scriptHash: 0x05,\n      privateKey: 0x80\n    }\n  },\n  defaultEndpoints: {\n    arc: ['https://arc.taal.com'],\n    chainTracker: ['https://api.whatsonchain.com/v1/bsv/main'],\n    broadcast: ['https://api.whatsonchain.com/v1/bsv/main/tx/raw']\n  }\n}\n</code></pre>"},{"location":"reference/configuration/#testnet-configuration","title":"Testnet Configuration","text":"<pre><code>const TESTNET_CONFIG: NetworkConfig = {\n  name: 'testnet',\n  chainParams: {\n    genesisHash: '000000000933ea01ad0ee984209779baaec3ced90fa3f408719526f8d77f4943',\n    port: 18333,\n    dnsSeeds: [\n      'testnet-seed.bitcoinsv.io',\n      'testnet-seed.cascharia.com'\n    ],\n    addressPrefix: {\n      pubKeyHash: 0x6f,\n      scriptHash: 0xc4,\n      privateKey: 0xef\n    }\n  },\n  defaultEndpoints: {\n    arc: ['https://arc-testnet.taal.com'],\n    chainTracker: ['https://api.whatsonchain.com/v1/bsv/test'],\n    broadcast: ['https://api.whatsonchain.com/v1/bsv/test/tx/raw']\n  }\n}\n</code></pre>"},{"location":"reference/configuration/#regtest-configuration","title":"Regtest Configuration","text":"<pre><code>const REGTEST_CONFIG: NetworkConfig = {\n  name: 'regtest',\n  chainParams: {\n    genesisHash: '0f9188f13cb7b2c71f2a335e3a4fc328bf5beb436012afca590b1a11466e2206',\n    port: 18444,\n    dnsSeeds: [],\n    addressPrefix: {\n      pubKeyHash: 0x6f,\n      scriptHash: 0xc4,\n      privateKey: 0xef\n    }\n  },\n  defaultEndpoints: {\n    arc: ['http://localhost:9090'],\n    chainTracker: ['http://localhost:3001/v1/bsv/regtest'],\n    broadcast: ['http://localhost:3001/v1/bsv/regtest/tx/raw']\n  }\n}\n</code></pre>"},{"location":"reference/configuration/#arc-configuration","title":"ARC Configuration","text":""},{"location":"reference/configuration/#arcconfig-interface","title":"ARCConfig Interface","text":"<pre><code>interface ARCConfig {\n  apiUrl: string\n  apiKey?: string\n  timeout: number\n  retryAttempts: number\n  retryDelay: number\n  rateLimiting: {\n    requestsPerSecond: number\n    burstLimit: number\n  }\n  endpoints: {\n    submit: string\n    status: string\n    policy: string\n  }\n}\n</code></pre>"},{"location":"reference/configuration/#default-arc-configuration","title":"Default ARC Configuration","text":"<pre><code>const DEFAULT_ARC_CONFIG: ARCConfig = {\n  apiUrl: 'https://arc.taal.com',\n  timeout: 30000, // 30 seconds\n  retryAttempts: 3,\n  retryDelay: 1000, // 1 second\n  rateLimiting: {\n    requestsPerSecond: 10,\n    burstLimit: 50\n  },\n  endpoints: {\n    submit: '/v1/tx',\n    status: '/v1/tx/{txid}',\n    policy: '/v1/policy'\n  }\n}\n</code></pre>"},{"location":"reference/configuration/#arc-authentication","title":"ARC Authentication","text":"<pre><code>interface ARCAuth {\n  type: 'bearer' | 'api-key' | 'none'\n  credentials: {\n    token?: string\n    apiKey?: string\n    secret?: string\n  }\n}\n</code></pre>"},{"location":"reference/configuration/#fee-configuration","title":"Fee Configuration","text":""},{"location":"reference/configuration/#feeconfig-interface","title":"FeeConfig Interface","text":"<pre><code>interface FeeConfig {\n  strategy: FeeStrategy\n  rates: FeeRates\n  limits: FeeLimits\n  estimation: FeeEstimationConfig\n}\n</code></pre>"},{"location":"reference/configuration/#fee-strategy-types","title":"Fee Strategy Types","text":"<pre><code>type FeeStrategy = 'fixed' | 'dynamic' | 'priority' | 'custom'\n\ninterface FeeRates {\n  // Satoshis per byte\n  standard: number\n  priority: number\n  economy: number\n  custom?: number\n}\n\ninterface FeeLimits {\n  minFeeRate: number // Minimum satoshis per byte\n  maxFeeRate: number // Maximum satoshis per byte\n  maxTotalFee: number // Maximum total fee in satoshis\n}\n</code></pre>"},{"location":"reference/configuration/#default-fee-configuration","title":"Default Fee Configuration","text":"<pre><code>const DEFAULT_FEE_CONFIG: FeeConfig = {\n  strategy: 'standard',\n  rates: {\n    standard: 0.5,  // 0.5 sat/byte\n    priority: 1.0,  // 1.0 sat/byte\n    economy: 0.25   // 0.25 sat/byte\n  },\n  limits: {\n    minFeeRate: 0.25,\n    maxFeeRate: 10.0,\n    maxTotalFee: 100000 // 1000 sat maximum\n  },\n  estimation: {\n    enabled: true,\n    source: 'arc',\n    fallbackRate: 0.5,\n    updateInterval: 300000 // 5 minutes\n  }\n}\n</code></pre>"},{"location":"reference/configuration/#fee-estimation-configuration","title":"Fee Estimation Configuration","text":"<pre><code>interface FeeEstimationConfig {\n  enabled: boolean\n  source: 'arc' | 'chainTracker' | 'static'\n  fallbackRate: number\n  updateInterval: number\n  cacheTimeout: number\n}\n</code></pre>"},{"location":"reference/configuration/#security-configuration","title":"Security Configuration","text":""},{"location":"reference/configuration/#securityconfig-interface","title":"SecurityConfig Interface","text":"<pre><code>interface SecurityConfig {\n  keyGeneration: KeyGenerationConfig\n  encryption: EncryptionConfig\n  validation: ValidationConfig\n  randomness: RandomnessConfig\n}\n</code></pre>"},{"location":"reference/configuration/#key-generation-configuration","title":"Key Generation Configuration","text":"<pre><code>interface KeyGenerationConfig {\n  source: 'secure-random' | 'deterministic'\n  entropy: {\n    minBits: number\n    sources: EntropySource[]\n  }\n  derivation: {\n    hardened: boolean\n    maxDepth: number\n  }\n}\n\ntype EntropySource = 'crypto' | 'mouse' | 'keyboard' | 'timing'\n</code></pre>"},{"location":"reference/configuration/#encryption-configuration","title":"Encryption Configuration","text":"<pre><code>interface EncryptionConfig {\n  algorithm: 'AES-GCM' | 'AES-CBC'\n  keySize: 128 | 256\n  ivSize: number\n  tagSize: number\n  keyDerivation: {\n    algorithm: 'PBKDF2' | 'scrypt'\n    iterations: number\n    saltSize: number\n  }\n}\n</code></pre>"},{"location":"reference/configuration/#default-security-configuration","title":"Default Security Configuration","text":"<pre><code>const DEFAULT_SECURITY_CONFIG: SecurityConfig = {\n  keyGeneration: {\n    source: 'secure-random',\n    entropy: {\n      minBits: 256,\n      sources: ['crypto']\n    },\n    derivation: {\n      hardened: true,\n      maxDepth: 5\n    }\n  },\n  encryption: {\n    algorithm: 'AES-GCM',\n    keySize: 256,\n    ivSize: 12,\n    tagSize: 16,\n    keyDerivation: {\n      algorithm: 'PBKDF2',\n      iterations: 100000,\n      saltSize: 32\n    }\n  },\n  validation: {\n    strictMode: true,\n    checkSignatures: true,\n    validateScripts: true,\n    enforceMinimumFees: true\n  },\n  randomness: {\n    source: 'crypto.getRandomValues',\n    testRandomness: false,\n    fallbackToMath: false\n  }\n}\n</code></pre>"},{"location":"reference/configuration/#wallet-configuration","title":"Wallet Configuration","text":""},{"location":"reference/configuration/#walletconfig-interface","title":"WalletConfig Interface","text":"<pre><code>interface WalletConfig {\n  substrate: WalletSubstrate\n  connection: ConnectionConfig\n  authentication: AuthConfig\n  permissions: PermissionConfig\n}\n</code></pre>"},{"location":"reference/configuration/#wallet-substrate-types","title":"Wallet Substrate Types","text":"<pre><code>type WalletSubstrate = \n  | 'auto'\n  | 'Cicada'\n  | 'XDM'\n  | 'window.CWI'\n  | 'json-api'\n  | 'react-native'\n  | WalletInterface\n</code></pre>"},{"location":"reference/configuration/#connection-configuration","title":"Connection Configuration","text":"<pre><code>interface ConnectionConfig {\n  timeout: number\n  retryAttempts: number\n  retryDelay: number\n  keepAlive: boolean\n  autoReconnect: boolean\n}\n</code></pre>"},{"location":"reference/configuration/#authentication-configuration","title":"Authentication Configuration","text":"<pre><code>interface AuthConfig {\n  required: boolean\n  timeout: number\n  cacheCredentials: boolean\n  refreshInterval: number\n  originator: string\n}\n</code></pre>"},{"location":"reference/configuration/#default-wallet-configuration","title":"Default Wallet Configuration","text":"<pre><code>const DEFAULT_WALLET_CONFIG: WalletConfig = {\n  substrate: 'auto',\n  connection: {\n    timeout: 10000,\n    retryAttempts: 3,\n    retryDelay: 1000,\n    keepAlive: true,\n    autoReconnect: true\n  },\n  authentication: {\n    required: true,\n    timeout: 30000,\n    cacheCredentials: false,\n    refreshInterval: 3600000, // 1 hour\n    originator: 'localhost'\n  },\n  permissions: {\n    createActions: true,\n    signTransactions: true,\n    accessKeys: false,\n    manageOutputs: true\n  }\n}\n</code></pre>"},{"location":"reference/configuration/#chain-tracker-configuration","title":"Chain Tracker Configuration","text":""},{"location":"reference/configuration/#chaintrackerconfig-interface","title":"ChainTrackerConfig Interface","text":"<pre><code>interface ChainTrackerConfig {\n  primary: ChainTrackerEndpoint\n  fallbacks: ChainTrackerEndpoint[]\n  failover: FailoverConfig\n  caching: CacheConfig\n}\n</code></pre>"},{"location":"reference/configuration/#chain-tracker-endpoint","title":"Chain Tracker Endpoint","text":"<pre><code>interface ChainTrackerEndpoint {\n  url: string\n  apiKey?: string\n  timeout: number\n  rateLimiting: RateLimitConfig\n  capabilities: TrackerCapability[]\n}\n\ntype TrackerCapability = \n  | 'getHeight'\n  | 'getHeader'\n  | 'getTransaction'\n  | 'getMerkleProof'\n  | 'broadcast'\n</code></pre>"},{"location":"reference/configuration/#failover-configuration","title":"Failover Configuration","text":"<pre><code>interface FailoverConfig {\n  enabled: boolean\n  maxFailures: number\n  failureWindow: number\n  recoveryTime: number\n  healthCheck: {\n    enabled: boolean\n    interval: number\n    timeout: number\n  }\n}\n</code></pre>"},{"location":"reference/configuration/#default-chain-tracker-configuration","title":"Default Chain Tracker Configuration","text":"<pre><code>const DEFAULT_CHAINTRACKER_CONFIG: ChainTrackerConfig = {\n  primary: {\n    url: 'https://api.whatsonchain.com/v1/bsv/main',\n    timeout: 10000,\n    rateLimiting: {\n      requestsPerSecond: 5,\n      burstLimit: 20\n    },\n    capabilities: ['getHeight', 'getHeader', 'getTransaction', 'getMerkleProof']\n  },\n  fallbacks: [\n    {\n      url: 'https://api.bitindex.network',\n      timeout: 15000,\n      rateLimiting: {\n        requestsPerSecond: 3,\n        burstLimit: 10\n      },\n      capabilities: ['getHeight', 'getTransaction']\n    }\n  ],\n  failover: {\n    enabled: true,\n    maxFailures: 3,\n    failureWindow: 300000, // 5 minutes\n    recoveryTime: 600000,  // 10 minutes\n    healthCheck: {\n      enabled: true,\n      interval: 60000,     // 1 minute\n      timeout: 5000\n    }\n  },\n  caching: {\n    enabled: true,\n    ttl: 30000,           // 30 seconds\n    maxSize: 1000,\n    strategy: 'lru'\n  }\n}\n</code></pre>"},{"location":"reference/configuration/#logging-configuration","title":"Logging Configuration","text":""},{"location":"reference/configuration/#loggingconfig-interface","title":"LoggingConfig Interface","text":"<pre><code>interface LoggingConfig {\n  level: LogLevel\n  outputs: LogOutput[]\n  format: LogFormat\n  filters: LogFilter[]\n  performance: PerformanceLoggingConfig\n}\n</code></pre>"},{"location":"reference/configuration/#log-levels-and-outputs","title":"Log Levels and Outputs","text":"<pre><code>type LogLevel = 'error' | 'warn' | 'info' | 'debug' | 'trace'\n\ninterface LogOutput {\n  type: 'console' | 'file' | 'remote'\n  config: {\n    file?: string\n    url?: string\n    maxSize?: number\n    rotation?: boolean\n  }\n}\n\ninterface LogFormat {\n  timestamp: boolean\n  level: boolean\n  component: boolean\n  structured: boolean\n  colors: boolean\n}\n</code></pre>"},{"location":"reference/configuration/#default-logging-configuration","title":"Default Logging Configuration","text":"<pre><code>const DEFAULT_LOGGING_CONFIG: LoggingConfig = {\n  level: 'info',\n  outputs: [\n    {\n      type: 'console',\n      config: {}\n    }\n  ],\n  format: {\n    timestamp: true,\n    level: true,\n    component: true,\n    structured: false,\n    colors: true\n  },\n  filters: [],\n  performance: {\n    enabled: false,\n    threshold: 1000,\n    includeStackTrace: false\n  }\n}\n</code></pre>"},{"location":"reference/configuration/#configuration-loading-and-management","title":"Configuration Loading and Management","text":""},{"location":"reference/configuration/#configuration-builder","title":"Configuration Builder","text":"<pre><code>class SDKConfigBuilder {\n  private config: Partial&lt;SDKConfig&gt; = {}\n\n  network(type: NetworkType): this {\n    this.config.network = type\n    return this\n  }\n\n  arc(config: Partial&lt;ARCConfig&gt;): this {\n    this.config.arc = { ...DEFAULT_ARC_CONFIG, ...config }\n    return this\n  }\n\n  fees(config: Partial&lt;FeeConfig&gt;): this {\n    this.config.fees = { ...DEFAULT_FEE_CONFIG, ...config }\n    return this\n  }\n\n  security(config: Partial&lt;SecurityConfig&gt;): this {\n    this.config.security = { ...DEFAULT_SECURITY_CONFIG, ...config }\n    return this\n  }\n\n  wallet(config: Partial&lt;WalletConfig&gt;): this {\n    this.config.wallet = { ...DEFAULT_WALLET_CONFIG, ...config }\n    return this\n  }\n\n  chainTracker(config: Partial&lt;ChainTrackerConfig&gt;): this {\n    this.config.chainTracker = { ...DEFAULT_CHAINTRACKER_CONFIG, ...config }\n    return this\n  }\n\n  logging(config: Partial&lt;LoggingConfig&gt;): this {\n    this.config.logging = { ...DEFAULT_LOGGING_CONFIG, ...config }\n    return this\n  }\n\n  build(): SDKConfig {\n    return {\n      network: this.config.network || 'testnet',\n      arc: this.config.arc || DEFAULT_ARC_CONFIG,\n      fees: this.config.fees || DEFAULT_FEE_CONFIG,\n      security: this.config.security || DEFAULT_SECURITY_CONFIG,\n      wallet: this.config.wallet || DEFAULT_WALLET_CONFIG,\n      chainTracker: this.config.chainTracker || DEFAULT_CHAINTRACKER_CONFIG,\n      logging: this.config.logging || DEFAULT_LOGGING_CONFIG\n    }\n  }\n}\n</code></pre>"},{"location":"reference/configuration/#configuration-usage-examples","title":"Configuration Usage Examples","text":""},{"location":"reference/configuration/#basic-configuration","title":"Basic Configuration","text":"<pre><code>import { SDKConfigBuilder } from '@bsv/sdk'\n\nconst config = new SDKConfigBuilder()\n  .network('testnet')\n  .fees({ strategy: 'priority' })\n  .build()\n</code></pre>"},{"location":"reference/configuration/#production-configuration","title":"Production Configuration","text":"<pre><code>const productionConfig = new SDKConfigBuilder()\n  .network('mainnet')\n  .arc({\n    apiUrl: 'https://arc.taal.com',\n    apiKey: process.env.TAAL_API_KEY,\n    timeout: 30000\n  })\n  .fees({\n    strategy: 'dynamic',\n    rates: {\n      standard: 0.5,\n      priority: 1.0,\n      economy: 0.25\n    }\n  })\n  .security({\n    validation: {\n      strictMode: true,\n      checkSignatures: true,\n      validateScripts: true\n    }\n  })\n  .chainTracker({\n    primary: {\n      url: 'https://api.whatsonchain.com/v1/bsv/main',\n      timeout: 10000\n    },\n    failover: {\n      enabled: true,\n      maxFailures: 3\n    }\n  })\n  .logging({\n    level: 'warn',\n    outputs: [\n      { type: 'console', config: {} },\n      { type: 'file', config: { file: '/var/log/bsv-sdk.log' } }\n    ]\n  })\n  .build()\n</code></pre>"},{"location":"reference/configuration/#development-configuration","title":"Development Configuration","text":"<pre><code>const devConfig = new SDKConfigBuilder()\n  .network('regtest')\n  .arc({\n    apiUrl: 'http://localhost:9090',\n    timeout: 5000\n  })\n  .fees({\n    strategy: 'fixed',\n    rates: { standard: 1.0 }\n  })\n  .chainTracker({\n    primary: {\n      url: 'http://localhost:3001/v1/bsv/regtest',\n      timeout: 5000\n    },\n    failover: { enabled: false }\n  })\n  .logging({\n    level: 'debug',\n    format: {\n      timestamp: true,\n      colors: true,\n      structured: true\n    }\n  })\n  .build()\n</code></pre>"},{"location":"reference/configuration/#environment-based-configuration","title":"Environment-Based Configuration","text":""},{"location":"reference/configuration/#configuration-from-environment-variables","title":"Configuration from Environment Variables","text":"<pre><code>function loadConfigFromEnv(): SDKConfig {\n  return new SDKConfigBuilder()\n    .network((process.env.BSV_NETWORK as NetworkType) || 'testnet')\n    .arc({\n      apiUrl: process.env.ARC_API_URL || 'https://arc-testnet.taal.com',\n      apiKey: process.env.ARC_API_KEY,\n      timeout: parseInt(process.env.ARC_TIMEOUT || '30000')\n    })\n    .fees({\n      strategy: (process.env.FEE_STRATEGY as FeeStrategy) || 'standard',\n      rates: {\n        standard: parseFloat(process.env.FEE_RATE_STANDARD || '0.5'),\n        priority: parseFloat(process.env.FEE_RATE_PRIORITY || '1.0'),\n        economy: parseFloat(process.env.FEE_RATE_ECONOMY || '0.25')\n      }\n    })\n    .wallet({\n      substrate: (process.env.WALLET_SUBSTRATE as WalletSubstrate) || 'auto',\n      authentication: {\n        originator: process.env.WALLET_ORIGINATOR || 'localhost'\n      }\n    })\n    .logging({\n      level: (process.env.LOG_LEVEL as LogLevel) || 'info'\n    })\n    .build()\n}\n</code></pre>"},{"location":"reference/configuration/#configuration-validation","title":"Configuration Validation","text":"<pre><code>function validateConfig(config: SDKConfig): string[] {\n  const errors: string[] = []\n\n  // Validate network\n  if (!['mainnet', 'testnet', 'regtest'].includes(config.network)) {\n    errors.push('Invalid network type')\n  }\n\n  // Validate ARC configuration\n  if (!config.arc.apiUrl) {\n    errors.push('ARC API URL is required')\n  }\n\n  if (config.arc.timeout &lt; 1000) {\n    errors.push('ARC timeout must be at least 1000ms')\n  }\n\n  // Validate fee configuration\n  if (config.fees.rates.standard &lt;= 0) {\n    errors.push('Standard fee rate must be positive')\n  }\n\n  if (config.fees.limits.minFeeRate &gt; config.fees.limits.maxFeeRate) {\n    errors.push('Minimum fee rate cannot exceed maximum fee rate')\n  }\n\n  // Validate security configuration\n  if (config.security.encryption.keySize !== 128 &amp;&amp; config.security.encryption.keySize !== 256) {\n    errors.push('Encryption key size must be 128 or 256 bits')\n  }\n\n  return errors\n}\n</code></pre>"},{"location":"reference/configuration/#configuration-best-practices","title":"Configuration Best Practices","text":""},{"location":"reference/configuration/#security-considerations","title":"Security Considerations","text":"<ol> <li>Never hardcode API keys - Use environment variables or secure configuration management</li> <li>Use HTTPS endpoints - Ensure all external API calls use secure connections</li> <li>Validate configuration - Always validate configuration before using</li> <li>Rotate credentials - Regularly rotate API keys and authentication tokens</li> <li>Limit permissions - Use principle of least privilege for wallet permissions</li> </ol>"},{"location":"reference/configuration/#performance-optimization","title":"Performance Optimization","text":"<ol> <li>Configure appropriate timeouts - Balance responsiveness with reliability</li> <li>Use connection pooling - Reuse connections where possible</li> <li>Enable caching - Cache frequently accessed data with appropriate TTLs</li> <li>Configure failover - Use multiple endpoints for high availability</li> <li>Monitor performance - Enable performance logging in production</li> </ol>"},{"location":"reference/configuration/#environment-specific-settings","title":"Environment-Specific Settings","text":""},{"location":"reference/configuration/#development","title":"Development","text":"<ul> <li>Use testnet or regtest networks</li> <li>Enable debug logging</li> <li>Shorter timeouts for faster feedback</li> <li>Disable strict validation for testing</li> </ul>"},{"location":"reference/configuration/#staging","title":"Staging","text":"<ul> <li>Mirror production configuration</li> <li>Enable comprehensive logging</li> <li>Use production-like endpoints</li> <li>Enable all validation checks</li> </ul>"},{"location":"reference/configuration/#production","title":"Production","text":"<ul> <li>Use mainnet network</li> <li>Minimal logging (warn/error only)</li> <li>Longer timeouts for reliability</li> <li>Enable all security features</li> <li>Use redundant endpoints</li> </ul> <p>This comprehensive configuration reference provides developers with all the tools needed to properly configure the BSV TypeScript SDK for any environment or use case.</p>"},{"location":"reference/debugging/","title":"Debugging Reference","text":"<p>Complete guide for debugging, logging, and troubleshooting applications built with the BSV TypeScript SDK.</p>"},{"location":"reference/debugging/#debug-mode-activation","title":"Debug Mode Activation","text":""},{"location":"reference/debugging/#environment-variables","title":"Environment Variables","text":"<pre><code># Enable debug mode\nexport BSV_DEBUG=true\n\n# Set debug level\nexport BSV_DEBUG_LEVEL=debug\n\n# Enable specific debug categories\nexport BSV_DEBUG_CATEGORIES=wallet,transaction,network\n\n# Enable performance debugging\nexport BSV_DEBUG_PERFORMANCE=true\n</code></pre>"},{"location":"reference/debugging/#programmatic-debug-configuration","title":"Programmatic Debug Configuration","text":"<pre><code>import { SDKConfigBuilder } from '@bsv/sdk'\n\nconst debugConfig = new SDKConfigBuilder()\n  .logging({\n    level: 'debug',\n    outputs: [\n      { type: 'console', config: {} },\n      { type: 'file', config: { file: './debug.log' } }\n    ],\n    format: {\n      timestamp: true,\n      level: true,\n      component: true,\n      structured: true,\n      colors: true\n    },\n    performance: {\n      enabled: true,\n      threshold: 100, // Log operations taking &gt;100ms\n      includeStackTrace: true\n    }\n  })\n  .build()\n</code></pre>"},{"location":"reference/debugging/#sdk-logging-system","title":"SDK Logging System","text":""},{"location":"reference/debugging/#log-levels","title":"Log Levels","text":"<pre><code>enum LogLevel {\n  ERROR = 0,   // Critical errors only\n  WARN = 1,    // Warnings and errors\n  INFO = 2,    // General information\n  DEBUG = 3,   // Detailed debugging info\n  TRACE = 4    // Extremely verbose tracing\n}\n</code></pre>"},{"location":"reference/debugging/#logger-interface","title":"Logger Interface","text":"<pre><code>interface Logger {\n  error(message: string, context?: any): void\n  warn(message: string, context?: any): void\n  info(message: string, context?: any): void\n  debug(message: string, context?: any): void\n  trace(message: string, context?: any): void\n\n  // Performance logging\n  time(label: string): void\n  timeEnd(label: string): void\n\n  // Structured logging\n  log(level: LogLevel, message: string, context: any): void\n}\n</code></pre>"},{"location":"reference/debugging/#creating-custom-loggers","title":"Creating Custom Loggers","text":"<pre><code>class CustomLogger implements Logger {\n  private level: LogLevel = LogLevel.INFO\n\n  constructor(level: LogLevel = LogLevel.INFO) {\n    this.level = level\n  }\n\n  error(message: string, context?: any): void {\n    if (this.level &gt;= LogLevel.ERROR) {\n      console.error(`[ERROR] ${new Date().toISOString()} ${message}`, context)\n    }\n  }\n\n  warn(message: string, context?: any): void {\n    if (this.level &gt;= LogLevel.WARN) {\n      console.warn(`[WARN] ${new Date().toISOString()} ${message}`, context)\n    }\n  }\n\n  info(message: string, context?: any): void {\n    if (this.level &gt;= LogLevel.INFO) {\n      console.info(`[INFO] ${new Date().toISOString()} ${message}`, context)\n    }\n  }\n\n  debug(message: string, context?: any): void {\n    if (this.level &gt;= LogLevel.DEBUG) {\n      console.debug(`[DEBUG] ${new Date().toISOString()} ${message}`, context)\n    }\n  }\n\n  trace(message: string, context?: any): void {\n    if (this.level &gt;= LogLevel.TRACE) {\n      console.trace(`[TRACE] ${new Date().toISOString()} ${message}`, context)\n    }\n  }\n\n  time(label: string): void {\n    console.time(label)\n  }\n\n  timeEnd(label: string): void {\n    console.timeEnd(label)\n  }\n\n  log(level: LogLevel, message: string, context: any): void {\n    const methods = [this.error, this.warn, this.info, this.debug, this.trace]\n    methods[level]?.call(this, message, context)\n  }\n}\n</code></pre>"},{"location":"reference/debugging/#debug-categories","title":"Debug Categories","text":""},{"location":"reference/debugging/#wallet-debugging","title":"Wallet Debugging","text":"<pre><code>// Enable wallet debugging\nconst walletDebugger = {\n  logConnection: (substrate: string, status: string) =&gt; {\n    console.debug(`[WALLET] Connection ${status} to ${substrate}`)\n  },\n\n  logAction: (action: string, args: any) =&gt; {\n    console.debug(`[WALLET] Action: ${action}`, {\n      args: JSON.stringify(args, null, 2),\n      timestamp: new Date().toISOString()\n    })\n  },\n\n  logError: (error: any, context: any) =&gt; {\n    console.error(`[WALLET] Error:`, {\n      error: error.message,\n      code: error.code,\n      context,\n      stack: error.stack\n    })\n  }\n}\n\n// Usage in wallet operations\ntry {\n  walletDebugger.logAction('createAction', { description: 'Test transaction' })\n  const result = await wallet.createAction({\n    description: 'Test transaction',\n    outputs: [{ satoshis: 100, lockingScript: '...' }]\n  })\n  walletDebugger.logConnection('substrate', 'success')\n} catch (error) {\n  walletDebugger.logError(error, { operation: 'createAction' })\n}\n</code></pre>"},{"location":"reference/debugging/#transaction-debugging","title":"Transaction Debugging","text":"<pre><code>class TransactionDebugger {\n  static logConstruction(tx: Transaction): void {\n    console.debug(`[TRANSACTION] Construction:`, {\n      inputs: tx.inputs.length,\n      outputs: tx.outputs.length,\n      totalInput: tx.inputs.reduce((sum, input) =&gt; sum + input.satoshis, 0),\n      totalOutput: tx.outputs.reduce((sum, output) =&gt; sum + output.satoshis, 0),\n      fee: tx.getFee(),\n      size: tx.toHex().length / 2,\n      txid: Buffer.from(tx.id()).toString('hex')\n    })\n  }\n\n  static logSigning(tx: Transaction, inputIndex: number): void {\n    console.debug(`[TRANSACTION] Signing input ${inputIndex}:`, {\n      txid: Buffer.from(tx.id()).toString('hex'),\n      input: {\n        sourceTXID: tx.inputs[inputIndex].sourceTXID,\n        sourceOutputIndex: tx.inputs[inputIndex].sourceOutputIndex,\n        unlockingScript: tx.inputs[inputIndex].unlockingScript?.toASM()\n      }\n    })\n  }\n\n  static logValidation(tx: Transaction, isValid: boolean, errors?: string[]): void {\n    console.debug(`[TRANSACTION] Validation:`, {\n      txid: Buffer.from(tx.id()).toString('hex'),\n      valid: isValid,\n      errors: errors || [],\n      timestamp: new Date().toISOString()\n    })\n  }\n}\n</code></pre>"},{"location":"reference/debugging/#network-debugging","title":"Network Debugging","text":"<pre><code>class NetworkDebugger {\n  static logRequest(endpoint: string, method: string, data?: any): void {\n    console.debug(`[NETWORK] Request:`, {\n      endpoint,\n      method,\n      data: data ? JSON.stringify(data) : undefined,\n      timestamp: new Date().toISOString()\n    })\n  }\n\n  static logResponse(endpoint: string, status: number, data?: any): void {\n    console.debug(`[NETWORK] Response:`, {\n      endpoint,\n      status,\n      dataSize: data ? JSON.stringify(data).length : 0,\n      timestamp: new Date().toISOString()\n    })\n  }\n\n  static logError(endpoint: string, error: any): void {\n    console.error(`[NETWORK] Error:`, {\n      endpoint,\n      error: error.message,\n      code: error.code,\n      stack: error.stack,\n      timestamp: new Date().toISOString()\n    })\n  }\n}\n</code></pre>"},{"location":"reference/debugging/#transaction-inspection-tools","title":"Transaction Inspection Tools","text":""},{"location":"reference/debugging/#transaction-analyzer","title":"Transaction Analyzer","text":"<pre><code>class TransactionAnalyzer {\n  static analyze(tx: Transaction): TransactionAnalysis {\n    const analysis: TransactionAnalysis = {\n      basic: this.analyzeBasic(tx),\n      inputs: this.analyzeInputs(tx),\n      outputs: this.analyzeOutputs(tx),\n      scripts: this.analyzeScripts(tx),\n      fees: this.analyzeFees(tx),\n      size: this.analyzeSize(tx)\n    }\n\n    return analysis\n  }\n\n  private static analyzeBasic(tx: Transaction): BasicAnalysis {\n    return {\n      txid: Buffer.from(tx.id()).toString('hex'),\n      version: tx.version,\n      lockTime: tx.lockTime,\n      inputCount: tx.inputs.length,\n      outputCount: tx.outputs.length\n    }\n  }\n\n  private static analyzeInputs(tx: Transaction): InputAnalysis[] {\n    return tx.inputs.map((input, index) =&gt; ({\n      index,\n      sourceTXID: input.sourceTXID,\n      sourceOutputIndex: input.sourceOutputIndex,\n      satoshis: input.satoshis,\n      unlockingScript: {\n        asm: input.unlockingScript?.toASM(),\n        hex: input.unlockingScript?.toHex(),\n        size: input.unlockingScript?.toHex().length / 2\n      },\n      sequence: input.sequence\n    }))\n  }\n\n  private static analyzeOutputs(tx: Transaction): OutputAnalysis[] {\n    return tx.outputs.map((output, index) =&gt; ({\n      index,\n      satoshis: output.satoshis,\n      lockingScript: {\n        asm: output.lockingScript.toASM(),\n        hex: output.lockingScript.toHex(),\n        size: output.lockingScript.toHex().length / 2,\n        type: this.detectScriptType(output.lockingScript)\n      }\n    }))\n  }\n\n  private static detectScriptType(script: Script): string {\n    const asm = script.toASM()\n\n    if (asm.includes('OP_DUP OP_HASH160') &amp;&amp; asm.includes('OP_EQUALVERIFY OP_CHECKSIG')) {\n      return 'P2PKH'\n    } else if (asm.includes('OP_HASH160') &amp;&amp; asm.includes('OP_EQUAL')) {\n      return 'P2SH'\n    } else if (asm.startsWith('OP_RETURN')) {\n      return 'OP_RETURN'\n    } else {\n      return 'CUSTOM'\n    }\n  }\n}\n\ninterface TransactionAnalysis {\n  basic: BasicAnalysis\n  inputs: InputAnalysis[]\n  outputs: OutputAnalysis[]\n  scripts: ScriptAnalysis\n  fees: FeeAnalysis\n  size: SizeAnalysis\n}\n</code></pre>"},{"location":"reference/debugging/#script-debugger","title":"Script Debugger","text":"<pre><code>class ScriptDebugger {\n  static debugScript(script: Script): ScriptDebugInfo {\n    const chunks = script.chunks\n    const debugInfo: ScriptDebugInfo = {\n      chunks: [],\n      opcodes: [],\n      data: [],\n      analysis: {\n        isValid: true,\n        errors: [],\n        warnings: []\n      }\n    }\n\n    chunks.forEach((chunk, index) =&gt; {\n      if (chunk.opcode !== undefined) {\n        debugInfo.opcodes.push({\n          index,\n          opcode: chunk.opcode,\n          name: this.getOpcodeName(chunk.opcode),\n          description: this.getOpcodeDescription(chunk.opcode)\n        })\n      }\n\n      if (chunk.data) {\n        debugInfo.data.push({\n          index,\n          data: chunk.data,\n          hex: Buffer.from(chunk.data).toString('hex'),\n          size: chunk.data.length\n        })\n      }\n    })\n\n    return debugInfo\n  }\n\n  private static getOpcodeName(opcode: number): string {\n    const opcodeMap: Record&lt;number, string&gt; = {\n      0: 'OP_0',\n      76: 'OP_PUSHDATA1',\n      77: 'OP_PUSHDATA2',\n      78: 'OP_PUSHDATA4',\n      79: 'OP_1NEGATE',\n      81: 'OP_1',\n      82: 'OP_2',\n      // ... add more opcodes as needed\n      118: 'OP_DUP',\n      169: 'OP_HASH160',\n      136: 'OP_EQUALVERIFY',\n      172: 'OP_CHECKSIG'\n    }\n\n    return opcodeMap[opcode] || `OP_UNKNOWN_${opcode}`\n  }\n}\n</code></pre>"},{"location":"reference/debugging/#performance-debugging","title":"Performance Debugging","text":""},{"location":"reference/debugging/#performance-monitor","title":"Performance Monitor","text":"<pre><code>class PerformanceMonitor {\n  private static timers = new Map&lt;string, number&gt;()\n  private static metrics = new Map&lt;string, PerformanceMetric&gt;()\n\n  static startTimer(label: string): void {\n    this.timers.set(label, performance.now())\n  }\n\n  static endTimer(label: string): number {\n    const startTime = this.timers.get(label)\n    if (!startTime) {\n      console.warn(`Timer '${label}' was not started`)\n      return 0\n    }\n\n    const duration = performance.now() - startTime\n    this.timers.delete(label)\n\n    // Update metrics\n    const metric = this.metrics.get(label) || {\n      count: 0,\n      totalTime: 0,\n      avgTime: 0,\n      minTime: Infinity,\n      maxTime: 0\n    }\n\n    metric.count++\n    metric.totalTime += duration\n    metric.avgTime = metric.totalTime / metric.count\n    metric.minTime = Math.min(metric.minTime, duration)\n    metric.maxTime = Math.max(metric.maxTime, duration)\n\n    this.metrics.set(label, metric)\n\n    console.debug(`[PERFORMANCE] ${label}: ${duration.toFixed(2)}ms`)\n    return duration\n  }\n\n  static getMetrics(): Map&lt;string, PerformanceMetric&gt; {\n    return new Map(this.metrics)\n  }\n\n  static resetMetrics(): void {\n    this.metrics.clear()\n    this.timers.clear()\n  }\n}\n\ninterface PerformanceMetric {\n  count: number\n  totalTime: number\n  avgTime: number\n  minTime: number\n  maxTime: number\n}\n</code></pre>"},{"location":"reference/debugging/#memory-usage-monitoring","title":"Memory Usage Monitoring","text":"<pre><code>class MemoryMonitor {\n  static logMemoryUsage(label: string): void {\n    if (typeof process !== 'undefined' &amp;&amp; process.memoryUsage) {\n      const usage = process.memoryUsage()\n      console.debug(`[MEMORY] ${label}:`, {\n        rss: `${Math.round(usage.rss / 1024 / 1024)}MB`,\n        heapTotal: `${Math.round(usage.heapTotal / 1024 / 1024)}MB`,\n        heapUsed: `${Math.round(usage.heapUsed / 1024 / 1024)}MB`,\n        external: `${Math.round(usage.external / 1024 / 1024)}MB`\n      })\n    } else if (typeof performance !== 'undefined' &amp;&amp; (performance as any).memory) {\n      const memory = (performance as any).memory\n      console.debug(`[MEMORY] ${label}:`, {\n        used: `${Math.round(memory.usedJSHeapSize / 1024 / 1024)}MB`,\n        total: `${Math.round(memory.totalJSHeapSize / 1024 / 1024)}MB`,\n        limit: `${Math.round(memory.jsHeapSizeLimit / 1024 / 1024)}MB`\n      })\n    }\n  }\n}\n</code></pre>"},{"location":"reference/debugging/#debug-utilities","title":"Debug Utilities","text":""},{"location":"reference/debugging/#hex-dump-utility","title":"Hex Dump Utility","text":"<pre><code>class HexDump {\n  static dump(data: Uint8Array | number[], bytesPerLine: number = 16): string {\n    const bytes = Array.from(data)\n    let result = ''\n\n    for (let i = 0; i &lt; bytes.length; i += bytesPerLine) {\n      const line = bytes.slice(i, i + bytesPerLine)\n      const offset = i.toString(16).padStart(8, '0')\n      const hex = line.map(b =&gt; b.toString(16).padStart(2, '0')).join(' ')\n      const ascii = line.map(b =&gt; (b &gt;= 32 &amp;&amp; b &lt;= 126) ? String.fromCharCode(b) : '.').join('')\n\n      result += `${offset}: ${hex.padEnd(bytesPerLine * 3 - 1)} |${ascii}|\\n`\n    }\n\n    return result\n  }\n\n  static logDump(data: Uint8Array | number[], label: string): void {\n    console.debug(`[HEX DUMP] ${label}:\\n${this.dump(data)}`)\n  }\n}\n</code></pre>"},{"location":"reference/debugging/#network-request-inspector","title":"Network Request Inspector","text":"<pre><code>class NetworkInspector {\n  private static requests = new Map&lt;string, NetworkRequest&gt;()\n\n  static startRequest(id: string, url: string, method: string, data?: any): void {\n    this.requests.set(id, {\n      id,\n      url,\n      method,\n      data,\n      startTime: Date.now(),\n      status: 'pending'\n    })\n\n    console.debug(`[NETWORK] Starting request ${id}:`, {\n      url,\n      method,\n      dataSize: data ? JSON.stringify(data).length : 0\n    })\n  }\n\n  static endRequest(id: string, status: number, response?: any): void {\n    const request = this.requests.get(id)\n    if (!request) return\n\n    const duration = Date.now() - request.startTime\n    request.status = 'completed'\n    request.duration = duration\n    request.response = response\n\n    console.debug(`[NETWORK] Completed request ${id}:`, {\n      status,\n      duration: `${duration}ms`,\n      responseSize: response ? JSON.stringify(response).length : 0\n    })\n\n    // Clean up old requests\n    setTimeout(() =&gt; this.requests.delete(id), 60000)\n  }\n\n  static failRequest(id: string, error: any): void {\n    const request = this.requests.get(id)\n    if (!request) return\n\n    const duration = Date.now() - request.startTime\n    request.status = 'failed'\n    request.duration = duration\n    request.error = error\n\n    console.error(`[NETWORK] Failed request ${id}:`, {\n      error: error.message,\n      duration: `${duration}ms`\n    })\n  }\n\n  static getActiveRequests(): NetworkRequest[] {\n    return Array.from(this.requests.values()).filter(r =&gt; r.status === 'pending')\n  }\n}\n\ninterface NetworkRequest {\n  id: string\n  url: string\n  method: string\n  data?: any\n  startTime: number\n  duration?: number\n  status: 'pending' | 'completed' | 'failed'\n  response?: any\n  error?: any\n}\n</code></pre>"},{"location":"reference/debugging/#debug-configuration-examples","title":"Debug Configuration Examples","text":""},{"location":"reference/debugging/#development-debug-setup","title":"Development Debug Setup","text":"<pre><code>// Enable comprehensive debugging for development\nconst devDebugConfig = {\n  logging: {\n    level: 'debug' as LogLevel,\n    outputs: [\n      { type: 'console', config: { colors: true } },\n      { type: 'file', config: { file: './dev-debug.log' } }\n    ],\n    format: {\n      timestamp: true,\n      level: true,\n      component: true,\n      structured: true,\n      colors: true\n    },\n    performance: {\n      enabled: true,\n      threshold: 50,\n      includeStackTrace: true\n    }\n  }\n}\n</code></pre>"},{"location":"reference/debugging/#production-debug-setup","title":"Production Debug Setup","text":"<pre><code>// Minimal debugging for production\nconst prodDebugConfig = {\n  logging: {\n    level: 'warn' as LogLevel,\n    outputs: [\n      { type: 'file', config: { file: '/var/log/bsv-app.log', rotation: true } }\n    ],\n    format: {\n      timestamp: true,\n      level: true,\n      component: false,\n      structured: true,\n      colors: false\n    },\n    performance: {\n      enabled: true,\n      threshold: 1000,\n      includeStackTrace: false\n    }\n  }\n}\n</code></pre>"},{"location":"reference/debugging/#testing-debug-setup","title":"Testing Debug Setup","text":"<pre><code>// Debug configuration for testing\nconst testDebugConfig = {\n  logging: {\n    level: 'trace' as LogLevel,\n    outputs: [\n      { type: 'console', config: {} }\n    ],\n    format: {\n      timestamp: false,\n      level: true,\n      component: true,\n      structured: false,\n      colors: false\n    },\n    performance: {\n      enabled: false\n    }\n  }\n}\n</code></pre>"},{"location":"reference/debugging/#troubleshooting-common-issues","title":"Troubleshooting Common Issues","text":""},{"location":"reference/debugging/#debug-checklist","title":"Debug Checklist","text":"<ol> <li>Enable appropriate logging level</li> </ol> <pre><code>// Set debug level based on issue severity\nconst config = { logging: { level: 'debug' } }\n</code></pre> <ol> <li>Check network connectivity</li> </ol> <pre><code>NetworkInspector.startRequest('health-check', 'https://api.whatsonchain.com/v1/bsv/main/chain/info', 'GET')\n</code></pre> <ol> <li>Validate transaction structure</li> </ol> <pre><code>const analysis = TransactionAnalyzer.analyze(transaction)\nconsole.log('Transaction Analysis:', analysis)\n</code></pre> <ol> <li>Monitor performance</li> </ol> <pre><code>PerformanceMonitor.startTimer('wallet-operation')\n// ... perform operation\nPerformanceMonitor.endTimer('wallet-operation')\n</code></pre> <ol> <li>Check memory usage</li> </ol> <pre><code>MemoryMonitor.logMemoryUsage('before-operation')\n// ... perform operation\nMemoryMonitor.logMemoryUsage('after-operation')\n</code></pre> <p>This comprehensive debugging reference provides developers with all the tools and techniques needed to effectively debug and troubleshoot applications built with the BSV TypeScript SDK.</p>"},{"location":"reference/errors/","title":"Error Reference","text":"<p>Complete reference for error codes, messages, and troubleshooting in the BSV TypeScript SDK.</p>"},{"location":"reference/errors/#error-categories","title":"Error Categories","text":""},{"location":"reference/errors/#transaction-errors","title":"Transaction Errors","text":""},{"location":"reference/errors/#insufficient_funds","title":"INSUFFICIENT_FUNDS","text":"<p>Code: <code>INSUFFICIENT_FUNDS</code> Message: \"Insufficient funds to create transaction\" Cause: Wallet doesn't have enough UTXOs to cover transaction outputs and fees Solutions:</p> <ul> <li>Check wallet balance with <code>listOutputs()</code></li> <li>Reduce transaction amount</li> <li>Wait for pending transactions to confirm</li> <li>Use smaller fee rates</li> </ul>"},{"location":"reference/errors/#invalid_transaction","title":"INVALID_TRANSACTION","text":"<p>Code: <code>INVALID_TRANSACTION</code> Message: \"Transaction validation failed\" Cause: Transaction structure or signatures are invalid Solutions:</p> <ul> <li>Verify all inputs are properly signed</li> <li>Check script templates are correct</li> <li>Ensure transaction format is valid</li> <li>Validate all output amounts are positive</li> </ul>"},{"location":"reference/errors/#transaction_too_large","title":"TRANSACTION_TOO_LARGE","text":"<p>Code: <code>TRANSACTION_TOO_LARGE</code> Message: \"Transaction exceeds maximum size limit\" Cause: Transaction size exceeds network limits Solutions:</p> <ul> <li>Reduce number of inputs/outputs</li> <li>Use more efficient script templates</li> <li>Split into multiple transactions</li> <li>Optimize data storage methods</li> </ul>"},{"location":"reference/errors/#invalid_script","title":"INVALID_SCRIPT","text":"<p>Code: <code>INVALID_SCRIPT</code> Message: \"Script execution failed\" Cause: Locking or unlocking script contains errors Solutions:</p> <ul> <li>Validate script syntax with <code>Script.fromASM()</code></li> <li>Check opcode usage and limits</li> <li>Verify script template implementation</li> <li>Test script execution in isolation</li> </ul>"},{"location":"reference/errors/#wallet-errors","title":"Wallet Errors","text":""},{"location":"reference/errors/#wallet_not_connected","title":"WALLET_NOT_CONNECTED","text":"<p>Code: <code>WALLET_NOT_CONNECTED</code> Message: \"Wallet connection not established\" Cause: WalletClient not connected to substrate Solutions:</p> <ul> <li>Call <code>await wallet.connectToSubstrate()</code></li> <li>Check wallet application is running</li> <li>Verify network connectivity</li> <li>Restart wallet application if needed</li> </ul>"},{"location":"reference/errors/#authentication_failed","title":"AUTHENTICATION_FAILED","text":"<p>Code: <code>AUTHENTICATION_FAILED</code> Message: \"Wallet authentication failed\" Cause: User denied access or authentication expired Solutions:</p> <ul> <li>Re-authenticate with wallet</li> <li>Check originator domain permissions</li> <li>Verify wallet trust settings</li> <li>Clear cached authentication state</li> </ul>"},{"location":"reference/errors/#wallet_locked","title":"WALLET_LOCKED","text":"<p>Code: <code>WALLET_LOCKED</code> Message: \"Wallet is locked or requires password\" Cause: Wallet requires user authentication Solutions:</p> <ul> <li>Unlock wallet application</li> <li>Enter wallet password</li> <li>Check wallet auto-lock settings</li> <li>Verify user session is active</li> </ul>"},{"location":"reference/errors/#action_rejected","title":"ACTION_REJECTED","text":"<p>Code: <code>ACTION_REJECTED</code> Message: \"User rejected the transaction\" Cause: User declined transaction in wallet UI Solutions:</p> <ul> <li>Retry transaction with user consent</li> <li>Adjust transaction parameters</li> <li>Provide clearer transaction description</li> <li>Check transaction amounts and fees</li> </ul>"},{"location":"reference/errors/#network-errors","title":"Network Errors","text":""},{"location":"reference/errors/#network_error","title":"NETWORK_ERROR","text":"<p>Code: <code>NETWORK_ERROR</code> Message: \"Network request failed\" Cause: Connection issues with blockchain nodes Solutions:</p> <ul> <li>Check internet connectivity</li> <li>Verify node endpoints are accessible</li> <li>Try alternative chain trackers</li> <li>Implement retry logic with exponential backoff</li> </ul>"},{"location":"reference/errors/#node_unavailable","title":"NODE_UNAVAILABLE","text":"<p>Code: <code>NODE_UNAVAILABLE</code> Message: \"Blockchain node is unavailable\" Cause: Target node is down or unreachable Solutions:</p> <ul> <li>Switch to backup node endpoints</li> <li>Check node status and health</li> <li>Use multiple chain tracker instances</li> <li>Implement failover mechanisms</li> </ul>"},{"location":"reference/errors/#broadcast_failed","title":"BROADCAST_FAILED","text":"<p>Code: <code>BROADCAST_FAILED</code> Message: \"Transaction broadcast failed\" Cause: Network rejected transaction or broadcast error Solutions:</p> <ul> <li>Verify transaction is valid</li> <li>Check network fees are adequate</li> <li>Retry broadcast after delay</li> <li>Use alternative broadcast endpoints</li> </ul>"},{"location":"reference/errors/#timeout_error","title":"TIMEOUT_ERROR","text":"<p>Code: <code>TIMEOUT_ERROR</code> Message: \"Request timeout exceeded\" Cause: Network request took too long Solutions:</p> <ul> <li>Increase timeout values</li> <li>Check network latency</li> <li>Use faster endpoints</li> <li>Implement request cancellation</li> </ul>"},{"location":"reference/errors/#cryptographic-errors","title":"Cryptographic Errors","text":""},{"location":"reference/errors/#invalid_private_key","title":"INVALID_PRIVATE_KEY","text":"<p>Code: <code>INVALID_PRIVATE_KEY</code> Message: \"Private key is invalid or out of range\" Cause: Private key doesn't meet secp256k1 requirements Solutions:</p> <ul> <li>Generate new key with <code>PrivateKey.fromRandom()</code></li> <li>Validate key is within curve order</li> <li>Check key format and encoding</li> <li>Use proper key derivation methods</li> </ul>"},{"location":"reference/errors/#invalid_public_key","title":"INVALID_PUBLIC_KEY","text":"<p>Code: <code>INVALID_PUBLIC_KEY</code> Message: \"Public key is invalid or not on curve\" Cause: Public key point is invalid Solutions:</p> <ul> <li>Verify key derivation from private key</li> <li>Check point coordinates are valid</li> <li>Validate key format (compressed/uncompressed)</li> <li>Use <code>PublicKey.fromPrivateKey()</code> for generation</li> </ul>"},{"location":"reference/errors/#signature_verification_failed","title":"SIGNATURE_VERIFICATION_FAILED","text":"<p>Code: <code>SIGNATURE_VERIFICATION_FAILED</code> Message: \"Digital signature verification failed\" Cause: Signature doesn't match message and public key Solutions:</p> <ul> <li>Verify message hash is correct</li> <li>Check signature format (DER encoding)</li> <li>Ensure correct public key is used</li> <li>Validate signature components (r, s values)</li> </ul>"},{"location":"reference/errors/#encryption_failed","title":"ENCRYPTION_FAILED","text":"<p>Code: <code>ENCRYPTION_FAILED</code> Message: \"Symmetric encryption operation failed\" Cause: AES encryption/decryption error Solutions:</p> <ul> <li>Verify encryption key is valid</li> <li>Check data format and encoding</li> <li>Ensure proper IV/nonce usage</li> <li>Validate authentication tags</li> </ul>"},{"location":"reference/errors/#spv-verification-errors","title":"SPV Verification Errors","text":""},{"location":"reference/errors/#invalid_merkle_proof","title":"INVALID_MERKLE_PROOF","text":"<p>Code: <code>INVALID_MERKLE_PROOF</code> Message: \"Merkle proof verification failed\" Cause: Merkle path doesn't lead to valid root Solutions:</p> <ul> <li>Verify merkle path structure</li> <li>Check transaction hash calculation</li> <li>Validate block header merkle root</li> <li>Ensure proof completeness</li> </ul>"},{"location":"reference/errors/#block_header_invalid","title":"BLOCK_HEADER_INVALID","text":"<p>Code: <code>BLOCK_HEADER_INVALID</code> Message: \"Block header validation failed\" Cause: Block header doesn't meet consensus rules Solutions:</p> <ul> <li>Verify header hash and difficulty</li> <li>Check timestamp validity</li> <li>Validate previous block hash</li> <li>Ensure proper header format</li> </ul>"},{"location":"reference/errors/#chain_validation_failed","title":"CHAIN_VALIDATION_FAILED","text":"<p>Code: <code>CHAIN_VALIDATION_FAILED</code> Message: \"Blockchain validation failed\" Cause: Chain doesn't follow consensus rules Solutions:</p> <ul> <li>Verify chain continuity</li> <li>Check difficulty adjustments</li> <li>Validate block timestamps</li> <li>Ensure proper chain selection</li> </ul>"},{"location":"reference/errors/#configuration-errors","title":"Configuration Errors","text":""},{"location":"reference/errors/#invalid_config","title":"INVALID_CONFIG","text":"<p>Code: <code>INVALID_CONFIG</code> Message: \"SDK configuration is invalid\" Cause: Configuration parameters are incorrect Solutions:</p> <ul> <li>Validate configuration schema</li> <li>Check required parameters are present</li> <li>Verify network settings</li> <li>Use default configuration as baseline</li> </ul>"},{"location":"reference/errors/#unsupported_network","title":"UNSUPPORTED_NETWORK","text":"<p>Code: <code>UNSUPPORTED_NETWORK</code> Message: \"Network type is not supported\" Cause: Invalid network specification Solutions:</p> <ul> <li>Use supported networks: mainnet, testnet, regtest</li> <li>Check network configuration</li> <li>Verify chain parameters</li> <li>Update SDK to latest version</li> </ul>"},{"location":"reference/errors/#error-interface","title":"Error Interface","text":"<p>All SDK errors implement the <code>WalletErrorObject</code> interface:</p> <pre><code>interface WalletErrorObject {\n  code: string\n  description: string\n  stack?: string\n  context?: Record&lt;string, any&gt;\n}\n</code></pre>"},{"location":"reference/errors/#error-handling-patterns","title":"Error Handling Patterns","text":""},{"location":"reference/errors/#basic-error-handling","title":"Basic Error Handling","text":"<pre><code>try {\n  const result = await wallet.createAction({\n    description: 'Test transaction',\n    outputs: [{\n      satoshis: 100,\n      lockingScript: Script.fromASM('OP_DUP OP_HASH160 ... OP_EQUALVERIFY OP_CHECKSIG').toHex()\n    }]\n  })\n} catch (error) {\n  if (error.code === 'INSUFFICIENT_FUNDS') {\n    console.log('Not enough funds available')\n    // Handle insufficient funds\n  } else if (error.code === 'WALLET_NOT_CONNECTED') {\n    console.log('Wallet connection required')\n    await wallet.connectToSubstrate()\n  } else {\n    console.error('Unexpected error:', error)\n  }\n}\n</code></pre>"},{"location":"reference/errors/#retry-logic-with-exponential-backoff","title":"Retry Logic with Exponential Backoff","text":"<pre><code>async function retryOperation&lt;T&gt;(\n  operation: () =&gt; Promise&lt;T&gt;,\n  maxRetries: number = 3,\n  baseDelay: number = 1000\n): Promise&lt;T&gt; {\n  for (let attempt = 0; attempt &lt;= maxRetries; attempt++) {\n    try {\n      return await operation()\n    } catch (error) {\n      if (attempt === maxRetries) throw error\n\n      // Only retry on network errors\n      if (!['NETWORK_ERROR', 'TIMEOUT_ERROR', 'NODE_UNAVAILABLE'].includes(error.code)) {\n        throw error\n      }\n\n      const delay = baseDelay * Math.pow(2, attempt)\n      await new Promise(resolve =&gt; setTimeout(resolve, delay))\n    }\n  }\n  throw new Error('Max retries exceeded')\n}\n</code></pre>"},{"location":"reference/errors/#comprehensive-error-categorization","title":"Comprehensive Error Categorization","text":"<pre><code>function categorizeError(error: WalletErrorObject): 'user' | 'network' | 'system' | 'config' {\n  const userErrors = ['ACTION_REJECTED', 'AUTHENTICATION_FAILED', 'WALLET_LOCKED']\n  const networkErrors = ['NETWORK_ERROR', 'NODE_UNAVAILABLE', 'BROADCAST_FAILED', 'TIMEOUT_ERROR']\n  const systemErrors = ['INVALID_TRANSACTION', 'SIGNATURE_VERIFICATION_FAILED', 'ENCRYPTION_FAILED']\n  const configErrors = ['INVALID_CONFIG', 'UNSUPPORTED_NETWORK']\n\n  if (userErrors.includes(error.code)) return 'user'\n  if (networkErrors.includes(error.code)) return 'network'\n  if (systemErrors.includes(error.code)) return 'system'\n  if (configErrors.includes(error.code)) return 'config'\n\n  return 'system' // Default category\n}\n</code></pre>"},{"location":"reference/errors/#troubleshooting-guide","title":"Troubleshooting Guide","text":""},{"location":"reference/errors/#common-issues-and-solutions","title":"Common Issues and Solutions","text":""},{"location":"reference/errors/#rpc-error-no-header-should-have-returned-false","title":"\"RPC Error: no header should have returned false\"","text":"<p>Symptoms: Error during <code>createAction</code> calls Cause: Wallet input selection issues Solutions:</p> <ol> <li>Restart wallet application</li> <li>Ensure wallet is fully synced</li> <li>Use slightly larger amounts (200-500 satoshis)</li> <li>Wait for wallet synchronization</li> <li>Check for sufficient confirmed UTXOs</li> </ol>"},{"location":"reference/errors/#insufficient-funds-with-available-balance","title":"\"Insufficient funds\" with Available Balance","text":"<p>Symptoms: Error despite wallet showing balance Cause: UTXOs not properly selected by wallet Solutions:</p> <ol> <li>Check UTXO status with <code>listOutputs()</code></li> <li>Verify UTXOs are confirmed</li> <li>Restart wallet to refresh UTXO cache</li> <li>Use manual input selection if supported</li> </ol>"},{"location":"reference/errors/#transaction-broadcast-failures","title":"Transaction Broadcast Failures","text":"<p>Symptoms: Valid transactions rejected by network Cause: Various network or validation issues Solutions:</p> <ol> <li>Verify transaction format and signatures</li> <li>Check fee rates are adequate</li> <li>Ensure inputs are unspent</li> <li>Try alternative broadcast endpoints</li> </ol>"},{"location":"reference/errors/#wallet-connection-issues","title":"Wallet Connection Issues","text":"<p>Symptoms: Cannot connect to wallet substrate Cause: Wallet not running or permission issues Solutions:</p> <ol> <li>Ensure wallet application is running</li> <li>Check originator domain permissions</li> <li>Clear browser cache and cookies</li> <li>Verify wallet trust settings</li> </ol>"},{"location":"reference/errors/#diagnostic-tools","title":"Diagnostic Tools","text":""},{"location":"reference/errors/#transaction-validation","title":"Transaction Validation","text":"<pre><code>function validateTransaction(tx: Transaction): string[] {\n  const errors: string[] = []\n\n  if (tx.inputs.length === 0) {\n    errors.push('Transaction must have at least one input')\n  }\n\n  if (tx.outputs.length === 0) {\n    errors.push('Transaction must have at least one output')\n  }\n\n  const totalInput = tx.inputs.reduce((sum, input) =&gt; sum + input.satoshis, 0)\n  const totalOutput = tx.outputs.reduce((sum, output) =&gt; sum + output.satoshis, 0)\n\n  if (totalInput &lt;= totalOutput) {\n    errors.push('Insufficient input value to cover outputs and fees')\n  }\n\n  return errors\n}\n</code></pre>"},{"location":"reference/errors/#network-connectivity-test","title":"Network Connectivity Test","text":"<pre><code>async function testNetworkConnectivity(chainTracker: ChainTracker): Promise&lt;boolean&gt; {\n  try {\n    const height = await chainTracker.getHeight()\n    return height &gt; 0\n  } catch (error) {\n    console.error('Network connectivity test failed:', error)\n    return false\n  }\n}\n</code></pre>"},{"location":"reference/errors/#wallet-health-check","title":"Wallet Health Check","text":"<pre><code>async function checkWalletHealth(wallet: WalletClient): Promise&lt;{\n  connected: boolean\n  authenticated: boolean\n  balance: number\n  errors: string[]\n}&gt; {\n  const result = {\n    connected: false,\n    authenticated: false,\n    balance: 0,\n    errors: [] as string[]\n  }\n\n  try {\n    await wallet.connectToSubstrate()\n    result.connected = true\n  } catch (error) {\n    result.errors.push(`Connection failed: ${error.message}`)\n  }\n\n  try {\n    const outputs = await wallet.listOutputs({ limit: 1 })\n    result.authenticated = true\n    result.balance = outputs.totalValue || 0\n  } catch (error) {\n    result.errors.push(`Authentication failed: ${error.message}`)\n  }\n\n  return result\n}\n</code></pre>"},{"location":"reference/errors/#error-recovery-strategies","title":"Error Recovery Strategies","text":""},{"location":"reference/errors/#automatic-recovery","title":"Automatic Recovery","text":"<pre><code>class ErrorRecoveryManager {\n  private retryAttempts = new Map&lt;string, number&gt;()\n  private maxRetries = 3\n\n  async executeWithRecovery&lt;T&gt;(\n    operation: () =&gt; Promise&lt;T&gt;,\n    operationId: string\n  ): Promise&lt;T&gt; {\n    try {\n      const result = await operation()\n      this.retryAttempts.delete(operationId)\n      return result\n    } catch (error) {\n      return this.handleError(error, operation, operationId)\n    }\n  }\n\n  private async handleError&lt;T&gt;(\n    error: WalletErrorObject,\n    operation: () =&gt; Promise&lt;T&gt;,\n    operationId: string\n  ): Promise&lt;T&gt; {\n    const attempts = this.retryAttempts.get(operationId) || 0\n\n    if (attempts &gt;= this.maxRetries) {\n      this.retryAttempts.delete(operationId)\n      throw error\n    }\n\n    // Implement recovery strategies based on error type\n    switch (error.code) {\n      case 'WALLET_NOT_CONNECTED':\n        await this.reconnectWallet()\n        break\n      case 'NETWORK_ERROR':\n        await this.switchToBackupNode()\n        break\n      case 'INSUFFICIENT_FUNDS':\n        await this.waitForConfirmations()\n        break\n      default:\n        throw error // No recovery strategy available\n    }\n\n    this.retryAttempts.set(operationId, attempts + 1)\n    return this.executeWithRecovery(operation, operationId)\n  }\n\n  private async reconnectWallet(): Promise&lt;void&gt; {\n    // Implement wallet reconnection logic\n  }\n\n  private async switchToBackupNode(): Promise&lt;void&gt; {\n    // Implement node failover logic\n  }\n\n  private async waitForConfirmations(): Promise&lt;void&gt; {\n    // Wait for pending transactions to confirm\n    await new Promise(resolve =&gt; setTimeout(resolve, 30000))\n  }\n}\n</code></pre>"},{"location":"reference/errors/#best-practices","title":"Best Practices","text":""},{"location":"reference/errors/#error-logging","title":"Error Logging","text":"<pre><code>class ErrorLogger {\n  static log(error: WalletErrorObject, context?: Record&lt;string, any&gt;): void {\n    const logEntry = {\n      timestamp: new Date().toISOString(),\n      code: error.code,\n      message: error.description,\n      context: { ...error.context, ...context },\n      stack: error.stack\n    }\n\n    // Log to appropriate destination based on severity\n    if (this.isCriticalError(error.code)) {\n      console.error('CRITICAL ERROR:', logEntry)\n    } else {\n      console.warn('ERROR:', logEntry)\n    }\n  }\n\n  private static isCriticalError(code: string): boolean {\n    return [\n      'INVALID_PRIVATE_KEY',\n      'SIGNATURE_VERIFICATION_FAILED',\n      'CHAIN_VALIDATION_FAILED'\n    ].includes(code)\n  }\n}\n</code></pre>"},{"location":"reference/errors/#user-friendly-error-messages","title":"User-Friendly Error Messages","text":"<pre><code>function getUserFriendlyMessage(error: WalletErrorObject): string {\n  const messages: Record&lt;string, string&gt; = {\n    'INSUFFICIENT_FUNDS': 'You don\\'t have enough funds for this transaction.',\n    'ACTION_REJECTED': 'Transaction was cancelled.',\n    'WALLET_NOT_CONNECTED': 'Please connect your wallet to continue.',\n    'NETWORK_ERROR': 'Network connection issue. Please try again.',\n    'INVALID_TRANSACTION': 'Transaction format is invalid. Please check your inputs.'\n  }\n\n  return messages[error.code] || 'An unexpected error occurred. Please try again.'\n}\n</code></pre> <p>This comprehensive error reference provides developers with the tools and knowledge needed to handle all types of errors that may occur when using the BSV TypeScript SDK.</p>"},{"location":"reference/identity/","title":"API","text":"<p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/identity/#interfaces","title":"Interfaces","text":"DisplayableIdentity IdentityClientOptions <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/identity/#interface-displayableidentity","title":"Interface: DisplayableIdentity","text":"<pre><code>export interface DisplayableIdentity {\n    name: string;\n    avatarURL: string;\n    abbreviatedKey: string;\n    identityKey: string;\n    badgeIconURL: string;\n    badgeLabel: string;\n    badgeClickURL: string;\n}\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/identity/#interface-identityclientoptions","title":"Interface: IdentityClientOptions","text":"<pre><code>export interface IdentityClientOptions {\n    protocolID: WalletProtocol;\n    keyID: string;\n    tokenAmount: number;\n    outputIndex: number;\n}\n</code></pre> <p>See also: WalletProtocol</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/identity/#classes","title":"Classes","text":"ContactsManager IdentityClient <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/identity/#class-contactsmanager","title":"Class: ContactsManager","text":"<pre><code>export class ContactsManager {\n    constructor(wallet?: WalletInterface) \n    async getContacts(identityKey?: PubKeyHex, forceRefresh = false, limit = 1000): Promise&lt;Contact[]&gt; \n    async saveContact(contact: DisplayableIdentity, metadata?: Record&lt;string, any&gt;): Promise&lt;void&gt; \n    async removeContact(identityKey: string): Promise&lt;void&gt; \n}\n</code></pre> <p>See also: Contact, DisplayableIdentity, PubKeyHex, WalletInterface</p>"},{"location":"reference/identity/#method-getcontacts","title":"Method getContacts","text":"<p>Load all records from the contacts basket</p> <p><pre><code>async getContacts(identityKey?: PubKeyHex, forceRefresh = false, limit = 1000): Promise&lt;Contact[]&gt; \n</code></pre> See also: Contact, PubKeyHex</p> <p>Returns</p> <p>A promise that resolves with an array of contacts</p> <p>Argument Details</p> <ul> <li>identityKey</li> <li>Optional specific identity key to fetch</li> <li>forceRefresh</li> <li>Whether to force a check for new contact data</li> <li>limit</li> <li>Maximum number of contacts to return</li> </ul>"},{"location":"reference/identity/#method-removecontact","title":"Method removeContact","text":"<p>Remove a contact from the contacts basket</p> <pre><code>async removeContact(identityKey: string): Promise&lt;void&gt; \n</code></pre> <p>Argument Details</p> <ul> <li>identityKey</li> <li>The identity key of the contact to remove</li> </ul>"},{"location":"reference/identity/#method-savecontact","title":"Method saveContact","text":"<p>Save or update a Metanet contact</p> <p><pre><code>async saveContact(contact: DisplayableIdentity, metadata?: Record&lt;string, any&gt;): Promise&lt;void&gt; \n</code></pre> See also: DisplayableIdentity</p> <p>Argument Details</p> <ul> <li>contact</li> <li>The displayable identity information for the contact</li> <li>metadata</li> <li>Optional metadata to store with the contact (ex. notes, aliases, etc)</li> </ul> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/identity/#class-identityclient","title":"Class: IdentityClient","text":"<p>IdentityClient lets you discover who others are, and let the world know who you are.</p> <pre><code>export class IdentityClient {\n    constructor(wallet?: WalletInterface, private readonly options = DEFAULT_IDENTITY_CLIENT_OPTIONS, private readonly originator?: OriginatorDomainNameStringUnder250Bytes) \n    async publiclyRevealAttributes(certificate: WalletCertificate, fieldsToReveal: CertificateFieldNameUnder50Bytes[]): Promise&lt;BroadcastResponse | BroadcastFailure&gt; \n    async resolveByIdentityKey(args: DiscoverByIdentityKeyArgs, overrideWithContacts = true): Promise&lt;DisplayableIdentity[]&gt; \n    async resolveByAttributes(args: DiscoverByAttributesArgs, overrideWithContacts = true): Promise&lt;DisplayableIdentity[]&gt; \n    public async getContacts(identityKey?: PubKeyHex, forceRefresh = false, limit = 1000): Promise&lt;Contact[]&gt; \n    public async saveContact(contact: DisplayableIdentity, metadata?: Record&lt;string, any&gt;): Promise&lt;void&gt; \n    public async removeContact(identityKey: PubKeyHex): Promise&lt;void&gt; \n    static parseIdentity(identityToParse: IdentityCertificate): DisplayableIdentity \n}\n</code></pre> <p>See also: BroadcastFailure, BroadcastResponse, CertificateFieldNameUnder50Bytes, Contact, DEFAULT_IDENTITY_CLIENT_OPTIONS, DiscoverByAttributesArgs, DiscoverByIdentityKeyArgs, DisplayableIdentity, IdentityCertificate, OriginatorDomainNameStringUnder250Bytes, PubKeyHex, WalletCertificate, WalletInterface</p>"},{"location":"reference/identity/#method-getcontacts_1","title":"Method getContacts","text":"<p>TODO: Implement once revocation overlay is created Remove public certificate revelation from overlay services by spending the identity token</p> <p>Load all records from the contacts basket</p> <p><pre><code>public async getContacts(identityKey?: PubKeyHex, forceRefresh = false, limit = 1000): Promise&lt;Contact[]&gt; \n</code></pre> See also: Contact, PubKeyHex</p> <p>Returns</p> <p>A promise that resolves with an array of contacts</p> <p>Argument Details</p> <ul> <li>serialNumber</li> <li>Unique serial number of the certificate to revoke revelation</li> <li>identityKey</li> <li>Optional specific identity key to fetch</li> <li>forceRefresh</li> <li>Whether to force a check for new contact data</li> <li>limit</li> <li>Optional limit on number of contacts to fetch</li> </ul>"},{"location":"reference/identity/#method-parseidentity","title":"Method parseIdentity","text":"<p>Parse out identity and certifier attributes to display from an IdentityCertificate</p> <p><pre><code>static parseIdentity(identityToParse: IdentityCertificate): DisplayableIdentity \n</code></pre> See also: DisplayableIdentity, IdentityCertificate</p> <p>Returns</p> <ul> <li>IdentityToDisplay</li> </ul> <p>Argument Details</p> <ul> <li>identityToParse</li> <li>The Identity Certificate to parse</li> </ul>"},{"location":"reference/identity/#method-publiclyrevealattributes","title":"Method publiclyRevealAttributes","text":"<p>Publicly reveals selected fields from a given certificate by creating a publicly verifiable certificate. The publicly revealed certificate is included in a blockchain transaction and broadcast to a federated overlay node.</p> <p><pre><code>async publiclyRevealAttributes(certificate: WalletCertificate, fieldsToReveal: CertificateFieldNameUnder50Bytes[]): Promise&lt;BroadcastResponse | BroadcastFailure&gt; \n</code></pre> See also: BroadcastFailure, BroadcastResponse, CertificateFieldNameUnder50Bytes, WalletCertificate</p> <p>Returns</p> <p>A promise that resolves with the broadcast result from the overlay network.</p> <p>Argument Details</p> <ul> <li>certificate</li> <li>The master certificate to selectively reveal.</li> <li>fieldsToReveal</li> <li>An array of certificate field names to reveal. Only these fields will be included in the public certificate.</li> </ul> <p>Throws</p> <p>Throws an error if the certificate is invalid, the fields cannot be revealed, or if the broadcast fails.</p>"},{"location":"reference/identity/#method-removecontact_1","title":"Method removeContact","text":"<p>Remove a contact from the contacts basket</p> <p><pre><code>public async removeContact(identityKey: PubKeyHex): Promise&lt;void&gt; \n</code></pre> See also: PubKeyHex</p> <p>Argument Details</p> <ul> <li>identityKey</li> <li>The identity key of the contact to remove</li> </ul>"},{"location":"reference/identity/#method-resolvebyattributes","title":"Method resolveByAttributes","text":"<p>Resolves displayable identity certificates by specific identity attributes, issued by a trusted entity.</p> <p><pre><code>async resolveByAttributes(args: DiscoverByAttributesArgs, overrideWithContacts = true): Promise&lt;DisplayableIdentity[]&gt; \n</code></pre> See also: DiscoverByAttributesArgs, DisplayableIdentity</p> <p>Returns</p> <p>The promise resolves to displayable identities.</p> <p>Argument Details</p> <ul> <li>args</li> <li>Attributes and optional parameters used to discover certificates.</li> <li>overrideWithContacts</li> <li>Whether to override the results with personal contacts if available.</li> </ul>"},{"location":"reference/identity/#method-resolvebyidentitykey","title":"Method resolveByIdentityKey","text":"<p>Resolves displayable identity certificates, issued to a given identity key by a trusted certifier.</p> <p><pre><code>async resolveByIdentityKey(args: DiscoverByIdentityKeyArgs, overrideWithContacts = true): Promise&lt;DisplayableIdentity[]&gt; \n</code></pre> See also: DiscoverByIdentityKeyArgs, DisplayableIdentity</p> <p>Returns</p> <p>The promise resolves to displayable identities.</p> <p>Argument Details</p> <ul> <li>args</li> <li>Arguments for requesting the discovery based on the identity key.</li> <li>overrideWithContacts</li> <li>Whether to override the results with personal contacts if available.</li> </ul>"},{"location":"reference/identity/#method-savecontact_1","title":"Method saveContact","text":"<p>Save or update a Metanet contact</p> <p><pre><code>public async saveContact(contact: DisplayableIdentity, metadata?: Record&lt;string, any&gt;): Promise&lt;void&gt; \n</code></pre> See also: DisplayableIdentity</p> <p>Argument Details</p> <ul> <li>contact</li> <li>The displayable identity information for the contact</li> <li>metadata</li> <li>Optional metadata to store with the contact (ex. notes, aliases, etc)</li> </ul> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/identity/#functions","title":"Functions","text":""},{"location":"reference/identity/#types","title":"Types","text":""},{"location":"reference/identity/#type-contact","title":"Type: Contact","text":"<pre><code>export type Contact = DisplayableIdentity &amp; {\n    metadata?: Record&lt;string, any&gt;;\n}\n</code></pre> <p>See also: DisplayableIdentity</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/identity/#enums","title":"Enums","text":""},{"location":"reference/identity/#variables","title":"Variables","text":"DEFAULT_IDENTITY_CLIENT_OPTIONS KNOWN_IDENTITY_TYPES defaultIdentity <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/identity/#variable-default_identity_client_options","title":"Variable: DEFAULT_IDENTITY_CLIENT_OPTIONS","text":"<pre><code>DEFAULT_IDENTITY_CLIENT_OPTIONS: IdentityClientOptions = {\n    protocolID: [1, \"identity\"],\n    keyID: \"1\",\n    tokenAmount: 1,\n    outputIndex: 0\n}\n</code></pre> <p>See also: IdentityClientOptions</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/identity/#variable-known_identity_types","title":"Variable: KNOWN_IDENTITY_TYPES","text":"<pre><code>KNOWN_IDENTITY_TYPES = {\n    identiCert: \"z40BOInXkI8m7f/wBrv4MJ09bZfzZbTj2fJqCtONqCY=\",\n    discordCert: \"2TgqRC35B1zehGmB21xveZNc7i5iqHc0uxMb+1NMPW4=\",\n    phoneCert: \"mffUklUzxbHr65xLohn0hRL0Tq2GjW1GYF/OPfzqJ6A=\",\n    xCert: \"vdDWvftf1H+5+ZprUw123kjHlywH+v20aPQTuXgMpNc=\",\n    registrant: \"YoPsbfR6YQczjzPdHCoGC7nJsOdPQR50+SYqcWpJ0y0=\",\n    emailCert: \"exOl3KM0dIJ04EW5pZgbZmPag6MdJXd3/a1enmUU/BA=\",\n    anyone: \"mfkOMfLDQmrr3SBxBQ5WeE+6Hy3VJRFq6w4A5Ljtlis=\",\n    self: \"Hkge6X5JRxt1cWXtHLCrSTg6dCVTxjQJJ48iOYd7n3g=\",\n    coolCert: \"AGfk/WrT1eBDXpz3mcw386Zww2HmqcIn3uY6x4Af1eo=\"\n}\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/identity/#variable-defaultidentity","title":"Variable: defaultIdentity","text":"<pre><code>defaultIdentity: DisplayableIdentity = {\n    name: \"Unknown Identity\",\n    avatarURL: \"XUUB8bbn9fEthk15Ge3zTQXypUShfC94vFjp65v7u5CQ8qkpxzst\",\n    identityKey: \"\",\n    abbreviatedKey: \"\",\n    badgeIconURL: \"XUUV39HVPkpmMzYNTx7rpKzJvXfeiVyQWg2vfSpjBAuhunTCA9uG\",\n    badgeLabel: \"Not verified by anyone you trust.\",\n    badgeClickURL: \"https://projectbabbage.com/docs/unknown-identity\"\n}\n</code></pre> <p>See also: DisplayableIdentity</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/kvstore/","title":"API","text":"<p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/kvstore/#interfaces","title":"Interfaces","text":"KVContext KVStoreConfig KVStoreEntry KVStoreGetOptions KVStoreLookupResult KVStoreQuery KVStoreRemoveOptions KVStoreSetOptions KVStoreToken <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/kvstore/#interface-kvcontext","title":"Interface: KVContext","text":"<pre><code>export interface KVContext {\n    key: string;\n    protocolID: WalletProtocol;\n}\n</code></pre> <p>See also: WalletProtocol</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/kvstore/#interface-kvstoreconfig","title":"Interface: KVStoreConfig","text":"<p>Configuration interface for GlobalKVStore operations. Defines all options for connecting to overlay services and managing KVStore behavior.</p> <pre><code>export interface KVStoreConfig {\n    overlayHost?: string;\n    protocolID?: WalletProtocol;\n    serviceName?: string;\n    tokenAmount?: number;\n    topics?: string[];\n    originator?: string;\n    wallet?: WalletInterface;\n    networkPreset?: \"mainnet\" | \"testnet\" | \"local\";\n    acceptDelayedBroadcast?: boolean;\n    tokenSetDescription?: string;\n    tokenUpdateDescription?: string;\n    tokenRemovalDescription?: string;\n}\n</code></pre> <p>See also: WalletInterface, WalletProtocol</p>"},{"location":"reference/kvstore/#property-acceptdelayedbroadcast","title":"Property acceptDelayedBroadcast","text":"<p>Whether to accept delayed broadcast</p> <pre><code>acceptDelayedBroadcast?: boolean\n</code></pre>"},{"location":"reference/kvstore/#property-networkpreset","title":"Property networkPreset","text":"<p>Network preset for overlay services</p> <pre><code>networkPreset?: \"mainnet\" | \"testnet\" | \"local\"\n</code></pre>"},{"location":"reference/kvstore/#property-originator","title":"Property originator","text":"<p>Originator</p> <pre><code>originator?: string\n</code></pre>"},{"location":"reference/kvstore/#property-overlayhost","title":"Property overlayHost","text":"<p>The overlay service host URL</p> <pre><code>overlayHost?: string\n</code></pre>"},{"location":"reference/kvstore/#property-protocolid","title":"Property protocolID","text":"<p>Protocol ID for the KVStore protocol</p> <p><pre><code>protocolID?: WalletProtocol\n</code></pre> See also: WalletProtocol</p>"},{"location":"reference/kvstore/#property-servicename","title":"Property serviceName","text":"<p>Service name for overlay submission</p> <pre><code>serviceName?: string\n</code></pre>"},{"location":"reference/kvstore/#property-tokenamount","title":"Property tokenAmount","text":"<p>Amount of satoshis for each token</p> <pre><code>tokenAmount?: number\n</code></pre>"},{"location":"reference/kvstore/#property-tokenremovaldescription","title":"Property tokenRemovalDescription","text":"<p>Description for token removal</p> <pre><code>tokenRemovalDescription?: string\n</code></pre>"},{"location":"reference/kvstore/#property-tokensetdescription","title":"Property tokenSetDescription","text":"<p>Description for token set</p> <pre><code>tokenSetDescription?: string\n</code></pre>"},{"location":"reference/kvstore/#property-tokenupdatedescription","title":"Property tokenUpdateDescription","text":"<p>Description for token update</p> <pre><code>tokenUpdateDescription?: string\n</code></pre>"},{"location":"reference/kvstore/#property-topics","title":"Property topics","text":"<p>Topics for overlay submission</p> <pre><code>topics?: string[]\n</code></pre>"},{"location":"reference/kvstore/#property-wallet","title":"Property wallet","text":"<p>Wallet interface for operations</p> <p><pre><code>wallet?: WalletInterface\n</code></pre> See also: WalletInterface</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/kvstore/#interface-kvstoreentry","title":"Interface: KVStoreEntry","text":"<p>KVStore entry returned from queries</p> <pre><code>export interface KVStoreEntry {\n    key: string;\n    value: string;\n    controller: PubKeyHex;\n    protocolID: WalletProtocol;\n    tags?: string[];\n    token?: KVStoreToken;\n    history?: string[];\n}\n</code></pre> <p>See also: KVStoreToken, PubKeyHex, WalletProtocol</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/kvstore/#interface-kvstoregetoptions","title":"Interface: KVStoreGetOptions","text":"<p>Options for configuring KVStore get operations (local processing)</p> <pre><code>export interface KVStoreGetOptions {\n    history?: boolean;\n    includeToken?: boolean;\n    serviceName?: string;\n}\n</code></pre>"},{"location":"reference/kvstore/#property-history","title":"Property history","text":"<p>Whether to build and include history for each entry</p> <pre><code>history?: boolean\n</code></pre>"},{"location":"reference/kvstore/#property-includetoken","title":"Property includeToken","text":"<p>Whether to include token transaction data in results</p> <pre><code>includeToken?: boolean\n</code></pre>"},{"location":"reference/kvstore/#property-servicename_1","title":"Property serviceName","text":"<p>Service name for overlay retrieval</p> <pre><code>serviceName?: string\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/kvstore/#interface-kvstorelookupresult","title":"Interface: KVStoreLookupResult","text":"<p>Result structure for KVStore lookups from overlay services. Contains the transaction output information for a found key-value pair.</p> <pre><code>export interface KVStoreLookupResult {\n    txid: string;\n    outputIndex: number;\n    outputScript: string;\n    satoshis: number;\n    history?: (output: any, currentDepth: number) =&gt; Promise&lt;boolean&gt;;\n}\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/kvstore/#interface-kvstorequery","title":"Interface: KVStoreQuery","text":"<p>Query parameters for KVStore lookups from overlay services. Used when searching for existing key-value pairs in the network.</p> <pre><code>export interface KVStoreQuery {\n    key?: string;\n    controller?: PubKeyHex;\n    protocolID?: WalletProtocol;\n    tags?: string[];\n    tagQueryMode?: \"all\" | \"any\";\n    limit?: number;\n    skip?: number;\n    sortOrder?: \"asc\" | \"desc\";\n}\n</code></pre> <p>See also: PubKeyHex, WalletProtocol</p>"},{"location":"reference/kvstore/#property-tagquerymode","title":"Property tagQueryMode","text":"<p>Controls tag matching behavior when tags are specified. - 'all': Requires all specified tags to be present (default) - 'any': Requires at least one of the specified tags to be present</p> <pre><code>tagQueryMode?: \"all\" | \"any\"\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/kvstore/#interface-kvstoreremoveoptions","title":"Interface: KVStoreRemoveOptions","text":"<pre><code>export interface KVStoreRemoveOptions {\n    protocolID?: WalletProtocol;\n    tokenRemovalDescription?: string;\n}\n</code></pre> <p>See also: WalletProtocol</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/kvstore/#interface-kvstoresetoptions","title":"Interface: KVStoreSetOptions","text":"<pre><code>export interface KVStoreSetOptions {\n    protocolID?: WalletProtocol;\n    tokenSetDescription?: string;\n    tokenUpdateDescription?: string;\n    tokenAmount?: number;\n    tags?: string[];\n}\n</code></pre> <p>See also: WalletProtocol</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/kvstore/#interface-kvstoretoken","title":"Interface: KVStoreToken","text":"<p>Token structure containing a KVStore token from overlay services. Wraps the transaction data and metadata for a key-value pair.</p> <pre><code>export interface KVStoreToken {\n    txid: string;\n    outputIndex: number;\n    satoshis: number;\n    beef: Beef;\n}\n</code></pre> <p>See also: Beef</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/kvstore/#classes","title":"Classes","text":"GlobalKVStore LocalKVStore <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/kvstore/#class-globalkvstore","title":"Class: GlobalKVStore","text":"<p>Implements a global key-value storage system which uses an overlay service to track key-value pairs. Each key-value pair is represented by a PushDrop token output. Allows getting, setting, and removing key-value pairs with optional fetching by protocolID and history tracking.</p> <pre><code>export class GlobalKVStore {\n    constructor(config: KVStoreConfig = {}) \n    async get(query: KVStoreQuery, options: KVStoreGetOptions = {}): Promise&lt;KVStoreEntry | KVStoreEntry[] | undefined&gt; \n    async set(key: string, value: string, options: KVStoreSetOptions = {}): Promise&lt;OutpointString&gt; \n    async remove(key: string, outputs?: CreateActionOutput[], options: KVStoreRemoveOptions = {}): Promise&lt;HexString&gt; \n}\n</code></pre> <p>See also: CreateActionOutput, HexString, KVStoreConfig, KVStoreEntry, KVStoreGetOptions, KVStoreQuery, KVStoreRemoveOptions, KVStoreSetOptions, OutpointString</p>"},{"location":"reference/kvstore/#constructor","title":"Constructor","text":"<p>Creates an instance of the GlobalKVStore.</p> <p><pre><code>constructor(config: KVStoreConfig = {}) \n</code></pre> See also: KVStoreConfig</p> <p>Argument Details</p> <ul> <li>config</li> <li>Configuration options for the KVStore. Defaults to empty object.</li> <li>config.wallet</li> <li>Wallet to use for operations. Defaults to WalletClient.</li> </ul> <p>Throws</p> <p>If the configuration contains invalid parameters.</p>"},{"location":"reference/kvstore/#method-get","title":"Method get","text":"<p>Retrieves data from the KVStore. Can query by key+controller (single result), protocolID, controller, or key (multiple results).</p> <p><pre><code>async get(query: KVStoreQuery, options: KVStoreGetOptions = {}): Promise&lt;KVStoreEntry | KVStoreEntry[] | undefined&gt; \n</code></pre> See also: KVStoreEntry, KVStoreGetOptions, KVStoreQuery</p> <p>Returns</p> <p>Single entry for key+controller queries, array for all other queries</p> <p>Argument Details</p> <ul> <li>query</li> <li>Query parameters sent to overlay</li> <li>options</li> <li>Configuration options for the get operation</li> </ul>"},{"location":"reference/kvstore/#method-remove","title":"Method remove","text":"<p>Removes the key-value pair associated with the given key from the overlay service.</p> <p><pre><code>async remove(key: string, outputs?: CreateActionOutput[], options: KVStoreRemoveOptions = {}): Promise&lt;HexString&gt; \n</code></pre> See also: CreateActionOutput, HexString, KVStoreRemoveOptions</p> <p>Returns</p> <p>A promise that resolves to the txid of the removal transaction if successful.</p> <p>Argument Details</p> <ul> <li>key</li> <li>The key to remove.</li> <li>outputs</li> <li>Additional outputs to include in the removal transaction.</li> <li>options</li> <li>Optional parameters for the removal operation.</li> </ul> <p>Throws</p> <p>If the key is invalid.</p> <p>If the key does not exist in the store.</p> <p>If the overlay service is unreachable or the transaction fails.</p> <p>If there are existing tokens that cannot be unlocked.</p>"},{"location":"reference/kvstore/#method-set","title":"Method set","text":"<p>Sets a key-value pair. The current user (wallet identity) becomes the controller.</p> <p><pre><code>async set(key: string, value: string, options: KVStoreSetOptions = {}): Promise&lt;OutpointString&gt; \n</code></pre> See also: KVStoreSetOptions, OutpointString</p> <p>Returns</p> <p>The outpoint of the created token</p> <p>Argument Details</p> <ul> <li>key</li> <li>The key to set (user computes this however they want)</li> <li>value</li> <li>The value to store</li> <li>options</li> <li>Configuration options for the set operation</li> </ul> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/kvstore/#class-localkvstore","title":"Class: LocalKVStore","text":"<p>Implements a key-value storage system backed by transaction outputs managed by a wallet. Each key-value pair is represented by a PushDrop token output in a specific context (basket). Allows setting, getting, and removing key-value pairs, with optional encryption.</p> <pre><code>export default class LocalKVStore {\n    acceptDelayedBroadcast: boolean = false;\n    constructor(wallet: WalletInterface = new WalletClient(), context = \"kvstore default\", encrypt = true, originator?: string, acceptDelayedBroadcast = false) \n    async get(key: string, defaultValue: string | undefined = undefined): Promise&lt;string | undefined&gt; \n    async set(key: string, value: string): Promise&lt;OutpointString&gt; \n    async remove(key: string): Promise&lt;string[]&gt; \n}\n</code></pre> <p>See also: OutpointString, WalletClient, WalletInterface, encrypt</p>"},{"location":"reference/kvstore/#constructor_1","title":"Constructor","text":"<p>Creates an instance of the localKVStore.</p> <p><pre><code>constructor(wallet: WalletInterface = new WalletClient(), context = \"kvstore default\", encrypt = true, originator?: string, acceptDelayedBroadcast = false) \n</code></pre> See also: WalletClient, WalletInterface, encrypt</p> <p>Argument Details</p> <ul> <li>wallet</li> <li>The wallet interface to use. Defaults to a new WalletClient instance.</li> <li>context</li> <li>The context (basket) for namespacing keys. Defaults to 'kvstore default'.</li> <li>encrypt</li> <li>Whether to encrypt values. Defaults to true.</li> <li>originator</li> <li>\u2014 An originator to use with PushDrop and the wallet, if provided.</li> </ul> <p>Throws</p> <p>If the context is missing or empty.</p>"},{"location":"reference/kvstore/#method-get_1","title":"Method get","text":"<p>Retrieves the value associated with a given key.</p> <pre><code>async get(key: string, defaultValue: string | undefined = undefined): Promise&lt;string | undefined&gt; \n</code></pre> <p>Returns</p> <p>A promise that resolves to the value as a string, the defaultValue if the key is not found, or undefined if no defaultValue is provided.</p> <p>Argument Details</p> <ul> <li>key</li> <li>The key to retrieve the value for.</li> <li>defaultValue</li> <li>The value to return if the key is not found.</li> </ul> <p>Throws</p> <p>If too many outputs are found for the key (ambiguous state).</p> <p>If the found output's locking script cannot be decoded or represents an invalid token format.</p>"},{"location":"reference/kvstore/#method-remove_1","title":"Method remove","text":"<p>Removes the key-value pair associated with the given key. It finds the existing output(s) for the key and spends them without creating a new output. If multiple outputs exist, they are all spent in the same transaction. If the key does not exist, it does nothing. If signing the removal transaction fails, it relinquishes the original outputs instead of spending.</p> <pre><code>async remove(key: string): Promise&lt;string[]&gt; \n</code></pre> <p>Returns</p> <p>A promise that resolves to the txids of the removal transactions if successful.</p> <p>Argument Details</p> <ul> <li>key</li> <li>The key to remove.</li> </ul>"},{"location":"reference/kvstore/#method-set_1","title":"Method set","text":"<p>Sets or updates the value associated with a given key atomically. If the key already exists (one or more outputs found), it spends the existing output(s) and creates a new one with the updated value. If multiple outputs exist for the key, they are collapsed into a single new output. If the key does not exist, it creates a new output. Handles encryption if enabled. If signing the update/collapse transaction fails, it relinquishes the original outputs and starts over with a new chain. Ensures atomicity by locking the key during the operation, preventing concurrent updates to the same key from missing earlier changes.</p> <p><pre><code>async set(key: string, value: string): Promise&lt;OutpointString&gt; \n</code></pre> See also: OutpointString</p> <p>Returns</p> <p>A promise that resolves to the outpoint string (txid.vout) of the new or updated token output.</p> <p>Argument Details</p> <ul> <li>key</li> <li>The key to set or update.</li> <li>value</li> <li>The value to associate with the key.</li> </ul> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/kvstore/#functions","title":"Functions","text":""},{"location":"reference/kvstore/#types","title":"Types","text":""},{"location":"reference/kvstore/#enums","title":"Enums","text":""},{"location":"reference/kvstore/#variables","title":"Variables","text":"kvProtocol kvStoreInterpreter <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/kvstore/#variable-kvprotocol","title":"Variable: kvProtocol","text":"<pre><code>kvProtocol = {\n    protocolID: 0,\n    key: 1,\n    value: 2,\n    controller: 3,\n    tags: 4,\n    signature: 5\n}\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/kvstore/#variable-kvstoreinterpreter","title":"Variable: kvStoreInterpreter","text":"<pre><code>kvStoreInterpreter: InterpreterFunction&lt;string, KVContext&gt; = async (transaction: Transaction, outputIndex: number, ctx?: KVContext): Promise&lt;string | undefined&gt; =&gt; {\n    try {\n        const output = transaction.outputs[outputIndex];\n        if (output == null || output.lockingScript == null)\n            return undefined;\n        if (ctx == null || ctx.key == null)\n            return undefined;\n        const decoded = PushDrop.decode(output.lockingScript);\n        const expectedFieldCount = Object.keys(kvProtocol).length;\n        const hasTagsField = decoded.fields.length === expectedFieldCount;\n        const isOldFormat = decoded.fields.length === expectedFieldCount - 1;\n        if (!isOldFormat &amp;&amp; !hasTagsField)\n            return undefined;\n        const key = Utils.toUTF8(decoded.fields[kvProtocol.key]);\n        const protocolID = Utils.toUTF8(decoded.fields[kvProtocol.protocolID]);\n        if (key !== ctx.key || protocolID !== JSON.stringify(ctx.protocolID))\n            return undefined;\n        try {\n            return Utils.toUTF8(decoded.fields[kvProtocol.value]);\n        }\n        catch {\n            return undefined;\n        }\n    }\n    catch {\n        return undefined;\n    }\n}\n</code></pre> <p>See also: KVContext, PushDrop, Transaction, kvProtocol, toUTF8</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/messages/","title":"API","text":"<p>Links: API, Interfaces, Classes, Functions, Variables</p>"},{"location":"reference/messages/#interfaces","title":"Interfaces","text":""},{"location":"reference/messages/#classes","title":"Classes","text":""},{"location":"reference/messages/#functions","title":"Functions","text":""},{"location":"reference/messages/#variables","title":"Variables","text":"decrypt encrypt sign verify <p>Links: API, Interfaces, Classes, Functions, Variables</p>"},{"location":"reference/messages/#variable-decrypt","title":"Variable: decrypt","text":"<pre><code>decrypt = (message: number[], recipient: PrivateKey): number[] =&gt; {\n    const reader = new Reader(message);\n    const messageVersion = toHex(reader.read(4));\n    if (messageVersion !== VERSION) {\n        throw new Error(`Message version mismatch: Expected ${VERSION}, received ${messageVersion}`);\n    }\n    const sender = PublicKey.fromString(toHex(reader.read(33)));\n    const expectedRecipientDER = toHex(reader.read(33));\n    const actualRecipientDER = recipient\n        .toPublicKey()\n        .encode(true, \"hex\") as string;\n    if (expectedRecipientDER !== actualRecipientDER) {\n        throw new Error(`The encrypted message expects a recipient public key of ${expectedRecipientDER}, but the provided key is ${actualRecipientDER}`);\n    }\n    const keyID = toBase64(reader.read(32));\n    const encrypted = reader.read(reader.bin.length - reader.pos);\n    const invoiceNumber = `2-message encryption-${keyID}`;\n    const signingPriv = sender.deriveChild(recipient, invoiceNumber);\n    const recipientPub = recipient.deriveChild(sender, invoiceNumber);\n    const sharedSecret = signingPriv.deriveSharedSecret(recipientPub);\n    const symmetricKey = new SymmetricKey(sharedSecret.encode(true).slice(1));\n    return symmetricKey.decrypt(encrypted) as number[];\n}\n</code></pre> <p>See also: PrivateKey, PublicKey, Reader, SymmetricKey, encode, toBase64, toHex</p> <p>Links: API, Interfaces, Classes, Functions, Variables</p>"},{"location":"reference/messages/#variable-encrypt","title":"Variable: encrypt","text":"<pre><code>encrypt = (message: number[], sender: PrivateKey, recipient: PublicKey): number[] =&gt; {\n    const keyID = Random(32);\n    const keyIDBase64 = toBase64(keyID);\n    const invoiceNumber = `2-message encryption-${keyIDBase64}`;\n    const signingPriv = sender.deriveChild(recipient, invoiceNumber);\n    const recipientPub = recipient.deriveChild(sender, invoiceNumber);\n    const sharedSecret = signingPriv.deriveSharedSecret(recipientPub);\n    const symmetricKey = new SymmetricKey(sharedSecret.encode(true).slice(1));\n    const encrypted = symmetricKey.encrypt(message) as number[];\n    const senderPublicKey = sender.toPublicKey().encode(true);\n    const version = toArray(VERSION, \"hex\");\n    return [\n        ...version,\n        ...senderPublicKey,\n        ...recipient.encode(true),\n        ...keyID,\n        ...encrypted\n    ];\n}\n</code></pre> <p>See also: PrivateKey, PublicKey, SymmetricKey, encode, toArray, toBase64</p> <p>Links: API, Interfaces, Classes, Functions, Variables</p>"},{"location":"reference/messages/#variable-sign","title":"Variable: sign","text":"<pre><code>sign = (message: number[], signer: PrivateKey, verifier?: PublicKey): number[] =&gt; {\n    const recipientAnyone = typeof verifier !== \"object\";\n    if (recipientAnyone) {\n        const curve = new Curve();\n        const anyone = new PrivateKey(1);\n        const anyonePoint = curve.g.mul(anyone);\n        verifier = new PublicKey(anyonePoint.x, anyonePoint.y);\n    }\n    const keyID = Random(32);\n    const keyIDBase64 = toBase64(keyID);\n    const invoiceNumber = `2-message signing-${keyIDBase64}`;\n    const signingKey = signer.deriveChild(verifier, invoiceNumber);\n    const signature = signingKey.sign(message).toDER();\n    const senderPublicKey = signer.toPublicKey().encode(true);\n    const version = toArray(VERSION, \"hex\");\n    return [\n        ...version,\n        ...senderPublicKey,\n        ...(recipientAnyone ? [0] : verifier.encode(true)),\n        ...keyID,\n        ...signature\n    ];\n}\n</code></pre> <p>See also: Curve, PrivateKey, PublicKey, encode, toArray, toBase64</p> <p>Links: API, Interfaces, Classes, Functions, Variables</p>"},{"location":"reference/messages/#variable-verify","title":"Variable: verify","text":"<pre><code>verify = (message: number[], sig: number[], recipient?: PrivateKey): boolean =&gt; {\n    const reader = new Reader(sig);\n    const messageVersion = toHex(reader.read(4));\n    if (messageVersion !== VERSION) {\n        throw new Error(`Message version mismatch: Expected ${VERSION}, received ${messageVersion}`);\n    }\n    const signer = PublicKey.fromString(toHex(reader.read(33)));\n    const [verifierFirst] = reader.read(1);\n    if (verifierFirst === 0) {\n        recipient = new PrivateKey(1);\n    }\n    else {\n        const verifierRest = reader.read(32);\n        const verifierDER = toHex([verifierFirst, ...verifierRest]);\n        if (typeof recipient !== \"object\") {\n            throw new Error(`This signature can only be verified with knowledge of a specific private key. The associated public key is: ${verifierDER}`);\n        }\n        const recipientDER = recipient.toPublicKey().encode(true, \"hex\") as string;\n        if (verifierDER !== recipientDER) {\n            throw new Error(`The recipient public key is ${recipientDER} but the signature requres the recipient to have public key ${verifierDER}`);\n        }\n    }\n    const keyID = toBase64(reader.read(32));\n    const signatureDER = toHex(reader.read(reader.bin.length - reader.pos));\n    const signature = Signature.fromDER(signatureDER, \"hex\");\n    const invoiceNumber = `2-message signing-${keyID}`;\n    const signingKey = signer.deriveChild(recipient, invoiceNumber);\n    const verified = signingKey.verify(message, signature);\n    return verified;\n}\n</code></pre> <p>See also: PrivateKey, PublicKey, Reader, Signature, encode, toBase64, toHex</p> <p>Links: API, Interfaces, Classes, Functions, Variables</p>"},{"location":"reference/network-config/","title":"Network Configuration Reference","text":"<p>Complete reference for configuring network settings, chain trackers, and blockchain connectivity in the BSV TypeScript SDK.</p>"},{"location":"reference/network-config/#network-configuration-interface","title":"Network Configuration Interface","text":""},{"location":"reference/network-config/#networkconfig","title":"NetworkConfig","text":"<pre><code>interface NetworkConfig {\n  name: string\n  network: 'mainnet' | 'testnet' | 'regtest'\n  chainTracker: ChainTrackerConfig\n  feeModel: FeeModelConfig\n  limits: NetworkLimits\n  endpoints: NetworkEndpoints\n  security: NetworkSecurity\n  monitoring: NetworkMonitoring\n}\n</code></pre>"},{"location":"reference/network-config/#chaintrackerconfig","title":"ChainTrackerConfig","text":"<pre><code>interface ChainTrackerConfig {\n  provider: 'whatsonchain' | 'blockchair' | 'custom'\n  url?: string\n  apiKey?: string\n  timeout: number\n  retries: number\n  retryDelay: number\n  fallbacks: ChainTrackerFallback[]\n  caching: ChainTrackerCaching\n  spv: SPVConfig\n}\n\ninterface ChainTrackerFallback {\n  provider: string\n  url: string\n  apiKey?: string\n  priority: number\n  healthCheck: boolean\n}\n\ninterface ChainTrackerCaching {\n  enabled: boolean\n  ttl: number // Time to live in milliseconds\n  maxSize: number // Maximum cache entries\n  storage: 'memory' | 'localStorage' | 'custom'\n}\n\ninterface SPVConfig {\n  enabled: boolean\n  maxDepth: number\n  requiredConfirmations: number\n  merkleProofValidation: boolean\n  headerValidation: boolean\n}\n</code></pre>"},{"location":"reference/network-config/#networkendpoints","title":"NetworkEndpoints","text":"<pre><code>interface NetworkEndpoints {\n  // Block and transaction data\n  blocks: string\n  transactions: string\n  utxos: string\n  balance: string\n  history: string\n\n  // Mempool and broadcasting\n  mempool: string\n  broadcast: string\n  fees: string\n\n  // Chain information\n  chainInfo: string\n  blockHeight: string\n  difficulty: string\n\n  // WebSocket endpoints\n  websocket?: {\n    blocks: string\n    transactions: string\n    mempool: string\n  }\n}\n</code></pre>"},{"location":"reference/network-config/#networklimits","title":"NetworkLimits","text":"<pre><code>interface NetworkLimits {\n  maxBlockSize: number\n  maxTransactionSize: number\n  maxScriptSize: number\n  maxInputs: number\n  maxOutputs: number\n  maxSigOps: number\n  dustThreshold: number\n\n  // Rate limiting\n  requestsPerSecond: number\n  requestsPerMinute: number\n  requestsPerHour: number\n\n  // Connection limits\n  maxConcurrentRequests: number\n  maxRetries: number\n  backoffMultiplier: number\n}\n</code></pre>"},{"location":"reference/network-config/#networksecurity","title":"NetworkSecurity","text":"<pre><code>interface NetworkSecurity {\n  ssl: {\n    enabled: boolean\n    validateCertificates: boolean\n    allowSelfSigned: boolean\n  }\n\n  authentication: {\n    required: boolean\n    type: 'apiKey' | 'bearer' | 'basic'\n    credentials: Record&lt;string, string&gt;\n  }\n\n  rateLimit: {\n    enabled: boolean\n    windowMs: number\n    maxRequests: number\n    skipSuccessfulRequests: boolean\n  }\n\n  cors: {\n    enabled: boolean\n    origins: string[]\n    methods: string[]\n    headers: string[]\n  }\n}\n</code></pre>"},{"location":"reference/network-config/#predefined-network-configurations","title":"Predefined Network Configurations","text":""},{"location":"reference/network-config/#mainnet-configuration","title":"Mainnet Configuration","text":"<pre><code>const MAINNET_CONFIG: NetworkConfig = {\n  name: 'Bitcoin SV Mainnet',\n  network: 'mainnet',\n  chainTracker: {\n    provider: 'whatsonchain',\n    url: 'https://api.whatsonchain.com/v1/bsv/main',\n    timeout: 30000,\n    retries: 3,\n    retryDelay: 1000,\n    fallbacks: [\n      {\n        provider: 'blockchair',\n        url: 'https://api.blockchair.com/bitcoin-sv',\n        priority: 1,\n        healthCheck: true\n      }\n    ],\n    caching: {\n      enabled: true,\n      ttl: 300000, // 5 minutes\n      maxSize: 1000,\n      storage: 'memory'\n    },\n    spv: {\n      enabled: true,\n      maxDepth: 6,\n      requiredConfirmations: 6,\n      merkleProofValidation: true,\n      headerValidation: true\n    }\n  },\n  feeModel: {\n    standard: 0.5, // satoshis per byte\n    data: 0.25,\n    priority: 1.0\n  },\n  limits: {\n    maxBlockSize: 4000000000, // 4GB\n    maxTransactionSize: 100000000, // 100MB\n    maxScriptSize: 10000,\n    maxInputs: 100000,\n    maxOutputs: 100000,\n    maxSigOps: 4000000,\n    dustThreshold: 546,\n    requestsPerSecond: 10,\n    requestsPerMinute: 600,\n    requestsPerHour: 36000,\n    maxConcurrentRequests: 5,\n    maxRetries: 3,\n    backoffMultiplier: 2\n  },\n  endpoints: {\n    blocks: '/block',\n    transactions: '/tx',\n    utxos: '/address/{address}/unspent',\n    balance: '/address/{address}/balance',\n    history: '/address/{address}/history',\n    mempool: '/mempool',\n    broadcast: '/tx/raw',\n    fees: '/fees',\n    chainInfo: '/chain/info',\n    blockHeight: '/chain/info',\n    difficulty: '/chain/info'\n  },\n  security: {\n    ssl: {\n      enabled: true,\n      validateCertificates: true,\n      allowSelfSigned: false\n    },\n    authentication: {\n      required: false,\n      type: 'apiKey',\n      credentials: {}\n    },\n    rateLimit: {\n      enabled: true,\n      windowMs: 60000,\n      maxRequests: 100,\n      skipSuccessfulRequests: false\n    },\n    cors: {\n      enabled: false,\n      origins: [],\n      methods: ['GET', 'POST'],\n      headers: ['Content-Type', 'Authorization']\n    }\n  },\n  monitoring: {\n    enabled: true,\n    healthCheck: {\n      interval: 60000,\n      timeout: 10000,\n      endpoints: ['chainInfo', 'fees']\n    },\n    metrics: {\n      enabled: true,\n      collectInterval: 30000,\n      retentionPeriod: 86400000 // 24 hours\n    }\n  }\n}\n</code></pre>"},{"location":"reference/network-config/#testnet-configuration","title":"Testnet Configuration","text":"<pre><code>const TESTNET_CONFIG: NetworkConfig = {\n  name: 'Bitcoin SV Testnet',\n  network: 'testnet',\n  chainTracker: {\n    provider: 'whatsonchain',\n    url: 'https://api.whatsonchain.com/v1/bsv/test',\n    timeout: 30000,\n    retries: 3,\n    retryDelay: 1000,\n    fallbacks: [],\n    caching: {\n      enabled: true,\n      ttl: 300000,\n      maxSize: 500,\n      storage: 'memory'\n    },\n    spv: {\n      enabled: true,\n      maxDepth: 3, // Shorter for testnet\n      requiredConfirmations: 3,\n      merkleProofValidation: true,\n      headerValidation: true\n    }\n  },\n  feeModel: {\n    standard: 0.1, // Lower fees for testnet\n    data: 0.05,\n    priority: 0.2\n  },\n  limits: {\n    maxBlockSize: 4000000000,\n    maxTransactionSize: 100000000,\n    maxScriptSize: 10000,\n    maxInputs: 100000,\n    maxOutputs: 100000,\n    maxSigOps: 4000000,\n    dustThreshold: 546,\n    requestsPerSecond: 20, // Higher limits for testing\n    requestsPerMinute: 1200,\n    requestsPerHour: 72000,\n    maxConcurrentRequests: 10,\n    maxRetries: 5,\n    backoffMultiplier: 1.5\n  },\n  endpoints: {\n    blocks: '/block',\n    transactions: '/tx',\n    utxos: '/address/{address}/unspent',\n    balance: '/address/{address}/balance',\n    history: '/address/{address}/history',\n    mempool: '/mempool',\n    broadcast: '/tx/raw',\n    fees: '/fees',\n    chainInfo: '/chain/info',\n    blockHeight: '/chain/info',\n    difficulty: '/chain/info'\n  },\n  security: {\n    ssl: {\n      enabled: true,\n      validateCertificates: true,\n      allowSelfSigned: false\n    },\n    authentication: {\n      required: false,\n      type: 'apiKey',\n      credentials: {}\n    },\n    rateLimit: {\n      enabled: false, // Disabled for testing\n      windowMs: 60000,\n      maxRequests: 1000,\n      skipSuccessfulRequests: true\n    },\n    cors: {\n      enabled: true, // Enabled for development\n      origins: ['*'],\n      methods: ['GET', 'POST', 'OPTIONS'],\n      headers: ['*']\n    }\n  },\n  monitoring: {\n    enabled: true,\n    healthCheck: {\n      interval: 30000,\n      timeout: 5000,\n      endpoints: ['chainInfo']\n    },\n    metrics: {\n      enabled: true,\n      collectInterval: 60000,\n      retentionPeriod: 43200000 // 12 hours\n    }\n  }\n}\n</code></pre>"},{"location":"reference/network-config/#regtest-configuration","title":"RegTest Configuration","text":"<pre><code>const REGTEST_CONFIG: NetworkConfig = {\n  name: 'Bitcoin SV RegTest',\n  network: 'regtest',\n  chainTracker: {\n    provider: 'custom',\n    url: 'http://localhost:18332',\n    timeout: 5000,\n    retries: 1,\n    retryDelay: 500,\n    fallbacks: [],\n    caching: {\n      enabled: false, // Disabled for local testing\n      ttl: 0,\n      maxSize: 0,\n      storage: 'memory'\n    },\n    spv: {\n      enabled: false, // Disabled for regtest\n      maxDepth: 1,\n      requiredConfirmations: 1,\n      merkleProofValidation: false,\n      headerValidation: false\n    }\n  },\n  feeModel: {\n    standard: 0.01, // Minimal fees for regtest\n    data: 0.01,\n    priority: 0.01\n  },\n  limits: {\n    maxBlockSize: 4000000000,\n    maxTransactionSize: 100000000,\n    maxScriptSize: 10000,\n    maxInputs: 100000,\n    maxOutputs: 100000,\n    maxSigOps: 4000000,\n    dustThreshold: 546,\n    requestsPerSecond: 1000, // No limits for local testing\n    requestsPerMinute: 60000,\n    requestsPerHour: 3600000,\n    maxConcurrentRequests: 100,\n    maxRetries: 1,\n    backoffMultiplier: 1\n  },\n  endpoints: {\n    blocks: '/rest/block',\n    transactions: '/rest/tx',\n    utxos: '/rest/getutxos',\n    balance: '/rest/balance',\n    history: '/rest/history',\n    mempool: '/rest/mempool',\n    broadcast: '/rest/tx',\n    fees: '/rest/fees',\n    chainInfo: '/rest/chaininfo',\n    blockHeight: '/rest/chaininfo',\n    difficulty: '/rest/chaininfo'\n  },\n  security: {\n    ssl: {\n      enabled: false, // HTTP for local development\n      validateCertificates: false,\n      allowSelfSigned: true\n    },\n    authentication: {\n      required: true,\n      type: 'basic',\n      credentials: {\n        username: 'rpcuser',\n        password: 'rpcpassword'\n      }\n    },\n    rateLimit: {\n      enabled: false,\n      windowMs: 0,\n      maxRequests: 0,\n      skipSuccessfulRequests: true\n    },\n    cors: {\n      enabled: true,\n      origins: ['*'],\n      methods: ['*'],\n      headers: ['*']\n    }\n  },\n  monitoring: {\n    enabled: false, // Disabled for local testing\n    healthCheck: {\n      interval: 0,\n      timeout: 0,\n      endpoints: []\n    },\n    metrics: {\n      enabled: false,\n      collectInterval: 0,\n      retentionPeriod: 0\n    }\n  }\n}\n</code></pre>"},{"location":"reference/network-config/#network-configuration-builder","title":"Network Configuration Builder","text":""},{"location":"reference/network-config/#networkconfigbuilder-class","title":"NetworkConfigBuilder Class","text":"<pre><code>class NetworkConfigBuilder {\n  private config: Partial&lt;NetworkConfig&gt; = {}\n\n  name(name: string): NetworkConfigBuilder {\n    this.config.name = name\n    return this\n  }\n\n  network(network: 'mainnet' | 'testnet' | 'regtest'): NetworkConfigBuilder {\n    this.config.network = network\n    return this\n  }\n\n  chainTracker(config: Partial&lt;ChainTrackerConfig&gt;): NetworkConfigBuilder {\n    this.config.chainTracker = { ...this.config.chainTracker, ...config }\n    return this\n  }\n\n  feeModel(config: FeeModelConfig): NetworkConfigBuilder {\n    this.config.feeModel = config\n    return this\n  }\n\n  limits(config: Partial&lt;NetworkLimits&gt;): NetworkConfigBuilder {\n    this.config.limits = { ...this.config.limits, ...config }\n    return this\n  }\n\n  endpoints(config: Partial&lt;NetworkEndpoints&gt;): NetworkConfigBuilder {\n    this.config.endpoints = { ...this.config.endpoints, ...config }\n    return this\n  }\n\n  security(config: Partial&lt;NetworkSecurity&gt;): NetworkConfigBuilder {\n    this.config.security = { ...this.config.security, ...config }\n    return this\n  }\n\n  monitoring(config: Partial&lt;NetworkMonitoring&gt;): NetworkConfigBuilder {\n    this.config.monitoring = { ...this.config.monitoring, ...config }\n    return this\n  }\n\n  build(): NetworkConfig {\n    // Apply defaults based on network type\n    const defaults = this.getNetworkDefaults(this.config.network || 'mainnet')\n\n    return {\n      ...defaults,\n      ...this.config,\n      chainTracker: { ...defaults.chainTracker, ...this.config.chainTracker },\n      limits: { ...defaults.limits, ...this.config.limits },\n      endpoints: { ...defaults.endpoints, ...this.config.endpoints },\n      security: { ...defaults.security, ...this.config.security },\n      monitoring: { ...defaults.monitoring, ...this.config.monitoring }\n    } as NetworkConfig\n  }\n\n  private getNetworkDefaults(network: string): NetworkConfig {\n    switch (network) {\n      case 'mainnet':\n        return MAINNET_CONFIG\n      case 'testnet':\n        return TESTNET_CONFIG\n      case 'regtest':\n        return REGTEST_CONFIG\n      default:\n        return MAINNET_CONFIG\n    }\n  }\n}\n</code></pre>"},{"location":"reference/network-config/#usage-examples","title":"Usage Examples","text":"<pre><code>// Basic network configuration\nconst basicNetwork = new NetworkConfigBuilder()\n  .name('Custom Mainnet')\n  .network('mainnet')\n  .chainTracker({\n    provider: 'whatsonchain',\n    timeout: 15000\n  })\n  .build()\n\n// Custom network with fallbacks\nconst robustNetwork = new NetworkConfigBuilder()\n  .name('Production Mainnet')\n  .network('mainnet')\n  .chainTracker({\n    provider: 'whatsonchain',\n    url: 'https://api.whatsonchain.com/v1/bsv/main',\n    timeout: 30000,\n    retries: 3,\n    fallbacks: [\n      {\n        provider: 'blockchair',\n        url: 'https://api.blockchair.com/bitcoin-sv',\n        priority: 1,\n        healthCheck: true\n      },\n      {\n        provider: 'custom',\n        url: 'https://custom-api.example.com',\n        apiKey: 'your-api-key',\n        priority: 2,\n        healthCheck: true\n      }\n    ]\n  })\n  .security({\n    ssl: { enabled: true, validateCertificates: true },\n    rateLimit: { enabled: true, windowMs: 60000, maxRequests: 100 }\n  })\n  .monitoring({\n    enabled: true,\n    healthCheck: { interval: 30000, timeout: 5000 }\n  })\n  .build()\n</code></pre>"},{"location":"reference/network-config/#chain-tracker-management","title":"Chain Tracker Management","text":""},{"location":"reference/network-config/#chaintracker-interface","title":"ChainTracker Interface","text":"<pre><code>interface ChainTracker {\n  config: ChainTrackerConfig\n\n  // Block operations\n  getBlock(hash: string): Promise&lt;Block&gt;\n  getBlockHeader(hash: string): Promise&lt;BlockHeader&gt;\n  getBlockHeight(): Promise&lt;number&gt;\n\n  // Transaction operations\n  getTransaction(txid: string): Promise&lt;Transaction&gt;\n  getTransactionStatus(txid: string): Promise&lt;TransactionStatus&gt;\n  getRawTransaction(txid: string): Promise&lt;string&gt;\n\n  // UTXO operations\n  getUTXOs(address: string): Promise&lt;UTXO[]&gt;\n  getBalance(address: string): Promise&lt;number&gt;\n  getHistory(address: string): Promise&lt;TransactionHistory[]&gt;\n\n  // Broadcasting\n  broadcast(rawTx: string): Promise&lt;BroadcastResult&gt;\n\n  // Mempool\n  getMempoolInfo(): Promise&lt;MempoolInfo&gt;\n  getMempoolTransactions(): Promise&lt;string[]&gt;\n\n  // Health and status\n  getHealth(): Promise&lt;HealthStatus&gt;\n  isConnected(): boolean\n}\n</code></pre>"},{"location":"reference/network-config/#multi-provider-chain-tracker","title":"Multi-Provider Chain Tracker","text":"<pre><code>class MultiProviderChainTracker implements ChainTracker {\n  private providers: ChainTracker[]\n  private currentProvider = 0\n  private healthStatus = new Map&lt;string, boolean&gt;()\n\n  constructor(\n    public config: ChainTrackerConfig,\n    providers: ChainTracker[]\n  ) {\n    this.providers = providers\n    this.startHealthChecks()\n  }\n\n  async getTransaction(txid: string): Promise&lt;Transaction&gt; {\n    const provider = this.selectProvider()\n\n    try {\n      return await provider.getTransaction(txid)\n    } catch (error) {\n      this.markProviderUnhealthy(provider)\n\n      if (this.hasHealthyProviders()) {\n        return this.getTransaction(txid) // Retry with different provider\n      }\n\n      throw error\n    }\n  }\n\n  async broadcast(rawTx: string): Promise&lt;BroadcastResult&gt; {\n    const errors: Error[] = []\n\n    // Try all healthy providers for broadcasting\n    for (const provider of this.getHealthyProviders()) {\n      try {\n        return await provider.broadcast(rawTx)\n      } catch (error) {\n        errors.push(error as Error)\n        this.markProviderUnhealthy(provider)\n      }\n    }\n\n    throw new Error(`Broadcast failed on all providers: ${errors.map(e =&gt; e.message).join(', ')}`)\n  }\n\n  private selectProvider(): ChainTracker {\n    const healthyProviders = this.getHealthyProviders()\n\n    if (healthyProviders.length === 0) {\n      return this.providers[0] // Fallback to first provider\n    }\n\n    // Round-robin selection\n    const provider = healthyProviders[this.currentProvider % healthyProviders.length]\n    this.currentProvider++\n    return provider\n  }\n\n  private getHealthyProviders(): ChainTracker[] {\n    return this.providers.filter(provider =&gt; \n      this.healthStatus.get(this.getProviderId(provider)) !== false\n    )\n  }\n\n  private markProviderUnhealthy(provider: ChainTracker): void {\n    this.healthStatus.set(this.getProviderId(provider), false)\n  }\n\n  private getProviderId(provider: ChainTracker): string {\n    return provider.config.url || provider.config.provider\n  }\n\n  private startHealthChecks(): void {\n    setInterval(async () =&gt; {\n      for (const provider of this.providers) {\n        try {\n          await provider.getHealth()\n          this.healthStatus.set(this.getProviderId(provider), true)\n        } catch (error) {\n          this.healthStatus.set(this.getProviderId(provider), false)\n        }\n      }\n    }, 60000) // Check every minute\n  }\n\n  // Implement other ChainTracker methods...\n  async getBlock(hash: string): Promise&lt;Block&gt; {\n    const provider = this.selectProvider()\n    return provider.getBlock(hash)\n  }\n\n  async getUTXOs(address: string): Promise&lt;UTXO[]&gt; {\n    const provider = this.selectProvider()\n    return provider.getUTXOs(address)\n  }\n\n  async getHealth(): Promise&lt;HealthStatus&gt; {\n    const healthyCount = this.getHealthyProviders().length\n    const totalCount = this.providers.length\n\n    return {\n      status: healthyCount &gt; 0 ? 'healthy' : 'unhealthy',\n      providers: {\n        healthy: healthyCount,\n        total: totalCount,\n        percentage: (healthyCount / totalCount) * 100\n      },\n      timestamp: Date.now()\n    }\n  }\n\n  isConnected(): boolean {\n    return this.getHealthyProviders().length &gt; 0\n  }\n}\n</code></pre>"},{"location":"reference/network-config/#environment-based-network-configuration","title":"Environment-Based Network Configuration","text":""},{"location":"reference/network-config/#environment-configuration-loader","title":"Environment Configuration Loader","text":"<pre><code>class NetworkEnvironmentConfig {\n  static fromEnvironment(): NetworkConfig {\n    const network = (process.env.BSV_NETWORK || 'mainnet') as 'mainnet' | 'testnet' | 'regtest'\n    const baseConfig = NetworkEnvironmentConfig.getBaseConfig(network)\n\n    // Override with environment variables\n    if (process.env.BSV_CHAIN_TRACKER_URL) {\n      baseConfig.chainTracker.url = process.env.BSV_CHAIN_TRACKER_URL\n    }\n\n    if (process.env.BSV_CHAIN_TRACKER_API_KEY) {\n      baseConfig.chainTracker.apiKey = process.env.BSV_CHAIN_TRACKER_API_KEY\n    }\n\n    if (process.env.BSV_CHAIN_TRACKER_TIMEOUT) {\n      baseConfig.chainTracker.timeout = parseInt(process.env.BSV_CHAIN_TRACKER_TIMEOUT)\n    }\n\n    // Fee model overrides\n    if (process.env.BSV_FEE_STANDARD) {\n      baseConfig.feeModel.standard = parseFloat(process.env.BSV_FEE_STANDARD)\n    }\n\n    if (process.env.BSV_FEE_DATA) {\n      baseConfig.feeModel.data = parseFloat(process.env.BSV_FEE_DATA)\n    }\n\n    // Security overrides\n    if (process.env.BSV_SSL_ENABLED) {\n      baseConfig.security.ssl.enabled = process.env.BSV_SSL_ENABLED === 'true'\n    }\n\n    if (process.env.BSV_RATE_LIMIT_ENABLED) {\n      baseConfig.security.rateLimit.enabled = process.env.BSV_RATE_LIMIT_ENABLED === 'true'\n    }\n\n    return baseConfig\n  }\n\n  private static getBaseConfig(network: string): NetworkConfig {\n    switch (network) {\n      case 'mainnet':\n        return { ...MAINNET_CONFIG }\n      case 'testnet':\n        return { ...TESTNET_CONFIG }\n      case 'regtest':\n        return { ...REGTEST_CONFIG }\n      default:\n        return { ...MAINNET_CONFIG }\n    }\n  }\n\n  static validate(config: NetworkConfig): void {\n    if (!config.name) {\n      throw new Error('Network name is required')\n    }\n\n    if (!config.network) {\n      throw new Error('Network type is required')\n    }\n\n    if (!config.chainTracker.url &amp;&amp; config.chainTracker.provider === 'custom') {\n      throw new Error('Chain tracker URL is required for custom provider')\n    }\n\n    if (config.chainTracker.timeout &lt; 1000) {\n      throw new Error('Chain tracker timeout must be at least 1000ms')\n    }\n\n    if (config.limits.maxTransactionSize &gt; config.limits.maxBlockSize) {\n      throw new Error('Max transaction size cannot exceed max block size')\n    }\n\n    if (config.security.ssl.enabled &amp;&amp; !config.chainTracker.url?.startsWith('https')) {\n      console.warn('SSL is enabled but chain tracker URL is not HTTPS')\n    }\n  }\n}\n</code></pre>"},{"location":"reference/network-config/#network-configuration-best-practices","title":"Network Configuration Best Practices","text":""},{"location":"reference/network-config/#production-configuration","title":"Production Configuration","text":"<pre><code>const productionConfig = new NetworkConfigBuilder()\n  .name('Production Mainnet')\n  .network('mainnet')\n  .chainTracker({\n    provider: 'whatsonchain',\n    timeout: 30000,\n    retries: 3,\n    retryDelay: 2000,\n    fallbacks: [\n      {\n        provider: 'blockchair',\n        url: 'https://api.blockchair.com/bitcoin-sv',\n        priority: 1,\n        healthCheck: true\n      }\n    ],\n    caching: {\n      enabled: true,\n      ttl: 300000, // 5 minutes\n      maxSize: 10000,\n      storage: 'memory'\n    }\n  })\n  .security({\n    ssl: {\n      enabled: true,\n      validateCertificates: true,\n      allowSelfSigned: false\n    },\n    rateLimit: {\n      enabled: true,\n      windowMs: 60000,\n      maxRequests: 100\n    }\n  })\n  .monitoring({\n    enabled: true,\n    healthCheck: {\n      interval: 30000,\n      timeout: 10000,\n      endpoints: ['chainInfo', 'fees']\n    },\n    metrics: {\n      enabled: true,\n      collectInterval: 60000,\n      retentionPeriod: 86400000\n    }\n  })\n  .build()\n</code></pre>"},{"location":"reference/network-config/#development-configuration","title":"Development Configuration","text":"<pre><code>const developmentConfig = new NetworkConfigBuilder()\n  .name('Development Testnet')\n  .network('testnet')\n  .chainTracker({\n    provider: 'whatsonchain',\n    timeout: 15000,\n    retries: 5,\n    caching: {\n      enabled: false // Disable caching for development\n    }\n  })\n  .security({\n    ssl: { enabled: true },\n    rateLimit: { enabled: false }, // Disable rate limiting for development\n    cors: {\n      enabled: true,\n      origins: ['*'],\n      methods: ['*'],\n      headers: ['*']\n    }\n  })\n  .monitoring({\n    enabled: true,\n    healthCheck: { interval: 10000, timeout: 5000 }\n  })\n  .build()\n</code></pre> <p>This comprehensive network configuration reference provides developers with all the tools needed to effectively configure and manage network connectivity in their BSV TypeScript SDK applications.</p>"},{"location":"reference/op-codes/","title":"OP Codes","text":"<p>Understanding Bitcoin script opcodes and their usage in the BSV TypeScript SDK.</p>"},{"location":"reference/op-codes/#what-are-op-codes","title":"What are OP Codes?","text":"<p>OP codes (operation codes) are the fundamental building blocks of Bitcoin's scripting language. They are operational instructions that manipulate data on the script execution stack to define the conditions under which Bitcoin can be spent. Each opcode performs a specific function such as arithmetic operations, logical comparisons, cryptographic operations, or stack manipulation.</p>"},{"location":"reference/op-codes/#script-execution-environment","title":"Script Execution Environment","text":"<p>Bitcoin scripts operate in a stack-based execution environment with two primary data structures:</p> <ul> <li>Main Stack: Where most operations are performed</li> <li>Alt Stack: Provides additional stack flexibility for complex operations</li> </ul> <p>Scripts consist of two parts:</p> <ol> <li>Unlocking Script: Provided by the spender, supplies data to satisfy locking conditions</li> <li>Locking Script: Defines the conditions that must be met to spend the output</li> </ol> <p>The execution begins with the unlocking script placing data on the stack, followed by the locking script operating on the same stack. A spend is valid if the top of the stack contains a \"true\" value (non-zero) after execution.</p>"},{"location":"reference/op-codes/#sdk-integration","title":"SDK Integration","text":"<p>The BSV TypeScript SDK provides comprehensive opcode support through the <code>OP</code> object and script execution engine:</p> <pre><code>import { OP, Script, LockingScript, UnlockingScript } from '@bsv/sdk'\n\n// Access opcodes by name\nconsole.log(OP.OP_DUP)        // 0x76\nconsole.log(OP.OP_HASH160)    // 0xa9\nconsole.log(OP.OP_CHECKSIG)   // 0xac\n\n// Create scripts using opcodes\nconst lockingScript = new LockingScript([\n  { op: OP.OP_DUP },\n  { op: OP.OP_HASH160 },\n  { op: 20, data: publicKeyHash }, // Push 20 bytes\n  { op: OP.OP_EQUALVERIFY },\n  { op: OP.OP_CHECKSIG }\n])\n\n// Create from ASM (Assembly) format\nconst script = Script.fromASM('OP_DUP OP_HASH160 ' + publicKeyHash + ' OP_EQUALVERIFY OP_CHECKSIG')\n</code></pre>"},{"location":"reference/op-codes/#opcode-categories","title":"Opcode Categories","text":""},{"location":"reference/op-codes/#push-operations","title":"Push Operations","text":"<p>Push data onto the stack:</p> <pre><code>// Push small numbers (0-16)\nOP.OP_0        // Push empty array (false)\nOP.OP_1        // Push number 1 (true)\nOP.OP_2        // Push number 2\n// ... up to OP_16\n\n// Push data of various sizes\nOP.OP_PUSHDATA1  // Push up to 255 bytes\nOP.OP_PUSHDATA2  // Push up to 65,535 bytes  \nOP.OP_PUSHDATA4  // Push up to 4,294,967,295 bytes\n</code></pre>"},{"location":"reference/op-codes/#stack-operations","title":"Stack Operations","text":"<p>Manipulate stack contents:</p> <pre><code>OP.OP_DUP        // Duplicate top stack item\nOP.OP_DROP       // Remove top stack item\nOP.OP_SWAP       // Swap top two stack items\nOP.OP_ROT        // Rotate top three stack items\nOP.OP_2DUP       // Duplicate top two stack items\nOP.OP_TOALTSTACK // Move item to alt stack\n</code></pre>"},{"location":"reference/op-codes/#arithmetic-operations","title":"Arithmetic Operations","text":"<p>Perform mathematical operations:</p> <pre><code>OP.OP_ADD        // Add top two stack items\nOP.OP_SUB        // Subtract second from top\nOP.OP_MUL        // Multiply top two items\nOP.OP_DIV        // Divide second by top\nOP.OP_MOD        // Modulo operation\nOP.OP_MIN        // Return minimum of two values\nOP.OP_MAX        // Return maximum of two values\n</code></pre>"},{"location":"reference/op-codes/#comparison-operations","title":"Comparison Operations","text":"<p>Compare values and return boolean results:</p> <pre><code>OP.OP_EQUAL         // Check if top two items are equal\nOP.OP_EQUALVERIFY   // Equal check + verify (fail if false)\nOP.OP_NUMEQUAL      // Numeric equality check\nOP.OP_LESSTHAN      // Check if second &lt; top\nOP.OP_GREATERTHAN   // Check if second &gt; top\nOP.OP_WITHIN        // Check if value is within range\n</code></pre>"},{"location":"reference/op-codes/#cryptographic-operations","title":"Cryptographic Operations","text":"<p>Perform cryptographic functions:</p> <pre><code>OP.OP_SHA1          // SHA-1 hash\nOP.OP_SHA256        // SHA-256 hash\nOP.OP_HASH160       // RIPEMD160(SHA256(x))\nOP.OP_HASH256       // SHA256(SHA256(x))\nOP.OP_CHECKSIG      // Verify signature\nOP.OP_CHECKMULTISIG // Verify multiple signatures\n</code></pre>"},{"location":"reference/op-codes/#control-flow-operations","title":"Control Flow Operations","text":"<p>Control script execution:</p> <pre><code>OP.OP_IF         // Conditional execution\nOP.OP_ELSE       // Alternative branch\nOP.OP_ENDIF      // End conditional\nOP.OP_VERIFY     // Fail if top stack item is false\nOP.OP_RETURN     // Mark output as unspendable\n</code></pre>"},{"location":"reference/op-codes/#common-script-patterns","title":"Common Script Patterns","text":""},{"location":"reference/op-codes/#pay-to-public-key-hash-p2pkh","title":"Pay-to-Public-Key-Hash (P2PKH)","text":"<p>The most common Bitcoin script pattern:</p> <pre><code>// Locking script: OP_DUP OP_HASH160 &lt;pubKeyHash&gt; OP_EQUALVERIFY OP_CHECKSIG\nconst p2pkhLock = new LockingScript([\n  { op: OP.OP_DUP },\n  { op: OP.OP_HASH160 },\n  { op: 20, data: publicKeyHash },\n  { op: OP.OP_EQUALVERIFY },\n  { op: OP.OP_CHECKSIG }\n])\n\n// Unlocking script: &lt;signature&gt; &lt;publicKey&gt;\nconst p2pkhUnlock = new UnlockingScript([\n  { op: signature.length, data: signature },\n  { op: publicKey.length, data: publicKey }\n])\n</code></pre>"},{"location":"reference/op-codes/#data-storage-script","title":"Data Storage Script","text":"<p>Store arbitrary data on the blockchain:</p> <pre><code>// OP_RETURN &lt;data&gt;\nconst dataScript = new LockingScript([\n  { op: OP.OP_RETURN },\n  { op: data.length, data: data }\n])\n</code></pre>"},{"location":"reference/op-codes/#multi-signature-script","title":"Multi-Signature Script","text":"<p>Require multiple signatures:</p> <pre><code>// 2-of-3 multisig: OP_2 &lt;pubKey1&gt; &lt;pubKey2&gt; &lt;pubKey3&gt; OP_3 OP_CHECKMULTISIG\nconst multisigScript = new LockingScript([\n  { op: OP.OP_2 },\n  { op: pubKey1.length, data: pubKey1 },\n  { op: pubKey2.length, data: pubKey2 },\n  { op: pubKey3.length, data: pubKey3 },\n  { op: OP.OP_3 },\n  { op: OP.OP_CHECKMULTISIG }\n])\n</code></pre>"},{"location":"reference/op-codes/#security-considerations","title":"Security Considerations","text":""},{"location":"reference/op-codes/#disabled-opcodes","title":"Disabled Opcodes","text":"<p>Some opcodes are disabled for security reasons:</p> <pre><code>// These opcodes will cause script failure\nOP.OP_2MUL      // Disabled: multiply by 2\nOP.OP_2DIV      // Disabled: divide by 2  \nOP.OP_VERIF     // Disabled: conditional verification\nOP.OP_VERNOTIF  // Disabled: inverse conditional verification\n</code></pre>"},{"location":"reference/op-codes/#best-practices","title":"Best Practices","text":""},{"location":"reference/op-codes/#1-use-script-templates","title":"1. Use Script Templates","text":"<p>Leverage SDK script templates for common patterns:</p> <pre><code>import { P2PKH, MultiSig, RPuzzle } from '@bsv/sdk'\n\n// Use templates instead of manual opcode construction\nconst p2pkh = new P2PKH()\nconst lockingScript = p2pkh.lock(publicKeyHash)\n</code></pre>"},{"location":"reference/op-codes/#2-validate-scripts","title":"2. Validate Scripts","text":"<p>Always validate scripts before use:</p> <pre><code>try {\n  const script = Script.fromASM(asmString)\n  // Script is valid\n} catch (error) {\n  console.error('Invalid script:', error.message)\n}\n</code></pre>"},{"location":"reference/op-codes/#3-handle-execution-errors","title":"3. Handle Execution Errors","text":"<p>Implement proper error handling:</p> <pre><code>const spend = new Spend(params)\ntry {\n  while (!spend.isFinished()) {\n    if (!spend.step()) {\n      throw new Error(`Script execution failed: ${spend.getDebugString()}`)\n    }\n  }\n} catch (error) {\n  console.error('Script execution error:', error.message)\n}\n</code></pre>"},{"location":"reference/op-codes/#common-use-cases","title":"Common Use Cases","text":""},{"location":"reference/op-codes/#1-payment-scripts","title":"1. Payment Scripts","text":"<p>Standard payment to public key hash:</p> <pre><code>const paymentScript = Script.fromASM(`OP_DUP OP_HASH160 ${pubKeyHash} OP_EQUALVERIFY OP_CHECKSIG`)\n</code></pre>"},{"location":"reference/op-codes/#2-data-storage","title":"2. Data Storage","text":"<p>Store application data on-chain:</p> <pre><code>const dataScript = Script.fromASM(`OP_RETURN ${Buffer.from(jsonData).toString('hex')}`)\n</code></pre>"},{"location":"reference/op-codes/#3-smart-contracts","title":"3. Smart Contracts","text":"<p>Create conditional spending logic:</p> <pre><code>const contractScript = Script.fromASM(`\n  OP_IF\n    ${timelock} OP_CHECKLOCKTIMEVERIFY OP_DROP\n    OP_DUP OP_HASH160 ${ownerHash} OP_EQUALVERIFY OP_CHECKSIG\n  OP_ELSE\n    OP_DUP OP_HASH160 ${beneficiaryHash} OP_EQUALVERIFY OP_CHECKSIG\n  OP_ENDIF\n`)\n</code></pre>"},{"location":"reference/op-codes/#4-puzzle-scripts","title":"4. Puzzle Scripts","text":"<p>Create cryptographic puzzles:</p> <pre><code>// Hash puzzle: provide preimage to unlock\nconst puzzleScript = Script.fromASM(`OP_HASH256 ${targetHash} OP_EQUAL`)\n</code></pre>"},{"location":"reference/op-codes/#debugging-scripts","title":"Debugging Scripts","text":""},{"location":"reference/op-codes/#script-execution-tracing","title":"Script Execution Tracing","text":"<p>Monitor script execution step by step:</p> <pre><code>const spend = new Spend(params)\nconsole.log('Initial stack:', spend.getDebugString())\n\nwhile (!spend.isFinished()) {\n  const success = spend.step()\n  console.log('After step:', spend.getDebugString())\n\n  if (!success) {\n    console.log('Execution failed at:', spend.getCurrentOpcode())\n    break\n  }\n}\n</code></pre>"},{"location":"reference/op-codes/#common-debugging-patterns","title":"Common Debugging Patterns","text":"<p>Identify and fix common script issues:</p> <pre><code>// Check stack state\nif (spend.getStackSize() === 0) {\n  console.log('Stack is empty - missing data?')\n}\n\n// Check for script errors\nif (spend.hasError()) {\n  console.log('Script error:', spend.getErrorMessage())\n}\n\n// Verify final state\nif (spend.isSuccess() &amp;&amp; spend.getStackTop() !== 1) {\n  console.log('Script succeeded but top stack value is not true')\n}\n</code></pre> <p>Understanding OP codes enables you to create sophisticated Bitcoin applications with custom spending conditions, smart contracts, and advanced cryptographic protocols using the BSV TypeScript SDK.</p>"},{"location":"reference/overlay-tools/","title":"API","text":"<p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/overlay-tools/#interfaces","title":"Interfaces","text":"AdmittanceInstructions LookupQuestion LookupResolverConfig OverlayBroadcastFacilitator OverlayLookupFacilitator SHIPBroadcasterConfig TaggedBEEF <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/overlay-tools/#interface-admittanceinstructions","title":"Interface: AdmittanceInstructions","text":"<p>Instructs the Overlay Services Engine about which outputs to admit and which previous outputs to retain. Returned by a Topic Manager.</p> <pre><code>export interface AdmittanceInstructions {\n    outputsToAdmit: number[];\n    coinsToRetain: number[];\n    coinsRemoved?: number[];\n}\n</code></pre>"},{"location":"reference/overlay-tools/#property-coinsremoved","title":"Property coinsRemoved","text":"<p>The indices of all inputs from the provided transaction which reference previously-admitted outputs, which are now considered spent and have been removed from the managed topic.</p> <pre><code>coinsRemoved?: number[]\n</code></pre>"},{"location":"reference/overlay-tools/#property-coinstoretain","title":"Property coinsToRetain","text":"<p>The indices of all inputs from the provided transaction which spend previously-admitted outputs that should be retained for historical record-keeping.</p> <pre><code>coinsToRetain: number[]\n</code></pre>"},{"location":"reference/overlay-tools/#property-outputstoadmit","title":"Property outputsToAdmit","text":"<p>The indices of all admissible outputs into the managed topic from the provided transaction.</p> <pre><code>outputsToAdmit: number[]\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/overlay-tools/#interface-lookupquestion","title":"Interface: LookupQuestion","text":"<p>The question asked to the Overlay Services Engine when a consumer of state wishes to look up information.</p> <pre><code>export interface LookupQuestion {\n    service: string;\n    query: unknown;\n}\n</code></pre>"},{"location":"reference/overlay-tools/#property-query","title":"Property query","text":"<p>The query which will be forwarded to the Lookup Service. Its type depends on that prescribed by the Lookup Service employed.</p> <pre><code>query: unknown\n</code></pre>"},{"location":"reference/overlay-tools/#property-service","title":"Property service","text":"<p>The identifier for a Lookup Service which the person asking the question wishes to use.</p> <pre><code>service: string\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/overlay-tools/#interface-lookupresolverconfig","title":"Interface: LookupResolverConfig","text":"<p>Configuration options for the Lookup resolver.</p> <pre><code>export interface LookupResolverConfig {\n    networkPreset?: \"mainnet\" | \"testnet\" | \"local\";\n    facilitator?: OverlayLookupFacilitator;\n    slapTrackers?: string[];\n    hostOverrides?: Record&lt;string, string[]&gt;;\n    additionalHosts?: Record&lt;string, string[]&gt;;\n    cache?: CacheOptions;\n}\n</code></pre> <p>See also: OverlayLookupFacilitator</p>"},{"location":"reference/overlay-tools/#property-additionalhosts","title":"Property additionalHosts","text":"<p>Map of lookup service names to arrays of hosts to use in addition to resolving via SLAP.</p> <pre><code>additionalHosts?: Record&lt;string, string[]&gt;\n</code></pre>"},{"location":"reference/overlay-tools/#property-cache","title":"Property cache","text":"<p>Optional cache tuning.</p> <pre><code>cache?: CacheOptions\n</code></pre>"},{"location":"reference/overlay-tools/#property-facilitator","title":"Property facilitator","text":"<p>The facilitator used to make requests to Overlay Services hosts.</p> <p><pre><code>facilitator?: OverlayLookupFacilitator\n</code></pre> See also: OverlayLookupFacilitator</p>"},{"location":"reference/overlay-tools/#property-hostoverrides","title":"Property hostOverrides","text":"<p>Map of lookup service names to arrays of hosts to use in place of resolving via SLAP.</p> <pre><code>hostOverrides?: Record&lt;string, string[]&gt;\n</code></pre>"},{"location":"reference/overlay-tools/#property-networkpreset","title":"Property networkPreset","text":"<p>The network preset to use, unless other options override it. - mainnet: use mainnet SLAP trackers and HTTPS facilitator - testnet: use testnet SLAP trackers and HTTPS facilitator - local: directly query from localhost:8080 and a facilitator that permits plain HTTP</p> <pre><code>networkPreset?: \"mainnet\" | \"testnet\" | \"local\"\n</code></pre>"},{"location":"reference/overlay-tools/#property-slaptrackers","title":"Property slapTrackers","text":"<p>The list of SLAP trackers queried to resolve Overlay Services hosts for a given lookup service.</p> <pre><code>slapTrackers?: string[]\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/overlay-tools/#interface-overlaybroadcastfacilitator","title":"Interface: OverlayBroadcastFacilitator","text":"<p>Facilitates transaction broadcasts that return STEAK.</p> <pre><code>export interface OverlayBroadcastFacilitator {\n    send: (url: string, taggedBEEF: TaggedBEEF) =&gt; Promise&lt;STEAK&gt;;\n}\n</code></pre> <p>See also: STEAK, TaggedBEEF</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/overlay-tools/#interface-overlaylookupfacilitator","title":"Interface: OverlayLookupFacilitator","text":"<p>Facilitates lookups to URLs that return answers.</p> <pre><code>export interface OverlayLookupFacilitator {\n    lookup: (url: string, question: LookupQuestion, timeout?: number) =&gt; Promise&lt;LookupAnswer&gt;;\n}\n</code></pre> <p>See also: LookupAnswer, LookupQuestion</p>"},{"location":"reference/overlay-tools/#property-lookup","title":"Property lookup","text":"<p>Returns a lookup answer for a lookup question</p> <p><pre><code>lookup: (url: string, question: LookupQuestion, timeout?: number) =&gt; Promise&lt;LookupAnswer&gt;\n</code></pre> See also: LookupAnswer, LookupQuestion</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/overlay-tools/#interface-shipbroadcasterconfig","title":"Interface: SHIPBroadcasterConfig","text":"<p>Configuration options for the SHIP broadcaster.</p> <pre><code>export interface SHIPBroadcasterConfig {\n    networkPreset?: \"mainnet\" | \"testnet\" | \"local\";\n    facilitator?: OverlayBroadcastFacilitator;\n    resolver?: LookupResolver;\n    requireAcknowledgmentFromAllHostsForTopics?: \"all\" | \"any\" | string[];\n    requireAcknowledgmentFromAnyHostForTopics?: \"all\" | \"any\" | string[];\n    requireAcknowledgmentFromSpecificHostsForTopics?: Record&lt;string, \"all\" | \"any\" | string[]&gt;;\n}\n</code></pre> <p>See also: LookupResolver, OverlayBroadcastFacilitator</p>"},{"location":"reference/overlay-tools/#property-facilitator_1","title":"Property facilitator","text":"<p>The facilitator used to make requests to Overlay Services hosts.</p> <p><pre><code>facilitator?: OverlayBroadcastFacilitator\n</code></pre> See also: OverlayBroadcastFacilitator</p>"},{"location":"reference/overlay-tools/#property-networkpreset_1","title":"Property networkPreset","text":"<p>The network preset to use, unless other options override it. - mainnet: use mainnet resolver and HTTPS facilitator - testnet: use testnet resolver and HTTPS facilitator - local: directly send to localhost:8080 and a facilitator that permits plain HTTP</p> <pre><code>networkPreset?: \"mainnet\" | \"testnet\" | \"local\"\n</code></pre>"},{"location":"reference/overlay-tools/#property-requireacknowledgmentfromallhostsfortopics","title":"Property requireAcknowledgmentFromAllHostsForTopics","text":"<p>Determines which topics (all, any, or a specific list) must be present within all STEAKs received from every host for the broadcast to be considered a success. By default, all hosts must acknowledge all topics.</p> <pre><code>requireAcknowledgmentFromAllHostsForTopics?: \"all\" | \"any\" | string[]\n</code></pre>"},{"location":"reference/overlay-tools/#property-requireacknowledgmentfromanyhostfortopics","title":"Property requireAcknowledgmentFromAnyHostForTopics","text":"<p>Determines which topics (all, any, or a specific list) must be present within STEAK received from at least one host for the broadcast to be considered a success.</p> <pre><code>requireAcknowledgmentFromAnyHostForTopics?: \"all\" | \"any\" | string[]\n</code></pre>"},{"location":"reference/overlay-tools/#property-requireacknowledgmentfromspecifichostsfortopics","title":"Property requireAcknowledgmentFromSpecificHostsForTopics","text":"<p>Determines a mapping whose keys are specific hosts and whose values are the topics (all, any, or a specific list) that must be present within the STEAK received by the given hosts, in order for the broadcast to be considered a success.</p> <pre><code>requireAcknowledgmentFromSpecificHostsForTopics?: Record&lt;string, \"all\" | \"any\" | string[]&gt;\n</code></pre>"},{"location":"reference/overlay-tools/#property-resolver","title":"Property resolver","text":"<p>The resolver used to locate suitable hosts with SHIP</p> <p><pre><code>resolver?: LookupResolver\n</code></pre> See also: LookupResolver</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/overlay-tools/#interface-taggedbeef","title":"Interface: TaggedBEEF","text":"<p>Tagged BEEF</p> <pre><code>export interface TaggedBEEF {\n    beef: number[];\n    topics: string[];\n    offChainValues?: number[];\n}\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/overlay-tools/#classes","title":"Classes","text":"HTTPSOverlayBroadcastFacilitator HTTPSOverlayLookupFacilitator LookupResolver OverlayAdminTokenTemplate TopicBroadcaster <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/overlay-tools/#class-httpsoverlaybroadcastfacilitator","title":"Class: HTTPSOverlayBroadcastFacilitator","text":"<pre><code>export class HTTPSOverlayBroadcastFacilitator implements OverlayBroadcastFacilitator {\n    httpClient: typeof fetch;\n    allowHTTP: boolean;\n    constructor(httpClient = fetch, allowHTTP: boolean = false) \n    async send(url: string, taggedBEEF: TaggedBEEF): Promise&lt;STEAK&gt; \n}\n</code></pre> <p>See also: OverlayBroadcastFacilitator, STEAK, TaggedBEEF</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/overlay-tools/#class-httpsoverlaylookupfacilitator","title":"Class: HTTPSOverlayLookupFacilitator","text":"<pre><code>export class HTTPSOverlayLookupFacilitator implements OverlayLookupFacilitator {\n    fetchClient: typeof fetch;\n    allowHTTP: boolean;\n    constructor(httpClient = defaultFetch, allowHTTP: boolean = false) \n    async lookup(url: string, question: LookupQuestion, timeout: number = 5000): Promise&lt;LookupAnswer&gt; \n}\n</code></pre> <p>See also: LookupAnswer, LookupQuestion, OverlayLookupFacilitator</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/overlay-tools/#class-lookupresolver","title":"Class: LookupResolver","text":"<p>Represents a Lookup Resolver.</p> <pre><code>export default class LookupResolver {\n    constructor(config: LookupResolverConfig = {}) \n    async query(question: LookupQuestion, timeout?: number): Promise&lt;LookupAnswer&gt; \n}\n</code></pre> <p>See also: LookupAnswer, LookupQuestion, LookupResolverConfig</p>"},{"location":"reference/overlay-tools/#method-query","title":"Method query","text":"<p>Given a LookupQuestion, returns a LookupAnswer. Aggregates across multiple services and supports resiliency.</p> <p><pre><code>async query(question: LookupQuestion, timeout?: number): Promise&lt;LookupAnswer&gt; \n</code></pre> See also: LookupAnswer, LookupQuestion</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/overlay-tools/#class-overlayadmintokentemplate","title":"Class: OverlayAdminTokenTemplate","text":"<p>Script template enabling the creation, unlocking, and decoding of SHIP and SLAP advertisements.</p> <pre><code>export default class OverlayAdminTokenTemplate implements ScriptTemplate {\n    pushDrop: PushDrop;\n    static decode(script: LockingScript): {\n        protocol: \"SHIP\" | \"SLAP\";\n        identityKey: string;\n        domain: string;\n        topicOrService: string;\n    } \n    constructor(wallet: WalletInterface) \n    async lock(protocol: \"SHIP\" | \"SLAP\", domain: string, topicOrService: string): Promise&lt;LockingScript&gt; \n    unlock(protocol: \"SHIP\" | \"SLAP\"): {\n        sign: (tx: Transaction, inputIndex: number) =&gt; Promise&lt;UnlockingScript&gt;;\n        estimateLength: (tx: Transaction, inputIndex: number) =&gt; Promise&lt;number&gt;;\n    } \n}\n</code></pre> <p>See also: LockingScript, PushDrop, ScriptTemplate, Transaction, UnlockingScript, WalletInterface, sign</p>"},{"location":"reference/overlay-tools/#constructor","title":"Constructor","text":"<p>Constructs a new Overlay Admin template instance</p> <p><pre><code>constructor(wallet: WalletInterface) \n</code></pre> See also: WalletInterface</p> <p>Argument Details</p> <ul> <li>wallet</li> <li>Wallet to use for locking and unlocking</li> </ul>"},{"location":"reference/overlay-tools/#method-decode","title":"Method decode","text":"<p>Decodes a SHIP or SLAP advertisement from a given locking script.</p> <p><pre><code>static decode(script: LockingScript): {\n    protocol: \"SHIP\" | \"SLAP\";\n    identityKey: string;\n    domain: string;\n    topicOrService: string;\n} \n</code></pre> See also: LockingScript</p> <p>Returns</p> <p>Decoded SHIP or SLAP advertisement</p> <p>Argument Details</p> <ul> <li>script</li> <li>Locking script comprising a SHIP or SLAP token to decode</li> </ul>"},{"location":"reference/overlay-tools/#method-lock","title":"Method lock","text":"<p>Creates a new advertisement locking script</p> <p><pre><code>async lock(protocol: \"SHIP\" | \"SLAP\", domain: string, topicOrService: string): Promise&lt;LockingScript&gt; \n</code></pre> See also: LockingScript</p> <p>Returns</p> <p>Locking script comprising the advertisement token</p> <p>Argument Details</p> <ul> <li>protocol</li> <li>SHIP or SLAP</li> <li>domain</li> <li>Domain where the topic or service is available</li> <li>topicOrService</li> <li>Topic or service to advertise</li> </ul>"},{"location":"reference/overlay-tools/#method-unlock","title":"Method unlock","text":"<p>Unlocks an advertisement token as part of a transaction.</p> <p><pre><code>unlock(protocol: \"SHIP\" | \"SLAP\"): {\n    sign: (tx: Transaction, inputIndex: number) =&gt; Promise&lt;UnlockingScript&gt;;\n    estimateLength: (tx: Transaction, inputIndex: number) =&gt; Promise&lt;number&gt;;\n} \n</code></pre> See also: Transaction, UnlockingScript, sign</p> <p>Returns</p> <p>Script unlocker capable of unlocking the advertisement token</p> <p>Argument Details</p> <ul> <li>protocol</li> <li>SHIP or SLAP, depending on the token to unlock</li> </ul> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/overlay-tools/#class-topicbroadcaster","title":"Class: TopicBroadcaster","text":"<p>Broadcasts transactions to one or more overlay topics.</p> <pre><code>export default class TopicBroadcaster implements Broadcaster {\n    constructor(topics: string[], config: SHIPBroadcasterConfig = {}) \n    async broadcast(tx: Transaction): Promise&lt;BroadcastResponse | BroadcastFailure&gt; \n}\n</code></pre> <p>See also: BroadcastFailure, BroadcastResponse, Broadcaster, SHIPBroadcasterConfig, Transaction</p>"},{"location":"reference/overlay-tools/#constructor_1","title":"Constructor","text":"<p>Constructs an instance of the SHIP broadcaster.</p> <p><pre><code>constructor(topics: string[], config: SHIPBroadcasterConfig = {}) \n</code></pre> See also: SHIPBroadcasterConfig</p> <p>Argument Details</p> <ul> <li>topics</li> <li>The list of SHIP topic names where transactions are to be sent.</li> <li>config</li> <li>Configuration options for the SHIP broadcaster.</li> </ul>"},{"location":"reference/overlay-tools/#method-broadcast","title":"Method broadcast","text":"<p>Broadcasts a transaction to Overlay Services via SHIP.</p> <p><pre><code>async broadcast(tx: Transaction): Promise&lt;BroadcastResponse | BroadcastFailure&gt; \n</code></pre> See also: BroadcastFailure, BroadcastResponse, Transaction</p> <p>Returns</p> <p>A promise that resolves to either a success or failure response.</p> <p>Argument Details</p> <ul> <li>tx</li> <li>The transaction to be sent.</li> </ul> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/overlay-tools/#functions","title":"Functions","text":""},{"location":"reference/overlay-tools/#types","title":"Types","text":"LookupAnswer STEAK <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/overlay-tools/#type-lookupanswer","title":"Type: LookupAnswer","text":"<p>How the Overlay Services Engine responds to a Lookup Question. It may comprise either an output list or a freeform response from the Lookup Service.</p> <pre><code>export type LookupAnswer = {\n    type: \"output-list\";\n    outputs: Array&lt;{\n        beef: number[];\n        outputIndex: number;\n        context?: number[];\n    }&gt;;\n}\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/overlay-tools/#type-steak","title":"Type: STEAK","text":"<p>Submitted Transaction Execution AcKnowledgment</p> <pre><code>export type STEAK = Record&lt;string, AdmittanceInstructions&gt;\n</code></pre> <p>See also: AdmittanceInstructions</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/overlay-tools/#enums","title":"Enums","text":""},{"location":"reference/overlay-tools/#variables","title":"Variables","text":"DEFAULT_SLAP_TRACKERS DEFAULT_TESTNET_SLAP_TRACKERS <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/overlay-tools/#variable-default_slap_trackers","title":"Variable: DEFAULT_SLAP_TRACKERS","text":"<pre><code>DEFAULT_SLAP_TRACKERS: string[] = [\n    \"https://overlay-us-1.bsvb.tech\",\n    \"https://overlay-eu-1.bsvb.tech\",\n    \"https://overlay-ap-1.bsvb.tech\",\n    \"https://users.bapp.dev\"\n]\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/overlay-tools/#variable-default_testnet_slap_trackers","title":"Variable: DEFAULT_TESTNET_SLAP_TRACKERS","text":"<pre><code>DEFAULT_TESTNET_SLAP_TRACKERS: string[] = [\n    \"https://testnet-users.bapp.dev\"\n]\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/","title":"API","text":"<p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#interfaces","title":"Interfaces","text":""},{"location":"reference/primitives/#interface-jacobianpointbi","title":"Interface: JacobianPointBI","text":"<pre><code>export interface JacobianPointBI {\n    X: bigint;\n    Y: bigint;\n    Z: bigint;\n}\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#classes","title":"Classes","text":"BasePoint PointInFiniteField SHA256HMAC BigNumber Polynomial SHA512 Curve PrivateKey SHA512HMAC DRBG PublicKey Schnorr JacobianPoint RIPEMD160 Signature K256 Reader SymmetricKey KeyShares ReductionContext TransactionSignature Mersenne SHA1 Writer MontgomoryMethod SHA1HMAC Point SHA256 <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#class-basepoint","title":"Class: BasePoint","text":"<p>Base class for Point (affine coordinates) and JacobianPoint classes, defining their curve and type.</p> <pre><code>export default abstract class BasePoint {\n    curve: Curve;\n    type: \"affine\" | \"jacobian\";\n    precomputed: {\n        doubles?: {\n            step: number;\n            points: BasePoint[];\n        };\n        naf?: {\n            wnd: number;\n            points: BasePoint[];\n        };\n        beta?: BasePoint | null;\n    } | null;\n    constructor(type: \"affine\" | \"jacobian\") \n}\n</code></pre> <p>See also: Curve</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#class-bignumber","title":"Class: BigNumber","text":"<p>JavaScript numbers are only precise up to 53 bits. Since Bitcoin relies on 256-bit cryptography, this BigNumber class enables operations on larger numbers.</p> <pre><code>export default class BigNumber {\n    public static readonly zeros: string[] \n    static readonly groupSizes: number[] \n    static readonly groupBases: number[] \n    static readonly wordSize: number = 26;\n    public red: ReductionContext | null;\n    public get negative(): number \n    public set negative(val: number) \n    public get words(): number[] \n    public set words(newWords: number[]) \n    public get length(): number \n    static isBN(num: any): boolean \n    static max(left: BigNumber, right: BigNumber): BigNumber \n    static min(left: BigNumber, right: BigNumber): BigNumber \n    constructor(number: number | string | number[] | bigint | undefined = 0, base: number | \"be\" | \"le\" | \"hex\" = 10, endian: \"be\" | \"le\" = \"be\") \n    copy(dest: BigNumber): void \n    static move(dest: BigNumber, src: BigNumber): void \n    clone(): BigNumber \n    expand(size: number): this \n    strip(): this \n    normSign(): this { if (this._magnitude === 0n)\n        this._sign = 0; return this; }\n    inspect(): string \n    toString(base: number | \"hex\" = 10, padding: number = 1): string \n    toNumber(): number \n    toJSON(): string \n    toArray(endian: \"le\" | \"be\" = \"be\", length?: number): number[] \n    bitLength(): number { if (this._magnitude === 0n)\n        return 0; return this._magnitude.toString(2).length; }\n    static toBitArray(num: BigNumber): Array&lt;0 | 1&gt; \n    toBitArray(): Array&lt;0 | 1&gt; \n    zeroBits(): number \n    byteLength(): number { if (this._magnitude === 0n)\n        return 0; return Math.ceil(this.bitLength() / 8); }\n    toTwos(width: number): BigNumber \n    fromTwos(width: number): BigNumber \n    isNeg(): boolean \n    neg(): BigNumber \n    ineg(): this { if (this._magnitude !== 0n)\n        this._sign = this._sign === 1 ? 0 : 1; return this; }\n    iuor(num: BigNumber): this \n    iuand(num: BigNumber): this \n    iuxor(num: BigNumber): this \n    ior(num: BigNumber): this \n    iand(num: BigNumber): this \n    ixor(num: BigNumber): this \n    or(num: BigNumber): BigNumber \n    uor(num: BigNumber): BigNumber \n    and(num: BigNumber): BigNumber \n    uand(num: BigNumber): BigNumber \n    xor(num: BigNumber): BigNumber \n    uxor(num: BigNumber): BigNumber \n    inotn(width: number): this \n    notn(width: number): BigNumber \n    setn(bit: number, val: any): this { this.assert(typeof bit === \"number\" &amp;&amp; bit &gt;= 0); const Bb = BigInt(bit); if (val === 1 || val === true)\n        this._magnitude |= (1n &lt;&lt; Bb);\n    else\n        this._magnitude &amp;= ~(1n &lt;&lt; Bb); const wnb = Math.floor(bit / BigNumber.wordSize) + 1; this._nominalWordLength = Math.max(this._nominalWordLength, wnb); this._finishInitialization(); return this.strip(); }\n    iadd(num: BigNumber): this \n    add(num: BigNumber): BigNumber \n    isub(num: BigNumber): this \n    sub(num: BigNumber): BigNumber \n    mul(num: BigNumber): BigNumber \n    imul(num: BigNumber): this \n    imuln(num: number): this \n    muln(num: number): BigNumber \n    sqr(): BigNumber \n    isqr(): this \n    pow(num: BigNumber): BigNumber \n    iushln(bits: number): this { this.assert(typeof bits === \"number\" &amp;&amp; bits &gt;= 0); if (bits === 0)\n        return this; this._magnitude &lt;&lt;= BigInt(bits); this._finishInitialization(); return this.strip(); }\n    ishln(bits: number): this \n    iushrn(bits: number, hint?: number, extended?: BigNumber): this \n    ishrn(bits: number, hint?: number, extended?: BigNumber): this \n    shln(bits: number): BigNumber \n    ushln(bits: number): BigNumber \n    shrn(bits: number): BigNumber \n    ushrn(bits: number): BigNumber \n    testn(bit: number): boolean \n    imaskn(bits: number): this \n    maskn(bits: number): BigNumber \n    iaddn(num: number): this \n    _iaddn(num: number): this \n    isubn(num: number): this \n    addn(num: number): BigNumber \n    subn(num: number): BigNumber \n    iabs(): this \n    abs(): BigNumber \n    divmod(num: BigNumber, mode?: \"div\" | \"mod\", positive?: boolean): any \n    div(num: BigNumber): BigNumber \n    mod(num: BigNumber): BigNumber \n    umod(num: BigNumber): BigNumber \n    divRound(num: BigNumber): BigNumber \n    modrn(numArg: number): number \n    idivn(num: number): this \n    divn(num: number): BigNumber \n    egcd(p: BigNumber): {\n        a: BigNumber;\n        b: BigNumber;\n        gcd: BigNumber;\n    } \n    gcd(num: BigNumber): BigNumber \n    invm(num: BigNumber): BigNumber \n    isEven(): boolean \n    isOdd(): boolean \n    andln(num: number): number \n    bincn(bit: number): this \n    isZero(): boolean \n    cmpn(num: number): 1 | 0 | -1 { this.assert(Math.abs(num) &lt;= BigNumber.MAX_IMULN_ARG, \"Number is too big\"); const tV = this._getSignedValue(); const nV = BigInt(num); if (tV &lt; nV)\n        return -1; if (tV &gt; nV)\n        return 1; return 0; }\n    cmp(num: BigNumber): 1 | 0 | -1 { const tV = this._getSignedValue(); const nV = num._getSignedValue(); if (tV &lt; nV)\n        return -1; if (tV &gt; nV)\n        return 1; return 0; }\n    ucmp(num: BigNumber): 1 | 0 | -1 { if (this._magnitude &lt; num._magnitude)\n        return -1; if (this._magnitude &gt; num._magnitude)\n        return 1; return 0; }\n    gtn(num: number): boolean \n    gt(num: BigNumber): boolean \n    gten(num: number): boolean \n    gte(num: BigNumber): boolean \n    ltn(num: number): boolean \n    lt(num: BigNumber): boolean \n    lten(num: number): boolean \n    lte(num: BigNumber): boolean \n    eqn(num: number): boolean \n    eq(num: BigNumber): boolean \n    toRed(ctx: ReductionContext): BigNumber \n    fromRed(): BigNumber \n    forceRed(ctx: ReductionContext): this \n    redAdd(num: BigNumber): BigNumber \n    redIAdd(num: BigNumber): BigNumber \n    redSub(num: BigNumber): BigNumber \n    redISub(num: BigNumber): BigNumber \n    redShl(num: number): BigNumber \n    redMul(num: BigNumber): BigNumber \n    redIMul(num: BigNumber): BigNumber \n    redSqr(): BigNumber \n    redISqr(): BigNumber \n    redSqrt(): BigNumber \n    redInvm(): BigNumber \n    redNeg(): BigNumber \n    redPow(num: BigNumber): BigNumber \n    static fromHex(hex: string, endian?: \"le\" | \"be\" | \"little\" | \"big\"): BigNumber \n    toHex(byteLength: number = 0): string \n    static fromJSON(str: string): BigNumber \n    static fromNumber(n: number): BigNumber \n    static fromString(str: string, base?: number | \"hex\"): BigNumber \n    static fromSm(bytes: number[], endian: \"big\" | \"little\" = \"big\"): BigNumber \n    toSm(endian: \"big\" | \"little\" = \"big\"): number[] \n    static fromBits(bits: number, strict: boolean = false): BigNumber \n    toBits(): number \n    static fromScriptNum(num: number[], requireMinimal: boolean = false, maxNumSize?: number): BigNumber \n    toScriptNum(): number[] \n    _invmp(p: BigNumber): BigNumber \n    mulTo(num: BigNumber, out: BigNumber): BigNumber \n}\n</code></pre> <p>See also: ReductionContext, red, toArray, toHex</p>"},{"location":"reference/primitives/#constructor","title":"Constructor","text":"<pre><code>constructor(number: number | string | number[] | bigint | undefined = 0, base: number | \"be\" | \"le\" | \"hex\" = 10, endian: \"be\" | \"le\" = \"be\") \n</code></pre> <p>Argument Details</p> <ul> <li>number</li> <li>The number (various types accepted) to construct a BigNumber from. Default is 0.</li> <li>base</li> <li>The base of number provided. By default is 10.</li> <li>endian</li> <li>The endianness provided. By default is 'big endian'.</li> </ul>"},{"location":"reference/primitives/#property-red","title":"Property red","text":"<p>Reduction context of the big number.</p> <p><pre><code>public red: ReductionContext | null\n</code></pre> See also: ReductionContext</p>"},{"location":"reference/primitives/#property-wordsize","title":"Property wordSize","text":"<p>The word size of big number chunks.</p> <pre><code>static readonly wordSize: number = 26\n</code></pre> <p>Example</p> <pre><code>console.log(BigNumber.wordSize);  // output: 26\n</code></pre>"},{"location":"reference/primitives/#method-_invmp","title":"Method _invmp","text":"<p>Compute the multiplicative inverse of the current BigNumber in the modulus field specified by <code>p</code>. The multiplicative inverse is a number which when multiplied with the current BigNumber gives '1' in the modulus field.</p> <p><pre><code>_invmp(p: BigNumber): BigNumber \n</code></pre> See also: BigNumber</p> <p>Returns</p> <p>The multiplicative inverse <code>BigNumber</code> in the modulus field specified by <code>p</code>.</p> <p>Argument Details</p> <ul> <li>p</li> <li>The <code>BigNumber</code> specifying the modulus field.</li> </ul>"},{"location":"reference/primitives/#method-bitlength","title":"Method bitLength","text":"<p>Calculates the number of bits required to represent the BigNumber.</p> <pre><code>bitLength(): number { if (this._magnitude === 0n)\n    return 0; return this._magnitude.toString(2).length; }\n</code></pre> <p>Returns</p> <p>The bit length of the BigNumber.</p>"},{"location":"reference/primitives/#method-bytelength","title":"Method byteLength","text":"<p>Calculates the number of bytes required to represent the BigNumber.</p> <pre><code>byteLength(): number { if (this._magnitude === 0n)\n    return 0; return Math.ceil(this.bitLength() / 8); }\n</code></pre> <p>Returns</p> <p>The byte length of the BigNumber.</p>"},{"location":"reference/primitives/#method-frombits","title":"Method fromBits","text":"<p>Creates a BigNumber from a number representing the \"bits\" value in a block header.</p> <p><pre><code>static fromBits(bits: number, strict: boolean = false): BigNumber \n</code></pre> See also: BigNumber</p> <p>Returns</p> <p>Returns a BigNumber equivalent to the \"bits\" value in a block header.</p> <p>Argument Details</p> <ul> <li>bits</li> <li>The number representing the bits value in a block header.</li> <li>strict</li> <li>If true, an error is thrown if the number has negative bit set.</li> </ul> <p>Throws</p> <p>Will throw an error if <code>strict</code> is <code>true</code> and the number has negative bit set.</p>"},{"location":"reference/primitives/#method-fromhex","title":"Method fromHex","text":"<p>Creates a BigNumber from a hexadecimal string.</p> <p><pre><code>static fromHex(hex: string, endian?: \"le\" | \"be\" | \"little\" | \"big\"): BigNumber \n</code></pre> See also: BigNumber</p> <p>Returns</p> <p>Returns a BigNumber created from the hexadecimal input string.</p> <p>Argument Details</p> <ul> <li>hex</li> <li>The hexadecimal string to create a BigNumber from.</li> <li>endian</li> <li>Optional endianness for parsing the hex string.</li> </ul> <p>Example</p> <pre><code>const exampleHex = 'a1b2c3';\nconst bigNumber = BigNumber.fromHex(exampleHex);\n</code></pre>"},{"location":"reference/primitives/#method-fromjson","title":"Method fromJSON","text":"<p>Creates a BigNumber from a JSON-serialized string.</p> <p><pre><code>static fromJSON(str: string): BigNumber \n</code></pre> See also: BigNumber</p> <p>Returns</p> <p>Returns a BigNumber created from the JSON input string.</p> <p>Argument Details</p> <ul> <li>str</li> <li>The JSON-serialized string to create a BigNumber from.</li> </ul>"},{"location":"reference/primitives/#method-fromnumber","title":"Method fromNumber","text":"<p>Creates a BigNumber from a number.</p> <p><pre><code>static fromNumber(n: number): BigNumber \n</code></pre> See also: BigNumber</p> <p>Returns</p> <p>Returns a BigNumber equivalent to the input number.</p> <p>Argument Details</p> <ul> <li>n</li> <li>The number to create a BigNumber from.</li> </ul>"},{"location":"reference/primitives/#method-fromscriptnum","title":"Method fromScriptNum","text":"<p>Creates a BigNumber from the format used in Bitcoin scripts.</p> <p><pre><code>static fromScriptNum(num: number[], requireMinimal: boolean = false, maxNumSize?: number): BigNumber \n</code></pre> See also: BigNumber</p> <p>Returns</p> <p>Returns a BigNumber equivalent to the number used in a Bitcoin script.</p> <p>Argument Details</p> <ul> <li>num</li> <li>The number in the format used in Bitcoin scripts.</li> <li>requireMinimal</li> <li>If true, non-minimally encoded values will throw an error.</li> <li>maxNumSize</li> <li>The maximum allowed size for the number.</li> </ul>"},{"location":"reference/primitives/#method-fromsm","title":"Method fromSm","text":"<p>Creates a BigNumber from a signed magnitude number.</p> <p><pre><code>static fromSm(bytes: number[], endian: \"big\" | \"little\" = \"big\"): BigNumber \n</code></pre> See also: BigNumber</p> <p>Returns</p> <p>Returns a BigNumber equivalent to the signed magnitude number interpreted with specified endianess.</p> <p>Argument Details</p> <ul> <li>bytes</li> <li>The signed magnitude number to convert to a BigNumber.</li> <li>endian</li> <li>Defines endianess. If not provided, big endian is assumed.</li> </ul>"},{"location":"reference/primitives/#method-fromstring","title":"Method fromString","text":"<p>Creates a BigNumber from a string, considering an optional base.</p> <p><pre><code>static fromString(str: string, base?: number | \"hex\"): BigNumber \n</code></pre> See also: BigNumber</p> <p>Returns</p> <p>Returns a BigNumber equivalent to the string after conversion from the specified base.</p> <p>Argument Details</p> <ul> <li>str</li> <li>The string to create a BigNumber from.</li> <li>base</li> <li>The base used for conversion. If not provided, base 10 is assumed.</li> </ul>"},{"location":"reference/primitives/#method-isbn","title":"Method isBN","text":"<p>Checks whether a value is an instance of BigNumber. Regular JS numbers fail this check.</p> <pre><code>static isBN(num: any): boolean \n</code></pre> <p>Returns</p> <ul> <li>Returns a boolean value determining whether or not the checked num parameter is a BigNumber.</li> </ul> <p>Argument Details</p> <ul> <li>num</li> <li>The value to be checked.</li> </ul>"},{"location":"reference/primitives/#method-max","title":"Method max","text":"<p>Returns the bigger value between two BigNumbers</p> <p><pre><code>static max(left: BigNumber, right: BigNumber): BigNumber \n</code></pre> See also: BigNumber</p> <p>Returns</p> <ul> <li>Returns the bigger BigNumber between left and right.</li> </ul> <p>Argument Details</p> <ul> <li>left</li> <li>The first BigNumber to be compared.</li> <li>right</li> <li>The second BigNumber to be compared.</li> </ul>"},{"location":"reference/primitives/#method-min","title":"Method min","text":"<p>Returns the smaller value between two BigNumbers</p> <p><pre><code>static min(left: BigNumber, right: BigNumber): BigNumber \n</code></pre> See also: BigNumber</p> <p>Returns</p> <ul> <li>Returns the smaller value between left and right.</li> </ul> <p>Argument Details</p> <ul> <li>left</li> <li>The first BigNumber to be compared.</li> <li>right</li> <li>The second BigNumber to be compared.</li> </ul>"},{"location":"reference/primitives/#method-multo","title":"Method mulTo","text":"<p>Performs multiplication between the BigNumber instance and a given BigNumber. It chooses the multiplication method based on the lengths of the numbers to optimize execution time.</p> <p><pre><code>mulTo(num: BigNumber, out: BigNumber): BigNumber \n</code></pre> See also: BigNumber</p> <p>Returns</p> <p>The BigNumber resulting from the multiplication operation.</p> <p>Argument Details</p> <ul> <li>num</li> <li>The BigNumber multiply with.</li> <li>out</li> <li>The BigNumber where to store the result.</li> </ul>"},{"location":"reference/primitives/#method-toarray","title":"Method toArray","text":"<p>Converts the BigNumber instance to an array of bytes.</p> <pre><code>toArray(endian: \"le\" | \"be\" = \"be\", length?: number): number[] \n</code></pre> <p>Returns</p> <p>Array of bytes representing the BigNumber.</p> <p>Argument Details</p> <ul> <li>endian</li> <li>Endianness of the output array, defaults to 'be'.</li> <li>length</li> <li>Optional length of the output array.</li> </ul>"},{"location":"reference/primitives/#method-tobitarray","title":"Method toBitArray","text":"<p>Converts a BigNumber to an array of bits.</p> <p><pre><code>static toBitArray(num: BigNumber): Array&lt;0 | 1&gt; \n</code></pre> See also: BigNumber</p> <p>Returns</p> <p>An array of bits.</p> <p>Argument Details</p> <ul> <li>num</li> <li>The BigNumber to convert.</li> </ul>"},{"location":"reference/primitives/#method-tobits","title":"Method toBits","text":"<p>Converts this BigNumber to a number representing the \"bits\" value in a block header.</p> <pre><code>toBits(): number \n</code></pre> <p>Returns</p> <p>Returns a number equivalent to the \"bits\" value in a block header.</p>"},{"location":"reference/primitives/#method-tohex","title":"Method toHex","text":"<p>Converts this BigNumber to a hexadecimal string.</p> <pre><code>toHex(byteLength: number = 0): string \n</code></pre> <p>Returns</p> <p>Returns a string representing the hexadecimal value of this BigNumber.</p> <p>Argument Details</p> <ul> <li>length</li> <li>The minimum length of the hex string</li> </ul> <p>Example</p> <pre><code>const bigNumber = new BigNumber(255)\nconst hex = bigNumber.toHex()\n</code></pre>"},{"location":"reference/primitives/#method-tojson","title":"Method toJSON","text":"<p>Converts the BigNumber instance to a JSON-formatted string.</p> <pre><code>toJSON(): string \n</code></pre> <p>Returns</p> <p>The JSON string representation of the BigNumber instance.</p>"},{"location":"reference/primitives/#method-tonumber","title":"Method toNumber","text":"<p>Converts the BigNumber instance to a JavaScript number. Please note that JavaScript numbers are only precise up to 53 bits.</p> <pre><code>toNumber(): number \n</code></pre> <p>Returns</p> <p>The JavaScript number representation of the BigNumber instance.</p> <p>Throws</p> <p>If the BigNumber instance cannot be safely stored in a JavaScript number</p>"},{"location":"reference/primitives/#method-toscriptnum","title":"Method toScriptNum","text":"<p>Converts this BigNumber to a number in the format used in Bitcoin scripts.</p> <pre><code>toScriptNum(): number[] \n</code></pre> <p>Returns</p> <p>Returns the equivalent to this BigNumber as a Bitcoin script number.</p>"},{"location":"reference/primitives/#method-tosm","title":"Method toSm","text":"<p>Converts this BigNumber to a signed magnitude number.</p> <pre><code>toSm(endian: \"big\" | \"little\" = \"big\"): number[] \n</code></pre> <p>Returns</p> <p>Returns an array equivalent to this BigNumber interpreted as a signed magnitude with specified endianess.</p> <p>Argument Details</p> <ul> <li>endian</li> <li>Defines endianess. If not provided, big endian is assumed.</li> </ul>"},{"location":"reference/primitives/#method-tostring","title":"Method toString","text":"<p>function toString() { [native code] }</p> <p>Converts the BigNumber instance to a string representation.</p> <pre><code>toString(base: number | \"hex\" = 10, padding: number = 1): string \n</code></pre> <p>Returns</p> <p>The string representation of the BigNumber instance</p> <p>Argument Details</p> <ul> <li>base</li> <li>The base for representing number. Default is 10. Other accepted values are 16 and 'hex'.</li> <li>padding</li> <li>Represents the minimum number of digits to represent the BigNumber as a string. Default is 1.</li> </ul>"},{"location":"reference/primitives/#method-zerobits","title":"Method zeroBits","text":"<p>Returns the number of trailing zero bits in the big number.</p> <pre><code>zeroBits(): number \n</code></pre> <p>Returns</p> <p>Returns the number of trailing zero bits in the binary representation of the big number.</p> <p>Example</p> <pre><code>const bn = new BigNumber('8'); // binary: 1000\nconst zeroBits = bn.zeroBits(); // 3\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#class-curve","title":"Class: Curve","text":"<pre><code>export default class Curve {\n    p: BigNumber;\n    red: ReductionContext;\n    redN: BigNumber | null;\n    zero: BigNumber;\n    one: BigNumber;\n    two: BigNumber;\n    g: Point;\n    n: BigNumber;\n    a: BigNumber;\n    b: BigNumber;\n    tinv: BigNumber;\n    zeroA: boolean;\n    threeA: boolean;\n    endo: {\n        beta: BigNumber;\n        lambda: BigNumber;\n        basis: Array&lt;{\n            a: BigNumber;\n            b: BigNumber;\n        }&gt;;\n    } | undefined;\n    _endoWnafT1: BigNumber[];\n    _endoWnafT2: BigNumber[];\n    _wnafT1: BigNumber[];\n    _wnafT2: BigNumber[];\n    _wnafT3: BigNumber[];\n    _wnafT4: BigNumber[];\n    _bitLength: number;\n    static assert(expression: unknown, message: string = \"Elliptic curve assertion failed\"): void \n    getNAF(num: BigNumber, w: number, bits: number): number[] \n    getJSF(k1: BigNumber, k2: BigNumber): number[][] \n    static cachedProperty(obj, name: string, computer): void \n    static parseBytes(bytes: string | number[]): number[] \n    static intFromLE(bytes: number[]): BigNumber \n    constructor() \n    _getEndomorphism(conf): {\n        beta: BigNumber;\n        lambda: BigNumber;\n        basis: Array&lt;{\n            a: BigNumber;\n            b: BigNumber;\n        }&gt;;\n    } | undefined \n    _getEndoRoots(num: BigNumber): [\n        BigNumber,\n        BigNumber\n    ] \n    _getEndoBasis(lambda: BigNumber): [\n        {\n            a: BigNumber;\n            b: BigNumber;\n        },\n        {\n            a: BigNumber;\n            b: BigNumber;\n        }\n    ] \n    _endoSplit(k: BigNumber): {\n        k1: BigNumber;\n        k2: BigNumber;\n    } \n    validate(point: Point): boolean \n}\n</code></pre> <p>See also: BigNumber, Point, ReductionContext, red</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#class-drbg","title":"Class: DRBG","text":"<p>This class behaves as a HMAC-based deterministic random bit generator (DRBG). It implements a deterministic random number generator using SHA256HMAC HASH function. It takes an initial entropy and nonce when instantiated for seeding purpose.</p> <p>Example</p> <pre><code>const drbg = new DRBG('af12de...', '123ef...');\n</code></pre> <pre><code>export default class DRBG {\n    K: number[];\n    V: number[];\n    constructor(entropy: number[] | string, nonce: number[] | string) \n    hmac(): SHA256HMAC \n    update(seed?): void \n    generate(len: number): string \n}\n</code></pre> <p>See also: SHA256HMAC</p>"},{"location":"reference/primitives/#method-generate","title":"Method generate","text":"<p>Generates deterministic random hexadecimal string of given length. In every generation process, it also updates the internal state <code>K</code> and <code>V</code>.</p> <pre><code>generate(len: number): string \n</code></pre> <p>Returns</p> <p>The required deterministic random hexadecimal string.</p> <p>Argument Details</p> <ul> <li>len</li> <li>The length of required random number.</li> </ul> <p>Example</p> <pre><code>const randomHex = drbg.generate(256);\n</code></pre>"},{"location":"reference/primitives/#method-hmac","title":"Method hmac","text":"<p>Generates HMAC using the K value of the instance. This method is used internally for operations.</p> <p><pre><code>hmac(): SHA256HMAC \n</code></pre> See also: SHA256HMAC</p> <p>Returns</p> <p>The SHA256HMAC object created with K value.</p> <p>Example</p> <pre><code>const hmac = drbg.hmac();\n</code></pre>"},{"location":"reference/primitives/#method-update","title":"Method update","text":"<p>Updates the <code>K</code> and <code>V</code> values of the instance based on the seed. The seed if not provided uses <code>V</code> as seed.</p> <pre><code>update(seed?): void \n</code></pre> <p>Returns</p> <p>Nothing, but updates the internal state <code>K</code> and <code>V</code> value.</p> <p>Argument Details</p> <ul> <li>seed</li> <li>an optional value that used to update <code>K</code> and <code>V</code>. Default is <code>undefined</code>.</li> </ul> <p>Example</p> <pre><code>drbg.update('e13af...');\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#class-jacobianpoint","title":"Class: JacobianPoint","text":"<p>The <code>JacobianPoint</code> class extends the <code>BasePoint</code> class for handling Jacobian coordinates on an Elliptic Curve. This class defines the properties and the methods needed to work with points in Jacobian coordinates.</p> <p>The Jacobian coordinates represent a point (x, y, z) on an Elliptic Curve such that the usual (x, y) coordinates are given by (x/z^2, y/z^3).</p> <p>Example</p> <pre><code>const pointJ = new JacobianPoint('3', '4', '1');\n</code></pre> <pre><code>export default class JacobianPoint extends BasePoint {\n    x: BigNumber;\n    y: BigNumber;\n    z: BigNumber;\n    zOne: boolean;\n    constructor(x: string | BigNumber | null, y: string | BigNumber | null, z: string | BigNumber | null) \n    toP(): Point \n    neg(): JacobianPoint \n    add(p: JacobianPoint): JacobianPoint \n    mixedAdd(p: Point): JacobianPoint \n    dblp(pow: number): JacobianPoint \n    dbl(): JacobianPoint \n    eq(p: Point | JacobianPoint): boolean \n    eqXToP(x: BigNumber): boolean \n    inspect(): string \n    isInfinity(): boolean \n}\n</code></pre> <p>See also: BasePoint, BigNumber, Point</p>"},{"location":"reference/primitives/#constructor_1","title":"Constructor","text":"<p>Constructs a new <code>JacobianPoint</code> instance.</p> <p><pre><code>constructor(x: string | BigNumber | null, y: string | BigNumber | null, z: string | BigNumber | null) \n</code></pre> See also: BigNumber</p> <p>Argument Details</p> <ul> <li>x</li> <li>If <code>null</code>, the x-coordinate will default to the curve's defined 'one' constant. If <code>x</code> is not a BigNumber, <code>x</code> will be converted to a <code>BigNumber</code> assuming it is a hex string.</li> <li>y</li> <li>If <code>null</code>, the y-coordinate will default to the curve's defined 'one' constant. If <code>y</code> is not a BigNumber, <code>y</code> will be converted to a <code>BigNumber</code> assuming it is a hex string.</li> <li>z</li> <li>If <code>null</code>, the z-coordinate will default to 0. If <code>z</code> is not a BigNumber, <code>z</code> will be converted to a <code>BigNumber</code> assuming it is a hex string.</li> </ul> <p>Example</p> <pre><code>const pointJ1 = new JacobianPoint(null, null, null); // creates point at infinity\nconst pointJ2 = new JacobianPoint('3', '4', '1'); // creates point (3, 4, 1)\n</code></pre>"},{"location":"reference/primitives/#property-x","title":"Property x","text":"<p>The <code>x</code> coordinate of the point in the Jacobian form.</p> <p><pre><code>x: BigNumber\n</code></pre> See also: BigNumber</p>"},{"location":"reference/primitives/#property-y","title":"Property y","text":"<p>The <code>y</code> coordinate of the point in the Jacobian form.</p> <p><pre><code>y: BigNumber\n</code></pre> See also: BigNumber</p>"},{"location":"reference/primitives/#property-z","title":"Property z","text":"<p>The <code>z</code> coordinate of the point in the Jacobian form.</p> <p><pre><code>z: BigNumber\n</code></pre> See also: BigNumber</p>"},{"location":"reference/primitives/#property-zone","title":"Property zOne","text":"<p>Flag that indicates if the <code>z</code> coordinate is one.</p> <pre><code>zOne: boolean\n</code></pre>"},{"location":"reference/primitives/#method-add","title":"Method add","text":"<p>Addition operation in the Jacobian coordinates. It takes a Jacobian point as an argument and returns a new Jacobian point as a result of the addition. In the special cases, when either one of the points is the point at infinity, it will return the other point.</p> <p><pre><code>add(p: JacobianPoint): JacobianPoint \n</code></pre> See also: JacobianPoint</p> <p>Returns</p> <p>Returns a new Jacobian point as the result of the addition.</p> <p>Argument Details</p> <ul> <li>p</li> <li>The Jacobian point to be added.</li> </ul> <p>Example</p> <pre><code>const p1 = new JacobianPoint(x1, y1, z1)\nconst p2 = new JacobianPoint(x2, y2, z2)\nconst result = p1.add(p2)\n</code></pre>"},{"location":"reference/primitives/#method-dbl","title":"Method dbl","text":"<p>Point doubling operation in the Jacobian coordinates. A special case is when the point is the point at infinity, in this case, this function will return the point itself.</p> <p><pre><code>dbl(): JacobianPoint \n</code></pre> See also: JacobianPoint</p> <p>Returns</p> <p>Returns a new Jacobian point as the result of the doubling.</p> <p>Example</p> <pre><code>const jp = new JacobianPoint(x, y, z)\nconst result = jp.dbl()\n</code></pre>"},{"location":"reference/primitives/#method-dblp","title":"Method dblp","text":"<p>Multiple doubling operation. It doubles the Jacobian point as many times as the pow parameter specifies. If pow is 0 or the point is the point at infinity, it will return the point itself.</p> <p><pre><code>dblp(pow: number): JacobianPoint \n</code></pre> See also: JacobianPoint</p> <p>Returns</p> <p>Returns a new Jacobian point as the result of multiple doublings.</p> <p>Argument Details</p> <ul> <li>pow</li> <li>The number of times the point should be doubled.</li> </ul> <p>Example</p> <pre><code>const jp = new JacobianPoint(x, y, z)\nconst result = jp.dblp(3)\n</code></pre>"},{"location":"reference/primitives/#method-eq","title":"Method eq","text":"<p>Equality check operation. It checks whether the affine or Jacobian point is equal to this Jacobian point.</p> <p><pre><code>eq(p: Point | JacobianPoint): boolean \n</code></pre> See also: JacobianPoint, Point</p> <p>Returns</p> <p>Returns true if the points are equal, otherwise returns false.</p> <p>Argument Details</p> <ul> <li>p</li> <li>The affine or Jacobian point to compare with.</li> </ul> <p>Example</p> <pre><code>const jp1 = new JacobianPoint(x1, y1, z1)\nconst jp2 = new JacobianPoint(x2, y2, z2)\nconst areEqual = jp1.eq(jp2)\n</code></pre>"},{"location":"reference/primitives/#method-eqxtop","title":"Method eqXToP","text":"<p>Equality check operation in relation to an x coordinate of a point in projective coordinates. It checks whether the x coordinate of the Jacobian point is equal to the provided x coordinate of a point in projective coordinates.</p> <p><pre><code>eqXToP(x: BigNumber): boolean \n</code></pre> See also: BigNumber</p> <p>Returns</p> <p>Returns true if the x coordinates are equal, otherwise returns false.</p> <p>Argument Details</p> <ul> <li>x</li> <li>The x coordinate of a point in projective coordinates.</li> </ul> <p>Example</p> <pre><code>const jp = new JacobianPoint(x1, y1, z1)\nconst isXEqual = jp.eqXToP(x2)\n</code></pre>"},{"location":"reference/primitives/#method-inspect","title":"Method inspect","text":"<p>Returns the string representation of the JacobianPoint instance.</p> <pre><code>inspect(): string \n</code></pre> <p>Returns</p> <p>Returns the string description of the JacobianPoint. If the JacobianPoint represents a point at infinity, the return value of this function is ''. For a normal point, it returns the string description format as ''. <p>Example</p> <pre><code>const point = new JacobianPoint('5', '6', '1');\nconsole.log(point.inspect()); // Output: '&lt;EC JPoint x: 5 y: 6 z: 1&gt;'\n</code></pre>"},{"location":"reference/primitives/#method-isinfinity","title":"Method isInfinity","text":"<p>Checks whether the JacobianPoint instance represents a point at infinity.</p> <pre><code>isInfinity(): boolean \n</code></pre> <p>Returns</p> <p>Returns true if the JacobianPoint's z-coordinate equals to zero (which represents the point at infinity in Jacobian coordinates). Returns false otherwise.</p> <p>Example</p> <pre><code>const point = new JacobianPoint('5', '6', '0');\nconsole.log(point.isInfinity()); // Output: true\n</code></pre>"},{"location":"reference/primitives/#method-mixedadd","title":"Method mixedAdd","text":"<p>Mixed addition operation. This function combines the standard point addition with the transformation from the affine to Jacobian coordinates. It first converts the affine point to Jacobian, and then preforms the addition.</p> <p><pre><code>mixedAdd(p: Point): JacobianPoint \n</code></pre> See also: JacobianPoint, Point</p> <p>Returns</p> <p>Returns the result of the mixed addition as a new Jacobian point.</p> <p>Argument Details</p> <ul> <li>p</li> <li>The affine point to be added.</li> </ul> <p>Example</p> <pre><code>const jp = new JacobianPoint(x1, y1, z1)\nconst ap = new Point(x2, y2)\nconst result = jp.mixedAdd(ap)\n</code></pre>"},{"location":"reference/primitives/#method-neg","title":"Method neg","text":"<p>Negation operation. It returns the additive inverse of the Jacobian point.</p> <p><pre><code>neg(): JacobianPoint \n</code></pre> See also: JacobianPoint</p> <p>Returns</p> <p>Returns a new Jacobian point as the result of the negation.</p> <p>Example</p> <pre><code>const jp = new JacobianPoint(x, y, z)\nconst result = jp.neg()\n</code></pre>"},{"location":"reference/primitives/#method-top","title":"Method toP","text":"<p>Converts the <code>JacobianPoint</code> object instance to standard affine <code>Point</code> format and returns <code>Point</code> type.</p> <p><pre><code>toP(): Point \n</code></pre> See also: Point</p> <p>Returns</p> <p>The <code>Point</code>(affine) object representing the same point as the original <code>JacobianPoint</code>.</p> <p>If the initial <code>JacobianPoint</code> represents point at infinity, an instance of <code>Point</code> at infinity is returned.</p> <p>Example</p> <pre><code>const pointJ = new JacobianPoint('3', '4', '1');\nconst pointP = pointJ.toP();  // The point in affine coordinates.\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#class-k256","title":"Class: K256","text":"<p>A class representing K-256, a prime number with optimizations, specifically used in the secp256k1 curve. It extends the functionalities of the Mersenne class. K-256 prime is represented as 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f'</p> <p>Example</p> <pre><code>const k256 = new K256();\n</code></pre> <pre><code>export default class K256 extends Mersenne {\n    constructor() \n    split(input: BigNumber, output: BigNumber): void \n    imulK(num: BigNumber): BigNumber \n}\n</code></pre> <p>See also: BigNumber, Mersenne</p>"},{"location":"reference/primitives/#constructor_2","title":"Constructor","text":"<p>Constructor for the K256 class. Creates an instance of K256 using the super constructor from Mersenne.</p> <pre><code>constructor() \n</code></pre> <p>Example</p> <pre><code>const k256 = new K256();\n</code></pre>"},{"location":"reference/primitives/#method-imulk","title":"Method imulK","text":"<p>Multiplies a BigNumber ('num') with the constant 'K' in-place and returns the result. 'K' is equal to 0x1000003d1 or in decimal representation: [ 64, 977 ].</p> <p><pre><code>imulK(num: BigNumber): BigNumber \n</code></pre> See also: BigNumber</p> <p>Returns</p> <p>Returns the mutated BigNumber after multiplication.</p> <p>Argument Details</p> <ul> <li>num</li> <li>The BigNumber to multiply with K.</li> </ul> <p>Example</p> <pre><code>const number = new BigNumber(12345);\nconst result = k256.imulK(number);\n</code></pre>"},{"location":"reference/primitives/#method-split","title":"Method split","text":"<p>Splits a BigNumber into a new BigNumber based on specific computation rules. This method modifies the input and output big numbers.</p> <p><pre><code>split(input: BigNumber, output: BigNumber): void \n</code></pre> See also: BigNumber</p> <p>Argument Details</p> <ul> <li>input</li> <li>The BigNumber to be split.</li> <li>output</li> <li>The BigNumber that results from the split.</li> </ul> <p>Example</p> <pre><code>const input = new BigNumber(3456);\nconst output = new BigNumber(0);\nk256.split(input, output);\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#class-keyshares","title":"Class: KeyShares","text":"<p>Example</p> <pre><code>const key = PrivateKey.fromShares(shares)\n</code></pre> <pre><code>export class KeyShares {\n    points: PointInFiniteField[];\n    threshold: number;\n    integrity: string;\n    constructor(points: PointInFiniteField[], threshold: number, integrity: string) \n    static fromBackupFormat(shares: string[]): KeyShares \n    toBackupFormat(): string[] \n}\n</code></pre> <p>See also: PointInFiniteField</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#class-mersenne","title":"Class: Mersenne","text":"<p>A representation of a pseudo-Mersenne prime. A pseudo-Mersenne prime has the general form 2^n - k, where n and k are integers.</p> <pre><code>export default class Mersenne {\n    name: string;\n    p: BigNumber;\n    k: BigNumber;\n    n: number;\n    constructor(name: string, p: string) \n    ireduce(num: BigNumber): BigNumber \n    split(input: BigNumber, out: BigNumber): void \n    imulK(num: BigNumber): BigNumber \n}\n</code></pre> <p>See also: BigNumber</p>"},{"location":"reference/primitives/#constructor_3","title":"Constructor","text":"<pre><code>constructor(name: string, p: string) \n</code></pre> <p>Argument Details</p> <ul> <li>name</li> <li>An identifier for the Mersenne instance.</li> <li>p</li> <li>A string representation of the pseudo-Mersenne prime, expressed in hexadecimal.</li> </ul> <p>Example</p> <pre><code>const mersenne = new Mersenne('M31', '7FFFFFFF');\n</code></pre>"},{"location":"reference/primitives/#property-k","title":"Property k","text":"<p>The constant subtracted from 2^n to derive a pseudo-Mersenne prime.</p> <p><pre><code>k: BigNumber\n</code></pre> See also: BigNumber</p>"},{"location":"reference/primitives/#property-n","title":"Property n","text":"<p>The exponent which determines the magnitude of the prime.</p> <pre><code>n: number\n</code></pre>"},{"location":"reference/primitives/#property-name","title":"Property name","text":"<p>The identifier for the Mersenne instance.</p> <pre><code>name: string\n</code></pre>"},{"location":"reference/primitives/#property-p","title":"Property p","text":"<p>BigNumber equivalent to 2^n - k.</p> <p><pre><code>p: BigNumber\n</code></pre> See also: BigNumber</p>"},{"location":"reference/primitives/#method-imulk_1","title":"Method imulK","text":"<p>Performs an in-place multiplication of the parameter by constant k.</p> <p><pre><code>imulK(num: BigNumber): BigNumber \n</code></pre> See also: BigNumber</p> <p>Returns</p> <p>The result of the multiplication, in BigNumber format.</p> <p>Argument Details</p> <ul> <li>num</li> <li>The BigNumber to multiply with k.</li> </ul> <p>Example</p> <pre><code>const multiplied = mersenne.imulK(new BigNumber('2345', 16));\n</code></pre>"},{"location":"reference/primitives/#method-ireduce","title":"Method ireduce","text":"<p>Reduces an input BigNumber in place, under the assumption that it is less than the square of the pseudo-Mersenne prime.</p> <p><pre><code>ireduce(num: BigNumber): BigNumber \n</code></pre> See also: BigNumber</p> <p>Returns</p> <p>The reduced BigNumber.</p> <p>Argument Details</p> <ul> <li>num</li> <li>The BigNumber to be reduced.</li> </ul> <p>Example</p> <pre><code>const reduced = mersenne.ireduce(new BigNumber('2345', 16));\n</code></pre>"},{"location":"reference/primitives/#method-split_1","title":"Method split","text":"<p>Shifts bits of the input BigNumber to the right, in place, to meet the magnitude of the pseudo-Mersenne prime.</p> <p><pre><code>split(input: BigNumber, out: BigNumber): void \n</code></pre> See also: BigNumber</p> <p>Argument Details</p> <ul> <li>input</li> <li>The BigNumber to be shifted (will contain HI part).</li> <li>out</li> <li>The BigNumber to hold the shifted result (LO part).</li> </ul> <p>Example</p> <pre><code>mersenne.split(new BigNumber('2345', 16), new BigNumber());\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#class-montgomorymethod","title":"Class: MontgomoryMethod","text":"<p>Represents a Montgomery reduction context, which is a mathematical method for performing modular multiplication without division.</p> <p>Montgomery reduction is an algorithm used mainly in cryptography which can help to speed up calculations in contexts where there are many repeated computations.</p> <p>This class extends the <code>ReductionContext</code> class.</p> <pre><code>export default class MontgomoryMethod extends ReductionContext {\n    shift: number;\n    r: BigNumber;\n    r2: BigNumber;\n    rinv: BigNumber;\n    minv: BigNumber;\n    constructor(m: BigNumber | \"k256\") \n    convertTo(num: BigNumber): BigNumber \n    convertFrom(num: BigNumber): BigNumber \n    imul(a: BigNumber, b: BigNumber): BigNumber \n    mul(a: BigNumber, b: BigNumber): BigNumber \n    invm(a: BigNumber): BigNumber \n}\n</code></pre> <p>See also: BigNumber, ReductionContext</p>"},{"location":"reference/primitives/#constructor_4","title":"Constructor","text":"<p><pre><code>constructor(m: BigNumber | \"k256\") \n</code></pre> See also: BigNumber</p> <p>Argument Details</p> <ul> <li>m</li> <li>The modulus to be used for the Montgomery method reductions.</li> </ul>"},{"location":"reference/primitives/#property-minv","title":"Property minv","text":"<p>The modular multiplicative inverse of <code>m</code> mod <code>r</code>.</p> <p><pre><code>minv: BigNumber\n</code></pre> See also: BigNumber</p>"},{"location":"reference/primitives/#property-r","title":"Property r","text":"<p>The 2^shift, shifted left by the bit length of modulus <code>m</code>.</p> <p><pre><code>r: BigNumber\n</code></pre> See also: BigNumber</p>"},{"location":"reference/primitives/#property-r2","title":"Property r2","text":"<p>The square of <code>r</code> modulo <code>m</code>.</p> <p><pre><code>r2: BigNumber\n</code></pre> See also: BigNumber</p>"},{"location":"reference/primitives/#property-rinv","title":"Property rinv","text":"<p>The modular multiplicative inverse of <code>r</code> mod <code>m</code>.</p> <p><pre><code>rinv: BigNumber\n</code></pre> See also: BigNumber</p>"},{"location":"reference/primitives/#property-shift","title":"Property shift","text":"<p>The number of bits in the modulus.</p> <pre><code>shift: number\n</code></pre>"},{"location":"reference/primitives/#method-convertfrom","title":"Method convertFrom","text":"<p>Converts a number from the Montgomery domain back to the original domain.</p> <p><pre><code>convertFrom(num: BigNumber): BigNumber \n</code></pre> See also: BigNumber</p> <p>Returns</p> <p>The result of the conversion from the Montgomery domain.</p> <p>Argument Details</p> <ul> <li>num</li> <li>The number to be converted from the Montgomery domain.</li> </ul> <p>Example</p> <pre><code>const montMethod = new MontgomoryMethod(m);\nconst convertedNum = montMethod.convertFrom(num);\n</code></pre>"},{"location":"reference/primitives/#method-convertto","title":"Method convertTo","text":"<p>Converts a number into the Montgomery domain.</p> <p><pre><code>convertTo(num: BigNumber): BigNumber \n</code></pre> See also: BigNumber</p> <p>Returns</p> <p>The result of the conversion into the Montgomery domain.</p> <p>Argument Details</p> <ul> <li>num</li> <li>The number to be converted into the Montgomery domain.</li> </ul> <p>Example</p> <pre><code>const montMethod = new MontgomoryMethod(m);\nconst convertedNum = montMethod.convertTo(num);\n</code></pre>"},{"location":"reference/primitives/#method-imul","title":"Method imul","text":"<p>Performs an in-place multiplication of two numbers in the Montgomery domain.</p> <p><pre><code>imul(a: BigNumber, b: BigNumber): BigNumber \n</code></pre> See also: BigNumber</p> <p>Returns</p> <p>The result of the in-place multiplication.</p> <p>Argument Details</p> <ul> <li>a</li> <li>The first number to multiply.</li> <li>b</li> <li>The second number to multiply.</li> </ul> <p>Example</p> <pre><code>const montMethod = new MontgomoryMethod(m);\nconst product = montMethod.imul(a, b);\n</code></pre>"},{"location":"reference/primitives/#method-invm","title":"Method invm","text":"<p>Calculates the modular multiplicative inverse of a number in the Montgomery domain.</p> <p><pre><code>invm(a: BigNumber): BigNumber \n</code></pre> See also: BigNumber</p> <p>Returns</p> <p>The modular multiplicative inverse of 'a'.</p> <p>Argument Details</p> <ul> <li>a</li> <li>The number to compute the modular multiplicative inverse of.</li> </ul> <p>Example</p> <pre><code>const montMethod = new MontgomoryMethod(m);\nconst inverse = montMethod.invm(a);\n</code></pre>"},{"location":"reference/primitives/#method-mul","title":"Method mul","text":"<p>Performs the multiplication of two numbers in the Montgomery domain.</p> <p><pre><code>mul(a: BigNumber, b: BigNumber): BigNumber \n</code></pre> See also: BigNumber</p> <p>Returns</p> <p>The result of the multiplication.</p> <p>Argument Details</p> <ul> <li>a</li> <li>The first number to multiply.</li> <li>b</li> <li>The second number to multiply.</li> </ul> <p>Example</p> <pre><code>const montMethod = new MontgomoryMethod(m);\nconst product = montMethod.mul(a, b);\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#class-point","title":"Class: Point","text":"<p><code>Point</code> class is a representation of an elliptic curve point with affine coordinates. It extends the functionality of BasePoint and carries x, y coordinates of point on the curve. It also introduces new methods for handling Point operations in elliptic curve.</p> <pre><code>export default class Point extends BasePoint {\n    x: BigNumber | null;\n    y: BigNumber | null;\n    inf: boolean;\n    static fromDER(bytes: number[]): Point \n    static fromString(str: string): Point \n    static fromX(x: BigNumber | number | number[] | string, odd: boolean): Point \n    static fromJSON(obj: string | any[], isRed: boolean): Point \n    constructor(x: BigNumber | number | number[] | string | null, y: BigNumber | number | number[] | string | null, isRed: boolean = true) \n    validate(): boolean \n    encode(compact: boolean = true, enc?: \"hex\"): number[] | string \n    toString(): string \n    toJSON(): [\n        BigNumber | null,\n        BigNumber | null,\n        {\n            doubles: {\n                step: any;\n                points: any[];\n            } | undefined;\n            naf: {\n                wnd: any;\n                points: any[];\n            } | undefined;\n        }?\n    ] \n    inspect(): string \n    isInfinity(): boolean \n    add(p: Point): Point \n    dbl(): Point \n    getX(): BigNumber \n    getY(): BigNumber \n    mul(k: BigNumber | number | number[] | string): Point \n    mulAdd(k1: BigNumber, p2: Point, k2: BigNumber): Point \n    jmulAdd(k1: BigNumber, p2: Point, k2: BigNumber): JPoint \n    eq(p: Point): boolean \n    neg(_precompute?: boolean): Point \n    dblp(k: number): Point \n    toJ(): JPoint \n}\n</code></pre> <p>See also: BasePoint, BigNumber, encode</p>"},{"location":"reference/primitives/#constructor_5","title":"Constructor","text":"<p><pre><code>constructor(x: BigNumber | number | number[] | string | null, y: BigNumber | number | number[] | string | null, isRed: boolean = true) \n</code></pre> See also: BigNumber</p> <p>Argument Details</p> <ul> <li>x</li> <li>The x-coordinate of the point. May be a number, a BigNumber, a string (which will be interpreted as hex), a number array, or null. If null, an \"Infinity\" point is constructed.</li> <li>y</li> <li>The y-coordinate of the point, similar to x.</li> <li>isRed</li> <li>A boolean indicating if the point is a member of the field of integers modulo the k256 prime. Default is true.</li> </ul> <p>Example</p> <pre><code>new Point('abc123', 'def456');\nnew Point(null, null); // Generates Infinity point.\n</code></pre>"},{"location":"reference/primitives/#property-inf","title":"Property inf","text":"<p>Flag to record if the point is at infinity in the Elliptic Curve.</p> <pre><code>inf: boolean\n</code></pre>"},{"location":"reference/primitives/#property-x_1","title":"Property x","text":"<p>The x-coordinate of the point.</p> <p><pre><code>x: BigNumber | null\n</code></pre> See also: BigNumber</p>"},{"location":"reference/primitives/#property-y_1","title":"Property y","text":"<p>The y-coordinate of the point.</p> <p><pre><code>y: BigNumber | null\n</code></pre> See also: BigNumber</p>"},{"location":"reference/primitives/#method-add_1","title":"Method add","text":"<p>Adds another Point to this Point, returning a new Point.</p> <p><pre><code>add(p: Point): Point \n</code></pre> See also: Point</p> <p>Returns</p> <p>A new Point that results from the addition.</p> <p>Argument Details</p> <ul> <li>p</li> <li>The Point to add to this one.</li> </ul> <p>Example</p> <pre><code>const p1 = new Point(1, 2);\nconst p2 = new Point(2, 3);\nconst result = p1.add(p2);\n</code></pre>"},{"location":"reference/primitives/#method-dbl_1","title":"Method dbl","text":"<p>Doubles the current point.</p> <p><pre><code>dbl(): Point \n</code></pre> See also: Point</p> <p>Example</p> <pre><code>const P = new Point('123', '456');\nconst result = P.dbl();\n</code></pre>"},{"location":"reference/primitives/#method-dblp_1","title":"Method dblp","text":"<p>Performs the \"doubling\" operation on the Point a given number of times. This is used in elliptic curve operations to perform multiplication by 2, multiple times. If the point is at infinity, it simply returns the point because doubling a point at infinity is still infinity.</p> <p><pre><code>dblp(k: number): Point \n</code></pre> See also: Point</p> <p>Returns</p> <p>The Point after 'k' \"doubling\" operations have been performed.</p> <p>Argument Details</p> <ul> <li>k</li> <li>The number of times the \"doubling\" operation is to be performed on the Point.</li> </ul> <p>Example</p> <pre><code>const p = new Point(5, 20);\nconst doubledPoint = p.dblp(10); // returns the point after \"doubled\" 10 times\n</code></pre>"},{"location":"reference/primitives/#method-encode","title":"Method encode","text":"<p>Encodes the coordinates of a point into an array or a hexadecimal string. The details of encoding are determined by the optional compact and enc parameters.</p> <pre><code>encode(compact: boolean = true, enc?: \"hex\"): number[] | string \n</code></pre> <p>Returns</p> <p>If enc is undefined, a byte array representation of the point will be returned. if enc is 'hex', a hexadecimal string representation of the point will be returned.</p> <p>Argument Details</p> <ul> <li>compact</li> <li>If true, an additional prefix byte 0x02 or 0x03 based on the 'y' coordinate being even or odd respectively is used. If false, byte 0x04 is used.</li> <li>enc</li> <li>Expects the string 'hex' if hexadecimal string encoding is required instead of an array of numbers.</li> </ul> <p>Throws</p> <p>Will throw an error if the specified encoding method is not recognized. Expects 'hex'.</p> <p>Example</p> <pre><code>const aPoint = new Point(x, y);\nconst encodedPointArray = aPoint.encode();\nconst encodedPointHex = aPoint.encode(true, 'hex');\n</code></pre>"},{"location":"reference/primitives/#method-eq_1","title":"Method eq","text":"<p>Checks if the Point instance is equal to another given Point.</p> <p><pre><code>eq(p: Point): boolean \n</code></pre> See also: Point</p> <p>Returns</p> <p>Whether the two Point instances are equal. Both the 'x' and 'y' coordinates have to match, and both points have to either be valid or at infinity for equality. If both conditions are true, it returns true, else it returns false.</p> <p>Argument Details</p> <ul> <li>p</li> <li>The Point to be checked if equal to the current instance.</li> </ul> <p>Example</p> <pre><code>const p1 = new Point(5, 20);\nconst p2 = new Point(5, 20);\nconst areEqual = p1.eq(p2); // returns true\n</code></pre>"},{"location":"reference/primitives/#method-fromder","title":"Method fromDER","text":"<p>Creates a point object from a given Array. These numbers can represent coordinates in hex format, or points in multiple established formats. The function verifies the integrity of the provided data and throws errors if inconsistencies are found.</p> <p><pre><code>static fromDER(bytes: number[]): Point \n</code></pre> See also: Point</p> <p>Returns</p> <p>Returns a new point representing the given string.</p> <p>Argument Details</p> <ul> <li>bytes</li> <li>The point representation number array.</li> </ul> <p>Throws</p> <p><code>Error</code> If the point number[] value has a wrong length.</p> <p><code>Error</code> If the point format is unknown.</p> <p>Example</p> <pre><code>const derPoint = [ 2, 18, 123, 108, 125, 83, 1, 251, 164, 214, 16, 119, 200, 216, 210, 193, 251, 193, 129, 67, 97, 146, 210, 216, 77, 254, 18, 6, 150, 190, 99, 198, 128 ];\nconst point = Point.fromDER(derPoint);\n</code></pre>"},{"location":"reference/primitives/#method-fromjson_1","title":"Method fromJSON","text":"<p>Generates a point from a serialized JSON object. The function accounts for different options in the JSON object, including precomputed values for optimization of EC operations, and calls another helper function to turn nested JSON points into proper Point objects.</p> <p><pre><code>static fromJSON(obj: string | any[], isRed: boolean): Point \n</code></pre> See also: Point</p> <p>Returns</p> <p>Returns a new point based on the deserialized JSON object.</p> <p>Argument Details</p> <ul> <li>obj</li> <li>An object or array that holds the data for the point.</li> <li>isRed</li> <li>A boolean to direct how the Point is constructed from the JSON object.</li> </ul> <p>Example</p> <pre><code>const serializedPoint = '{\"x\":52,\"y\":15}';\nconst point = Point.fromJSON(serializedPoint, true);\n</code></pre>"},{"location":"reference/primitives/#method-fromstring_1","title":"Method fromString","text":"<p>Creates a point object from a given string. This string can represent coordinates in hex format, or points in multiple established formats. The function verifies the integrity of the provided data and throws errors if inconsistencies are found.</p> <p><pre><code>static fromString(str: string): Point \n</code></pre> See also: Point</p> <p>Returns</p> <p>Returns a new point representing the given string.</p> <p>Argument Details</p> <ul> <li>str</li> <li>The point representation string.</li> </ul> <p>Throws</p> <p><code>Error</code> If the point string value has a wrong length.</p> <p><code>Error</code> If the point format is unknown.</p> <p>Example</p> <pre><code>const pointStr = 'abcdef';\nconst point = Point.fromString(pointStr);\n</code></pre>"},{"location":"reference/primitives/#method-fromx","title":"Method fromX","text":"<p>Generates a point from an x coordinate and a boolean indicating whether the corresponding y coordinate is odd.</p> <p><pre><code>static fromX(x: BigNumber | number | number[] | string, odd: boolean): Point \n</code></pre> See also: BigNumber, Point</p> <p>Returns</p> <p>Returns the new point.</p> <p>Argument Details</p> <ul> <li>x</li> <li>The x coordinate of the point.</li> <li>odd</li> <li>Boolean indicating whether the corresponding y coordinate is odd or not.</li> </ul> <p>Throws</p> <p><code>Error</code> If the point is invalid.</p> <p>Example</p> <pre><code>const xCoordinate = new BigNumber('10');\nconst point = Point.fromX(xCoordinate, true);\n</code></pre>"},{"location":"reference/primitives/#method-getx","title":"Method getX","text":"<p>Returns X coordinate of point</p> <p><pre><code>getX(): BigNumber \n</code></pre> See also: BigNumber</p> <p>Example</p> <pre><code>const P = new Point('123', '456');\nconst x = P.getX();\n</code></pre>"},{"location":"reference/primitives/#method-gety","title":"Method getY","text":"<p>Returns X coordinate of point</p> <p><pre><code>getY(): BigNumber \n</code></pre> See also: BigNumber</p> <p>Example</p> <pre><code>const P = new Point('123', '456');\nconst x = P.getX();\n</code></pre>"},{"location":"reference/primitives/#method-inspect_1","title":"Method inspect","text":"<p>Provides the point coordinates in a human-readable string format for debugging purposes.</p> <pre><code>inspect(): string \n</code></pre> <p>Returns</p> <p>String of the format '', or '' if the point is at infinity. <p>Example</p> <pre><code>const aPoint = new Point(x, y);\nconsole.log(aPoint.inspect());\n</code></pre>"},{"location":"reference/primitives/#method-isinfinity_1","title":"Method isInfinity","text":"<p>Checks if the point is at infinity.</p> <pre><code>isInfinity(): boolean \n</code></pre> <p>Returns</p> <p>Returns whether or not the point is at infinity.</p> <p>Example</p> <pre><code>const p = new Point(null, null);\nconsole.log(p.isInfinity()); // outputs: true\n</code></pre>"},{"location":"reference/primitives/#method-jmuladd","title":"Method jmulAdd","text":"<p>Performs the Jacobian multiplication and addition operation in a single step. Instead of returning a regular Point, the result is a JacobianPoint.</p> <p><pre><code>jmulAdd(k1: BigNumber, p2: Point, k2: BigNumber): JPoint \n</code></pre> See also: BigNumber, Point</p> <p>Returns</p> <p>A JacobianPoint that results from the combined multiplication and addition operation.</p> <p>Argument Details</p> <ul> <li>k1</li> <li>The scalar value to multiply this Point by.</li> <li>p2</li> <li>The other Point to be involved in the operation</li> <li>k2</li> <li>The scalar value to multiply the Point p2 by.</li> </ul> <p>Example</p> <pre><code>const p1 = new Point(1, 2);\nconst p2 = new Point(2, 3);\nconst result = p1.jmulAdd(2, p2, 3);\n</code></pre>"},{"location":"reference/primitives/#method-mul_1","title":"Method mul","text":"<p>Multiplies this Point by a scalar value, returning a new Point.</p> <p><pre><code>mul(k: BigNumber | number | number[] | string): Point \n</code></pre> See also: BigNumber, Point</p> <p>Returns</p> <p>A new Point that results from the multiplication.</p> <p>Argument Details</p> <ul> <li>k</li> <li>The scalar value to multiply this Point by.</li> </ul> <p>Example</p> <pre><code>const p = new Point(1, 2);\nconst result = p.mul(2); // this doubles the Point\n</code></pre>"},{"location":"reference/primitives/#method-muladd","title":"Method mulAdd","text":"<p>Performs a multiplication and addition operation in a single step. Multiplies this Point by k1, adds the resulting Point to the result of p2 multiplied by k2.</p> <p><pre><code>mulAdd(k1: BigNumber, p2: Point, k2: BigNumber): Point \n</code></pre> See also: BigNumber, Point</p> <p>Returns</p> <p>A Point that results from the combined multiplication and addition operations.</p> <p>Argument Details</p> <ul> <li>k1</li> <li>The scalar value to multiply this Point by.</li> <li>p2</li> <li>The other Point to be involved in the operation.</li> <li>k2</li> <li>The scalar value to multiply the Point p2 by.</li> </ul> <p>Example</p> <pre><code>const p1 = new Point(1, 2);\nconst p2 = new Point(2, 3);\nconst result = p1.mulAdd(2, p2, 3);\n</code></pre>"},{"location":"reference/primitives/#method-neg_1","title":"Method neg","text":"<p>Negate a point. The negation of a point P is the mirror of P about x-axis.</p> <p><pre><code>neg(_precompute?: boolean): Point \n</code></pre> See also: Point</p> <p>Example</p> <pre><code>const P = new Point('123', '456');\nconst result = P.neg();\n</code></pre>"},{"location":"reference/primitives/#method-toj","title":"Method toJ","text":"<p>Converts the point to a Jacobian point. If the point is at infinity, the corresponding Jacobian point will also be at infinity.</p> <pre><code>toJ(): JPoint \n</code></pre> <p>Returns</p> <p>Returns a new Jacobian point based on the current point.</p> <p>Example</p> <pre><code>const point = new Point(xCoordinate, yCoordinate);\nconst jacobianPoint = point.toJ();\n</code></pre>"},{"location":"reference/primitives/#method-tojson_1","title":"Method toJSON","text":"<p>Exports the x and y coordinates of the point, and the precomputed doubles and non-adjacent form (NAF) for optimization. The output is an array.</p> <p><pre><code>toJSON(): [\n    BigNumber | null,\n    BigNumber | null,\n    {\n        doubles: {\n            step: any;\n            points: any[];\n        } | undefined;\n        naf: {\n            wnd: any;\n            points: any[];\n        } | undefined;\n    }?\n] \n</code></pre> See also: BigNumber</p> <p>Returns</p> <p>An Array where first two elements are the coordinates of the point and optional third element is an object with doubles and NAF points.</p> <p>Example</p> <pre><code>const aPoint = new Point(x, y);\nconst jsonPoint = aPoint.toJSON();\n</code></pre>"},{"location":"reference/primitives/#method-tostring_1","title":"Method toString","text":"<p>function toString() { [native code] }</p> <p>Converts the point coordinates to a hexadecimal string. A wrapper method for encode. Byte 0x02 or 0x03 is used as prefix based on the 'y' coordinate being even or odd respectively.</p> <pre><code>toString(): string \n</code></pre> <p>Returns</p> <p>A hexadecimal string representation of the point coordinates.</p> <p>Example</p> <pre><code>const aPoint = new Point(x, y);\nconst stringPoint = aPoint.toString();\n</code></pre>"},{"location":"reference/primitives/#method-validate","title":"Method validate","text":"<p>Validates if a point belongs to the curve. Follows the short Weierstrass equation for elliptic curves: y^2 = x^3 + ax + b.</p> <pre><code>validate(): boolean \n</code></pre> <p>Returns</p> <p>true if the point is on the curve, false otherwise.</p> <p>Example</p> <pre><code>const aPoint = new Point(x, y);\nconst isValid = aPoint.validate();\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#class-pointinfinitefield","title":"Class: PointInFiniteField","text":"<pre><code>export class PointInFiniteField {\n    x: BigNumber;\n    y: BigNumber;\n    constructor(x: BigNumber, y: BigNumber) \n    toString(): string \n    static fromString(str: string): PointInFiniteField \n}\n</code></pre> <p>See also: BigNumber</p>"},{"location":"reference/primitives/#method-tostring_2","title":"Method toString","text":"<p>function toString() { [native code] }</p> <pre><code>toString(): string \n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#class-polynomial","title":"Class: Polynomial","text":"<p>Polynomial class</p> <p>This class is used to create a polynomial with a given threshold and a private key. The polynomial is used to create shares of the private key.</p> <p>Example</p> <pre><code>const key = new PrivateKey()\nconst threshold = 2\nconst polynomial = new Polynomial(key, threshold)\n</code></pre> <pre><code>export default class Polynomial {\n    readonly points: PointInFiniteField[];\n    readonly threshold: number;\n    constructor(points: PointInFiniteField[], threshold?: number) \n    static fromPrivateKey(key: PrivateKey, threshold: number): Polynomial \n    valueAt(x: BigNumber): BigNumber \n}\n</code></pre> <p>See also: BigNumber, PointInFiniteField, PrivateKey</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#class-privatekey","title":"Class: PrivateKey","text":"<p>Represents a Private Key, which is a secret that can be used to generate signatures in a cryptographic system.</p> <p>The <code>PrivateKey</code> class extends from the <code>BigNumber</code> class. It offers methods to create signatures, verify them, create a corresponding public key and derive a shared secret from a public key.</p> <pre><code>export default class PrivateKey extends BigNumber {\n    static fromRandom(): PrivateKey \n    static fromString(str: string, base: number | \"hex\" = \"hex\"): PrivateKey \n    static fromHex(str: string): PrivateKey \n    static fromWif(wif: string, prefixLength: number = 1): PrivateKey \n    constructor(number: BigNumber | number | string | number[] = 0, base: number | \"be\" | \"le\" | \"hex\" = 10, endian: \"be\" | \"le\" = \"be\", modN: \"apply\" | \"nocheck\" | \"error\" = \"apply\") \n    checkInField(): {\n        inField: boolean;\n        modN: BigNumber;\n    } \n    isValid(): boolean \n    sign(msg: number[] | string, enc?: \"hex\" | \"utf8\", forceLowS: boolean = true, customK?: ((iter: number) =&gt; BigNumber) | BigNumber): Signature \n    verify(msg: number[] | string, sig: Signature, enc?: \"hex\"): boolean \n    toPublicKey(): PublicKey \n    toWif(prefix: number[] = [128]): string \n    toAddress(prefix: number[] | string = [0]): string \n    toHex(): string \n    toString(base: number | \"hex\" = \"hex\", padding: number = 64): string \n    deriveSharedSecret(key: PublicKey): Point \n    deriveChild(publicKey: PublicKey, invoiceNumber: string, cacheSharedSecret?: ((priv: PrivateKey, pub: Point, point: Point) =&gt; void), retrieveCachedSharedSecret?: ((priv: PrivateKey, pub: Point) =&gt; (Point | undefined))): PrivateKey \n    toKeyShares(threshold: number, totalShares: number): KeyShares \n    toBackupShares(threshold: number, totalShares: number): string[] \n    static fromBackupShares(shares: string[]): PrivateKey \n    static fromKeyShares(keyShares: KeyShares): PrivateKey \n}\n</code></pre> <p>See also: BigNumber, KeyShares, Point, PublicKey, Signature, modN, sign, toHex, verify</p>"},{"location":"reference/primitives/#constructor_6","title":"Constructor","text":"<p><pre><code>constructor(number: BigNumber | number | string | number[] = 0, base: number | \"be\" | \"le\" | \"hex\" = 10, endian: \"be\" | \"le\" = \"be\", modN: \"apply\" | \"nocheck\" | \"error\" = \"apply\") \n</code></pre> See also: BigNumber, modN</p> <p>Argument Details</p> <ul> <li>number</li> <li>The number (various types accepted) to construct a BigNumber from. Default is 0.</li> <li>base</li> <li>The base of number provided. By default is 10. Ignored if number is BigNumber.</li> <li>endian</li> <li>The endianness provided. By default is 'big endian'. Ignored if number is BigNumber.</li> <li>modN</li> <li>Optional. Default 'apply. If 'apply', apply modN to input to guarantee a valid PrivateKey. If 'error', if input is out of field throw new Error('Input is out of field'). If 'nocheck', assumes input is in field.</li> </ul> <p>Example</p> <pre><code>import PrivateKey from './PrivateKey';\nimport BigNumber from './BigNumber';\nconst privKey = new PrivateKey(new BigNumber('123456', 10, 'be'));\n</code></pre>"},{"location":"reference/primitives/#method-checkinfield","title":"Method checkInField","text":"<p>A utility function to check that the value of this PrivateKey lies in the field limited by curve.n</p> <p><pre><code>checkInField(): {\n    inField: boolean;\n    modN: BigNumber;\n} \n</code></pre> See also: BigNumber, modN</p> <p>Returns</p> <p>, modN } where modN is this PrivateKey's current BigNumber value mod curve.n, and inField is true only if modN equals current BigNumber value.</p>"},{"location":"reference/primitives/#method-derivechild","title":"Method deriveChild","text":"<p>Derives a child key with BRC-42.</p> <p><pre><code>deriveChild(publicKey: PublicKey, invoiceNumber: string, cacheSharedSecret?: ((priv: PrivateKey, pub: Point, point: Point) =&gt; void), retrieveCachedSharedSecret?: ((priv: PrivateKey, pub: Point) =&gt; (Point | undefined))): PrivateKey \n</code></pre> See also: Point, PrivateKey, PublicKey</p> <p>Returns</p> <p>The derived child key.</p> <p>Argument Details</p> <ul> <li>publicKey</li> <li>The public key of the other party</li> <li>invoiceNumber</li> <li>The invoice number used to derive the child key</li> <li>cacheSharedSecret</li> <li>Optional function to cache shared secrets</li> <li>retrieveCachedSharedSecret</li> <li>Optional function to retrieve shared secrets from the cache</li> </ul>"},{"location":"reference/primitives/#method-derivesharedsecret","title":"Method deriveSharedSecret","text":"<p>Derives a shared secret from the public key.</p> <p><pre><code>deriveSharedSecret(key: PublicKey): Point \n</code></pre> See also: Point, PublicKey</p> <p>Returns</p> <p>The derived shared secret (a point on the curve).</p> <p>Argument Details</p> <ul> <li>key</li> <li>The public key to derive the shared secret from.</li> </ul> <p>Throws</p> <p>Will throw an error if the public key is not valid.</p> <p>Example</p> <pre><code>const privateKey = PrivateKey.fromRandom();\nconst publicKey = privateKey.toPublicKey();\nconst sharedSecret = privateKey.deriveSharedSecret(publicKey);\n</code></pre>"},{"location":"reference/primitives/#method-frombackupshares","title":"Method fromBackupShares","text":"<p><pre><code>static fromBackupShares(shares: string[]): PrivateKey \n</code></pre> See also: PrivateKey</p> <p>Returns</p> <p>PrivateKey</p> <p>Example</p> <pre><code>const share1 = '3znuzt7DZp8HzZTfTh5MF9YQKNX3oSxTbSYmSRGrH2ev.2Nm17qoocmoAhBTCs8TEBxNXCskV9N41rB2PckcgYeqV.2.35449bb9'\nconst share2 = 'Cm5fuUc39X5xgdedao8Pr1kvCSm8Gk7Cfenc7xUKcfLX.2juyK9BxCWn2DiY5JUAgj9NsQ77cc9bWksFyW45haXZm.2.35449bb9'\n\nconst recoveredKey = PrivateKey.fromBackupShares([share1, share2])\n</code></pre>"},{"location":"reference/primitives/#method-fromhex_1","title":"Method fromHex","text":"<p>Generates a private key from a hexadecimal string.</p> <p><pre><code>static fromHex(str: string): PrivateKey \n</code></pre> See also: PrivateKey</p> <p>Returns</p> <p>The generated Private Key instance.</p> <p>Argument Details</p> <ul> <li>str</li> <li>The hexadecimal string representing the private key. The string must represent a valid private key in big-endian format.</li> </ul> <p>Throws</p> <p>If the string is not a valid hexadecimal or represents an invalid private key.</p>"},{"location":"reference/primitives/#method-fromkeyshares","title":"Method fromKeyShares","text":"<p>Combines shares to reconstruct the private key.</p> <p><pre><code>static fromKeyShares(keyShares: KeyShares): PrivateKey \n</code></pre> See also: KeyShares, PrivateKey</p> <p>Returns</p> <p>The reconstructed private key.</p> <p>Argument Details</p> <ul> <li>shares</li> <li>An array of points (shares) to be used to reconstruct the private key.</li> <li>threshold</li> <li>The minimum number of shares required to reconstruct the private key.</li> </ul>"},{"location":"reference/primitives/#method-fromrandom","title":"Method fromRandom","text":"<p>Generates a private key randomly.</p> <p><pre><code>static fromRandom(): PrivateKey \n</code></pre> See also: PrivateKey</p> <p>Returns</p> <p>The newly generated Private Key.</p> <p>Example</p> <pre><code>const privateKey = PrivateKey.fromRandom();\n</code></pre>"},{"location":"reference/primitives/#method-fromstring_2","title":"Method fromString","text":"<p>Generates a private key from a string.</p> <p><pre><code>static fromString(str: string, base: number | \"hex\" = \"hex\"): PrivateKey \n</code></pre> See also: PrivateKey</p> <p>Returns</p> <p>The generated Private Key.</p> <p>Argument Details</p> <ul> <li>str</li> <li>The string to generate the private key from.</li> <li>base</li> <li>The base of the string.</li> </ul> <p>Throws</p> <p>Will throw an error if the string is not valid.</p>"},{"location":"reference/primitives/#method-fromwif","title":"Method fromWif","text":"<p>Generates a private key from a WIF (Wallet Import Format) string.</p> <p><pre><code>static fromWif(wif: string, prefixLength: number = 1): PrivateKey \n</code></pre> See also: PrivateKey</p> <p>Returns</p> <p>The generated Private Key.</p> <p>Argument Details</p> <ul> <li>wif</li> <li>The WIF string to generate the private key from.</li> <li>base</li> <li>The base of the string.</li> </ul> <p>Throws</p> <p>Will throw an error if the string is not a valid WIF.</p>"},{"location":"reference/primitives/#method-isvalid","title":"Method isValid","text":"<pre><code>isValid(): boolean \n</code></pre> <p>Returns</p> <p>true if the PrivateKey's current BigNumber value lies in the field limited by curve.n</p>"},{"location":"reference/primitives/#method-sign","title":"Method sign","text":"<p>Signs a message using the private key.</p> <p><pre><code>sign(msg: number[] | string, enc?: \"hex\" | \"utf8\", forceLowS: boolean = true, customK?: ((iter: number) =&gt; BigNumber) | BigNumber): Signature \n</code></pre> See also: BigNumber, Signature</p> <p>Returns</p> <p>A digital signature generated from the hash of the message and the private key.</p> <p>Argument Details</p> <ul> <li>msg</li> <li>The message (array of numbers or string) to be signed.</li> <li>enc</li> <li>If 'hex' the string will be treated as hex, utf8 otherwise.</li> <li>forceLowS</li> <li>If true (the default), the signature will be forced to have a low S value.</li> <li>customK</li> <li>\u2014 If provided, uses a custom K-value for the signature. Provie a function that returns a BigNumber, or the BigNumber itself.</li> </ul> <p>Example</p> <pre><code>const privateKey = PrivateKey.fromRandom();\nconst signature = privateKey.sign('Hello, World!');\n</code></pre>"},{"location":"reference/primitives/#method-toaddress","title":"Method toAddress","text":"<p>Base58Check encodes the hash of the public key associated with this private key with a prefix to indicate locking script type. Defaults to P2PKH for mainnet, otherwise known as a \"Bitcoin Address\".</p> <pre><code>toAddress(prefix: number[] | string = [0]): string \n</code></pre> <p>Returns</p> <p>Returns the address encoding associated with the hash of the public key associated with this private key.</p> <p>Argument Details</p> <ul> <li>prefix</li> <li>defaults to [0x00] for mainnet, set to [0x6f] for testnet or use the strings 'testnet' or 'mainnet'</li> </ul> <p>Example</p> <pre><code>const address = privkey.toAddress()\nconst address = privkey.toAddress('mainnet')\nconst testnetAddress = privkey.toAddress([0x6f])\nconst testnetAddress = privkey.toAddress('testnet')\n</code></pre>"},{"location":"reference/primitives/#method-tobackupshares","title":"Method toBackupShares","text":"<pre><code>toBackupShares(threshold: number, totalShares: number): string[] \n</code></pre> <p>Argument Details</p> <ul> <li>threshold</li> <li>The number of shares which will be required to reconstruct the private key.</li> <li>totalShares</li> <li>The number of shares to generate for distribution.</li> </ul>"},{"location":"reference/primitives/#method-tohex_1","title":"Method toHex","text":"<p>Converts this PrivateKey to a hexadecimal string.</p> <pre><code>toHex(): string \n</code></pre> <p>Returns</p> <p>Returns a string representing the hexadecimal value of this BigNumber.</p> <p>Argument Details</p> <ul> <li>length</li> <li>The minimum length of the hex string</li> </ul> <p>Example</p> <pre><code>const bigNumber = new BigNumber(255);\nconst hex = bigNumber.toHex();\n</code></pre>"},{"location":"reference/primitives/#method-tokeyshares","title":"Method toKeyShares","text":"<p>Splits the private key into shares using Shamir's Secret Sharing Scheme.</p> <p><pre><code>toKeyShares(threshold: number, totalShares: number): KeyShares \n</code></pre> See also: KeyShares</p> <p>Returns</p> <p>An array of shares.</p> <p>Argument Details</p> <ul> <li>threshold</li> <li>The minimum number of shares required to reconstruct the private key.</li> <li>totalShares</li> <li>The total number of shares to generate.</li> <li>prime</li> <li>The prime number to be used in Shamir's Secret Sharing Scheme.</li> </ul> <p>Example</p> <pre><code>const key = PrivateKey.fromRandom()\nconst shares = key.toKeyShares(2, 5)\n</code></pre>"},{"location":"reference/primitives/#method-topublickey","title":"Method toPublicKey","text":"<p>Converts the private key to its corresponding public key.</p> <p>The public key is generated by multiplying the base point G of the curve and the private key.</p> <p><pre><code>toPublicKey(): PublicKey \n</code></pre> See also: PublicKey</p> <p>Returns</p> <p>The generated PublicKey.</p> <p>Example</p> <pre><code>const privateKey = PrivateKey.fromRandom();\nconst publicKey = privateKey.toPublicKey();\n</code></pre>"},{"location":"reference/primitives/#method-tostring_3","title":"Method toString","text":"<p>function toString() { [native code] }</p> <p>Converts this PrivateKey to a string representation.</p> <pre><code>toString(base: number | \"hex\" = \"hex\", padding: number = 64): string \n</code></pre> <p>Returns</p> <p>A string representation of the PrivateKey in the specified base, padded to the specified length.</p> <p>Argument Details</p> <ul> <li>base</li> <li>The base for representing the number. Default is hexadecimal ('hex').</li> <li>padding</li> <li>The minimum number of digits for the output string. Default is 64, ensuring a 256-bit representation in hexadecimal.</li> </ul>"},{"location":"reference/primitives/#method-towif","title":"Method toWif","text":"<p>Converts the private key to a Wallet Import Format (WIF) string.</p> <p>Base58Check encoding is used for encoding the private key. The prefix</p> <pre><code>toWif(prefix: number[] = [128]): string \n</code></pre> <p>Returns</p> <p>The WIF string.</p> <p>Argument Details</p> <ul> <li>prefix</li> <li>defaults to [0x80] for mainnet, set it to [0xef] for testnet.</li> </ul> <p>Throws</p> <p>Error('Value is out of field') if current BigNumber value is out of field limited by curve.n</p> <p>Example</p> <pre><code>const privateKey = PrivateKey.fromRandom();\nconst wif = privateKey.toWif();\nconst testnetWif = privateKey.toWif([0xef]);\n</code></pre>"},{"location":"reference/primitives/#method-verify","title":"Method verify","text":"<p>Verifies a message's signature using the public key associated with this private key.</p> <p><pre><code>verify(msg: number[] | string, sig: Signature, enc?: \"hex\"): boolean \n</code></pre> See also: Signature</p> <p>Returns</p> <p>Whether or not the signature is valid.</p> <p>Argument Details</p> <ul> <li>msg</li> <li>The original message which has been signed.</li> <li>sig</li> <li>The signature to be verified.</li> <li>enc</li> <li>The data encoding method.</li> </ul> <p>Example</p> <pre><code>const privateKey = PrivateKey.fromRandom();\nconst signature = privateKey.sign('Hello, World!');\nconst isSignatureValid = privateKey.verify('Hello, World!', signature);\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#class-publickey","title":"Class: PublicKey","text":"<p>The PublicKey class extends the Point class. It is used in public-key cryptography to derive shared secret, verify message signatures, and encode the public key in the DER format. The class comes with static methods to generate PublicKey instances from private keys or from strings.</p> <pre><code>export default class PublicKey extends Point {\n    static fromPrivateKey(key: PrivateKey): PublicKey \n    static fromString(str: string): PublicKey \n    static fromDER(bytes: number[]): PublicKey \n    constructor(x: Point | BigNumber | number | number[] | string | null, y: BigNumber | number | number[] | string | null = null, isRed: boolean = true) \n    deriveSharedSecret(priv: PrivateKey): Point \n    verify(msg: number[] | string, sig: Signature, enc?: \"hex\" | \"utf8\"): boolean \n    toDER(enc?: \"hex\" | undefined): number[] | string \n    toHash(enc?: \"hex\"): number[] | string \n    toAddress(prefix: number[] | string = [0]): string \n    deriveChild(privateKey: PrivateKey, invoiceNumber: string, cacheSharedSecret?: ((priv: PrivateKey, pub: Point, point: Point) =&gt; void), retrieveCachedSharedSecret?: ((priv: PrivateKey, pub: Point) =&gt; (Point | undefined))): PublicKey \n    static fromMsgHashAndCompactSignature(msgHash: BigNumber, signature: number[] | string, enc?: \"hex\" | \"base64\"): PublicKey \n}\n</code></pre> <p>See also: BigNumber, Point, PrivateKey, Signature, verify</p>"},{"location":"reference/primitives/#constructor_7","title":"Constructor","text":"<p><pre><code>constructor(x: Point | BigNumber | number | number[] | string | null, y: BigNumber | number | number[] | string | null = null, isRed: boolean = true) \n</code></pre> See also: BigNumber, Point</p> <p>Argument Details</p> <ul> <li>x</li> <li>A point or the x-coordinate of the point. May be a number, a BigNumber, a string (which will be interpreted as hex), a number array, or null. If null, an \"Infinity\" point is constructed.</li> <li>y</li> <li>If x is not a point, the y-coordinate of the point, similar to x.</li> <li>isRed</li> <li>A boolean indicating if the point is a member of the field of integers modulo the k256 prime. Default is true.</li> </ul> <p>Example</p> <pre><code>new PublicKey(point1);\nnew PublicKey('abc123', 'def456');\n</code></pre>"},{"location":"reference/primitives/#method-derivechild_1","title":"Method deriveChild","text":"<p>Derives a child key with BRC-42.</p> <p><pre><code>deriveChild(privateKey: PrivateKey, invoiceNumber: string, cacheSharedSecret?: ((priv: PrivateKey, pub: Point, point: Point) =&gt; void), retrieveCachedSharedSecret?: ((priv: PrivateKey, pub: Point) =&gt; (Point | undefined))): PublicKey \n</code></pre> See also: Point, PrivateKey, PublicKey</p> <p>Returns</p> <p>The derived child key.</p> <p>Argument Details</p> <ul> <li>privateKey</li> <li>The private key of the other party</li> <li>invoiceNumber</li> <li>The invoice number used to derive the child key</li> <li>cacheSharedSecret</li> <li>Optional function to cache shared secrets</li> <li>retrieveCachedSharedSecret</li> <li>Optional function to retrieve shared secrets from the cache</li> </ul>"},{"location":"reference/primitives/#method-derivesharedsecret_1","title":"Method deriveSharedSecret","text":"<p>Derive a shared secret from a public key and a private key for use in symmetric encryption. This method multiplies the public key (an instance of Point) with a private key.</p> <p><pre><code>deriveSharedSecret(priv: PrivateKey): Point \n</code></pre> See also: Point, PrivateKey</p> <p>Returns</p> <p>Returns the Point representing the shared secret.</p> <p>Argument Details</p> <ul> <li>priv</li> <li>The private key to use in deriving the shared secret.</li> </ul> <p>Throws</p> <p>Will throw an error if the public key is not valid for ECDH secret derivation.</p> <p>Example</p> <pre><code>const myPrivKey = new PrivateKey(...)\nconst sharedSecret = myPubKey.deriveSharedSecret(myPrivKey)\n</code></pre>"},{"location":"reference/primitives/#method-fromder_1","title":"Method fromDER","text":"<p>Static factory method to create a PublicKey instance from a number array.</p> <p><pre><code>static fromDER(bytes: number[]): PublicKey \n</code></pre> See also: PublicKey</p> <p>Returns</p> <p>Returns the PublicKey created from the number array.</p> <p>Argument Details</p> <ul> <li>bytes</li> <li>A number array representing a public key.</li> </ul> <p>Example</p> <pre><code>const myPubKey = PublicKey.fromString(\"03....\")\n</code></pre>"},{"location":"reference/primitives/#method-frommsghashandcompactsignature","title":"Method fromMsgHashAndCompactSignature","text":"<p>Takes an array of numbers or a string and returns a new PublicKey instance. This method will throw an error if the Compact encoding is invalid. If a string is provided, it is assumed to represent a hexadecimal sequence. compactByte value 27-30 means uncompressed public key. 31-34 means compressed public key. The range represents the recovery param which can be 0,1,2,3.</p> <p><pre><code>static fromMsgHashAndCompactSignature(msgHash: BigNumber, signature: number[] | string, enc?: \"hex\" | \"base64\"): PublicKey \n</code></pre> See also: BigNumber, PublicKey</p> <p>Returns</p> <p>A PublicKey instance derived from the message hash and compact signature.</p> <p>Argument Details</p> <ul> <li>msgHash</li> <li>The message hash which was signed.</li> <li>signature</li> <li>The signature in compact format.</li> <li>enc</li> <li>The encoding of the signature string.</li> </ul> <p>Example</p> <pre><code>const publicKey = Signature.fromMsgHashAndCompactSignature(msgHash, 'IMOl2mVKfDgsSsHT4uIYBNN4e...', 'base64');\n</code></pre>"},{"location":"reference/primitives/#method-fromprivatekey","title":"Method fromPrivateKey","text":"<p>Static factory method to derive a public key from a private key. It multiplies the generator point 'g' on the elliptic curve by the private key.</p> <p><pre><code>static fromPrivateKey(key: PrivateKey): PublicKey \n</code></pre> See also: PrivateKey, PublicKey</p> <p>Returns</p> <p>Returns the PublicKey derived from the given PrivateKey.</p> <p>Argument Details</p> <ul> <li>key</li> <li>The private key from which to derive the public key.</li> </ul> <p>Example</p> <pre><code>const myPrivKey = new PrivateKey(...)\nconst myPubKey = PublicKey.fromPrivateKey(myPrivKey)\n</code></pre>"},{"location":"reference/primitives/#method-fromstring_3","title":"Method fromString","text":"<p>Static factory method to create a PublicKey instance from a string.</p> <p><pre><code>static fromString(str: string): PublicKey \n</code></pre> See also: PublicKey</p> <p>Returns</p> <p>Returns the PublicKey created from the string.</p> <p>Argument Details</p> <ul> <li>str</li> <li>A string representing a public key.</li> </ul> <p>Example</p> <pre><code>const myPubKey = PublicKey.fromString(\"03....\")\n</code></pre>"},{"location":"reference/primitives/#method-toaddress_1","title":"Method toAddress","text":"<p>Base58Check encodes the hash of the public key with a prefix to indicate locking script type. Defaults to P2PKH for mainnet, otherwise known as a \"Bitcoin Address\".</p> <pre><code>toAddress(prefix: number[] | string = [0]): string \n</code></pre> <p>Returns</p> <p>Returns the address encoding associated with the hash of the public key.</p> <p>Argument Details</p> <ul> <li>prefix</li> <li>defaults to [0x00] for mainnet, set to [0x6f] for testnet or use the strings 'mainnet' or 'testnet'</li> </ul> <p>Example</p> <pre><code>const address = pubkey.toAddress()\nconst address = pubkey.toAddress('mainnet')\nconst testnetAddress = pubkey.toAddress([0x6f])\nconst testnetAddress = pubkey.toAddress('testnet')\n</code></pre>"},{"location":"reference/primitives/#method-toder","title":"Method toDER","text":"<p>Encode the public key to DER (Distinguished Encoding Rules) format.</p> <pre><code>toDER(enc?: \"hex\" | undefined): number[] | string \n</code></pre> <p>Returns</p> <p>Returns the DER-encoded public key in number array or string.</p> <p>Argument Details</p> <ul> <li>enc</li> <li>The encoding of the DER string. undefined = number array, 'hex' = hex string.</li> </ul> <p>Example</p> <pre><code>const derPublicKey = myPubKey.toDER()\n</code></pre>"},{"location":"reference/primitives/#method-tohash","title":"Method toHash","text":"<p>Hash sha256 and ripemd160 of the public key.</p> <pre><code>toHash(enc?: \"hex\"): number[] | string \n</code></pre> <p>Returns</p> <p>Returns the hash of the public key.</p> <p>Example</p> <pre><code>const publicKeyHash = pubkey.toHash()\n</code></pre>"},{"location":"reference/primitives/#method-verify_1","title":"Method verify","text":"<p>Verify a signature of a message using this public key.</p> <p><pre><code>verify(msg: number[] | string, sig: Signature, enc?: \"hex\" | \"utf8\"): boolean \n</code></pre> See also: Signature</p> <p>Returns</p> <p>Returns true if the signature is verified successfully, otherwise false.</p> <p>Argument Details</p> <ul> <li>msg</li> <li>The message to verify. It can be a string or an array of numbers.</li> <li>sig</li> <li>The Signature of the message that needs verification.</li> <li>enc</li> <li>The encoding of the message. It defaults to 'utf8'.</li> </ul> <p>Example</p> <pre><code>const myMessage = \"Hello, world!\"\nconst mySignature = new Signature(...)\nconst isVerified = myPubKey.verify(myMessage, mySignature)\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#class-ripemd160","title":"Class: RIPEMD160","text":"<p>An implementation of RIPEMD160 cryptographic hash function. Extends the BaseHash class. It provides a way to compute a 'digest' for any kind of input data; transforming the data into a unique output of fixed size. The output is deterministic; it will always be the same for the same input.</p> <p>Example</p> <pre><code>const ripemd160 = new RIPEMD160();\n</code></pre> <pre><code>export class RIPEMD160 extends BaseHash {\n    h: number[];\n    constructor() \n    _update(msg: number[], start: number): void \n    _digest(): number[] \n    _digestHex(): string \n}\n</code></pre>"},{"location":"reference/primitives/#property-h","title":"Property h","text":"<p>Array that is updated iteratively as part of hashing computation.</p> <pre><code>h: number[]\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#class-reader","title":"Class: Reader","text":"<pre><code>export class Reader {\n    public bin: number[];\n    public pos: number;\n    constructor(bin: number[] = [], pos: number = 0) \n    public eof(): boolean \n    public read(len = this.length): number[] \n    public readReverse(len = this.length): number[] \n    public readUInt8(): number \n    public readInt8(): number \n    public readUInt16BE(): number \n    public readInt16BE(): number \n    public readUInt16LE(): number \n    public readInt16LE(): number \n    public readUInt32BE(): number \n    public readInt32BE(): number \n    public readUInt32LE(): number \n    public readInt32LE(): number \n    public readUInt64BEBn(): BigNumber \n    public readUInt64LEBn(): BigNumber \n    public readInt64LEBn(): BigNumber \n    public readVarIntNum(signed: boolean = true): number \n    public readVarInt(): number[] \n    public readVarIntBn(): BigNumber \n}\n</code></pre> <p>See also: BigNumber</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#class-reductioncontext","title":"Class: ReductionContext","text":"<p>A base reduction engine that provides several arithmetic operations over big numbers under a modulus context. It's particularly suitable for calculations required in cryptography algorithms and encoding schemas.</p> <pre><code>export default class ReductionContext {\n    prime: Mersenne | null;\n    m: BigNumber;\n    constructor(m: BigNumber | \"k256\") \n    verify1(a: BigNumber): void \n    verify2(a: BigNumber, b: BigNumber): void \n    imod(a: BigNumber): BigNumber \n    neg(a: BigNumber): BigNumber \n    add(a: BigNumber, b: BigNumber): BigNumber \n    iadd(a: BigNumber, b: BigNumber): BigNumber \n    sub(a: BigNumber, b: BigNumber): BigNumber \n    isub(a: BigNumber, b: BigNumber): BigNumber \n    shl(a: BigNumber, num: number): BigNumber \n    imul(a: BigNumber, b: BigNumber): BigNumber \n    mul(a: BigNumber, b: BigNumber): BigNumber \n    isqr(a: BigNumber): BigNumber \n    sqr(a: BigNumber): BigNumber \n    sqrt(a: BigNumber): BigNumber \n    invm(a: BigNumber): BigNumber \n    pow(a: BigNumber, num: BigNumber): BigNumber \n    convertTo(num: BigNumber): BigNumber \n    convertFrom(num: BigNumber): BigNumber \n}\n</code></pre> <p>See also: BigNumber, Mersenne</p>"},{"location":"reference/primitives/#constructor_8","title":"Constructor","text":"<p>Constructs a new ReductionContext.</p> <p><pre><code>constructor(m: BigNumber | \"k256\") \n</code></pre> See also: BigNumber</p> <p>Argument Details</p> <ul> <li>m</li> <li>A BigNumber representing the modulus, or 'k256' to create a context for Koblitz curve.</li> </ul> <p>Example</p> <pre><code>new ReductionContext(new BigNumber(11));\nnew ReductionContext('k256');\n</code></pre>"},{"location":"reference/primitives/#property-m","title":"Property m","text":"<p>The modulus used for reduction operations.</p> <p><pre><code>m: BigNumber\n</code></pre> See also: BigNumber</p>"},{"location":"reference/primitives/#property-prime","title":"Property prime","text":"<p>The prime number utilised in the reduction context, typically an instance of Mersenne class.</p> <p><pre><code>prime: Mersenne | null\n</code></pre> See also: Mersenne</p>"},{"location":"reference/primitives/#method-add_2","title":"Method add","text":"<p>Performs the addition operation on two BigNumbers in the reduction context.</p> <p><pre><code>add(a: BigNumber, b: BigNumber): BigNumber \n</code></pre> See also: BigNumber</p> <p>Returns</p> <p>Returns the result of 'a + b' in the reduction context.</p> <p>Argument Details</p> <ul> <li>a</li> <li>First BigNumber to add.</li> <li>b</li> <li>Second BigNumber to add.</li> </ul> <p>Example</p> <pre><code>const context = new ReductionContext(new BigNumber(5));\ncontext.add(new BigNumber(2), new BigNumber(4)); // Returns 1\n</code></pre>"},{"location":"reference/primitives/#method-convertfrom_1","title":"Method convertFrom","text":"<p>Converts a BigNumber from reduction context to its regular form.</p> <p><pre><code>convertFrom(num: BigNumber): BigNumber \n</code></pre> See also: BigNumber</p> <p>Returns</p> <p>Returns the converted BigNumber in its regular form.</p> <p>Argument Details</p> <ul> <li>num</li> <li>The BigNumber to convert from the reduction context.</li> </ul> <p>Example</p> <pre><code>const context = new ReductionContext(new BigNumber(7));\nconst a = context.convertTo(new BigNumber(8)); // 'a' is now 1 in the reduction context\ncontext.convertFrom(a); // Returns 1\n</code></pre>"},{"location":"reference/primitives/#method-convertto_1","title":"Method convertTo","text":"<p>Converts a BigNumber to its equivalent in the reduction context.</p> <p><pre><code>convertTo(num: BigNumber): BigNumber \n</code></pre> See also: BigNumber</p> <p>Returns</p> <p>Returns the converted BigNumber compatible with the reduction context.</p> <p>Argument Details</p> <ul> <li>num</li> <li>The BigNumber to convert to the reduction context.</li> </ul> <p>Example</p> <pre><code>const context = new ReductionContext(new BigNumber(7));\ncontext.convertTo(new BigNumber(8)); // Returns 1 (8 % 7)\n</code></pre>"},{"location":"reference/primitives/#method-iadd","title":"Method iadd","text":"<p>Performs an in-place addition operation on two BigNumbers in the reduction context in order to avoid creating a new BigNumber, it modifies the first one with the result.</p> <p><pre><code>iadd(a: BigNumber, b: BigNumber): BigNumber \n</code></pre> See also: BigNumber</p> <p>Returns</p> <p>Returns the modified 'a' after addition with 'b' in the reduction context.</p> <p>Argument Details</p> <ul> <li>a</li> <li>First BigNumber to add.</li> <li>b</li> <li>Second BigNumber to add.</li> </ul> <p>Example</p> <pre><code>const context = new ReductionContext(new BigNumber(5));\nconst a = new BigNumber(2);\ncontext.iadd(a, new BigNumber(4)); // Modifies 'a' to be 1\n</code></pre>"},{"location":"reference/primitives/#method-imod","title":"Method imod","text":"<p>Performs an in-place reduction of the given BigNumber by the modulus of the reduction context, 'm'.</p> <p><pre><code>imod(a: BigNumber): BigNumber \n</code></pre> See also: BigNumber</p> <p>Returns</p> <p>Returns the reduced result.</p> <p>Argument Details</p> <ul> <li>a</li> <li>BigNumber to be reduced.</li> </ul> <p>Example</p> <pre><code>const context = new ReductionContext(new BigNumber(7));\ncontext.imod(new BigNumber(19)); // Returns 5\n</code></pre>"},{"location":"reference/primitives/#method-imul_1","title":"Method imul","text":"<p>Performs in-place multiplication of two BigNumbers in the reduction context, modifying the first BigNumber with the result.</p> <p><pre><code>imul(a: BigNumber, b: BigNumber): BigNumber \n</code></pre> See also: BigNumber</p> <p>Returns</p> <p>Returns the modified 'a' after multiplication with 'b' in the reduction context.</p> <p>Argument Details</p> <ul> <li>a</li> <li>First BigNumber to multiply.</li> <li>b</li> <li>Second BigNumber to multiply.</li> </ul> <p>Example</p> <pre><code>const context = new ReductionContext(new BigNumber(7));\nconst a = new BigNumber(3);\ncontext.imul(a, new BigNumber(2)); // Modifies 'a' to be 6\n</code></pre>"},{"location":"reference/primitives/#method-invm_1","title":"Method invm","text":"<p>Calculates the multiplicative inverse of a BigNumber in the reduction context.</p> <p><pre><code>invm(a: BigNumber): BigNumber \n</code></pre> See also: BigNumber</p> <p>Returns</p> <p>Returns the multiplicative inverse of 'a' in the reduction context.</p> <p>Argument Details</p> <ul> <li>a</li> <li>The BigNumber to find the multiplicative inverse of.</li> </ul> <p>Example</p> <pre><code>const context = new ReductionContext(new BigNumber(11));\ncontext.invm(new BigNumber(3)); // Returns 4 (3*4 mod 11 = 1)\n</code></pre>"},{"location":"reference/primitives/#method-isqr","title":"Method isqr","text":"<p>Calculates the square of a BigNumber in the reduction context, modifying the original BigNumber with the result.</p> <p><pre><code>isqr(a: BigNumber): BigNumber \n</code></pre> See also: BigNumber</p> <p>Returns</p> <p>Returns the squared 'a' in the reduction context.</p> <p>Argument Details</p> <ul> <li>a</li> <li>BigNumber to be squared.</li> </ul> <p>Example</p> <pre><code>const context = new ReductionContext(new BigNumber(7));\nconst a = new BigNumber(3);\ncontext.isqr(a); // Modifies 'a' to be 2 (9 % 7 = 2)\n</code></pre>"},{"location":"reference/primitives/#method-isub","title":"Method isub","text":"<p>Performs in-place subtraction of one BigNumber from another in the reduction context, it modifies the first BigNumber with the result.</p> <p><pre><code>isub(a: BigNumber, b: BigNumber): BigNumber \n</code></pre> See also: BigNumber</p> <p>Returns</p> <p>Returns the modified 'a' after subtraction of 'b' in the reduction context.</p> <p>Argument Details</p> <ul> <li>a</li> <li>BigNumber to be subtracted from.</li> <li>b</li> <li>BigNumber to subtract.</li> </ul> <p>Example</p> <pre><code>const context = new ReductionContext(new BigNumber(5));\nconst a = new BigNumber(4);\ncontext.isub(a, new BigNumber(2)); // Modifies 'a' to be 2\n</code></pre>"},{"location":"reference/primitives/#method-mul_2","title":"Method mul","text":"<p>Multiplies two BigNumbers in the reduction context.</p> <p><pre><code>mul(a: BigNumber, b: BigNumber): BigNumber \n</code></pre> See also: BigNumber</p> <p>Returns</p> <p>Returns the result of 'a * b' in the reduction context.</p> <p>Argument Details</p> <ul> <li>a</li> <li>First BigNumber to multiply.</li> <li>b</li> <li>Second BigNumber to multiply.</li> </ul> <p>Example</p> <pre><code>const context = new ReductionContext(new BigNumber(7));\ncontext.mul(new BigNumber(3), new BigNumber(2)); // Returns 6\n</code></pre>"},{"location":"reference/primitives/#method-neg_2","title":"Method neg","text":"<p>Negates a BigNumber in the context of the modulus.</p> <p><pre><code>neg(a: BigNumber): BigNumber \n</code></pre> See also: BigNumber</p> <p>Returns</p> <p>Returns the negation of 'a' in the reduction context.</p> <p>Argument Details</p> <ul> <li>a</li> <li>BigNumber to negate.</li> </ul> <p>Example</p> <pre><code>const context = new ReductionContext(new BigNumber(7));\ncontext.neg(new BigNumber(3)); // Returns 4\n</code></pre>"},{"location":"reference/primitives/#method-pow","title":"Method pow","text":"<p>Raises a BigNumber to a power in the reduction context.</p> <p><pre><code>pow(a: BigNumber, num: BigNumber): BigNumber \n</code></pre> See also: BigNumber</p> <p>Returns</p> <p>Returns the result of 'a' raised to the power of 'num' in the reduction context.</p> <p>Argument Details</p> <ul> <li>a</li> <li>The BigNumber to be raised to a power.</li> <li>num</li> <li>The power to raise the BigNumber to.</li> </ul> <p>Example</p> <pre><code>const context = new ReductionContext(new BigNumber(7));\ncontext.pow(new BigNumber(3), new BigNumber(2)); // Returns 2 (3^2 % 7)\n</code></pre>"},{"location":"reference/primitives/#method-shl","title":"Method shl","text":"<p>Performs bitwise shift left operation on a BigNumber in the reduction context.</p> <p><pre><code>shl(a: BigNumber, num: number): BigNumber \n</code></pre> See also: BigNumber</p> <p>Returns</p> <p>Returns the result of shifting 'a' left by 'num' positions in the reduction context.</p> <p>Argument Details</p> <ul> <li>a</li> <li>BigNumber to perform shift on.</li> <li>num</li> <li>The number of positions to shift.</li> </ul> <p>Example</p> <pre><code>const context = new ReductionContext(new BigNumber(32));\ncontext.shl(new BigNumber(4), 2); // Returns 16\n</code></pre>"},{"location":"reference/primitives/#method-sqr","title":"Method sqr","text":"<p>Calculates the square of a BigNumber in the reduction context.</p> <p><pre><code>sqr(a: BigNumber): BigNumber \n</code></pre> See also: BigNumber</p> <p>Returns</p> <p>Returns the result of 'a^2' in the reduction context.</p> <p>Argument Details</p> <ul> <li>a</li> <li>BigNumber to be squared.</li> </ul> <p>Example</p> <pre><code>const context = new ReductionContext(new BigNumber(7));\ncontext.sqr(new BigNumber(3)); // Returns 2 (9 % 7 = 2)\n</code></pre>"},{"location":"reference/primitives/#method-sqrt","title":"Method sqrt","text":"<p>Calculates the square root of a BigNumber in the reduction context.</p> <p><pre><code>sqrt(a: BigNumber): BigNumber \n</code></pre> See also: BigNumber</p> <p>Returns</p> <p>Returns the square root of 'a' in the reduction context.</p> <p>Argument Details</p> <ul> <li>a</li> <li>The BigNumber to calculate the square root of.</li> </ul> <p>Example</p> <pre><code>const context = new ReductionContext(new BigNumber(9));\ncontext.sqrt(new BigNumber(4)); // Returns 2\n</code></pre>"},{"location":"reference/primitives/#method-sub","title":"Method sub","text":"<p>Subtracts one BigNumber from another BigNumber in the reduction context.</p> <p><pre><code>sub(a: BigNumber, b: BigNumber): BigNumber \n</code></pre> See also: BigNumber</p> <p>Returns</p> <p>Returns the result of 'a - b' in the reduction context.</p> <p>Argument Details</p> <ul> <li>a</li> <li>BigNumber to be subtracted from.</li> <li>b</li> <li>BigNumber to subtract.</li> </ul> <p>Example</p> <pre><code>const context = new ReductionContext(new BigNumber(7));\ncontext.sub(new BigNumber(3), new BigNumber(2)); // Returns 1\n</code></pre>"},{"location":"reference/primitives/#method-verify1","title":"Method verify1","text":"<p>Verifies that a BigNumber is positive and red. Throws an error if these conditions are not met.</p> <p><pre><code>verify1(a: BigNumber): void \n</code></pre> See also: BigNumber</p> <p>Argument Details</p> <ul> <li>a</li> <li>The BigNumber to be verified.</li> </ul> <p>Example</p> <pre><code>this.verify1(new BigNumber(10).toRed());\nthis.verify1(new BigNumber(-10).toRed()); //throws an Error\nthis.verify1(new BigNumber(10)); //throws an Error\n</code></pre>"},{"location":"reference/primitives/#method-verify2","title":"Method verify2","text":"<p>Verifies that two BigNumbers are both positive and red. Also checks that they have the same reduction context. Throws an error if these conditions are not met.</p> <p><pre><code>verify2(a: BigNumber, b: BigNumber): void \n</code></pre> See also: BigNumber</p> <p>Argument Details</p> <ul> <li>a</li> <li>The first BigNumber to be verified.</li> <li>b</li> <li>The second BigNumber to be verified.</li> </ul> <p>Example</p> <pre><code>this.verify2(new BigNumber(10).toRed(this), new BigNumber(20).toRed(this));\nthis.verify2(new BigNumber(-10).toRed(this), new BigNumber(20).toRed(this)); //throws an Error\nthis.verify2(new BigNumber(10).toRed(this), new BigNumber(20)); //throws an Error\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#class-sha1","title":"Class: SHA1","text":"<p>An implementation of SHA1 cryptographic hash function. Extends the BaseHash class. It provides a way to compute a 'digest' for any kind of input data; transforming the data into a unique output of fixed size. The output is deterministic; it will always be the same for the same input.</p> <p>Example</p> <pre><code>const sha1 = new SHA1();\n</code></pre> <pre><code>export class SHA1 extends BaseHash {\n    h: number[];\n    W: number[];\n    k: number[];\n    constructor() \n    _update(msg: number[], start?: number): void \n    _digest(): number[] \n    _digestHex(): string \n}\n</code></pre>"},{"location":"reference/primitives/#property-w","title":"Property W","text":"<p>Provides a way to recycle usage of the array memory.</p> <pre><code>W: number[]\n</code></pre>"},{"location":"reference/primitives/#property-h_1","title":"Property h","text":"<p>The initial hash constants.</p> <pre><code>h: number[]\n</code></pre>"},{"location":"reference/primitives/#property-k_1","title":"Property k","text":"<p>The round constants used for each round of SHA-1.</p> <pre><code>k: number[]\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#class-sha1hmac","title":"Class: SHA1HMAC","text":"<pre><code>export class SHA1HMAC {\n    inner: SHA1;\n    outer: SHA1;\n    blockSize = 64;\n    constructor(key: number[] | string) \n    update(msg: number[] | string, enc?: \"hex\"): SHA1HMAC \n    digest(): number[] \n    digestHex(): string \n}\n</code></pre> <p>See also: SHA1</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#class-sha256","title":"Class: SHA256","text":"<p>An implementation of SHA256 cryptographic hash function. Extends the BaseHash class. It provides a way to compute a 'digest' for any kind of input data; transforming the data into a unique output of fixed size. The output is deterministic; it will always be the same for the same input.</p> <p>Example</p> <pre><code>const sha256 = new SHA256();\n</code></pre> <pre><code>export class SHA256 {\n    constructor() \n    update(msg: number[] | string, enc?: \"hex\" | \"utf8\"): this \n    digest(): number[] \n    digestHex(): string \n}\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#class-sha256hmac","title":"Class: SHA256HMAC","text":"<p>The <code>SHA256HMAC</code> class is used to create Hash-based Message Authentication Code (HMAC) using the SHA-256 cryptographic hash function.</p> <p>HMAC is a specific type of MAC involving a cryptographic hash function and a secret cryptographic key. It may be used to simultaneously verify both the data integrity and the authenticity of a message.</p> <p>This class also uses the SHA-256 cryptographic hash algorithm that produces a 256-bit (32-byte) hash value.</p> <pre><code>export class SHA256HMAC {\n    blockSize = 64;\n    outSize = 32;\n    constructor(key: number[] | string) \n    update(msg: number[] | string, enc?: \"hex\"): SHA256HMAC \n    digest(): number[] \n    digestHex(): string \n}\n</code></pre>"},{"location":"reference/primitives/#constructor_9","title":"Constructor","text":"<p>The constructor for the <code>SHA256HMAC</code> class.</p> <p>It initializes the <code>SHA256HMAC</code> object and sets up the inner and outer padded keys. If the key size is larger than the blockSize, it is digested using SHA-256. If the key size is less than the blockSize, it is padded with zeroes.</p> <pre><code>constructor(key: number[] | string) \n</code></pre> <p>Argument Details</p> <ul> <li>key</li> <li>The key to use to create the HMAC. Can be a number array or a string in hexadecimal format.</li> </ul> <p>Example</p> <pre><code>const myHMAC = new SHA256HMAC('deadbeef');\n</code></pre>"},{"location":"reference/primitives/#property-blocksize","title":"Property blockSize","text":"<p>The block size for the SHA-256 hash function, in bytes. It's set to 64 bytes.</p> <pre><code>blockSize = 64\n</code></pre>"},{"location":"reference/primitives/#property-outsize","title":"Property outSize","text":"<p>The output size of the SHA-256 hash function, in bytes. It's set to 32 bytes.</p> <pre><code>outSize = 32\n</code></pre>"},{"location":"reference/primitives/#method-digest","title":"Method digest","text":"<p>Finalizes the HMAC computation and returns the resultant hash.</p> <pre><code>digest(): number[] \n</code></pre> <p>Returns</p> <p>Returns the digest of the hashed data. Can be a number array or a string.</p> <p>Example</p> <pre><code>let hashedMessage = myHMAC.digest();\n</code></pre>"},{"location":"reference/primitives/#method-digesthex","title":"Method digestHex","text":"<p>Finalizes the HMAC computation and returns the resultant hash as a hex string.</p> <pre><code>digestHex(): string \n</code></pre> <p>Returns</p> <p>Returns the digest of the hashed data as a hex string</p> <p>Example</p> <pre><code>let hashedMessage = myHMAC.digestHex();\n</code></pre>"},{"location":"reference/primitives/#method-update_1","title":"Method update","text":"<p>Updates the <code>SHA256HMAC</code> object with part of the message to be hashed.</p> <p><pre><code>update(msg: number[] | string, enc?: \"hex\"): SHA256HMAC \n</code></pre> See also: SHA256HMAC</p> <p>Returns</p> <p>Returns the instance of <code>SHA256HMAC</code> for chaining calls.</p> <p>Argument Details</p> <ul> <li>msg</li> <li>Part of the message to hash. Can be a number array or a string.</li> <li>enc</li> <li>If 'hex', then the input is encoded as hexadecimal. If undefined or not 'hex', then no encoding is performed.</li> </ul> <p>Example</p> <pre><code>myHMAC.update('deadbeef', 'hex');\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#class-sha512","title":"Class: SHA512","text":"<p>An implementation of SHA512 cryptographic hash function. Extends the BaseHash class. It provides a way to compute a 'digest' for any kind of input data; transforming the data into a unique output of fixed size. The output is deterministic; it will always be the same for the same input.</p> <p>Example</p> <pre><code>const sha512 = new SHA512();\n</code></pre> <pre><code>export class SHA512 {\n    constructor() \n    update(msg: number[] | string, enc?: \"hex\" | \"utf8\"): this \n    digest(): number[] \n    digestHex(): string \n}\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#class-sha512hmac","title":"Class: SHA512HMAC","text":"<p>The <code>SHA512HMAC</code> class is used to create Hash-based Message Authentication Code (HMAC) using the SHA-512 cryptographic hash function.</p> <p>HMAC is a specific type of MAC involving a cryptographic hash function and a secret cryptographic key. It may be used to simultaneously verify both the data integrity and the authenticity of a message.</p> <p>This class also uses the SHA-512 cryptographic hash algorithm that produces a 512-bit (64-byte) hash value.</p> <pre><code>export class SHA512HMAC {\n    blockSize = 128;\n    outSize = 32;\n    constructor(key: number[] | string) \n    update(msg: number[] | string, enc?: \"hex\" | \"utf8\"): SHA512HMAC \n    digest(): number[] \n    digestHex(): string \n}\n</code></pre>"},{"location":"reference/primitives/#constructor_10","title":"Constructor","text":"<p>The constructor for the <code>SHA512HMAC</code> class.</p> <p>It initializes the <code>SHA512HMAC</code> object and sets up the inner and outer padded keys. If the key size is larger than the blockSize, it is digested using SHA-512. If the key size is less than the blockSize, it is padded with zeroes.</p> <pre><code>constructor(key: number[] | string) \n</code></pre> <p>Argument Details</p> <ul> <li>key</li> <li>The key to use to create the HMAC. Can be a number array or a string in hexadecimal format.</li> </ul> <p>Example</p> <pre><code>const myHMAC = new SHA512HMAC('deadbeef');\n</code></pre>"},{"location":"reference/primitives/#property-blocksize_1","title":"Property blockSize","text":"<p>The block size for the SHA-512 hash function, in bytes. It's set to 128 bytes.</p> <pre><code>blockSize = 128\n</code></pre>"},{"location":"reference/primitives/#property-outsize_1","title":"Property outSize","text":"<p>The output size of the SHA-512 hash function, in bytes. It's set to 64 bytes.</p> <pre><code>outSize = 32\n</code></pre>"},{"location":"reference/primitives/#method-digest_1","title":"Method digest","text":"<p>Finalizes the HMAC computation and returns the resultant hash.</p> <pre><code>digest(): number[] \n</code></pre> <p>Returns</p> <p>Returns the digest of the hashed data as a number array.</p> <p>Example</p> <pre><code>let hashedMessage = myHMAC.digest();\n</code></pre>"},{"location":"reference/primitives/#method-digesthex_1","title":"Method digestHex","text":"<p>Finalizes the HMAC computation and returns the resultant hash as a hex string.</p> <pre><code>digestHex(): string \n</code></pre> <p>Returns</p> <p>Returns the digest of the hashed data as a hex string</p> <p>Example</p> <pre><code>let hashedMessage = myHMAC.digestHex();\n</code></pre>"},{"location":"reference/primitives/#method-update_2","title":"Method update","text":"<p>Updates the <code>SHA512HMAC</code> object with part of the message to be hashed.</p> <p><pre><code>update(msg: number[] | string, enc?: \"hex\" | \"utf8\"): SHA512HMAC \n</code></pre> See also: SHA512HMAC</p> <p>Returns</p> <p>Returns the instance of <code>SHA512HMAC</code> for chaining calls.</p> <p>Argument Details</p> <ul> <li>msg</li> <li>Part of the message to hash. Can be a number array or a string.</li> <li>enc</li> <li>If 'hex', then the input is encoded as hexadecimal. If undefined or not 'hex', then no encoding is performed.</li> </ul> <p>Example</p> <pre><code>myHMAC.update('deadbeef', 'hex');\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#class-schnorr","title":"Class: Schnorr","text":"<p>Class representing the Schnorr Zero-Knowledge Proof (ZKP) protocol.</p> <p>This class provides methods to generate and verify proofs that demonstrate knowledge of a secret without revealing it. Specifically, it allows one party to prove to another that they know the private key corresponding to a public key and have correctly computed a shared secret, without disclosing the private key itself.</p> <p>The protocol involves two main methods: - <code>generateProof</code>: Generates a proof linking a public key <code>A</code> and a shared secret <code>S</code>, proving knowledge of the corresponding private key <code>a</code>. - <code>verifyProof</code>: Verifies the provided proof, ensuring its validity without revealing any secret information.</p> <p>The class utilizes elliptic curve cryptography (ECC) and the SHA-256 hash function to compute challenges within the proof.</p> <p>Example</p> <p><pre><code>const schnorr = new Schnorr();\nconst a = PrivateKey.fromRandom(); // Prover's private key\nconst A = a.toPublicKey();         // Prover's public key\nconst b = PrivateKey.fromRandom(); // Other party's private key\nconst B = b.toPublicKey();         // Other party's public key\nconst S = B.mul(a);                // Shared secret\n\n// Prover generates the proof\nconst proof = schnorr.generateProof(a, A, B, S);\n\n// Verifier verifies the proof\nconst isValid = schnorr.verifyProof(A.point, B.point, S.point, proof);\nconsole.log(`Proof is valid: ${isValid}`);\n</code></pre> <pre><code>export default class Schnorr {\n    constructor() \n    generateProof(aArg: PrivateKey, AArg: PublicKey, BArg: PublicKey, S: Point): {\n        R: Point;\n        SPrime: Point;\n        z: BigNumber;\n    } \n    verifyProof(A: Point, B: Point, S: Point, proof: {\n        R: Point;\n        SPrime: Point;\n        z: BigNumber;\n    }): boolean \n}\n</code></pre></p> <p>See also: BigNumber, Point, PrivateKey, PublicKey</p>"},{"location":"reference/primitives/#method-generateproof","title":"Method generateProof","text":"<p>Generates a proof that demonstrates the link between public key A and shared secret S</p> <p><pre><code>generateProof(aArg: PrivateKey, AArg: PublicKey, BArg: PublicKey, S: Point): {\n    R: Point;\n    SPrime: Point;\n    z: BigNumber;\n} \n</code></pre> See also: BigNumber, Point, PrivateKey, PublicKey</p> <p>Returns</p> <p>Proof (R, S', z)</p> <p>Argument Details</p> <ul> <li>a</li> <li>Private key corresponding to public key A</li> <li>A</li> <li>Public key</li> <li>B</li> <li>Other party's public key</li> <li>S</li> <li>Shared secret</li> </ul>"},{"location":"reference/primitives/#method-verifyproof","title":"Method verifyProof","text":"<p>Verifies the proof of the link between public key A and shared secret S</p> <p><pre><code>verifyProof(A: Point, B: Point, S: Point, proof: {\n    R: Point;\n    SPrime: Point;\n    z: BigNumber;\n}): boolean \n</code></pre> See also: BigNumber, Point</p> <p>Returns</p> <p>True if the proof is valid, false otherwise</p> <p>Argument Details</p> <ul> <li>A</li> <li>Public key</li> <li>B</li> <li>Other party's public key</li> <li>S</li> <li>Shared secret</li> <li>proof</li> <li>Proof (R, S', z)</li> </ul> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#class-signature","title":"Class: Signature","text":"<p>Represents a digital signature.</p> <p>A digital signature is a mathematical scheme for verifying the authenticity of digital messages or documents. In many scenarios, it is equivalent to a handwritten signature or stamped seal. The signature pair (R, S) corresponds to the raw ECDSA (Elliptic Curve Digital Signature Algorithm) signature. Signatures are often serialized into a format known as 'DER encoding' for transmission.</p> <pre><code>export default class Signature {\n    r: BigNumber;\n    s: BigNumber;\n    static fromDER(data: number[] | string, enc?: \"hex\" | \"base64\"): Signature \n    static fromCompact(data: number[] | string, enc?: \"hex\" | \"base64\"): Signature \n    constructor(r: BigNumber, s: BigNumber) \n    verify(msg: number[] | string, key: PublicKey, enc?: \"hex\"): boolean \n    toString(enc?: \"hex\" | \"base64\"): number[] | string \n    toDER(enc?: \"hex\" | \"base64\"): number[] | string \n    toCompact(recovery: number, compressed: boolean, enc?: \"hex\" | \"base64\"): number[] | string \n    RecoverPublicKey(recovery: number, e: BigNumber): PublicKey \n    CalculateRecoveryFactor(pubkey: PublicKey, msgHash: BigNumber): number \n}\n</code></pre> <p>See also: BigNumber, PublicKey, verify</p>"},{"location":"reference/primitives/#constructor_11","title":"Constructor","text":"<p>Creates an instance of the Signature class.</p> <p><pre><code>constructor(r: BigNumber, s: BigNumber) \n</code></pre> See also: BigNumber</p> <p>Argument Details</p> <ul> <li>r</li> <li>The R component of the signature.</li> <li>s</li> <li>The S component of the signature.</li> </ul> <p>Example</p> <pre><code>const r = new BigNumber('208755674028...');\nconst s = new BigNumber('564745627577...');\nconst signature = new Signature(r, s);\n</code></pre>"},{"location":"reference/primitives/#method-calculaterecoveryfactor","title":"Method CalculateRecoveryFactor","text":"<p>Calculates the recovery factor which will work for a particular public key and message hash. This method will return the recovery factor if it finds a valid recovery factor. If it does not find a valid recovery factor, it will throw an error. The recovery factor is a number between 0 and 3.</p> <p><pre><code>CalculateRecoveryFactor(pubkey: PublicKey, msgHash: BigNumber): number \n</code></pre> See also: BigNumber, PublicKey</p> <p>Returns</p> <p>the recovery factor: number /</p> <p>Argument Details</p> <ul> <li>msgHash</li> <li>The message hash.</li> </ul> <p>Example</p> <pre><code>const recovery = signature.CalculateRecoveryFactor(publicKey, msgHash);\n</code></pre>"},{"location":"reference/primitives/#method-recoverpublickey","title":"Method RecoverPublicKey","text":"<p>Recovers the public key from a signature. This method will return the public key if it finds a valid public key. If it does not find a valid public key, it will throw an error. The recovery factor is a number between 0 and 3.</p> <p><pre><code>RecoverPublicKey(recovery: number, e: BigNumber): PublicKey \n</code></pre> See also: BigNumber, PublicKey</p> <p>Returns</p> <p>The public key associated with the signature.</p> <p>Argument Details</p> <ul> <li>recovery</li> <li>The recovery factor.</li> <li>e</li> <li>The message hash.</li> </ul> <p>Example</p> <pre><code>const publicKey = signature.RecoverPublicKey(0, msgHash);\n</code></pre>"},{"location":"reference/primitives/#method-fromcompact","title":"Method fromCompact","text":"<p>Takes an array of numbers or a string and returns a new Signature instance. This method will throw an error if the Compact encoding is invalid. If a string is provided, it is assumed to represent a hexadecimal sequence. compactByte value 27-30 means uncompressed public key. 31-34 means compressed public key. The range represents the recovery param which can be 0,1,2,3. We could support recovery functions in future if there's demand.</p> <p><pre><code>static fromCompact(data: number[] | string, enc?: \"hex\" | \"base64\"): Signature \n</code></pre> See also: Signature</p> <p>Returns</p> <p>The decoded data in the form of Signature instance.</p> <p>Argument Details</p> <ul> <li>data</li> <li>The sequence to decode from Compact encoding.</li> <li>enc</li> <li>The encoding of the data string.</li> </ul> <p>Example</p> <pre><code>const signature = Signature.fromCompact('1b18c1f5502f8...', 'hex');\n</code></pre>"},{"location":"reference/primitives/#method-fromder_2","title":"Method fromDER","text":"<p>Takes an array of numbers or a string and returns a new Signature instance. This method will throw an error if the DER encoding is invalid. If a string is provided, it is assumed to represent a hexadecimal sequence.</p> <p><pre><code>static fromDER(data: number[] | string, enc?: \"hex\" | \"base64\"): Signature \n</code></pre> See also: Signature</p> <p>Returns</p> <p>The decoded data in the form of Signature instance.</p> <p>Argument Details</p> <ul> <li>data</li> <li>The sequence to decode from DER encoding.</li> <li>enc</li> <li>The encoding of the data string.</li> </ul> <p>Example</p> <pre><code>const signature = Signature.fromDER('30440220018c1f5502f8...', 'hex');\n</code></pre>"},{"location":"reference/primitives/#method-tocompact","title":"Method toCompact","text":"<p>Converts an instance of Signature into Compact encoding.</p> <p>If the encoding parameter is set to 'hex', the function will return a hex string. If 'base64', it will return a base64 string. Otherwise, it will return an array of numbers.</p> <pre><code>toCompact(recovery: number, compressed: boolean, enc?: \"hex\" | \"base64\"): number[] | string \n</code></pre> <p>Returns</p> <p>The current instance in DER encoding.</p> <p>Argument Details</p> <ul> <li>enc</li> <li>The encoding to use for the output.</li> </ul> <p>Example</p> <pre><code>const compact = signature.toCompact(3, true, 'base64');\n</code></pre>"},{"location":"reference/primitives/#method-toder_1","title":"Method toDER","text":"<p>Converts an instance of Signature into DER encoding.</p> <p>If the encoding parameter is set to 'hex', the function will return a hex string. If 'base64', it will return a base64 string. Otherwise, it will return an array of numbers.</p> <pre><code>toDER(enc?: \"hex\" | \"base64\"): number[] | string \n</code></pre> <p>Returns</p> <p>The current instance in DER encoding.</p> <p>Argument Details</p> <ul> <li>enc</li> <li>The encoding to use for the output.</li> </ul> <p>Example</p> <pre><code>const der = signature.toDER('hex');\n</code></pre>"},{"location":"reference/primitives/#method-tostring_4","title":"Method toString","text":"<p>function toString() { [native code] }</p> <p>Converts an instance of Signature into DER encoding. An alias for the toDER method.</p> <p>If the encoding parameter is set to 'hex', the function will return a hex string. If 'base64', it will return a base64 string. Otherwise, it will return an array of numbers.</p> <pre><code>toString(enc?: \"hex\" | \"base64\"): number[] | string \n</code></pre> <p>Returns</p> <p>The current instance in DER encoding.</p> <p>Argument Details</p> <ul> <li>enc</li> <li>The encoding to use for the output.</li> </ul> <p>Example</p> <pre><code>const der = signature.toString('base64');\n</code></pre>"},{"location":"reference/primitives/#method-verify_2","title":"Method verify","text":"<p>Verifies a digital signature.</p> <p>This method will return true if the signature, key, and message hash match. If the data or key do not match the signature, the function returns false.</p> <p><pre><code>verify(msg: number[] | string, key: PublicKey, enc?: \"hex\"): boolean \n</code></pre> See also: PublicKey</p> <p>Returns</p> <p>A boolean representing whether the signature is valid.</p> <p>Argument Details</p> <ul> <li>msg</li> <li>The message to verify.</li> <li>key</li> <li>The public key used to sign the original message.</li> <li>enc</li> <li>The encoding of the msg string.</li> </ul> <p>Example</p> <pre><code>const msg = 'The quick brown fox jumps over the lazy dog';\nconst publicKey = PublicKey.fromString('04188ca1050...');\nconst isVerified = signature.verify(msg, publicKey);\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#class-symmetrickey","title":"Class: SymmetricKey","text":"<p><code>SymmetricKey</code> is a class that extends the <code>BigNumber</code> class and implements symmetric encryption and decryption methods. Symmetric-Key encryption is a form of encryption where the same key is used to encrypt and decrypt the message. It leverages the Advanced Encryption Standard Galois/Counter Mode (AES-GCM) for encryption and decryption of messages.</p> <pre><code>export default class SymmetricKey extends BigNumber {\n    static fromRandom(): SymmetricKey \n    encrypt(msg: number[] | string, enc?: \"hex\"): string | number[] \n    decrypt(msg: number[] | string, enc?: \"hex\" | \"utf8\"): string | number[] \n}\n</code></pre> <p>See also: BigNumber, decrypt, encrypt</p>"},{"location":"reference/primitives/#method-decrypt","title":"Method decrypt","text":"<p>Decrypts a given AES-GCM encrypted message using the same key that was used for encryption. The method extracts the IV and the authentication tag from the encrypted message, then attempts to decrypt it. If the decryption fails (e.g., due to message tampering), an error is thrown.</p> <pre><code>decrypt(msg: number[] | string, enc?: \"hex\" | \"utf8\"): string | number[] \n</code></pre> <p>Returns</p> <p>Returns the decrypted message as a string or an array of numbers, depending on <code>enc</code> argument. If absent, an array of numbers is returned.</p> <p>Argument Details</p> <ul> <li>msg</li> <li>The encrypted message to be decrypted. It can be a string or an array of numbers.</li> <li>enc</li> <li>optional. The encoding of the message (if no encoding is provided, uses utf8 for strings, unless specified as hex).</li> </ul> <p>Throws</p> <p>Will throw an error if the decryption fails, likely due to message tampering or incorrect decryption key.</p> <p>Example</p> <pre><code>const key = new SymmetricKey(1234);\nconst decryptedMessage = key.decrypt(encryptedMessage, 'utf8');\n</code></pre>"},{"location":"reference/primitives/#method-encrypt","title":"Method encrypt","text":"<p>Encrypts a given message using AES-GCM encryption. The generated Initialization Vector (IV) is attached to the encrypted message for decryption purposes. The OpenSSL format of |IV|encryptedContent|authTag| is used.</p> <pre><code>encrypt(msg: number[] | string, enc?: \"hex\"): string | number[] \n</code></pre> <p>Returns</p> <p>Returns the encrypted message as a string or an array of numbers, depending on <code>enc</code> argument.</p> <p>Argument Details</p> <ul> <li>msg</li> <li>The message to be encrypted. It can be a string or an array of numbers.</li> <li>enc</li> <li>optional. The encoding of the message. If hex, the string is assumed to be hex, UTF-8 otherwise.</li> </ul> <p>Example</p> <pre><code>const key = new SymmetricKey(1234);\nconst encryptedMessage = key.encrypt('plainText', 'utf8');\n</code></pre>"},{"location":"reference/primitives/#method-fromrandom_1","title":"Method fromRandom","text":"<p>Generates a symmetric key randomly.</p> <p><pre><code>static fromRandom(): SymmetricKey \n</code></pre> See also: SymmetricKey</p> <p>Returns</p> <p>The newly generated Symmetric Key.</p> <p>Example</p> <pre><code>const symmetricKey = SymmetricKey.fromRandom();\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#class-transactionsignature","title":"Class: TransactionSignature","text":"<pre><code>export default class TransactionSignature extends Signature {\n    public static readonly SIGHASH_ALL = 1;\n    public static readonly SIGHASH_NONE = 2;\n    public static readonly SIGHASH_SINGLE = 3;\n    public static readonly SIGHASH_FORKID = 64;\n    public static readonly SIGHASH_ANYONECANPAY = 128;\n    scope: number;\n    static format(params: {\n        sourceTXID: string;\n        sourceOutputIndex: number;\n        sourceSatoshis: number;\n        transactionVersion: number;\n        otherInputs: TransactionInput[];\n        outputs: TransactionOutput[];\n        inputIndex: number;\n        subscript: Script;\n        inputSequence: number;\n        lockTime: number;\n        scope: number;\n    }): number[] \n    static fromChecksigFormat(buf: number[]): TransactionSignature \n    constructor(r: BigNumber, s: BigNumber, scope: number) \n    public hasLowS(): boolean \n    toChecksigFormat(): number[] \n}\n</code></pre> <p>See also: BigNumber, Script, Signature, TransactionInput, TransactionOutput</p>"},{"location":"reference/primitives/#method-haslows","title":"Method hasLowS","text":"<p>Compares to bitcoind's IsLowDERSignature See also Ecdsa signature algorithm which enforces this. See also Bip 62, \"low S values in signatures\"</p> <pre><code>public hasLowS(): boolean \n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#class-writer","title":"Class: Writer","text":"<pre><code>export class Writer {\n    public bufs: number[][];\n    constructor(bufs?: number[][]) \n    getLength(): number \n    toArray(): number[] \n    write(buf: number[]): this \n    writeReverse(buf: number[]): this \n    writeUInt8(n: number): this \n    writeInt8(n: number): this \n    writeUInt16BE(n: number): this \n    writeInt16BE(n: number): this \n    writeUInt16LE(n: number): this \n    writeInt16LE(n: number): this \n    writeUInt32BE(n: number): this \n    writeInt32BE(n: number): this \n    writeUInt32LE(n: number): this \n    writeInt32LE(n: number): this \n    writeUInt64BEBn(bn: BigNumber): this \n    writeUInt64LEBn(bn: BigNumber): this \n    writeUInt64LE(n: number): this \n    writeVarIntNum(n: number): this \n    writeVarIntBn(bn: BigNumber): this \n    static varIntNum(n: number): number[] \n    static varIntBn(bn: BigNumber): number[] \n}\n</code></pre> <p>See also: BigNumber, toArray</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#functions","title":"Functions","text":"AES AESGCM AESGCMDecrypt ghash pbkdf2 red toArray toBase64 <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#function-aes","title":"Function: AES","text":"<pre><code>export function AES(input: number[], key: number[]): number[] \n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#function-aesgcm","title":"Function: AESGCM","text":"<pre><code>export function AESGCM(plainText: number[], additionalAuthenticatedData: number[], initializationVector: number[], key: number[]): {\n    result: number[];\n    authenticationTag: number[];\n} \n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#function-aesgcmdecrypt","title":"Function: AESGCMDecrypt","text":"<pre><code>export function AESGCMDecrypt(cipherText: number[], additionalAuthenticatedData: number[], initializationVector: number[], authenticationTag: number[], key: number[]): number[] | null \n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#function-ghash","title":"Function: ghash","text":"<pre><code>export function ghash(input: number[], hashSubKey: number[]): number[] \n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#function-pbkdf2","title":"Function: pbkdf2","text":"<p>Limited SHA-512-only PBKDF2 function for use in deprecated BIP39 code.</p> <pre><code>export function pbkdf2(password: number[], salt: number[], iterations: number, keylen: number, digest = \"sha512\"): number[] \n</code></pre> <p>Returns</p> <p>The computed key</p> <p>Argument Details</p> <ul> <li>password</li> <li>The PBKDF2 password</li> <li>salt</li> <li>The PBKDF2 salt</li> <li>iterations</li> <li>The number of of iterations to run</li> <li>keylen</li> <li>The length of the key</li> <li>digest</li> <li>The digest (must be sha512 for this implementation)</li> </ul> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#function-red","title":"Function: red","text":"<pre><code>export function red(x: bigint): bigint \n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#function-toarray","title":"Function: toArray","text":"<pre><code>export function toArray(msg: number[] | string, enc?: \"hex\" | \"utf8\"): number[] \n</code></pre> <p>Returns</p> <p>array of byte values from msg. If msg is an array, a copy is returned.</p> <p>Argument Details</p> <ul> <li>enc</li> <li>Optional. Encoding to use if msg is string. Default is 'utf8'.</li> </ul> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#function-tobase64","title":"Function: toBase64","text":"<p>Converts an array of bytes (each between 0 and 255) into a base64 encoded string.</p> <p>Example</p> <pre><code>const bytes = [72, 101, 108, 108, 111]; // Represents the string \"Hello\"\nconsole.log(toBase64(bytes)); // Outputs: SGVsbG8=\n</code></pre> <pre><code>export function toBase64(byteArray: number[]): string \n</code></pre> <p>Returns</p> <p>The base64 encoded string.</p> <p>Argument Details</p> <ul> <li>byteArray</li> <li>An array of numbers where each number is a byte (0-255).</li> </ul> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#types","title":"Types","text":""},{"location":"reference/primitives/#enums","title":"Enums","text":""},{"location":"reference/primitives/#variables","title":"Variables","text":"BI_EIGHT biModSqrt multiply BI_FOUR biModSub rightShift BI_ONE checkBit ripemd160 BI_THREE encode scalarMultiplyWNAF BI_TWO exclusiveOR sha1 BI_ZERO fromBase58 sha256 GX_BIGINT fromBase58Check sha256hmac GY_BIGINT getBytes sha512 MASK_256 hash160 sha512hmac N_BIGINT hash256 sign P_BIGINT incrementLeastSignificantThirtyTwoBits toArray P_PLUS1_DIV4 jpAdd toBase58 biMod jpDouble toBase58Check biModAdd jpNeg toHex biModInv minimallyEncode toUTF8 biModMul modInvN verify biModPow modMulN zero2 biModSqr modN <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#variable-bi_eight","title":"Variable: BI_EIGHT","text":"<pre><code>BI_EIGHT = 8n\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#variable-bi_four","title":"Variable: BI_FOUR","text":"<pre><code>BI_FOUR = 4n\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#variable-bi_one","title":"Variable: BI_ONE","text":"<pre><code>BI_ONE = 1n\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#variable-bi_three","title":"Variable: BI_THREE","text":"<pre><code>BI_THREE = 3n\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#variable-bi_two","title":"Variable: BI_TWO","text":"<pre><code>BI_TWO = 2n\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#variable-bi_zero","title":"Variable: BI_ZERO","text":"<pre><code>BI_ZERO = 0n\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#variable-gx_bigint","title":"Variable: GX_BIGINT","text":"<pre><code>GX_BIGINT = BigInt(\"0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798\")\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#variable-gy_bigint","title":"Variable: GY_BIGINT","text":"<pre><code>GY_BIGINT = BigInt(\"0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8\")\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#variable-mask_256","title":"Variable: MASK_256","text":"<pre><code>MASK_256 = (1n &lt;&lt; 256n) - 1n\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#variable-n_bigint","title":"Variable: N_BIGINT","text":"<pre><code>N_BIGINT = 0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141n\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#variable-p_bigint","title":"Variable: P_BIGINT","text":"<pre><code>P_BIGINT = 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2fn\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#variable-p_plus1_div4","title":"Variable: P_PLUS1_DIV4","text":"<pre><code>P_PLUS1_DIV4 = (P_BIGINT + 1n) &gt;&gt; 2n\n</code></pre> <p>See also: P_BIGINT</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#variable-bimod","title":"Variable: biMod","text":"<pre><code>biMod = (a: bigint): bigint =&gt; red((a % P_BIGINT + P_BIGINT) % P_BIGINT)\n</code></pre> <p>See also: P_BIGINT, red</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#variable-bimodadd","title":"Variable: biModAdd","text":"<pre><code>biModAdd = (a: bigint, b: bigint): bigint =&gt; red(a + b)\n</code></pre> <p>See also: red</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#variable-bimodinv","title":"Variable: biModInv","text":"<pre><code>biModInv = (a: bigint): bigint =&gt; {\n    let lm = BI_ONE;\n    let hm = BI_ZERO;\n    let low = biMod(a);\n    let high = P_BIGINT;\n    while (low &gt; BI_ONE) {\n        const r = high / low;\n        [lm, hm] = [hm - lm * r, lm];\n        [low, high] = [high - low * r, low];\n    }\n    return biMod(lm);\n}\n</code></pre> <p>See also: BI_ONE, BI_ZERO, P_BIGINT, biMod</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#variable-bimodmul","title":"Variable: biModMul","text":"<pre><code>biModMul = (a: bigint, b: bigint): bigint =&gt; red(a * b)\n</code></pre> <p>See also: red</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#variable-bimodpow","title":"Variable: biModPow","text":"<pre><code>biModPow = (base: bigint, exp: bigint): bigint =&gt; {\n    let result = BI_ONE;\n    base = biMod(base);\n    let e = exp;\n    while (e &gt; BI_ZERO) {\n        if ((e &amp; BI_ONE) === BI_ONE)\n            result = biModMul(result, base);\n        base = biModMul(base, base);\n        e &gt;&gt;= BI_ONE;\n    }\n    return result;\n}\n</code></pre> <p>See also: BI_ONE, BI_ZERO, biMod, biModMul</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#variable-bimodsqr","title":"Variable: biModSqr","text":"<pre><code>biModSqr = (a: bigint): bigint =&gt; biModMul(a, a)\n</code></pre> <p>See also: biModMul</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#variable-bimodsqrt","title":"Variable: biModSqrt","text":"<pre><code>biModSqrt = (a: bigint): bigint | null =&gt; {\n    const r = biModPow(a, P_PLUS1_DIV4);\n    return biModMul(r, r) === biMod(a) ? r : null;\n}\n</code></pre> <p>See also: P_PLUS1_DIV4, biMod, biModMul, biModPow</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#variable-bimodsub","title":"Variable: biModSub","text":"<pre><code>biModSub = (a: bigint, b: bigint): bigint =&gt; (a &gt;= b ? a - b : P_BIGINT - (b - a))\n</code></pre> <p>See also: P_BIGINT</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#variable-checkbit","title":"Variable: checkBit","text":"<pre><code>checkBit = function (byteArray: number[], byteIndex: number, bitIndex: number): 1 | 0 {\n    return (byteArray[byteIndex] &amp; (1 &lt;&lt; bitIndex)) !== 0 ? 1 : 0;\n}\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#variable-encode","title":"Variable: encode","text":"<pre><code>encode = (arr: number[], enc?: \"hex\" | \"utf8\"): string | number[] =&gt; {\n    switch (enc) {\n        case \"hex\":\n            return toHex(arr);\n        case \"utf8\":\n            return toUTF8(arr);\n        default:\n            return arr;\n    }\n}\n</code></pre> <p>See also: toHex, toUTF8</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#variable-exclusiveor","title":"Variable: exclusiveOR","text":"<pre><code>exclusiveOR = function (block0: number[], block1: number[]): number[] {\n    const len = block0.length;\n    const result = new Array(len);\n    for (let i = 0; i &lt; len; i++) {\n        result[i] = block0[i] ^ block1[i];\n    }\n    return result;\n}\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#variable-frombase58","title":"Variable: fromBase58","text":"<pre><code>fromBase58 = (str: string): number[] =&gt; {\n    if (str === \"\" || typeof str !== \"string\") {\n        throw new Error(`Expected base58 string but got \u201c${str}\u201d`);\n    }\n    const match: string[] | null = str.match(/[IOl0]/gmu);\n    if (match !== null) {\n        throw new Error(`Invalid base58 character \u201c${match.join(\"\")}\u201d`);\n    }\n    const lz = str.match(/^1+/gmu);\n    const psz: number = (lz !== null) ? lz[0].length : 0;\n    const size = ((str.length - psz) * (Math.log(58) / Math.log(256)) + 1) &gt;&gt;&gt; 0;\n    const uint8 = new Uint8Array([\n        ...new Uint8Array(psz),\n        ...(str.match(/./gmu) ?? [])\n            .map((i) =&gt; base58chars.indexOf(i))\n            .reduce((acc, i) =&gt; {\n            acc = acc.map((j) =&gt; {\n                const x = j * 58 + i;\n                i = x &gt;&gt; 8;\n                return x;\n            });\n            return acc;\n        }, new Uint8Array(size))\n            .reverse()\n            .filter(((lastValue) =&gt; (value) =&gt; (lastValue = lastValue || value))(false))\n    ]);\n    return [...uint8];\n}\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#variable-frombase58check","title":"Variable: fromBase58Check","text":"<pre><code>fromBase58Check = (str: string, enc?: \"hex\", prefixLength: number = 1): {\n    data: number[] | string;\n    prefix: number[] | string;\n} =&gt; {\n    const bin = fromBase58(str);\n    let prefix: string | number[] = bin.slice(0, prefixLength);\n    let data: string | number[] = bin.slice(prefixLength, -4);\n    let hash = [...prefix, ...data];\n    hash = hash256(hash);\n    bin.slice(-4).forEach((check, index) =&gt; {\n        if (check !== hash[index]) {\n            throw new Error(\"Invalid checksum\");\n        }\n    });\n    if (enc === \"hex\") {\n        prefix = toHex(prefix);\n        data = toHex(data);\n    }\n    return { prefix, data };\n}\n</code></pre> <p>See also: fromBase58, hash256, toHex</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#variable-getbytes","title":"Variable: getBytes","text":"<pre><code>getBytes = function (numericValue: number): number[] {\n    return [\n        (numericValue &amp; 4278190080) &gt;&gt;&gt; 24,\n        (numericValue &amp; 16711680) &gt;&gt; 16,\n        (numericValue &amp; 65280) &gt;&gt; 8,\n        numericValue &amp; 255\n    ];\n}\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#variable-hash160","title":"Variable: hash160","text":"<pre><code>hash160 = (msg: number[] | string, enc?: \"hex\" | \"utf8\"): number[] =&gt; {\n    const first = new SHA256().update(msg, enc).digest();\n    return new RIPEMD160().update(first).digest();\n}\n</code></pre> <p>See also: RIPEMD160, SHA256</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#variable-hash256","title":"Variable: hash256","text":"<pre><code>hash256 = (msg: number[] | string, enc?: \"hex\" | \"utf8\"): number[] =&gt; {\n    const first = new SHA256().update(msg, enc).digest();\n    return new SHA256().update(first).digest();\n}\n</code></pre> <p>See also: SHA256</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#variable-incrementleastsignificantthirtytwobits","title":"Variable: incrementLeastSignificantThirtyTwoBits","text":"<pre><code>incrementLeastSignificantThirtyTwoBits = function (block: number[]): number[] {\n    let i;\n    const result = block.slice();\n    for (i = 15; i !== 11; i--) {\n        result[i] = result[i] + 1;\n        if (result[i] === 256) {\n            result[i] = 0;\n        }\n        else {\n            break;\n        }\n    }\n    return result;\n}\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#variable-jpadd","title":"Variable: jpAdd","text":"<pre><code>jpAdd = (P: JacobianPointBI, Q: JacobianPointBI): JacobianPointBI =&gt; {\n    if (P.Z === BI_ZERO)\n        return Q;\n    if (Q.Z === BI_ZERO)\n        return P;\n    const Z1Z1 = biModMul(P.Z, P.Z);\n    const Z2Z2 = biModMul(Q.Z, Q.Z);\n    const U1 = biModMul(P.X, Z2Z2);\n    const U2 = biModMul(Q.X, Z1Z1);\n    const S1 = biModMul(P.Y, biModMul(Z2Z2, Q.Z));\n    const S2 = biModMul(Q.Y, biModMul(Z1Z1, P.Z));\n    const H = biModSub(U2, U1);\n    const r = biModSub(S2, S1);\n    if (H === BI_ZERO) {\n        if (r === BI_ZERO)\n            return jpDouble(P);\n        return { X: BI_ZERO, Y: BI_ONE, Z: BI_ZERO };\n    }\n    const HH = biModMul(H, H);\n    const HHH = biModMul(H, HH);\n    const V = biModMul(U1, HH);\n    const X3 = biModSub(biModSub(biModMul(r, r), HHH), biModMul(BI_TWO, V));\n    const Y3 = biModSub(biModMul(r, biModSub(V, X3)), biModMul(S1, HHH));\n    const Z3 = biModMul(H, biModMul(P.Z, Q.Z));\n    return { X: X3, Y: Y3, Z: Z3 };\n}\n</code></pre> <p>See also: BI_ONE, BI_TWO, BI_ZERO, JacobianPointBI, biModMul, biModSub, jpDouble</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#variable-jpdouble","title":"Variable: jpDouble","text":"<pre><code>jpDouble = (P: JacobianPointBI): JacobianPointBI =&gt; {\n    const { X: X1, Y: Y1, Z: Z1 } = P;\n    if (Y1 === BI_ZERO)\n        return { X: BI_ZERO, Y: BI_ONE, Z: BI_ZERO };\n    const Y1sq = biModMul(Y1, Y1);\n    const S = biModMul(BI_FOUR, biModMul(X1, Y1sq));\n    const M = biModMul(BI_THREE, biModMul(X1, X1));\n    const X3 = biModSub(biModMul(M, M), biModMul(BI_TWO, S));\n    const Y3 = biModSub(biModMul(M, biModSub(S, X3)), biModMul(BI_EIGHT, biModMul(Y1sq, Y1sq)));\n    const Z3 = biModMul(BI_TWO, biModMul(Y1, Z1));\n    return { X: X3, Y: Y3, Z: Z3 };\n}\n</code></pre> <p>See also: BI_EIGHT, BI_FOUR, BI_ONE, BI_THREE, BI_TWO, BI_ZERO, JacobianPointBI, biModMul, biModSub</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#variable-jpneg","title":"Variable: jpNeg","text":"<pre><code>jpNeg = (P: JacobianPointBI): JacobianPointBI =&gt; {\n    if (P.Z === BI_ZERO)\n        return P;\n    return { X: P.X, Y: P_BIGINT - P.Y, Z: P.Z };\n}\n</code></pre> <p>See also: BI_ZERO, JacobianPointBI, P_BIGINT</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#variable-minimallyencode","title":"Variable: minimallyEncode","text":"<pre><code>minimallyEncode = (buf: number[]): number[] =&gt; {\n    if (buf.length === 0) {\n        return buf;\n    }\n    const last = buf[buf.length - 1];\n    if ((last &amp; 127) !== 0) {\n        return buf;\n    }\n    if (buf.length === 1) {\n        return [];\n    }\n    if ((buf[buf.length - 2] &amp; 128) !== 0) {\n        return buf;\n    }\n    for (let i = buf.length - 1; i &gt; 0; i--) {\n        if (buf[i - 1] !== 0) {\n            if ((buf[i - 1] &amp; 128) !== 0) {\n                buf[i] = last;\n                return buf.slice(0, i + 1);\n            }\n            else {\n                buf[i - 1] |= last;\n                return buf.slice(0, i);\n            }\n        }\n    }\n    return [];\n}\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#variable-modinvn","title":"Variable: modInvN","text":"<pre><code>modInvN = (a: bigint): bigint =&gt; {\n    let lm = 1n;\n    let hm = 0n;\n    let low = modN(a);\n    let high = N_BIGINT;\n    while (low &gt; 1n) {\n        const q = high / low;\n        [lm, hm] = [hm - lm * q, lm];\n        [low, high] = [high - low * q, low];\n    }\n    return modN(lm);\n}\n</code></pre> <p>See also: N_BIGINT, modN</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#variable-modmuln","title":"Variable: modMulN","text":"<pre><code>modMulN = (a: bigint, b: bigint): bigint =&gt; modN(a * b)\n</code></pre> <p>See also: modN</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#variable-modn","title":"Variable: modN","text":"<pre><code>modN = (a: bigint): bigint =&gt; {\n    let r = a % N_BIGINT;\n    if (r &lt; 0n)\n        r += N_BIGINT;\n    return r;\n}\n</code></pre> <p>See also: N_BIGINT</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#variable-multiply","title":"Variable: multiply","text":"<pre><code>multiply = function (block0: number[], block1: number[]): number[] {\n    const v = block1.slice();\n    const z = createZeroBlock(16);\n    for (let i = 0; i &lt; 16; i++) {\n        for (let j = 7; j &gt;= 0; j--) {\n            if ((block0[i] &amp; (1 &lt;&lt; j)) !== 0) {\n                xorInto(z, v);\n            }\n            if ((v[15] &amp; 1) !== 0) {\n                rightShift(v);\n                xorInto(v, R);\n            }\n            else {\n                rightShift(v);\n            }\n        }\n    }\n    return z;\n}\n</code></pre> <p>See also: rightShift</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#variable-rightshift","title":"Variable: rightShift","text":"<pre><code>rightShift = function (block: number[]): number[] {\n    let i: number;\n    let carry = 0;\n    let oldCarry = 0;\n    for (i = 0; i &lt; block.length; i++) {\n        oldCarry = carry;\n        carry = block[i] &amp; 1;\n        block[i] = block[i] &gt;&gt; 1;\n        if (oldCarry !== 0) {\n            block[i] = block[i] | 128;\n        }\n    }\n    return block;\n}\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#variable-ripemd160","title":"Variable: ripemd160","text":"<pre><code>ripemd160 = (msg: number[] | string, enc?: \"hex\" | \"utf8\"): number[] =&gt; {\n    return new RIPEMD160().update(msg, enc).digest();\n}\n</code></pre> <p>See also: RIPEMD160</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#variable-scalarmultiplywnaf","title":"Variable: scalarMultiplyWNAF","text":"<pre><code>scalarMultiplyWNAF = (k: bigint, P0: {\n    x: bigint;\n    y: bigint;\n}, window: number = 5): JacobianPointBI =&gt; {\n    const key = `${window}:${P0.x.toString(16)}:${P0.y.toString(16)}`;\n    let tbl = WNAF_TABLE_CACHE.get(key);\n    let P: JacobianPointBI;\n    if (tbl === undefined) {\n        const tblSize = 1 &lt;&lt; (window - 1);\n        tbl = new Array(tblSize);\n        P = { X: P0.x, Y: P0.y, Z: BI_ONE };\n        tbl[0] = P;\n        const twoP = jpDouble(P);\n        for (let i = 1; i &lt; tblSize; i++) {\n            tbl[i] = jpAdd(tbl[i - 1], twoP);\n        }\n        WNAF_TABLE_CACHE.set(key, tbl);\n    }\n    else {\n        P = tbl[0];\n    }\n    const wnaf: number[] = [];\n    const wBig = 1n &lt;&lt; BigInt(window);\n    const wHalf = wBig &gt;&gt; 1n;\n    let kTmp = k;\n    while (kTmp &gt; 0n) {\n        if ((kTmp &amp; BI_ONE) === BI_ZERO) {\n            wnaf.push(0);\n            kTmp &gt;&gt;= BI_ONE;\n        }\n        else {\n            let z = kTmp &amp; (wBig - 1n);\n            if (z &gt; wHalf)\n                z -= wBig;\n            wnaf.push(Number(z));\n            kTmp -= z;\n            kTmp &gt;&gt;= BI_ONE;\n        }\n    }\n    let Q: JacobianPointBI = { X: BI_ZERO, Y: BI_ONE, Z: BI_ZERO };\n    for (let i = wnaf.length - 1; i &gt;= 0; i--) {\n        Q = jpDouble(Q);\n        const di = wnaf[i];\n        if (di !== 0) {\n            const idx = Math.abs(di) &gt;&gt; 1;\n            const addend = di &gt; 0 ? tbl[idx] : jpNeg(tbl[idx]);\n            Q = jpAdd(Q, addend);\n        }\n    }\n    return Q;\n}\n</code></pre> <p>See also: BI_ONE, BI_ZERO, JacobianPointBI, jpAdd, jpDouble, jpNeg</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#variable-sha1","title":"Variable: sha1","text":"<pre><code>sha1 = (msg: number[] | string, enc?: \"hex\" | \"utf8\"): number[] =&gt; {\n    return new SHA1().update(msg, enc).digest();\n}\n</code></pre> <p>See also: SHA1</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#variable-sha256","title":"Variable: sha256","text":"<pre><code>sha256 = (msg: number[] | string, enc?: \"hex\" | \"utf8\"): number[] =&gt; {\n    return new SHA256().update(msg, enc).digest();\n}\n</code></pre> <p>See also: SHA256</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#variable-sha256hmac","title":"Variable: sha256hmac","text":"<pre><code>sha256hmac = (key: number[] | string, msg: number[] | string, enc?: \"hex\"): number[] =&gt; {\n    return new SHA256HMAC(key).update(msg, enc).digest();\n}\n</code></pre> <p>See also: SHA256HMAC</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#variable-sha512","title":"Variable: sha512","text":"<pre><code>sha512 = (msg: number[] | string, enc?: \"hex\" | \"utf8\"): number[] =&gt; {\n    return new SHA512().update(msg, enc).digest();\n}\n</code></pre> <p>See also: SHA512</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#variable-sha512hmac","title":"Variable: sha512hmac","text":"<pre><code>sha512hmac = (key: number[] | string, msg: number[] | string, enc?: \"hex\"): number[] =&gt; {\n    return new SHA512HMAC(key).update(msg, enc).digest();\n}\n</code></pre> <p>See also: SHA512HMAC</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#variable-sign","title":"Variable: sign","text":"<pre><code>sign = (msg: BigNumber, key: BigNumber, forceLowS: boolean = false, customK?: BigNumber | ((iter: number) =&gt; BigNumber)): Signature =&gt; {\n    msg = truncateToN(msg);\n    const msgBig = BigInt(\"0x\" + msg.toString(16));\n    const keyBig = BigInt(\"0x\" + key.toString(16));\n    const bkey = key.toArray(\"be\", bytes);\n    const nonce = msg.toArray(\"be\", bytes);\n    const drbg = new DRBG(bkey, nonce);\n    for (let iter = 0;; iter++) {\n        let kBN = typeof customK === \"function\"\n            ? customK(iter)\n            : BigNumber.isBN(customK)\n                ? customK\n                : new BigNumber(drbg.generate(bytes), 16);\n        if (kBN == null)\n            throw new Error(\"k is undefined\");\n        kBN = truncateToN(kBN, true);\n        if (kBN.cmpn(1) &lt;= 0 || kBN.cmp(ns1) &gt;= 0) {\n            if (BigNumber.isBN(customK)) {\n                throw new Error(\"Invalid fixed custom K value (must be &gt;1 and &lt;N\\u20111)\");\n            }\n            continue;\n        }\n        const kBig = BigInt(\"0x\" + kBN.toString(16));\n        const R = scalarMultiplyWNAF(kBig, { x: GX_BIGINT, y: GY_BIGINT });\n        if (R.Z === 0n) {\n            if (BigNumber.isBN(customK)) {\n                throw new Error(\"Invalid fixed custom K value (k\\u00B7G at infinity)\");\n            }\n            continue;\n        }\n        const zInv = biModInv(R.Z);\n        const zInv2 = biModMul(zInv, zInv);\n        const xAff = biModMul(R.X, zInv2);\n        const rBig = modN(xAff);\n        if (rBig === 0n) {\n            if (BigNumber.isBN(customK)) {\n                throw new Error(\"Invalid fixed custom K value (r == 0)\");\n            }\n            continue;\n        }\n        const kInv = modInvN(kBig);\n        const rTimesKey = modMulN(rBig, keyBig);\n        const sum = modN(msgBig + rTimesKey);\n        let sBig = modMulN(kInv, sum);\n        if (sBig === 0n) {\n            if (BigNumber.isBN(customK)) {\n                throw new Error(\"Invalid fixed custom K value (s == 0)\");\n            }\n            continue;\n        }\n        if (forceLowS &amp;&amp; sBig &gt; halfN) {\n            sBig = N_BIGINT - sBig;\n        }\n        const r = new BigNumber(rBig.toString(16), 16);\n        const s = new BigNumber(sBig.toString(16), 16);\n        return new Signature(r, s);\n    }\n}\n</code></pre> <p>See also: BigNumber, DRBG, GX_BIGINT, GY_BIGINT, N_BIGINT, Signature, biModInv, biModMul, modInvN, modMulN, modN, scalarMultiplyWNAF, toArray</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#variable-toarray","title":"Variable: toArray","text":"<pre><code>toArray = (msg: any, enc?: \"hex\" | \"utf8\" | \"base64\"): any[] =&gt; {\n    if (Array.isArray(msg))\n        return msg.slice();\n    if (msg === undefined)\n        return [];\n    if (typeof msg !== \"string\") {\n        return Array.from(msg, (item: any) =&gt; item | 0);\n    }\n    switch (enc) {\n        case \"hex\":\n            return hexToArray(msg);\n        case \"base64\":\n            return base64ToArray(msg);\n        default:\n            return utf8ToArray(msg);\n    }\n}\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#variable-tobase58","title":"Variable: toBase58","text":"<pre><code>toBase58 = (bin: number[]): string =&gt; {\n    const base58Map = Array(256).fill(-1);\n    for (let i = 0; i &lt; base58chars.length; ++i) {\n        base58Map[base58chars.charCodeAt(i)] = i;\n    }\n    const result: number[] = [];\n    for (const byte of bin) {\n        let carry = byte;\n        for (let j = 0; j &lt; result.length; ++j) {\n            const x = (base58Map[result[j]] &lt;&lt; 8) + carry;\n            result[j] = base58chars.charCodeAt(x % 58);\n            carry = (x / 58) | 0;\n        }\n        while (carry !== 0) {\n            result.push(base58chars.charCodeAt(carry % 58));\n            carry = (carry / 58) | 0;\n        }\n    }\n    for (const byte of bin) {\n        if (byte !== 0)\n            break;\n        else\n            result.push(\"1\".charCodeAt(0));\n    }\n    result.reverse();\n    return String.fromCharCode(...result);\n}\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#variable-tobase58check","title":"Variable: toBase58Check","text":"<pre><code>toBase58Check = (bin: number[], prefix: number[] = [0]): string =&gt; {\n    let hash = hash256([...prefix, ...bin]);\n    hash = [...prefix, ...bin, ...hash.slice(0, 4)];\n    return toBase58(hash);\n}\n</code></pre> <p>See also: hash256, toBase58</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#variable-tohex","title":"Variable: toHex","text":"<pre><code>toHex = (msg: number[]): string =&gt; {\n    let res = \"\";\n    for (const num of msg) {\n        res += zero2(num.toString(16));\n    }\n    return res;\n}\n</code></pre> <p>See also: zero2</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#variable-toutf8","title":"Variable: toUTF8","text":"<pre><code>toUTF8 = (arr: number[]): string =&gt; {\n    let result = \"\";\n    let skip = 0;\n    for (let i = 0; i &lt; arr.length; i++) {\n        const byte = arr[i];\n        if (skip &gt; 0) {\n            skip--;\n            continue;\n        }\n        if (byte &lt;= 127) {\n            result += String.fromCharCode(byte);\n        }\n        else if (byte &gt;= 192 &amp;&amp; byte &lt;= 223) {\n            const byte2 = arr[i + 1];\n            skip = 1;\n            const codePoint = ((byte &amp; 31) &lt;&lt; 6) | (byte2 &amp; 63);\n            result += String.fromCharCode(codePoint);\n        }\n        else if (byte &gt;= 224 &amp;&amp; byte &lt;= 239) {\n            const byte2 = arr[i + 1];\n            const byte3 = arr[i + 2];\n            skip = 2;\n            const codePoint = ((byte &amp; 15) &lt;&lt; 12) | ((byte2 &amp; 63) &lt;&lt; 6) | (byte3 &amp; 63);\n            result += String.fromCharCode(codePoint);\n        }\n        else if (byte &gt;= 240 &amp;&amp; byte &lt;= 247) {\n            const byte2 = arr[i + 1];\n            const byte3 = arr[i + 2];\n            const byte4 = arr[i + 3];\n            skip = 3;\n            const codePoint = ((byte &amp; 7) &lt;&lt; 18) |\n                ((byte2 &amp; 63) &lt;&lt; 12) |\n                ((byte3 &amp; 63) &lt;&lt; 6) |\n                (byte4 &amp; 63);\n            const surrogate1 = 55296 + ((codePoint - 65536) &gt;&gt; 10);\n            const surrogate2 = 56320 + ((codePoint - 65536) &amp; 1023);\n            result += String.fromCharCode(surrogate1, surrogate2);\n        }\n    }\n    return result;\n}\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#variable-verify","title":"Variable: verify","text":"<pre><code>verify = (msg: BigNumber, sig: Signature, key: Point): boolean =&gt; {\n    const hash = BigInt(\"0x\" + msg.toString(16));\n    if ((key.x == null) || (key.y == null)) {\n        throw new Error(\"Invalid public key: missing coordinates.\");\n    }\n    const publicKey = {\n        x: BigInt(\"0x\" + key.x.toString(16)),\n        y: BigInt(\"0x\" + key.y.toString(16))\n    };\n    const signature = {\n        r: BigInt(\"0x\" + sig.r.toString(16)),\n        s: BigInt(\"0x\" + sig.s.toString(16))\n    };\n    const { r, s } = signature;\n    const z = hash;\n    if (r &lt;= BI_ZERO || r &gt;= N_BIGINT || s &lt;= BI_ZERO || s &gt;= N_BIGINT) {\n        return false;\n    }\n    const w = modInvN(s);\n    if (w === 0n)\n        return false;\n    const u1 = modMulN(z, w);\n    const u2 = modMulN(r, w);\n    const RG = scalarMultiplyWNAF(u1, { x: GX_BIGINT, y: GY_BIGINT });\n    const RQ = scalarMultiplyWNAF(u2, publicKey);\n    const R = jpAdd(RG, RQ);\n    if (R.Z === 0n)\n        return false;\n    const zInv = biModInv(R.Z);\n    const zInv2 = biModMul(zInv, zInv);\n    const xAff = biModMul(R.X, zInv2);\n    const v = modN(xAff);\n    return v === r;\n}\n</code></pre> <p>See also: BI_ZERO, BigNumber, GX_BIGINT, GY_BIGINT, N_BIGINT, Point, Signature, biModInv, biModMul, jpAdd, modInvN, modMulN, modN, scalarMultiplyWNAF</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#variable-zero2","title":"Variable: zero2","text":"<pre><code>zero2 = (word: string): string =&gt; {\n    if (word.length % 2 === 1) {\n        return \"0\" + word;\n    }\n    else {\n        return word;\n    }\n}\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/registry/","title":"API","text":"<p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/registry/#interfaces","title":"Interfaces","text":"BasketDefinitionData BasketQuery CertificateDefinitionData CertificateFieldDescriptor CertificateQuery ProtocolDefinitionData ProtocolQuery RegistryQueryMapping TokenData <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/registry/#interface-basketdefinitiondata","title":"Interface: BasketDefinitionData","text":"<p>Registry data for a Basket-style record.</p> <pre><code>export interface BasketDefinitionData {\n    definitionType: \"basket\";\n    basketID: string;\n    name: string;\n    iconURL: string;\n    description: string;\n    documentationURL: string;\n    registryOperator?: PubKeyHex;\n}\n</code></pre> <p>See also: PubKeyHex</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/registry/#interface-basketquery","title":"Interface: BasketQuery","text":"<p>When searching for basket definitions, we can filter by:  - basketID  - registryOperators  - name</p> <pre><code>export interface BasketQuery {\n    basketID?: string;\n    registryOperators?: string[];\n    name?: string;\n}\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/registry/#interface-certificatedefinitiondata","title":"Interface: CertificateDefinitionData","text":"<p>Registry data for a Certificate-style record.</p> <pre><code>export interface CertificateDefinitionData {\n    definitionType: \"certificate\";\n    type: string;\n    name: string;\n    iconURL: string;\n    description: string;\n    documentationURL: string;\n    fields: Record&lt;string, CertificateFieldDescriptor&gt;;\n    registryOperator?: PubKeyHex;\n}\n</code></pre> <p>See also: CertificateFieldDescriptor, PubKeyHex</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/registry/#interface-certificatefielddescriptor","title":"Interface: CertificateFieldDescriptor","text":"<p>Describes a re-usable structure for certificate fields (used by CertMap).</p> <pre><code>export interface CertificateFieldDescriptor {\n    friendlyName: string;\n    description: string;\n    type: \"text\" | \"imageURL\" | \"other\";\n    fieldIcon: string;\n}\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/registry/#interface-certificatequery","title":"Interface: CertificateQuery","text":"<p>When searching for certificate definitions, we can filter by:  - type  - name  - registryOperators</p> <pre><code>export interface CertificateQuery {\n    type?: string;\n    name?: string;\n    registryOperators?: string[];\n}\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/registry/#interface-protocoldefinitiondata","title":"Interface: ProtocolDefinitionData","text":"<p>Registry data for a Protocol-style record.</p> <pre><code>export interface ProtocolDefinitionData {\n    definitionType: \"protocol\";\n    protocolID: WalletProtocol;\n    name: string;\n    iconURL: string;\n    description: string;\n    documentationURL: string;\n    registryOperator?: PubKeyHex;\n}\n</code></pre> <p>See also: PubKeyHex, WalletProtocol</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/registry/#interface-protocolquery","title":"Interface: ProtocolQuery","text":"<p>When searching for protocol definitions, we can filter by:  - name  - registryOperators  - protocolID</p> <pre><code>export interface ProtocolQuery {\n    name?: string;\n    registryOperators?: string[];\n    protocolID?: WalletProtocol;\n}\n</code></pre> <p>See also: WalletProtocol</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/registry/#interface-registryquerymapping","title":"Interface: RegistryQueryMapping","text":"<p>A lookup-service mapping of queries by each definition type.</p> <pre><code>export interface RegistryQueryMapping {\n    basket: BasketQuery;\n    protocol: ProtocolQuery;\n    certificate: CertificateQuery;\n}\n</code></pre> <p>See also: BasketQuery, CertificateQuery, ProtocolQuery</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/registry/#interface-tokendata","title":"Interface: TokenData","text":"<p>Common info for the on-chain token/UTXO that points to a registry entry.</p> <pre><code>export interface TokenData {\n    txid: string;\n    outputIndex: number;\n    satoshis: number;\n    lockingScript: string;\n    beef: BEEF;\n}\n</code></pre> <p>See also: BEEF</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/registry/#classes","title":"Classes","text":""},{"location":"reference/registry/#class-registryclient","title":"Class: RegistryClient","text":"<p>RegistryClient manages on-chain registry definitions for three types: - basket (basket-based items) - protocol (protocol-based items) - certificate (certificate-based items)</p> <p>It provides methods to: - Register new definitions using pushdrop-based UTXOs. - Resolve existing definitions using a lookup service. - List registry entries associated with the operator's wallet. - Revoke an existing registry entry by spending its UTXO.</p> <p>Registry operators use this client to establish and manage canonical references for baskets, protocols, and certificate types.</p> <pre><code>export class RegistryClient {\n    constructor(private readonly wallet: WalletInterface = new WalletClient()) \n    async registerDefinition(data: DefinitionData): Promise&lt;BroadcastResponse | BroadcastFailure&gt; \n    async resolve&lt;T extends DefinitionType&gt;(definitionType: T, query: RegistryQueryMapping[T]): Promise&lt;DefinitionData[]&gt; \n    async listOwnRegistryEntries(definitionType: DefinitionType): Promise&lt;RegistryRecord[]&gt; \n    async revokeOwnRegistryEntry(registryRecord: RegistryRecord): Promise&lt;BroadcastResponse | BroadcastFailure&gt; \n}\n</code></pre> <p>See also: BroadcastFailure, BroadcastResponse, DefinitionData, DefinitionType, RegistryQueryMapping, RegistryRecord, WalletClient, WalletInterface</p>"},{"location":"reference/registry/#method-listownregistryentries","title":"Method listOwnRegistryEntries","text":"<p>Lists the registry operator's published definitions for the given type.</p> <p>Returns parsed registry records including transaction details such as txid, outputIndex, satoshis, and the locking script.</p> <p><pre><code>async listOwnRegistryEntries(definitionType: DefinitionType): Promise&lt;RegistryRecord[]&gt; \n</code></pre> See also: DefinitionType, RegistryRecord</p> <p>Returns</p> <p>A promise that resolves to an array of RegistryRecord objects.</p> <p>Argument Details</p> <ul> <li>definitionType</li> <li>The type of registry definition to list ('basket', 'protocol', or 'certificate').</li> </ul>"},{"location":"reference/registry/#method-registerdefinition","title":"Method registerDefinition","text":"<p>Publishes a new on-chain definition for baskets, protocols, or certificates. The definition data is encoded in a pushdrop-based UTXO.</p> <p>Registry operators (i.e., identity key owners) can create these definitions to establish canonical references for basket IDs, protocol specs, or certificate schemas.</p> <p><pre><code>async registerDefinition(data: DefinitionData): Promise&lt;BroadcastResponse | BroadcastFailure&gt; \n</code></pre> See also: BroadcastFailure, BroadcastResponse, DefinitionData</p> <p>Returns</p> <p>A promise with the broadcast result or failure.</p> <p>Argument Details</p> <ul> <li>data</li> <li>Structured information about a 'basket', 'protocol', or 'certificate'.</li> </ul>"},{"location":"reference/registry/#method-resolve","title":"Method resolve","text":"<p>Resolves registrant tokens of a particular type using a lookup service.</p> <p>The query object shape depends on the registry type: - For \"basket\", the query is of type BasketMapQuery:   { basketID?: string; name?: string; registryOperators?: string[]; } - For \"protocol\", the query is of type ProtoMapQuery:   { name?: string; registryOperators?: string[]; protocolID?: WalletProtocol; } - For \"certificate\", the query is of type CertMapQuery:   { type?: string; name?: string; registryOperators?: string[]; }</p> <p><pre><code>async resolve&lt;T extends DefinitionType&gt;(definitionType: T, query: RegistryQueryMapping[T]): Promise&lt;DefinitionData[]&gt; \n</code></pre> See also: DefinitionData, DefinitionType, RegistryQueryMapping</p> <p>Returns</p> <p>A promise that resolves to an array of matching registry records.</p> <p>Argument Details</p> <ul> <li>definitionType</li> <li>The registry type, which can be 'basket', 'protocol', or 'certificate'.</li> <li>query</li> <li>The query object used to filter registry records, whose shape is determined by the registry type.</li> </ul>"},{"location":"reference/registry/#method-revokeownregistryentry","title":"Method revokeOwnRegistryEntry","text":"<p>Revokes a registry record by spending its associated UTXO.</p> <p><pre><code>async revokeOwnRegistryEntry(registryRecord: RegistryRecord): Promise&lt;BroadcastResponse | BroadcastFailure&gt; \n</code></pre> See also: BroadcastFailure, BroadcastResponse, RegistryRecord</p> <p>Returns</p> <p>Broadcast success/failure.</p> <p>Argument Details</p> <ul> <li>registryRecord</li> <li>Must have valid txid, outputIndex, and lockingScript.</li> </ul> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/registry/#functions","title":"Functions","text":""},{"location":"reference/registry/#function-deserializewalletprotocol","title":"Function: deserializeWalletProtocol","text":"<pre><code>export function deserializeWalletProtocol(str: string): WalletProtocol \n</code></pre> <p>See also: WalletProtocol</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/registry/#types","title":"Types","text":"DefinitionData DefinitionType RegistryRecord <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/registry/#type-definitiondata","title":"Type: DefinitionData","text":"<p>Union of all possible definition data objects.</p> <pre><code>export type DefinitionData = BasketDefinitionData | ProtocolDefinitionData | CertificateDefinitionData\n</code></pre> <p>See also: BasketDefinitionData, CertificateDefinitionData, ProtocolDefinitionData</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/registry/#type-definitiontype","title":"Type: DefinitionType","text":"<p>We unify the registry \u201ctype\u201d to these three strings everywhere:   'basket' | 'protocol' | 'certificate'</p> <pre><code>export type DefinitionType = \"basket\" | \"protocol\" | \"certificate\"\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/registry/#type-registryrecord","title":"Type: RegistryRecord","text":"<p>A registry record is a combination of the typed definition data plus the on-chain token data for the UTXO holding it.</p> <pre><code>export type RegistryRecord = DefinitionData &amp; TokenData\n</code></pre> <p>See also: DefinitionData, TokenData</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/registry/#enums","title":"Enums","text":""},{"location":"reference/registry/#variables","title":"Variables","text":""},{"location":"reference/script/","title":"API","text":"<p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/script/#interfaces","title":"Interfaces","text":"ScriptChunk ScriptTemplate ScriptTemplateUnlock <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/script/#interface-scriptchunk","title":"Interface: ScriptChunk","text":"<p>A representation of a chunk of a script, which includes an opcode. For push operations, the associated data to push onto the stack is also included.</p> <pre><code>export default interface ScriptChunk {\n    op: number;\n    data?: number[];\n}\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/script/#interface-scripttemplate","title":"Interface: ScriptTemplate","text":"<pre><code>export default interface ScriptTemplate {\n    lock: (...params: any[]) =&gt; LockingScript | Promise&lt;LockingScript&gt;;\n    unlock: (...params: any[]) =&gt; ScriptTemplateUnlock;\n}\n</code></pre> <p>See also: LockingScript, ScriptTemplateUnlock</p>"},{"location":"reference/script/#property-lock","title":"Property lock","text":"<p>Creates a locking script with the given parameters.</p> <p><pre><code>lock: (...params: any[]) =&gt; LockingScript | Promise&lt;LockingScript&gt;\n</code></pre> See also: LockingScript</p>"},{"location":"reference/script/#property-unlock","title":"Property unlock","text":"<p>Creates a function that generates an unlocking script along with its signature and length estimation.</p> <p>This method returns an object containing two functions: 1. <code>sign</code> - A function that, when called with a transaction and an input index, returns an UnlockingScript instance. 2. <code>estimateLength</code> - A function that returns the estimated length of the unlocking script in bytes.</p> <p><pre><code>unlock: (...params: any[]) =&gt; ScriptTemplateUnlock\n</code></pre> See also: ScriptTemplateUnlock</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/script/#interface-scripttemplateunlock","title":"Interface: ScriptTemplateUnlock","text":"<pre><code>export default interface ScriptTemplateUnlock {\n    sign: (tx: Transaction, inputIndex: number) =&gt; Promise&lt;UnlockingScript&gt;;\n    estimateLength: (tx: Transaction, inputIndex: number) =&gt; Promise&lt;number&gt;;\n}\n</code></pre> <p>See also: Transaction, UnlockingScript, sign</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/script/#classes","title":"Classes","text":"LockingScript P2PKH PushDrop RPuzzle Script ScriptEvaluationError Spend UnlockingScript <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/script/#class-lockingscript","title":"Class: LockingScript","text":"<p>The LockingScript class represents a locking script in a Bitcoin SV transaction. It extends the Script class and is used specifically for output scripts that lock funds.</p> <p>Inherits all properties and methods from the Script class.</p> <pre><code>export default class LockingScript extends Script {\n    isLockingScript(): boolean \n    isUnlockingScript(): boolean \n}\n</code></pre> <p>See also: Script</p>"},{"location":"reference/script/#method-islockingscript","title":"Method isLockingScript","text":"<pre><code>isLockingScript(): boolean \n</code></pre> <p>Returns</p> <p>Always returns true for a LockingScript instance.</p>"},{"location":"reference/script/#method-isunlockingscript","title":"Method isUnlockingScript","text":"<pre><code>isUnlockingScript(): boolean \n</code></pre> <p>Returns</p> <p>Always returns false for a LockingScript instance.</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/script/#class-p2pkh","title":"Class: P2PKH","text":"<p>P2PKH (Pay To Public Key Hash) class implementing ScriptTemplate.</p> <p>This class provides methods to create Pay To Public Key Hash locking and unlocking scripts, including the unlocking of P2PKH UTXOs with the private key.</p> <pre><code>export default class P2PKH implements ScriptTemplate {\n    lock(pubkeyhash: string | number[]): LockingScript \n    unlock(privateKey: PrivateKey, signOutputs: \"all\" | \"none\" | \"single\" = \"all\", anyoneCanPay: boolean = false, sourceSatoshis?: number, lockingScript?: Script): {\n        sign: (tx: Transaction, inputIndex: number) =&gt; Promise&lt;UnlockingScript&gt;;\n        estimateLength: () =&gt; Promise&lt;108&gt;;\n    } \n}\n</code></pre> <p>See also: LockingScript, PrivateKey, Script, ScriptTemplate, Transaction, UnlockingScript, sign</p>"},{"location":"reference/script/#method-lock","title":"Method lock","text":"<p>Creates a P2PKH locking script for a given public key hash or address string</p> <p><pre><code>lock(pubkeyhash: string | number[]): LockingScript \n</code></pre> See also: LockingScript</p> <p>Returns</p> <ul> <li>A P2PKH locking script.</li> </ul> <p>Argument Details</p> <ul> <li>pubkeyhash</li> <li>or address - An array or address representing the public key hash.</li> </ul>"},{"location":"reference/script/#method-unlock","title":"Method unlock","text":"<p>Creates a function that generates a P2PKH unlocking script along with its signature and length estimation.</p> <p>The returned object contains: 1. <code>sign</code> - A function that, when invoked with a transaction and an input index,    produces an unlocking script suitable for a P2PKH locked output. 2. <code>estimateLength</code> - A function that returns the estimated length of the unlocking script in bytes.</p> <p><pre><code>unlock(privateKey: PrivateKey, signOutputs: \"all\" | \"none\" | \"single\" = \"all\", anyoneCanPay: boolean = false, sourceSatoshis?: number, lockingScript?: Script): {\n    sign: (tx: Transaction, inputIndex: number) =&gt; Promise&lt;UnlockingScript&gt;;\n    estimateLength: () =&gt; Promise&lt;108&gt;;\n} \n</code></pre> See also: PrivateKey, Script, Transaction, UnlockingScript, sign</p> <p>Returns</p> <ul> <li>An object containing the <code>sign</code> and <code>estimateLength</code> functions.</li> </ul> <p>Argument Details</p> <ul> <li>privateKey</li> <li>The private key used for signing the transaction.</li> <li>signOutputs</li> <li>The signature scope for outputs.</li> <li>anyoneCanPay</li> <li>Flag indicating if the signature allows for other inputs to be added later.</li> <li>sourceSatoshis</li> <li>Optional. The amount being unlocked. Otherwise the input.sourceTransaction is required.</li> <li>lockingScript</li> <li>Optional. The lockinScript. Otherwise the input.sourceTransaction is required.</li> </ul> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/script/#class-pushdrop","title":"Class: PushDrop","text":"<pre><code>export default class PushDrop implements ScriptTemplate {\n    wallet: WalletInterface;\n    originator?: string;\n    static decode(script: LockingScript): {\n        lockingPublicKey: PublicKey;\n        fields: number[][];\n    } \n    constructor(wallet: WalletInterface, originator?: string) \n    async lock(fields: number[][], protocolID: WalletProtocol, keyID: string, counterparty: string, forSelf = false, includeSignature = true, lockPosition: \"before\" | \"after\" = \"before\"): Promise&lt;LockingScript&gt; \n    unlock(protocolID: WalletProtocol, keyID: string, counterparty: string, signOutputs: \"all\" | \"none\" | \"single\" = \"all\", anyoneCanPay = false, sourceSatoshis?: number, lockingScript?: LockingScript): {\n        sign: (tx: Transaction, inputIndex: number) =&gt; Promise&lt;UnlockingScript&gt;;\n        estimateLength: () =&gt; Promise&lt;73&gt;;\n    } \n}\n</code></pre> <p>See also: LockingScript, PublicKey, ScriptTemplate, Transaction, UnlockingScript, WalletInterface, WalletProtocol, sign</p>"},{"location":"reference/script/#constructor","title":"Constructor","text":"<p>Constructs a new instance of the PushDrop class.</p> <p><pre><code>constructor(wallet: WalletInterface, originator?: string) \n</code></pre> See also: WalletInterface</p> <p>Argument Details</p> <ul> <li>wallet</li> <li>The wallet interface used for creating signatures and accessing public keys.</li> <li>originator</li> <li>\u2014 The originator to use with Wallet requests</li> </ul>"},{"location":"reference/script/#method-decode","title":"Method decode","text":"<p>Decodes a PushDrop script back into its token fields and the locking public key. If a signature was present, it will be the last field returned. Warning: Only works with a P2PK lock at the beginning of the script.</p> <p><pre><code>static decode(script: LockingScript): {\n    lockingPublicKey: PublicKey;\n    fields: number[][];\n} \n</code></pre> See also: LockingScript, PublicKey</p> <p>Returns</p> <p>An object containing PushDrop token fields and the locking public key. If a signature was included, it will be the last field.</p> <p>Argument Details</p> <ul> <li>script</li> <li>PushDrop script to decode back into token fields</li> </ul>"},{"location":"reference/script/#method-lock_1","title":"Method lock","text":"<p>Creates a PushDrop locking script with arbitrary data fields and a public key lock.</p> <p><pre><code>async lock(fields: number[][], protocolID: WalletProtocol, keyID: string, counterparty: string, forSelf = false, includeSignature = true, lockPosition: \"before\" | \"after\" = \"before\"): Promise&lt;LockingScript&gt; \n</code></pre> See also: LockingScript, WalletProtocol</p> <p>Returns</p> <p>The generated PushDrop locking script.</p> <p>Argument Details</p> <ul> <li>fields</li> <li>The token fields to include in the locking script.</li> <li>protocolID</li> <li>The protocol ID to use.</li> <li>keyID</li> <li>The key ID to use.</li> <li>counterparty</li> <li>The counterparty involved in the transaction, \"self\" or \"anyone\".</li> <li>forSelf</li> <li>Flag indicating if the lock is for the creator (default no).</li> <li>includeSignature</li> <li>Flag indicating if a signature should be included in the script (default yes).</li> </ul>"},{"location":"reference/script/#method-unlock_1","title":"Method unlock","text":"<p>Creates an unlocking script for spending a PushDrop token output.</p> <p><pre><code>unlock(protocolID: WalletProtocol, keyID: string, counterparty: string, signOutputs: \"all\" | \"none\" | \"single\" = \"all\", anyoneCanPay = false, sourceSatoshis?: number, lockingScript?: LockingScript): {\n    sign: (tx: Transaction, inputIndex: number) =&gt; Promise&lt;UnlockingScript&gt;;\n    estimateLength: () =&gt; Promise&lt;73&gt;;\n} \n</code></pre> See also: LockingScript, Transaction, UnlockingScript, WalletProtocol, sign</p> <p>Returns</p> <p>An object containing functions to sign the transaction and estimate the script length.</p> <p>Argument Details</p> <ul> <li>protocolID</li> <li>The protocol ID to use.</li> <li>keyID</li> <li>The key ID to use.</li> <li>counterparty</li> <li>The counterparty involved in the transaction, \"self\" or \"anyone\".</li> <li>sourceTXID</li> <li>The TXID of the source transaction.</li> <li>sourceSatoshis</li> <li>The number of satoshis in the source output.</li> <li>lockingScript</li> <li>The locking script of the source output.</li> <li>signOutputs</li> <li>Specifies which outputs to sign.</li> <li>anyoneCanPay</li> <li>Specifies if the anyone-can-pay flag is set.</li> </ul> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/script/#class-rpuzzle","title":"Class: RPuzzle","text":"<p>RPuzzle class implementing ScriptTemplate.</p> <p>This class provides methods to create R Puzzle and R Puzzle Hash locking and unlocking scripts, including the unlocking of UTXOs with the correct K value.</p> <pre><code>export default class RPuzzle implements ScriptTemplate {\n    type: \"raw\" | \"SHA1\" | \"SHA256\" | \"HASH256\" | \"RIPEMD160\" | \"HASH160\" = \"raw\";\n    constructor(type: \"raw\" | \"SHA1\" | \"SHA256\" | \"HASH256\" | \"RIPEMD160\" | \"HASH160\" = \"raw\") \n    lock(value: number[]): LockingScript \n    unlock(k: BigNumber, privateKey: PrivateKey, signOutputs: \"all\" | \"none\" | \"single\" = \"all\", anyoneCanPay: boolean = false): {\n        sign: (tx: Transaction, inputIndex: number) =&gt; Promise&lt;UnlockingScript&gt;;\n        estimateLength: () =&gt; Promise&lt;108&gt;;\n    } \n}\n</code></pre> <p>See also: BigNumber, LockingScript, PrivateKey, ScriptTemplate, Transaction, UnlockingScript, sign</p>"},{"location":"reference/script/#constructor_1","title":"Constructor","text":"<pre><code>constructor(type: \"raw\" | \"SHA1\" | \"SHA256\" | \"HASH256\" | \"RIPEMD160\" | \"HASH160\" = \"raw\") \n</code></pre> <p>Argument Details</p> <ul> <li>type</li> <li>Denotes the type of puzzle to create</li> </ul>"},{"location":"reference/script/#method-lock_2","title":"Method lock","text":"<p>Creates an R puzzle locking script for a given R value or R value hash.</p> <p><pre><code>lock(value: number[]): LockingScript \n</code></pre> See also: LockingScript</p> <p>Returns</p> <ul> <li>An R puzzle locking script.</li> </ul> <p>Argument Details</p> <ul> <li>value</li> <li>An array representing the R value or its hash.</li> </ul>"},{"location":"reference/script/#method-unlock_2","title":"Method unlock","text":"<p>Creates a function that generates an R puzzle unlocking script along with its signature and length estimation.</p> <p>The returned object contains: 1. <code>sign</code> - A function that, when invoked with a transaction and an input index,    produces an unlocking script suitable for an R puzzle locked output. 2. <code>estimateLength</code> - A function that returns the estimated length of the unlocking script in bytes.</p> <p><pre><code>unlock(k: BigNumber, privateKey: PrivateKey, signOutputs: \"all\" | \"none\" | \"single\" = \"all\", anyoneCanPay: boolean = false): {\n    sign: (tx: Transaction, inputIndex: number) =&gt; Promise&lt;UnlockingScript&gt;;\n    estimateLength: () =&gt; Promise&lt;108&gt;;\n} \n</code></pre> See also: BigNumber, PrivateKey, Transaction, UnlockingScript, sign</p> <p>Returns</p> <ul> <li>An object containing the <code>sign</code> and <code>estimateLength</code> functions.</li> </ul> <p>Argument Details</p> <ul> <li>k</li> <li>\u2014 The K-value used to unlock the R-puzzle.</li> <li>privateKey</li> <li>The private key used for signing the transaction. If not provided, a random key will be generated.</li> <li>signOutputs</li> <li>The signature scope for outputs.</li> <li>anyoneCanPay</li> <li>Flag indicating if the signature allows for other inputs to be added later.</li> </ul> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/script/#class-script","title":"Class: Script","text":"<p>The Script class represents a script in a Bitcoin SV transaction, encapsulating the functionality to construct, parse, and serialize scripts used in both locking (output) and unlocking (input) scripts.</p> <pre><code>export default class Script {\n    chunks: ScriptChunk[];\n    static fromASM(asm: string): Script \n    static fromHex(hex: string): Script \n    static fromBinary(bin: number[]): Script \n    constructor(chunks: ScriptChunk[] = []) \n    toASM(): string \n    toHex(): string \n    toBinary(): number[] \n    writeScript(script: Script): Script \n    writeOpCode(op: number): Script \n    setChunkOpCode(i: number, op: number): Script \n    writeBn(bn: BigNumber): Script \n    writeBin(bin: number[]): Script \n    writeNumber(num: number): Script \n    removeCodeseparators(): Script \n    findAndDelete(script: Script): Script \n    isPushOnly(): boolean \n    isLockingScript(): boolean \n    isUnlockingScript(): boolean \n}\n</code></pre> <p>See also: BigNumber, ScriptChunk, toHex</p>"},{"location":"reference/script/#constructor_2","title":"Constructor","text":"<p><pre><code>constructor(chunks: ScriptChunk[] = []) \n</code></pre> See also: ScriptChunk</p> <p>Argument Details</p> <ul> <li>chunks</li> <li>=[] - An array of script chunks to directly initialize the script.</li> </ul>"},{"location":"reference/script/#method-findanddelete","title":"Method findAndDelete","text":"<p>Deletes the given item wherever it appears in the current script.</p> <p><pre><code>findAndDelete(script: Script): Script \n</code></pre> See also: Script</p> <p>Returns</p> <p>This script instance for chaining.</p> <p>Argument Details</p> <ul> <li>script</li> <li>The script containing the item to delete from the current script.</li> </ul>"},{"location":"reference/script/#method-fromasm","title":"Method fromASM","text":"<p><pre><code>static fromASM(asm: string): Script \n</code></pre> See also: Script</p> <p>Returns</p> <p>A new Script instance.</p> <p>Argument Details</p> <ul> <li>asm</li> <li>The script in ASM string format.</li> </ul> <p>Example</p> <pre><code>const script = Script.fromASM(\"OP_DUP OP_HASH160 abcd... OP_EQUALVERIFY OP_CHECKSIG\")\n</code></pre>"},{"location":"reference/script/#method-frombinary","title":"Method fromBinary","text":"<p><pre><code>static fromBinary(bin: number[]): Script \n</code></pre> See also: Script</p> <p>Returns</p> <p>A new Script instance.</p> <p>Argument Details</p> <ul> <li>bin</li> <li>The script in binary array format.</li> </ul> <p>Example</p> <pre><code>const script = Script.fromBinary([0x76, 0xa9, ...])\n</code></pre>"},{"location":"reference/script/#method-fromhex","title":"Method fromHex","text":"<p><pre><code>static fromHex(hex: string): Script \n</code></pre> See also: Script</p> <p>Returns</p> <p>A new Script instance.</p> <p>Argument Details</p> <ul> <li>hex</li> <li>The script in hexadecimal format.</li> </ul> <p>Example</p> <pre><code>const script = Script.fromHex(\"76a9...\");\n</code></pre>"},{"location":"reference/script/#method-islockingscript_1","title":"Method isLockingScript","text":"<pre><code>isLockingScript(): boolean \n</code></pre> <p>Returns</p> <p>True if the script is a locking script, otherwise false.</p>"},{"location":"reference/script/#method-ispushonly","title":"Method isPushOnly","text":"<pre><code>isPushOnly(): boolean \n</code></pre> <p>Returns</p> <p>True if the script is push-only, otherwise false.</p>"},{"location":"reference/script/#method-isunlockingscript_1","title":"Method isUnlockingScript","text":"<pre><code>isUnlockingScript(): boolean \n</code></pre> <p>Returns</p> <p>True if the script is an unlocking script, otherwise false.</p>"},{"location":"reference/script/#method-removecodeseparators","title":"Method removeCodeseparators","text":"<p><pre><code>removeCodeseparators(): Script \n</code></pre> See also: Script</p> <p>Returns</p> <p>This script instance for chaining.</p>"},{"location":"reference/script/#method-setchunkopcode","title":"Method setChunkOpCode","text":"<p><pre><code>setChunkOpCode(i: number, op: number): Script \n</code></pre> See also: Script</p> <p>Returns</p> <p>This script instance for chaining.</p> <p>Argument Details</p> <ul> <li>i</li> <li>The index of the chunk.</li> <li>op</li> <li>The opcode to set.</li> </ul>"},{"location":"reference/script/#method-toasm","title":"Method toASM","text":"<pre><code>toASM(): string \n</code></pre> <p>Returns</p> <p>The script in ASM string format.</p>"},{"location":"reference/script/#method-tobinary","title":"Method toBinary","text":"<pre><code>toBinary(): number[] \n</code></pre> <p>Returns</p> <p>The script in binary array format.</p>"},{"location":"reference/script/#method-tohex","title":"Method toHex","text":"<pre><code>toHex(): string \n</code></pre> <p>Returns</p> <p>The script in hexadecimal format.</p>"},{"location":"reference/script/#method-writebin","title":"Method writeBin","text":"<p><pre><code>writeBin(bin: number[]): Script \n</code></pre> See also: Script</p> <p>Returns</p> <p>This script instance for chaining.</p> <p>Argument Details</p> <ul> <li>bin</li> <li>The binary data to append.</li> </ul> <p>Throws</p> <p>Throws an error if the data is too large to be pushed.</p>"},{"location":"reference/script/#method-writebn","title":"Method writeBn","text":"<p><pre><code>writeBn(bn: BigNumber): Script \n</code></pre> See also: BigNumber, Script</p> <p>Returns</p> <p>This script instance for chaining.</p> <p>Argument Details</p> <ul> <li>bn</li> <li>The BigNumber to append.</li> </ul>"},{"location":"reference/script/#method-writenumber","title":"Method writeNumber","text":"<p><pre><code>writeNumber(num: number): Script \n</code></pre> See also: Script</p> <p>Returns</p> <p>This script instance for chaining.</p> <p>Argument Details</p> <ul> <li>num</li> <li>The number to append.</li> </ul>"},{"location":"reference/script/#method-writeopcode","title":"Method writeOpCode","text":"<p><pre><code>writeOpCode(op: number): Script \n</code></pre> See also: Script</p> <p>Returns</p> <p>This script instance for chaining.</p> <p>Argument Details</p> <ul> <li>op</li> <li>The opcode to append.</li> </ul>"},{"location":"reference/script/#method-writescript","title":"Method writeScript","text":"<p><pre><code>writeScript(script: Script): Script \n</code></pre> See also: Script</p> <p>Returns</p> <p>This script instance for chaining.</p> <p>Argument Details</p> <ul> <li>script</li> <li>The script to append.</li> </ul> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/script/#class-scriptevaluationerror","title":"Class: ScriptEvaluationError","text":"<pre><code>export default class ScriptEvaluationError extends Error {\n    txid: string;\n    outputIndex: number;\n    context: \"UnlockingScript\" | \"LockingScript\";\n    programCounter: number;\n    stackState: number[][];\n    altStackState: number[][];\n    ifStackState: boolean[];\n    stackMem: number;\n    altStackMem: number;\n    constructor(params: {\n        message: string;\n        txid: string;\n        outputIndex: number;\n        context: \"UnlockingScript\" | \"LockingScript\";\n        programCounter: number;\n        stackState: number[][];\n        altStackState: number[][];\n        ifStackState: boolean[];\n        stackMem: number;\n        altStackMem: number;\n    }) \n}\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/script/#class-spend","title":"Class: Spend","text":"<p>The Spend class represents a spend action within a Bitcoin SV transaction. It encapsulates all the necessary data required for spending a UTXO (Unspent Transaction Output) and includes details about the source transaction, output, and the spending transaction itself.</p> <pre><code>export default class Spend {\n    sourceTXID: string;\n    sourceOutputIndex: number;\n    sourceSatoshis: number;\n    lockingScript: LockingScript;\n    transactionVersion: number;\n    otherInputs: TransactionInput[];\n    outputs: TransactionOutput[];\n    inputIndex: number;\n    unlockingScript: UnlockingScript;\n    inputSequence: number;\n    lockTime: number;\n    context: \"UnlockingScript\" | \"LockingScript\";\n    programCounter: number;\n    lastCodeSeparator: number | null;\n    stack: number[][];\n    altStack: number[][];\n    ifStack: boolean[];\n    memoryLimit: number;\n    stackMem: number;\n    altStackMem: number;\n    constructor(params: {\n        sourceTXID: string;\n        sourceOutputIndex: number;\n        sourceSatoshis: number;\n        lockingScript: LockingScript;\n        transactionVersion: number;\n        otherInputs: TransactionInput[];\n        outputs: TransactionOutput[];\n        unlockingScript: UnlockingScript;\n        inputSequence: number;\n        inputIndex: number;\n        lockTime: number;\n        memoryLimit?: number;\n    }) \n    reset(): void \n    step(): boolean \n    validate(): boolean \n}\n</code></pre> <p>See also: LockingScript, TransactionInput, TransactionOutput, UnlockingScript</p>"},{"location":"reference/script/#constructor_3","title":"Constructor","text":"<p><pre><code>constructor(params: {\n    sourceTXID: string;\n    sourceOutputIndex: number;\n    sourceSatoshis: number;\n    lockingScript: LockingScript;\n    transactionVersion: number;\n    otherInputs: TransactionInput[];\n    outputs: TransactionOutput[];\n    unlockingScript: UnlockingScript;\n    inputSequence: number;\n    inputIndex: number;\n    lockTime: number;\n    memoryLimit?: number;\n}) \n</code></pre> See also: LockingScript, TransactionInput, TransactionOutput, UnlockingScript</p> <p>Argument Details</p> <ul> <li>params.sourceTXID</li> <li>The transaction ID of the source UTXO.</li> <li>params.sourceOutputIndex</li> <li>The index of the output in the source transaction.</li> <li>params.sourceSatoshis</li> <li>The amount of satoshis in the source UTXO.</li> <li>params.lockingScript</li> <li>The locking script associated with the UTXO.</li> <li>params.transactionVersion</li> <li>The version of the current transaction.</li> <li>params.otherInputs</li> <li>- An array of other inputs in the transaction.</li> <li>params.outputs</li> <li>- The outputs of the current transaction.</li> <li>params.inputIndex</li> <li>The index of this input in the current transaction.</li> <li>params.unlockingScript</li> <li>The unlocking script for this spend.</li> <li>params.inputSequence</li> <li>The sequence number of this input.</li> <li>params.lockTime</li> <li>The lock time of the transaction.</li> </ul> <p>Example</p> <pre><code>const spend = new Spend({\n  sourceTXID: \"abcd1234\", // sourceTXID\n  sourceOutputIndex: 0, // sourceOutputIndex\n  sourceSatoshis: new BigNumber(1000), // sourceSatoshis\n  lockingScript: LockingScript.fromASM(\"OP_DUP OP_HASH160 abcd1234... OP_EQUALVERIFY OP_CHECKSIG\"),\n  transactionVersion: 1, // transactionVersion\n  otherInputs: [{ sourceTXID: \"abcd1234\", sourceOutputIndex: 1, sequence: 0xffffffff }], // otherInputs\n  outputs: [{ satoshis: new BigNumber(500), lockingScript: LockingScript.fromASM(\"OP_DUP...\") }], // outputs\n  inputIndex: 0, // inputIndex\n  unlockingScript: UnlockingScript.fromASM(\"3045... 02ab...\"),\n  inputSequence: 0xffffffff // inputSequence\n  memoryLimit: 100000 // memoryLimit\n});\n</code></pre>"},{"location":"reference/script/#method-validate","title":"Method validate","text":"<pre><code>validate(): boolean \n</code></pre> <p>Returns</p> <p>Returns true if the scripts are valid and the spend is legitimate, otherwise false.</p> <p>Example</p> <pre><code>if (spend.validate()) {\n  console.log(\"Spend is valid!\");\n} else {\n  console.log(\"Invalid spend!\");\n}\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/script/#class-unlockingscript","title":"Class: UnlockingScript","text":"<p>The UnlockingScript class represents an unlocking script in a Bitcoin SV transaction. It extends the Script class and is used specifically for input scripts that unlock funds.</p> <p>Inherits all properties and methods from the Script class.</p> <pre><code>export default class UnlockingScript extends Script {\n    isLockingScript(): boolean \n    isUnlockingScript(): boolean \n}\n</code></pre> <p>See also: Script</p>"},{"location":"reference/script/#method-islockingscript_2","title":"Method isLockingScript","text":"<pre><code>isLockingScript(): boolean \n</code></pre> <p>Returns</p> <p>Always returns false for an UnlockingScript instance.</p>"},{"location":"reference/script/#method-isunlockingscript_2","title":"Method isUnlockingScript","text":"<pre><code>isUnlockingScript(): boolean \n</code></pre> <p>Returns</p> <p>Always returns true for an UnlockingScript instance.</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/script/#functions","title":"Functions","text":""},{"location":"reference/script/#types","title":"Types","text":""},{"location":"reference/script/#enums","title":"Enums","text":""},{"location":"reference/script/#variables","title":"Variables","text":""},{"location":"reference/storage/","title":"API","text":"<p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/storage/#interfaces","title":"Interfaces","text":"DownloadResult DownloaderConfig FindFileData RenewFileResult UploadFileResult UploadableFile UploaderConfig <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/storage/#interface-downloadresult","title":"Interface: DownloadResult","text":"<pre><code>export interface DownloadResult {\n    data: Uint8Array;\n    mimeType: string | null;\n}\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/storage/#interface-downloaderconfig","title":"Interface: DownloaderConfig","text":"<pre><code>export interface DownloaderConfig {\n    networkPreset: \"mainnet\" | \"testnet\" | \"local\";\n}\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/storage/#interface-findfiledata","title":"Interface: FindFileData","text":"<pre><code>export interface FindFileData {\n    name: string;\n    size: string;\n    mimeType: string;\n    expiryTime: number;\n}\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/storage/#interface-renewfileresult","title":"Interface: RenewFileResult","text":"<pre><code>export interface RenewFileResult {\n    status: string;\n    prevExpiryTime?: number;\n    newExpiryTime?: number;\n    amount?: number;\n}\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/storage/#interface-uploadfileresult","title":"Interface: UploadFileResult","text":"<pre><code>export interface UploadFileResult {\n    published: boolean;\n    uhrpURL: string;\n}\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/storage/#interface-uploadablefile","title":"Interface: UploadableFile","text":"<pre><code>export interface UploadableFile {\n    data: Uint8Array | number[];\n    type: string;\n}\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/storage/#interface-uploaderconfig","title":"Interface: UploaderConfig","text":"<pre><code>export interface UploaderConfig {\n    storageURL: string;\n    wallet: WalletInterface;\n}\n</code></pre> <p>See also: WalletInterface</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/storage/#classes","title":"Classes","text":"StorageDownloader StorageUploader <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/storage/#class-storagedownloader","title":"Class: StorageDownloader","text":"<pre><code>export class StorageDownloader {\n    constructor(config?: DownloaderConfig) \n    public async resolve(uhrpUrl: string): Promise&lt;string[]&gt; \n    public async download(uhrpUrl: string): Promise&lt;DownloadResult&gt; \n}\n</code></pre> <p>See also: DownloadResult, DownloaderConfig</p>"},{"location":"reference/storage/#method-download","title":"Method download","text":"<p>Downloads the content from the UHRP URL after validating the hash for integrity.</p> <p><pre><code>public async download(uhrpUrl: string): Promise&lt;DownloadResult&gt; \n</code></pre> See also: DownloadResult</p> <p>Returns</p> <p>A promise that resolves to the downloaded content.</p> <p>Argument Details</p> <ul> <li>uhrpUrl</li> <li>The UHRP URL to download.</li> </ul>"},{"location":"reference/storage/#method-resolve","title":"Method resolve","text":"<p>Resolves the UHRP URL to a list of HTTP URLs where content can be downloaded.</p> <pre><code>public async resolve(uhrpUrl: string): Promise&lt;string[]&gt; \n</code></pre> <p>Returns</p> <p>A promise that resolves to an array of HTTP URLs.</p> <p>Argument Details</p> <ul> <li>uhrpUrl</li> <li>The UHRP URL to resolve.</li> </ul> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/storage/#class-storageuploader","title":"Class: StorageUploader","text":"<p>The StorageUploader class provides client-side methods for: - Uploading files with a specified retention period - Finding file metadata by UHRP URL - Listing all user uploads - Renewing an existing advertisement's expiry time</p> <pre><code>export class StorageUploader {\n    constructor(config: UploaderConfig) \n    public async publishFile(params: {\n        file: UploadableFile;\n        retentionPeriod: number;\n    }): Promise&lt;UploadFileResult&gt; \n    public async findFile(uhrpUrl: string): Promise&lt;FindFileData&gt; \n    public async listUploads(): Promise&lt;any&gt; \n    public async renewFile(uhrpUrl: string, additionalMinutes: number): Promise&lt;RenewFileResult&gt; \n}\n</code></pre> <p>See also: FindFileData, RenewFileResult, UploadFileResult, UploadableFile, UploaderConfig</p>"},{"location":"reference/storage/#constructor","title":"Constructor","text":"<p>Creates a new StorageUploader instance.</p> <p><pre><code>constructor(config: UploaderConfig) \n</code></pre> See also: UploaderConfig</p> <p>Argument Details</p> <ul> <li>config</li> <li>An object containing the storage server's URL and a wallet interface</li> </ul>"},{"location":"reference/storage/#method-findfile","title":"Method findFile","text":"<p>Retrieves metadata for a file matching the given UHRP URL from the <code>/find</code> route.</p> <p><pre><code>public async findFile(uhrpUrl: string): Promise&lt;FindFileData&gt; \n</code></pre> See also: FindFileData</p> <p>Returns</p> <p>An object with file name, size, MIME type, and expiry time</p> <p>Argument Details</p> <ul> <li>uhrpUrl</li> <li>The UHRP URL, e.g. \"uhrp://abcd...\"</li> </ul> <p>Throws</p> <p>If the server or the route returns an error</p>"},{"location":"reference/storage/#method-listuploads","title":"Method listUploads","text":"<p>Lists all advertisements belonging to the user from the <code>/list</code> route.</p> <pre><code>public async listUploads(): Promise&lt;any&gt; \n</code></pre> <p>Returns</p> <p>The array of uploads returned by the server</p> <p>Throws</p> <p>If the server or the route returns an error</p>"},{"location":"reference/storage/#method-publishfile","title":"Method publishFile","text":"<p>Publishes a file to the storage server with the specified retention period.</p> <p>This will: 1. Request an upload URL from the server. 2. Perform an HTTP PUT to upload the file\u2019s raw bytes. 3. Return a UHRP URL referencing the file once published.</p> <p><pre><code>public async publishFile(params: {\n    file: UploadableFile;\n    retentionPeriod: number;\n}): Promise&lt;UploadFileResult&gt; \n</code></pre> See also: UploadFileResult, UploadableFile</p> <p>Returns</p> <p>An object with the file's UHRP URL</p> <p>Throws</p> <p>If the server or upload step returns a non-OK response</p>"},{"location":"reference/storage/#method-renewfile","title":"Method renewFile","text":"<p>Renews the hosting time for an existing file advertisement identified by uhrpUrl. Calls the <code>/renew</code> route to add <code>additionalMinutes</code> to the GCS customTime and re-mint the advertisement token on-chain.</p> <p><pre><code>public async renewFile(uhrpUrl: string, additionalMinutes: number): Promise&lt;RenewFileResult&gt; \n</code></pre> See also: RenewFileResult</p> <p>Returns</p> <p>An object with the new and previous expiry times, plus any cost</p> <p>Argument Details</p> <ul> <li>uhrpUrl</li> <li>The UHRP URL of the file (e.g., \"uhrp://abcd1234...\")</li> <li>additionalMinutes</li> <li>The number of minutes to extend</li> </ul> <p>Throws</p> <p>If the request fails or the server returns an error</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/storage/#functions","title":"Functions","text":""},{"location":"reference/storage/#types","title":"Types","text":""},{"location":"reference/storage/#enums","title":"Enums","text":""},{"location":"reference/storage/#variables","title":"Variables","text":"getHashFromURL getURLForFile getURLForHash isValidURL normalizeURL <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/storage/#variable-gethashfromurl","title":"Variable: getHashFromURL","text":"<pre><code>getHashFromURL = (URL: string): number[] =&gt; {\n    URL = normalizeURL(URL);\n    const { data, prefix } = fromBase58Check(URL, undefined, 2);\n    if (data.length !== 32) {\n        throw new Error(\"Invalid length!\");\n    }\n    if (toHex(prefix as number[]) !== \"ce00\") {\n        throw new Error(\"Bad prefix\");\n    }\n    return data as number[];\n}\n</code></pre> <p>See also: fromBase58Check, normalizeURL, toHex</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/storage/#variable-geturlforfile","title":"Variable: getURLForFile","text":"<pre><code>getURLForFile = (file: Uint8Array | number[]): string =&gt; {\n    const data = file instanceof Uint8Array ? file : Uint8Array.from(file);\n    const hasher = new Hash.SHA256();\n    const chunkSize = 1024 * 1024;\n    for (let i = 0; i &lt; data.length; i += chunkSize) {\n        const chunk = data.subarray(i, i + chunkSize);\n        hasher.update(Array.from(chunk));\n    }\n    const hash = hasher.digest();\n    return getURLForHash(hash);\n}\n</code></pre> <p>See also: SHA256, getURLForHash</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/storage/#variable-geturlforhash","title":"Variable: getURLForHash","text":"<pre><code>getURLForHash = (hash: number[]): string =&gt; {\n    if (hash.length !== 32) {\n        throw new Error(\"Hash length must be 32 bytes (sha256)\");\n    }\n    return toBase58Check(hash, toArray(\"ce00\", \"hex\"));\n}\n</code></pre> <p>See also: toArray, toBase58Check</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/storage/#variable-isvalidurl","title":"Variable: isValidURL","text":"<pre><code>isValidURL = (URL: string): boolean =&gt; {\n    try {\n        getHashFromURL(URL);\n        return true;\n    }\n    catch (e) {\n        return false;\n    }\n}\n</code></pre> <p>See also: getHashFromURL</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/storage/#variable-normalizeurl","title":"Variable: normalizeURL","text":"<pre><code>normalizeURL = (URL: string): string =&gt; {\n    if (URL.toLowerCase().startsWith(\"uhrp:\"))\n        URL = URL.slice(5);\n    if (URL.startsWith(\"//\"))\n        URL = URL.slice(2);\n    return URL;\n}\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/totp/","title":"API","text":"<p>Links: API, Interfaces, Classes, Functions, Types, Variables</p>"},{"location":"reference/totp/#interfaces","title":"Interfaces","text":""},{"location":"reference/totp/#interface-totpoptions","title":"Interface: TOTPOptions","text":"<p>Options for TOTP generation.</p> <pre><code>export interface TOTPOptions {\n    digits?: number;\n    algorithm?: TOTPAlgorithm;\n    period?: number;\n    timestamp?: number;\n}\n</code></pre> <p>See also: TOTPAlgorithm</p> <p>Links: API, Interfaces, Classes, Functions, Types, Variables</p>"},{"location":"reference/totp/#classes","title":"Classes","text":""},{"location":"reference/totp/#class-totp","title":"Class: TOTP","text":"<pre><code>export class TOTP {\n    static generate(secret: number[], options?: TOTPOptions): string \n    static validate(secret: number[], passcode: string, options?: TOTPValidateOptions): boolean \n}\n</code></pre> <p>See also: TOTPOptions, TOTPValidateOptions</p>"},{"location":"reference/totp/#method-generate","title":"Method generate","text":"<p>Generates a Time-based One-Time Password (TOTP).</p> <p><pre><code>static generate(secret: number[], options?: TOTPOptions): string \n</code></pre> See also: TOTPOptions</p> <p>Returns</p> <p>The generated TOTP.</p> <p>Argument Details</p> <ul> <li>secret</li> <li>The secret key for TOTP.</li> <li>options</li> <li>Optional parameters for TOTP.</li> </ul>"},{"location":"reference/totp/#method-validate","title":"Method validate","text":"<p>Validates a Time-based One-Time Password (TOTP).</p> <p><pre><code>static validate(secret: number[], passcode: string, options?: TOTPValidateOptions): boolean \n</code></pre> See also: TOTPValidateOptions</p> <p>Returns</p> <p>A boolean indicating whether the passcode is valid.</p> <p>Argument Details</p> <ul> <li>secret</li> <li>The secret key for TOTP.</li> <li>passcode</li> <li>The passcode to validate.</li> <li>options</li> <li>Optional parameters for TOTP validation.</li> </ul> <p>Links: API, Interfaces, Classes, Functions, Types, Variables</p>"},{"location":"reference/totp/#functions","title":"Functions","text":""},{"location":"reference/totp/#types","title":"Types","text":"TOTPAlgorithm TOTPValidateOptions <p>Links: API, Interfaces, Classes, Functions, Types, Variables</p>"},{"location":"reference/totp/#type-totpalgorithm","title":"Type: TOTPAlgorithm","text":"<pre><code>export type TOTPAlgorithm = \"SHA-1\" | \"SHA-256\" | \"SHA-512\"\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Variables</p>"},{"location":"reference/totp/#type-totpvalidateoptions","title":"Type: TOTPValidateOptions","text":"<p>Options for TOTP validation.</p> <pre><code>export type TOTPValidateOptions = TOTPOptions &amp; {\n    skew?: number;\n}\n</code></pre> <p>See also: TOTPOptions</p> <p>Links: API, Interfaces, Classes, Functions, Types, Variables</p>"},{"location":"reference/totp/#variables","title":"Variables","text":""},{"location":"reference/transaction-signatures/","title":"Transaction Signatures Reference","text":"<p>** SKELETON PLACEHOLDER - check  https://docs.bsvblockchain.org/guides/sdks/ts/low-level/tx_sig *** This is a technical reference document for transaction signatures in the BSV TypeScript SDK.</p>"},{"location":"reference/transaction-signatures/#introduction","title":"Introduction","text":"<p>This reference document provides detailed technical information about transaction signatures in Bitcoin SV and how they are implemented in the TypeScript SDK. It complements the Key Management and Cryptography tutorial and the Advanced Transaction Signing guide.</p>"},{"location":"reference/transaction-signatures/#signature-components","title":"Signature Components","text":""},{"location":"reference/transaction-signatures/#ecdsa-signatures","title":"ECDSA Signatures","text":"<p>Bitcoin uses the Elliptic Curve Digital Signature Algorithm (ECDSA) with the secp256k1 curve. Each signature consists of two components:</p> <ul> <li><code>r</code>: A value derived from a random nonce used during signing</li> <li><code>s</code>: A value that combines the private key, message hash, and the nonce</li> </ul> <pre><code>// Structure of a Signature class instance\nclass Signature {\n  r: BigNumber; // The r component\n  s: BigNumber; // The s component\n\n  // Methods for serialization\n  toDER(encoding?: 'hex'): number[] | string;\n\n  // Static methods for deserialization\n  static fromDER(bytes: number[]): Signature;\n  // Additional methods...\n}\n</code></pre>"},{"location":"reference/transaction-signatures/#der-encoding","title":"DER Encoding","text":"<p>Signatures in Bitcoin are encoded using the Distinguished Encoding Rules (DER) format, which provides a standardized way to represent the ECDSA signature components.</p>"},{"location":"reference/transaction-signatures/#signature-hash-sighash-types","title":"Signature Hash (SIGHASH) Types","text":"<p>Bitcoin transactions use SIGHASH flags to indicate which parts of a transaction are included in the signature hash:</p> Flag Hex Value Description SIGHASH_ALL 0x01 Signs all inputs and outputs (default) SIGHASH_NONE 0x02 Signs inputs only, allows any outputs SIGHASH_SINGLE 0x03 Signs inputs and the output with the same index SIGHASH_ANYONECANPAY 0x80 Can be combined with above flags, allows additional inputs"},{"location":"reference/transaction-signatures/#transaction-signature-verification-process","title":"Transaction Signature Verification Process","text":"<ol> <li>Extract signature and public key from the unlockingScript</li> <li>Determine the SIGHASH flag from the signature</li> <li>Recreate the signature hash based on the SIGHASH flag</li> <li>Verify the signature against the hash using the public key</li> </ol>"},{"location":"reference/transaction-signatures/#api-reference","title":"API Reference","text":""},{"location":"reference/transaction-signatures/#privatekey-methods","title":"PrivateKey Methods","text":"<pre><code>// Sign a message or transaction with a private key\nsign(message: string | number[], sigHashType?: number): Promise&lt;Signature&gt;;\n</code></pre>"},{"location":"reference/transaction-signatures/#publickey-methods","title":"PublicKey Methods","text":"<pre><code>// Verify a signature with a public key\nverify(message: string | number[], signature: Signature): boolean;\n</code></pre>"},{"location":"reference/transaction-signatures/#transaction-methods","title":"Transaction Methods","text":"<pre><code>// Sign a transaction\nsign(sigHashType?: number): Promise&lt;void&gt;;\n\n// Verify all signatures in a transaction\nverify(): Promise&lt;boolean&gt;;\n</code></pre>"},{"location":"reference/transaction-signatures/#example-implementation-details","title":"Example Implementation Details","text":"<pre><code>// Example of how signature hashing is implemented\nfunction calculateSignatureHash(tx: Transaction, inputIndex: number, sigHashType: number): number[] {\n  // Implementation details...\n}\n</code></pre>"},{"location":"reference/transaction-signatures/#related-resources","title":"Related Resources","text":"<ul> <li>Advanced Transaction Signing guide</li> <li>Key Management and Cryptography tutorial</li> <li>Bitcoin Transaction Format</li> </ul>"},{"location":"reference/transaction/","title":"API","text":"<p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/transaction/#interfaces","title":"Interfaces","text":"ArcConfig HttpClientRequestOptions BroadcastFailure HttpsNodejs BroadcastResponse MerklePathLeaf Broadcaster NodejsHttpClientRequest ChainTracker TransactionInput FeeModel TransactionOutput FetchOptions WhatsOnChainConfig HttpClient <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/transaction/#interface-arcconfig","title":"Interface: ArcConfig","text":"<p>Configuration options for the ARC broadcaster.</p> <pre><code>export interface ArcConfig {\n    apiKey?: string;\n    httpClient?: HttpClient;\n    deploymentId?: string;\n    callbackUrl?: string;\n    callbackToken?: string;\n    headers?: Record&lt;string, string&gt;;\n}\n</code></pre> <p>See also: HttpClient</p>"},{"location":"reference/transaction/#property-apikey","title":"Property apiKey","text":"<p>Authentication token for the ARC API</p> <pre><code>apiKey?: string\n</code></pre>"},{"location":"reference/transaction/#property-callbacktoken","title":"Property callbackToken","text":"<p>default access token for notification callback endpoint. It will be used as a Authorization header for the http callback</p> <pre><code>callbackToken?: string\n</code></pre>"},{"location":"reference/transaction/#property-callbackurl","title":"Property callbackUrl","text":"<p>notification callback endpoint for proofs and double spend notification</p> <pre><code>callbackUrl?: string\n</code></pre>"},{"location":"reference/transaction/#property-deploymentid","title":"Property deploymentId","text":"<p>Deployment id used annotating api calls in XDeployment-ID header - this value will be randomly generated if not set</p> <pre><code>deploymentId?: string\n</code></pre>"},{"location":"reference/transaction/#property-headers","title":"Property headers","text":"<p>additional headers to be attached to all tx submissions.</p> <pre><code>headers?: Record&lt;string, string&gt;\n</code></pre>"},{"location":"reference/transaction/#property-httpclient","title":"Property httpClient","text":"<p>The HTTP client used to make requests to the ARC API.</p> <p><pre><code>httpClient?: HttpClient\n</code></pre> See also: HttpClient</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/transaction/#interface-broadcastfailure","title":"Interface: BroadcastFailure","text":"<p>Defines the structure of a failed broadcast response.</p> <pre><code>export interface BroadcastFailure {\n    status: \"error\";\n    code: string;\n    txid?: string;\n    description: string;\n    more?: object;\n}\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/transaction/#interface-broadcastresponse","title":"Interface: BroadcastResponse","text":"<p>Defines the structure of a successful broadcast response.</p> <pre><code>export interface BroadcastResponse {\n    status: \"success\";\n    txid: string;\n    message: string;\n    competingTxs?: string[];\n}\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/transaction/#interface-broadcaster","title":"Interface: Broadcaster","text":"<p>Represents the interface for a transaction broadcaster. This interface defines a standard method for broadcasting transactions.</p> <pre><code>export interface Broadcaster {\n    broadcast: (transaction: Transaction) =&gt; Promise&lt;BroadcastResponse | BroadcastFailure&gt;;\n    broadcastMany?: (txs: Transaction[]) =&gt; Promise&lt;object[]&gt;;\n}\n</code></pre> <p>See also: BroadcastFailure, BroadcastResponse, Transaction</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/transaction/#interface-chaintracker","title":"Interface: ChainTracker","text":"<p>The Chain Tracker is responsible for verifying the validity of a given Merkle root for a specific block height within the blockchain.</p> <p>Chain Trackers ensure the integrity of the blockchain by validating new headers against the chain's history. They use accumulated proof-of-work and protocol adherence as metrics to assess the legitimacy of blocks.</p> <p>Example</p> <pre><code>const chainTracker = {\n  isValidRootForHeight: async (root, height) =&gt; {\n    // Implementation to check if the Merkle root is valid for the specified block height.\n  }\n currentHeight: async () =&gt; {\n    // Implementation to get the current block height.\n  }\n};\n</code></pre> <pre><code>export default interface ChainTracker {\n    isValidRootForHeight: (root: string, height: number) =&gt; Promise&lt;boolean&gt;;\n    currentHeight: () =&gt; Promise&lt;number&gt;;\n}\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/transaction/#interface-feemodel","title":"Interface: FeeModel","text":"<p>Represents the interface for a transaction fee model. This interface defines a standard method for computing a fee when given a transaction.</p> <pre><code>export default interface FeeModel {\n    computeFee: (transaction: Transaction) =&gt; Promise&lt;number&gt;;\n}\n</code></pre> <p>See also: Transaction</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/transaction/#interface-fetchoptions","title":"Interface: FetchOptions","text":"<p>An interface for configuration of the request to be passed to the fetch method limited to options needed by ts-sdk.</p> <pre><code>export interface FetchOptions {\n    method?: string;\n    headers?: Record&lt;string, string&gt;;\n    body?: string | null;\n}\n</code></pre>"},{"location":"reference/transaction/#property-body","title":"Property body","text":"<p>An object or null to set request's body.</p> <pre><code>body?: string | null\n</code></pre>"},{"location":"reference/transaction/#property-headers_1","title":"Property headers","text":"<p>An object literal set request's headers.</p> <pre><code>headers?: Record&lt;string, string&gt;\n</code></pre>"},{"location":"reference/transaction/#property-method","title":"Property method","text":"<p>A string to set request's method.</p> <pre><code>method?: string\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/transaction/#interface-httpclient","title":"Interface: HttpClient","text":"<p>An interface for HTTP client used to make HTTP requests.</p> <pre><code>export interface HttpClient {\n    request: &lt;T = any, D = any&gt;(url: string, options: HttpClientRequestOptions&lt;D&gt;) =&gt; Promise&lt;HttpClientResponse&lt;T&gt;&gt;;\n}\n</code></pre> <p>See also: HttpClientRequestOptions, HttpClientResponse</p>"},{"location":"reference/transaction/#property-request","title":"Property request","text":"<p>Makes a request to the server.</p> <p><pre><code>request: &lt;T = any, D = any&gt;(url: string, options: HttpClientRequestOptions&lt;D&gt;) =&gt; Promise&lt;HttpClientResponse&lt;T&gt;&gt;\n</code></pre> See also: HttpClientRequestOptions, HttpClientResponse</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/transaction/#interface-httpclientrequestoptions","title":"Interface: HttpClientRequestOptions","text":"<p>An interface for configuration of the request to be passed to the request method.</p> <pre><code>export interface HttpClientRequestOptions&lt;Data = any&gt; {\n    method?: string;\n    headers?: Record&lt;string, string&gt;;\n    data?: Data;\n    signal?: AbortSignal;\n}\n</code></pre>"},{"location":"reference/transaction/#property-data","title":"Property data","text":"<p>An object or null to set request's body.</p> <pre><code>data?: Data\n</code></pre>"},{"location":"reference/transaction/#property-headers_2","title":"Property headers","text":"<p>An object literal set request's headers.</p> <pre><code>headers?: Record&lt;string, string&gt;\n</code></pre>"},{"location":"reference/transaction/#property-method_1","title":"Property method","text":"<p>A string to set request's method.</p> <pre><code>method?: string\n</code></pre>"},{"location":"reference/transaction/#property-signal","title":"Property signal","text":"<p>An optional AbortSignal to cancel the request, including by explicit timeout.</p> <pre><code>signal?: AbortSignal\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/transaction/#interface-httpsnodejs","title":"Interface: HttpsNodejs","text":"<p>Node Https module interface limited to options needed by ts-sdk</p> <pre><code>export interface HttpsNodejs {\n    request: (url: string, options: HttpClientRequestOptions, callback: (res: any) =&gt; void) =&gt; NodejsHttpClientRequest;\n}\n</code></pre> <p>See also: HttpClientRequestOptions, NodejsHttpClientRequest</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/transaction/#interface-merklepathleaf","title":"Interface: MerklePathLeaf","text":"<pre><code>export interface MerklePathLeaf {\n    offset: number;\n    hash?: string;\n    txid?: boolean;\n    duplicate?: boolean;\n}\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/transaction/#interface-nodejshttpclientrequest","title":"Interface: NodejsHttpClientRequest","text":"<p>Nodejs result of the Node https.request call limited to options needed by ts-sdk</p> <pre><code>export interface NodejsHttpClientRequest {\n    write: (chunk: string) =&gt; void;\n    on: (event: string, callback: (data: any) =&gt; void) =&gt; void;\n    end: (() =&gt; void) &amp; (() =&gt; void);\n}\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/transaction/#interface-transactioninput","title":"Interface: TransactionInput","text":"<p>Represents an input to a Bitcoin transaction. This interface defines the structure and components required to construct a transaction input in the Bitcoin blockchain.</p> <p>Example</p> <pre><code>// Creating a simple transaction input\nlet txInput = {\n  sourceTXID: '123abc...',\n  sourceOutputIndex: 0,\n  sequence: 0xFFFFFFFF\n};\n\n// Using an unlocking script template\ntxInput.unlockingScriptTemplate = {\n  sign: async (tx, index) =&gt; { ... },\n  estimateLength: async (tx, index) =&gt; { ... }\n};\n</code></pre> <pre><code>export default interface TransactionInput {\n    sourceTransaction?: Transaction;\n    sourceTXID?: string;\n    sourceOutputIndex: number;\n    unlockingScript?: UnlockingScript;\n    unlockingScriptTemplate?: {\n        sign: (tx: Transaction, inputIndex: number) =&gt; Promise&lt;UnlockingScript&gt;;\n        estimateLength: (tx: Transaction, inputIndex: number) =&gt; Promise&lt;number&gt;;\n    };\n    sequence?: number;\n}\n</code></pre> <p>See also: Transaction, UnlockingScript, sign</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/transaction/#interface-transactionoutput","title":"Interface: TransactionOutput","text":"<p>Represents an output in a Bitcoin transaction. This interface defines the structure and components necessary to construct a transaction output, which secures owned Bitcoins to be unlocked later.</p> <p>Example</p> <pre><code>// Creating a simple transaction output\nlet txOutput = {\n  satoshis: 1000,\n  lockingScript: LockingScript.fromASM('OP_DUP OP_HASH160 ... OP_EQUALVERIFY OP_CHECKSIG'),\n  change: false\n};\n</code></pre> <pre><code>export default interface TransactionOutput {\n    satoshis?: number;\n    lockingScript: LockingScript;\n    change?: boolean;\n}\n</code></pre> <p>See also: LockingScript</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/transaction/#interface-whatsonchainconfig","title":"Interface: WhatsOnChainConfig","text":"<p>Configuration options for the WhatsOnChain ChainTracker.</p> <pre><code>export interface WhatsOnChainConfig {\n    apiKey?: string;\n    httpClient?: HttpClient;\n}\n</code></pre> <p>See also: HttpClient</p>"},{"location":"reference/transaction/#property-apikey_1","title":"Property apiKey","text":"<p>Authentication token for the WhatsOnChain API</p> <pre><code>apiKey?: string\n</code></pre>"},{"location":"reference/transaction/#property-httpclient_1","title":"Property httpClient","text":"<p>The HTTP client used to make requests to the API.</p> <p><pre><code>httpClient?: HttpClient\n</code></pre> See also: HttpClient</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/transaction/#classes","title":"Classes","text":"ARC Beef BeefParty BeefTx FetchHttpClient LivePolicy MerklePath NodejsHttpClient SatoshisPerKilobyte Transaction WhatsOnChain <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/transaction/#class-arc","title":"Class: ARC","text":"<p>Represents an ARC transaction broadcaster.</p> <pre><code>export default class ARC implements Broadcaster {\n    readonly URL: string;\n    readonly apiKey: string | undefined;\n    readonly deploymentId: string;\n    readonly callbackUrl: string | undefined;\n    readonly callbackToken: string | undefined;\n    readonly headers: Record&lt;string, string&gt; | undefined;\n    constructor(URL: string, config?: ArcConfig);\n    constructor(URL: string, apiKey?: string);\n    constructor(URL: string, config?: string | ArcConfig) \n    async broadcast(tx: Transaction): Promise&lt;BroadcastResponse | BroadcastFailure&gt; \n    async broadcastMany(txs: Transaction[]): Promise&lt;object[]&gt; \n}\n</code></pre> <p>See also: ArcConfig, BroadcastFailure, BroadcastResponse, Broadcaster, Transaction</p>"},{"location":"reference/transaction/#constructor","title":"Constructor","text":"<p>Constructs an instance of the ARC broadcaster.</p> <p><pre><code>constructor(URL: string, config?: ArcConfig)\n</code></pre> See also: ArcConfig</p> <p>Argument Details</p> <ul> <li>URL</li> <li>The URL endpoint for the ARC API.</li> <li>config</li> <li>Configuration options for the ARC broadcaster.</li> </ul>"},{"location":"reference/transaction/#constructor_1","title":"Constructor","text":"<p>Constructs an instance of the ARC broadcaster.</p> <pre><code>constructor(URL: string, apiKey?: string)\n</code></pre> <p>Argument Details</p> <ul> <li>URL</li> <li>The URL endpoint for the ARC API.</li> <li>apiKey</li> <li>The API key used for authorization with the ARC API.</li> </ul>"},{"location":"reference/transaction/#method-broadcast","title":"Method broadcast","text":"<p>Broadcasts a transaction via ARC.</p> <p><pre><code>async broadcast(tx: Transaction): Promise&lt;BroadcastResponse | BroadcastFailure&gt; \n</code></pre> See also: BroadcastFailure, BroadcastResponse, Transaction</p> <p>Returns</p> <p>A promise that resolves to either a success or failure response.</p> <p>Argument Details</p> <ul> <li>tx</li> <li>The transaction to be broadcasted.</li> </ul>"},{"location":"reference/transaction/#method-broadcastmany","title":"Method broadcastMany","text":"<p>Broadcasts multiple transactions via ARC. Handles mixed responses where some transactions succeed and others fail.</p> <p><pre><code>async broadcastMany(txs: Transaction[]): Promise&lt;object[]&gt; \n</code></pre> See also: Transaction</p> <p>Returns</p> <p>A promise that resolves to an array of objects.</p> <p>Argument Details</p> <ul> <li>txs</li> <li>Array of transactions to be broadcasted.</li> </ul> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/transaction/#class-beef","title":"Class: Beef","text":"<pre><code>export class Beef {\n    bumps: MerklePath[] = [];\n    txs: BeefTx[] = [];\n    version: number = BEEF_V2;\n    atomicTxid: string | undefined = undefined;\n    constructor(version: number = BEEF_V2) \n    findTxid(txid: string): BeefTx | undefined \n    makeTxidOnly(txid: string): BeefTx | undefined \n    findBump(txid: string): MerklePath | undefined \n    findTransactionForSigning(txid: string): Transaction | undefined \n    findAtomicTransaction(txid: string): Transaction | undefined \n    mergeBump(bump: MerklePath): number \n    mergeRawTx(rawTx: number[], bumpIndex?: number): BeefTx \n    mergeTransaction(tx: Transaction): BeefTx \n    removeExistingTxid(txid: string): void \n    mergeTxidOnly(txid: string): BeefTx \n    mergeBeefTx(btx: BeefTx): BeefTx \n    mergeBeef(beef: number[] | Beef): void \n    isValid(allowTxidOnly?: boolean): boolean \n    async verify(chainTracker: ChainTracker, allowTxidOnly?: boolean): Promise&lt;boolean&gt; \n    verifyValid(allowTxidOnly?: boolean): {\n        valid: boolean;\n        roots: Record&lt;number, string&gt;;\n    } \n    toWriter(writer: Writer): void \n    toBinary(): number[] \n    toBinaryAtomic(txid: string): number[] \n    toHex(): string \n    static fromReader(br: Reader): Beef \n    static fromBinary(bin: number[]): Beef \n    static fromString(s: string, enc: \"hex\" | \"utf8\" | \"base64\" = \"hex\"): Beef \n    sortTxs(): {\n        missingInputs: string[];\n        notValid: string[];\n        valid: string[];\n        withMissingInputs: string[];\n        txidOnly: string[];\n    } \n    clone(): Beef \n    trimKnownTxids(knownTxids: string[]): void \n    getValidTxids(): string[] \n    toLogString(): string \n    addComputedLeaves(): void \n}\n</code></pre> <p>See also: BEEF_V2, BeefTx, ChainTracker, MerklePath, Reader, Transaction, Writer, toHex, verify</p>"},{"location":"reference/transaction/#method-addcomputedleaves","title":"Method addComputedLeaves","text":"<p>In some circumstances it may be helpful for the BUMP MerklePaths to include leaves that can be computed from row zero.</p> <pre><code>addComputedLeaves(): void \n</code></pre>"},{"location":"reference/transaction/#method-clone","title":"Method clone","text":"<p><pre><code>clone(): Beef \n</code></pre> See also: Beef</p> <p>Returns</p> <p>a shallow copy of this beef</p>"},{"location":"reference/transaction/#method-findatomictransaction","title":"Method findAtomicTransaction","text":"<p>Builds the proof tree rooted at a specific <code>Transaction</code>.</p> <p>To succeed, the Beef must contain all the required transaction and merkle path data.</p> <p><pre><code>findAtomicTransaction(txid: string): Transaction | undefined \n</code></pre> See also: Transaction</p> <p>Returns</p> <p>Transaction with input <code>SourceTransaction</code> and <code>MerklePath</code> populated from this Beef.</p> <p>Argument Details</p> <ul> <li>txid</li> <li>The id of the target transaction.</li> </ul>"},{"location":"reference/transaction/#method-findbump","title":"Method findBump","text":"<p><pre><code>findBump(txid: string): MerklePath | undefined \n</code></pre> See also: MerklePath</p> <p>Returns</p> <p><code>MerklePath</code> with level zero hash equal to txid or undefined.</p>"},{"location":"reference/transaction/#method-findtransactionforsigning","title":"Method findTransactionForSigning","text":"<p>Finds a Transaction in this <code>Beef</code> and adds any missing input SourceTransactions from this <code>Beef</code>.</p> <p>The result is suitable for signing.</p> <p><pre><code>findTransactionForSigning(txid: string): Transaction | undefined \n</code></pre> See also: Transaction</p> <p>Returns</p> <p>Transaction with all available input <code>SourceTransaction</code>s from this Beef.</p> <p>Argument Details</p> <ul> <li>txid</li> <li>The id of the target transaction.</li> </ul>"},{"location":"reference/transaction/#method-findtxid","title":"Method findTxid","text":"<p><pre><code>findTxid(txid: string): BeefTx | undefined \n</code></pre> See also: BeefTx</p> <p>Returns</p> <p><code>BeefTx</code> in <code>txs</code> with <code>txid</code>.</p> <p>Argument Details</p> <ul> <li>txid</li> <li>of <code>beefTx</code> to find</li> </ul>"},{"location":"reference/transaction/#method-frombinary","title":"Method fromBinary","text":"<p>Constructs an instance of the Beef class based on the provided binary array</p> <p><pre><code>static fromBinary(bin: number[]): Beef \n</code></pre> See also: Beef</p> <p>Returns</p> <p>An instance of the Beef class constructed from the binary data</p> <p>Argument Details</p> <ul> <li>bin</li> <li>The binary array from which to construct BEEF</li> </ul>"},{"location":"reference/transaction/#method-fromstring","title":"Method fromString","text":"<p>Constructs an instance of the Beef class based on the provided string</p> <p><pre><code>static fromString(s: string, enc: \"hex\" | \"utf8\" | \"base64\" = \"hex\"): Beef \n</code></pre> See also: Beef</p> <p>Returns</p> <p>An instance of the Beef class constructed from the string</p> <p>Argument Details</p> <ul> <li>s</li> <li>The string value from which to construct BEEF</li> <li>enc</li> <li>The encoding of the string value from which BEEF should be constructed</li> </ul>"},{"location":"reference/transaction/#method-getvalidtxids","title":"Method getValidTxids","text":"<pre><code>getValidTxids(): string[] \n</code></pre> <p>Returns</p> <p>array of transaction txids that either have a proof or whose inputs chain back to a proven transaction.</p>"},{"location":"reference/transaction/#method-isvalid","title":"Method isValid","text":"<p>Sorts <code>txs</code> and checks structural validity of beef.</p> <p>Does NOT verify merkle roots.</p> <p>Validity requirements: 1. No 'known' txids, unless <code>allowTxidOnly</code> is true. 2. All transactions have bumps or their inputs chain back to bumps (or are known). 3. Order of transactions satisfies dependencies before dependents. 4. No transactions with duplicate txids.</p> <pre><code>isValid(allowTxidOnly?: boolean): boolean \n</code></pre> <p>Argument Details</p> <ul> <li>allowTxidOnly</li> <li>optional. If true, transaction txid only is assumed valid</li> </ul>"},{"location":"reference/transaction/#method-maketxidonly","title":"Method makeTxidOnly","text":"<p>Replaces <code>BeefTx</code> for this txid with txidOnly.</p> <p>Replacement is done so that a <code>clone()</code> can be updated by this method without affecting the original.</p> <p><pre><code>makeTxidOnly(txid: string): BeefTx | undefined \n</code></pre> See also: BeefTx</p> <p>Returns</p> <p>undefined if txid is unknown.</p>"},{"location":"reference/transaction/#method-mergebump","title":"Method mergeBump","text":"<p>Merge a MerklePath that is assumed to be fully valid.</p> <p><pre><code>mergeBump(bump: MerklePath): number \n</code></pre> See also: MerklePath</p> <p>Returns</p> <p>index of merged bump</p>"},{"location":"reference/transaction/#method-mergerawtx","title":"Method mergeRawTx","text":"<p>Merge a serialized transaction.</p> <p>Checks that a transaction with the same txid hasn't already been merged.</p> <p>Replaces existing transaction with same txid.</p> <p><pre><code>mergeRawTx(rawTx: number[], bumpIndex?: number): BeefTx \n</code></pre> See also: BeefTx</p> <p>Returns</p> <p>txid of rawTx</p> <p>Argument Details</p> <ul> <li>bumpIndex</li> <li>Optional. If a number, must be valid index into bumps array.</li> </ul>"},{"location":"reference/transaction/#method-mergetransaction","title":"Method mergeTransaction","text":"<p>Merge a <code>Transaction</code> and any referenced <code>merklePath</code> and <code>sourceTransaction</code>, recursifely.</p> <p>Replaces existing transaction with same txid.</p> <p>Attempts to match an existing bump to the new transaction.</p> <p><pre><code>mergeTransaction(tx: Transaction): BeefTx \n</code></pre> See also: BeefTx, Transaction</p> <p>Returns</p> <p>txid of tx</p>"},{"location":"reference/transaction/#method-removeexistingtxid","title":"Method removeExistingTxid","text":"<p>Removes an existing transaction from the BEEF, given its TXID</p> <pre><code>removeExistingTxid(txid: string): void \n</code></pre> <p>Argument Details</p> <ul> <li>txid</li> <li>TXID of the transaction to remove</li> </ul>"},{"location":"reference/transaction/#method-sorttxs","title":"Method sortTxs","text":"<p>Sort the <code>txs</code> by input txid dependency order: - Oldest Tx Anchored by Path or txid only - Newer Txs depending on Older parents - Newest Tx</p> <p>with proof (MerklePath) last, longest chain of dependencies first</p> <pre><code>sortTxs(): {\n    missingInputs: string[];\n    notValid: string[];\n    valid: string[];\n    withMissingInputs: string[];\n    txidOnly: string[];\n} \n</code></pre> <p>Returns</p> <p><code>{ missingInputs, notValid, valid, withMissingInputs }</code></p>"},{"location":"reference/transaction/#method-tobinary","title":"Method toBinary","text":"<p>Returns a binary array representing the serialized BEEF</p> <pre><code>toBinary(): number[] \n</code></pre> <p>Returns</p> <p>A binary array representing the BEEF</p>"},{"location":"reference/transaction/#method-tobinaryatomic","title":"Method toBinaryAtomic","text":"<p>Serialize this Beef as AtomicBEEF.</p> <p><code>txid</code> must exist</p> <p>after sorting, if txid is not last txid, creates a clone and removes newer txs</p> <pre><code>toBinaryAtomic(txid: string): number[] \n</code></pre> <p>Returns</p> <p>serialized contents of this Beef with AtomicBEEF prefix.</p>"},{"location":"reference/transaction/#method-tohex","title":"Method toHex","text":"<p>Returns a hex string representing the serialized BEEF</p> <pre><code>toHex(): string \n</code></pre> <p>Returns</p> <p>A hex string representing the BEEF</p>"},{"location":"reference/transaction/#method-tologstring","title":"Method toLogString","text":"<pre><code>toLogString(): string \n</code></pre> <p>Returns</p> <p>Summary of <code>Beef</code> contents as multi-line string.</p>"},{"location":"reference/transaction/#method-towriter","title":"Method toWriter","text":"<p>Serializes this data to <code>writer</code></p> <p><pre><code>toWriter(writer: Writer): void \n</code></pre> See also: Writer</p>"},{"location":"reference/transaction/#method-trimknowntxids","title":"Method trimKnownTxids","text":"<p>Ensure that all the txids in <code>knownTxids</code> are txidOnly</p> <pre><code>trimKnownTxids(knownTxids: string[]): void \n</code></pre>"},{"location":"reference/transaction/#method-verify","title":"Method verify","text":"<p>Sorts <code>txs</code> and confirms validity of transaction data contained in beef by validating structure of this beef and confirming computed merkle roots using <code>chainTracker</code>.</p> <p>Validity requirements: 1. No 'known' txids, unless <code>allowTxidOnly</code> is true. 2. All transactions have bumps or their inputs chain back to bumps (or are known). 3. Order of transactions satisfies dependencies before dependents. 4. No transactions with duplicate txids.</p> <p><pre><code>async verify(chainTracker: ChainTracker, allowTxidOnly?: boolean): Promise&lt;boolean&gt; \n</code></pre> See also: ChainTracker</p> <p>Argument Details</p> <ul> <li>chainTracker</li> <li>Used to verify computed merkle path roots for all bump txids.</li> <li>allowTxidOnly</li> <li>optional. If true, transaction txid is assumed valid</li> </ul>"},{"location":"reference/transaction/#method-verifyvalid","title":"Method verifyValid","text":"<p>Sorts <code>txs</code> and confirms validity of transaction data contained in beef by validating structure of this beef.</p> <p>Returns block heights and merkle root values to be confirmed by a chaintracker.</p> <p>Validity requirements: 1. No 'known' txids, unless <code>allowTxidOnly</code> is true. 2. All transactions have bumps or their inputs chain back to bumps (or are known). 3. Order of transactions satisfies dependencies before dependents. 4. No transactions with duplicate txids.</p> <pre><code>verifyValid(allowTxidOnly?: boolean): {\n    valid: boolean;\n    roots: Record&lt;number, string&gt;;\n} \n</code></pre> <p>Returns</p> <p><code>valid</code> is true iff this Beef is structuraly valid. <code>roots</code> is a record where keys are block heights and values are the corresponding merkle roots to be validated.</p> <p>Argument Details</p> <ul> <li>allowTxidOnly</li> <li>optional. If true, transaction txid is assumed valid</li> </ul> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/transaction/#class-beefparty","title":"Class: BeefParty","text":"<p>Extends <code>Beef</code> that is used to exchange transaction validity data with more than one external party.</p> <p>Use <code>addKnownTxidsForParty</code> to keep track of who knows what to reduce re-transmission of potentially large transactions.</p> <p>Use <code>getTrimmedBeefForParty</code> to obtain a <code>Beef</code> trimmed of transaction validity data known to a specific party.</p> <p>Typical usage scenario:</p> <ol> <li>Query a wallet storage provider for spendable outputs.</li> <li>The provider replies with a Beef validating the returned outputs.</li> <li>Construct a new transaction using some of the queried outputs as inputs, including Beef validating all the inputs.</li> <li>Receive new valid raw transaction after processing and Beef validating change outputs added to original inputs.</li> <li>Return to step 1, continuing to build on old and new spendable outputs.</li> </ol> <p>By default, each Beef is required to be complete and valid: All transactions appear as full serialized bitcoin transactions and each transaction either has a merkle path proof (it has been mined) or all of its input transactions are included.</p> <p>The size and redundancy of these Beefs becomes a problem when chained transaction creation out-paces the block mining rate.</p> <pre><code>export class BeefParty extends Beef {\n    knownTo: Record&lt;string, Record&lt;string, boolean&gt;&gt; = {};\n    constructor(parties?: string[]) \n    isParty(party: string): boolean \n    addParty(party: string): void \n    getKnownTxidsForParty(party: string): string[] \n    getTrimmedBeefForParty(party: string): Beef \n    addKnownTxidsForParty(party: string, knownTxids: string[]): void \n    mergeBeefFromParty(party: string, beef: number[] | Beef): void \n}\n</code></pre> <p>See also: Beef</p>"},{"location":"reference/transaction/#constructor_2","title":"Constructor","text":"<pre><code>constructor(parties?: string[]) \n</code></pre> <p>Argument Details</p> <ul> <li>parties</li> <li>Optional array of initial unique party identifiers.</li> </ul>"},{"location":"reference/transaction/#property-knownto","title":"Property knownTo","text":"<p>keys are party identifiers. values are records of txids with truthy value for which the party already has validity proof.</p> <pre><code>knownTo: Record&lt;string, Record&lt;string, boolean&gt;&gt; = {}\n</code></pre>"},{"location":"reference/transaction/#method-addknowntxidsforparty","title":"Method addKnownTxidsForParty","text":"<p>Make note of additional txids \"known\" to <code>party</code>.</p> <pre><code>addKnownTxidsForParty(party: string, knownTxids: string[]): void \n</code></pre> <p>Argument Details</p> <ul> <li>party</li> <li>unique identifier, added if new.</li> </ul>"},{"location":"reference/transaction/#method-addparty","title":"Method addParty","text":"<p>Adds a new unique party identifier to this <code>BeefParty</code>.</p> <pre><code>addParty(party: string): void \n</code></pre>"},{"location":"reference/transaction/#method-getknowntxidsforparty","title":"Method getKnownTxidsForParty","text":"<pre><code>getKnownTxidsForParty(party: string): string[] \n</code></pre> <p>Returns</p> <p>Array of txids \"known\" to <code>party</code>.</p>"},{"location":"reference/transaction/#method-gettrimmedbeefforparty","title":"Method getTrimmedBeefForParty","text":"<p><pre><code>getTrimmedBeefForParty(party: string): Beef \n</code></pre> See also: Beef</p> <p>Returns</p> <p>trimmed beef of unknown transactions and proofs for <code>party</code></p>"},{"location":"reference/transaction/#method-isparty","title":"Method isParty","text":"<pre><code>isParty(party: string): boolean \n</code></pre> <p>Returns</p> <p><code>true</code> if <code>party</code> has already been added to this <code>BeefParty</code>.</p>"},{"location":"reference/transaction/#method-mergebeeffromparty","title":"Method mergeBeefFromParty","text":"<p>Merge a <code>beef</code> received from a specific <code>party</code>.</p> <p>Updates this <code>BeefParty</code> to track all the txids corresponding to transactions for which <code>party</code> has raw transaction and validity proof data.</p> <p><pre><code>mergeBeefFromParty(party: string, beef: number[] | Beef): void \n</code></pre> See also: Beef</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/transaction/#class-beeftx","title":"Class: BeefTx","text":"<p>A single bitcoin transaction associated with a <code>Beef</code> validity proof set.</p> <p>Simple case is transaction data included directly, either as raw bytes or fully parsed data, or both.</p> <p>Supports 'known' transactions which are represented by just their txid. It is assumed that intended consumer of this beef already has validity proof for such a transaction, which they can merge if necessary to create a valid beef.</p> <pre><code>export default class BeefTx {\n    _bumpIndex?: number;\n    _tx?: Transaction;\n    _rawTx?: number[];\n    _txid?: string;\n    inputTxids: string[] = [];\n    isValid?: boolean = undefined;\n    get bumpIndex(): number | undefined \n    set bumpIndex(v: number | undefined) \n    get hasProof(): boolean \n    get isTxidOnly(): boolean \n    get txid(): string \n    get tx(): Transaction | undefined \n    get rawTx(): number[] | undefined \n    constructor(tx: Transaction | number[] | string, bumpIndex?: number) \n    static fromTx(tx: Transaction, bumpIndex?: number): BeefTx \n    static fromRawTx(rawTx: number[], bumpIndex?: number): BeefTx \n    static fromTxid(txid: string, bumpIndex?: number): BeefTx \n    toWriter(writer: Writer, version: number): void \n    static fromReader(br: Reader, version: number): BeefTx \n}\n</code></pre> <p>See also: Reader, Transaction, Writer</p>"},{"location":"reference/transaction/#constructor_3","title":"Constructor","text":"<p><pre><code>constructor(tx: Transaction | number[] | string, bumpIndex?: number) \n</code></pre> See also: Transaction</p> <p>Argument Details</p> <ul> <li>tx</li> <li>If string, must be a valid txid. If <code>number[]</code> must be a valid serialized transaction.</li> <li>bumpIndex</li> <li>If transaction already has a proof in the beef to which it will be added.</li> </ul>"},{"location":"reference/transaction/#property-isvalid","title":"Property isValid","text":"<p>true if <code>hasProof</code> or all inputs chain to <code>hasProof</code>.</p> <p>Typically set by sorting transactions by proven dependency chains.</p> <pre><code>isValid?: boolean = undefined\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/transaction/#class-fetchhttpclient","title":"Class: FetchHttpClient","text":"<p>Adapter for Node Https module to be used as HttpClient</p> <pre><code>export class FetchHttpClient implements HttpClient {\n    constructor(private readonly fetch: Fetch) \n    async request&lt;D&gt;(url: string, options: HttpClientRequestOptions): Promise&lt;HttpClientResponse&lt;D&gt;&gt; \n}\n</code></pre> <p>See also: Fetch, HttpClient, HttpClientRequestOptions, HttpClientResponse</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/transaction/#class-livepolicy","title":"Class: LivePolicy","text":"<p>Represents a live fee policy that fetches current rates from ARC GorillaPool. Extends SatoshisPerKilobyte to reuse transaction size calculation logic.</p> <pre><code>export default class LivePolicy extends SatoshisPerKilobyte {\n    constructor(cacheValidityMs: number = 5 * 60 * 1000) \n    static getInstance(cacheValidityMs: number = 5 * 60 * 1000): LivePolicy \n    async computeFee(tx: Transaction): Promise&lt;number&gt; \n}\n</code></pre> <p>See also: SatoshisPerKilobyte, Transaction</p>"},{"location":"reference/transaction/#constructor_4","title":"Constructor","text":"<p>Constructs an instance of the live policy fee model.</p> <pre><code>constructor(cacheValidityMs: number = 5 * 60 * 1000) \n</code></pre> <p>Argument Details</p> <ul> <li>cacheValidityMs</li> <li>How long to cache the fee rate in milliseconds (default: 5 minutes)</li> </ul>"},{"location":"reference/transaction/#method-computefee","title":"Method computeFee","text":"<p>Computes the fee for a given transaction using the current live rate. Overrides the parent method to use dynamic rate fetching.</p> <p><pre><code>async computeFee(tx: Transaction): Promise&lt;number&gt; \n</code></pre> See also: Transaction</p> <p>Returns</p> <p>The fee in satoshis for the transaction.</p> <p>Argument Details</p> <ul> <li>tx</li> <li>The transaction for which a fee is to be computed.</li> </ul>"},{"location":"reference/transaction/#method-getinstance","title":"Method getInstance","text":"<p>Gets the singleton instance of LivePolicy to ensure cache sharing across the application.</p> <p><pre><code>static getInstance(cacheValidityMs: number = 5 * 60 * 1000): LivePolicy \n</code></pre> See also: LivePolicy</p> <p>Returns</p> <p>The singleton LivePolicy instance</p> <p>Argument Details</p> <ul> <li>cacheValidityMs</li> <li>How long to cache the fee rate in milliseconds (default: 5 minutes)</li> </ul> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/transaction/#class-merklepath","title":"Class: MerklePath","text":"<p>Represents a Merkle Path, which is used to provide a compact proof of inclusion for a transaction in a block. This class encapsulates all the details required for creating and verifying Merkle Proofs.</p> <p>Example</p> <pre><code>// Creating and verifying a Merkle Path\nconst merklePath = MerklePath.fromHex('...');\nconst isValid = merklePath.verify(txid, chainTracker);\n</code></pre> <pre><code>export default class MerklePath {\n    blockHeight: number;\n    path: Array&lt;Array&lt;{\n        offset: number;\n        hash?: string;\n        txid?: boolean;\n        duplicate?: boolean;\n    }&gt;&gt;;\n    static fromHex(hex: string): MerklePath \n    static fromReader(reader: Reader, legalOffsetsOnly: boolean = true): MerklePath \n    static fromBinary(bump: number[]): MerklePath \n    static fromCoinbaseTxidAndHeight(txid: string, height: number): MerklePath \n    constructor(blockHeight: number, path: Array&lt;Array&lt;{\n        offset: number;\n        hash?: string;\n        txid?: boolean;\n        duplicate?: boolean;\n    }&gt;&gt;, legalOffsetsOnly: boolean = true) \n    toBinary(): number[] \n    toHex(): string \n    computeRoot(txid?: string): string \n    findOrComputeLeaf(height: number, offset: number): MerklePathLeaf | undefined \n    async verify(txid: string, chainTracker: ChainTracker): Promise&lt;boolean&gt; \n    combine(other: MerklePath): void \n    trim(): void \n}\n</code></pre> <p>See also: ChainTracker, MerklePathLeaf, Reader, toHex, verify</p>"},{"location":"reference/transaction/#method-combine","title":"Method combine","text":"<p>Combines this MerklePath with another to create a compound proof.</p> <p><pre><code>combine(other: MerklePath): void \n</code></pre> See also: MerklePath</p> <p>Argument Details</p> <ul> <li>other</li> <li>Another MerklePath to combine with this path.</li> </ul> <p>Throws</p> <ul> <li>If the paths have different block heights or roots.</li> </ul>"},{"location":"reference/transaction/#method-computeroot","title":"Method computeRoot","text":"<p>Computes the Merkle root from the provided transaction ID.</p> <pre><code>computeRoot(txid?: string): string \n</code></pre> <p>Returns</p> <ul> <li>The computed Merkle root as a hexadecimal string.</li> </ul> <p>Argument Details</p> <ul> <li>txid</li> <li>The transaction ID to compute the Merkle root for. If not provided, the root will be computed from an unspecified branch, and not all branches will be validated!</li> </ul> <p>Throws</p> <ul> <li>If the transaction ID is not part of the Merkle Path.</li> </ul>"},{"location":"reference/transaction/#method-findorcomputeleaf","title":"Method findOrComputeLeaf","text":"<p>Find leaf with <code>offset</code> at <code>height</code> or compute from level below, recursively.</p> <p>Does not add computed leaves to path.</p> <p><pre><code>findOrComputeLeaf(height: number, offset: number): MerklePathLeaf | undefined \n</code></pre> See also: MerklePathLeaf</p>"},{"location":"reference/transaction/#method-frombinary_1","title":"Method fromBinary","text":"<p>Creates a MerklePath instance from a binary array.</p> <p><pre><code>static fromBinary(bump: number[]): MerklePath \n</code></pre> See also: MerklePath</p> <p>Returns</p> <ul> <li>A new MerklePath instance.</li> </ul> <p>Argument Details</p> <ul> <li>bump</li> <li>The binary array representation of the Merkle Path.</li> </ul>"},{"location":"reference/transaction/#method-fromcoinbasetxidandheight","title":"Method fromCoinbaseTxidAndHeight","text":"<p><pre><code>static fromCoinbaseTxidAndHeight(txid: string, height: number): MerklePath \n</code></pre> See also: MerklePath</p> <p>Returns</p> <ul> <li>A new MerklePath instance which assumes the tx is in a block with no other transactions.</li> </ul> <p>Argument Details</p> <ul> <li>txid</li> <li>The coinbase txid.</li> <li>height</li> <li>The height of the block.</li> </ul>"},{"location":"reference/transaction/#method-fromhex","title":"Method fromHex","text":"<p>Creates a MerklePath instance from a hexadecimal string.</p> <p><pre><code>static fromHex(hex: string): MerklePath \n</code></pre> See also: MerklePath</p> <p>Returns</p> <ul> <li>A new MerklePath instance.</li> </ul> <p>Argument Details</p> <ul> <li>hex</li> <li>The hexadecimal string representation of the Merkle Path.</li> </ul>"},{"location":"reference/transaction/#method-tobinary_1","title":"Method toBinary","text":"<p>Converts the MerklePath to a binary array format.</p> <pre><code>toBinary(): number[] \n</code></pre> <p>Returns</p> <ul> <li>The binary array representation of the Merkle Path.</li> </ul>"},{"location":"reference/transaction/#method-tohex_1","title":"Method toHex","text":"<p>Converts the MerklePath to a hexadecimal string format.</p> <pre><code>toHex(): string \n</code></pre> <p>Returns</p> <ul> <li>The hexadecimal string representation of the Merkle Path.</li> </ul>"},{"location":"reference/transaction/#method-trim","title":"Method trim","text":"<p>Remove all internal nodes that are not required by level zero txid nodes. Assumes that at least all required nodes are present. Leaves all levels sorted by increasing offset.</p> <pre><code>trim(): void \n</code></pre>"},{"location":"reference/transaction/#method-verify_1","title":"Method verify","text":"<p>Verifies if the given transaction ID is part of the Merkle tree at the specified block height.</p> <p><pre><code>async verify(txid: string, chainTracker: ChainTracker): Promise&lt;boolean&gt; \n</code></pre> See also: ChainTracker</p> <p>Returns</p> <ul> <li>True if the transaction ID is valid within the Merkle Path at the specified block height.</li> </ul> <p>Argument Details</p> <ul> <li>txid</li> <li>The transaction ID to verify.</li> <li>chainTracker</li> <li>The ChainTracker instance used to verify the Merkle root.</li> </ul> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/transaction/#class-nodejshttpclient","title":"Class: NodejsHttpClient","text":"<p>Adapter for Node Https module to be used as HttpClient</p> <pre><code>export class NodejsHttpClient implements HttpClient {\n    constructor(private readonly https: HttpsNodejs) \n    async request(url: string, requestOptions: HttpClientRequestOptions): Promise&lt;HttpClientResponse&gt; \n}\n</code></pre> <p>See also: HttpClient, HttpClientRequestOptions, HttpClientResponse, HttpsNodejs</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/transaction/#class-satoshisperkilobyte","title":"Class: SatoshisPerKilobyte","text":"<p>Represents the \"satoshis per kilobyte\" transaction fee model.</p> <pre><code>export default class SatoshisPerKilobyte implements FeeModel {\n    value: number;\n    constructor(value: number) \n    async computeFee(tx: Transaction): Promise&lt;number&gt; \n}\n</code></pre> <p>See also: FeeModel, Transaction</p>"},{"location":"reference/transaction/#constructor_5","title":"Constructor","text":"<p>Constructs an instance of the sat/kb fee model.</p> <pre><code>constructor(value: number) \n</code></pre> <p>Argument Details</p> <ul> <li>value</li> <li>The number of satoshis per kilobyte to charge as a fee.</li> </ul>"},{"location":"reference/transaction/#method-computefee_1","title":"Method computeFee","text":"<p>Computes the fee for a given transaction.</p> <p><pre><code>async computeFee(tx: Transaction): Promise&lt;number&gt; \n</code></pre> See also: Transaction</p> <p>Returns</p> <p>The fee in satoshis for the transaction, as a BigNumber.</p> <p>Argument Details</p> <ul> <li>tx</li> <li>The transaction for which a fee is to be computed.</li> </ul> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/transaction/#class-transaction","title":"Class: Transaction","text":"<p>Represents a complete Bitcoin transaction. This class encapsulates all the details required for creating, signing, and processing a Bitcoin transaction, including inputs, outputs, and various transaction-related methods.</p> <p>Example</p> <pre><code>// Creating a new transaction\nlet tx = new Transaction();\ntx.addInput(...);\ntx.addOutput(...);\nawait tx.fee();\nawait tx.sign();\nawait tx.broadcast();\n</code></pre> <pre><code>export default class Transaction {\n    version: number;\n    inputs: TransactionInput[];\n    outputs: TransactionOutput[];\n    lockTime: number;\n    metadata: Record&lt;string, any&gt;;\n    merklePath?: MerklePath;\n    static fromBEEF(beef: number[], txid?: string): Transaction \n    static fromAtomicBEEF(beef: number[]): Transaction \n    static fromEF(ef: number[]): Transaction \n    static parseScriptOffsets(bin: number[]): {\n        inputs: Array&lt;{\n            vin: number;\n            offset: number;\n            length: number;\n        }&gt;;\n        outputs: Array&lt;{\n            vout: number;\n            offset: number;\n            length: number;\n        }&gt;;\n    } \n    static fromReader(br: Reader): Transaction \n    static fromBinary(bin: number[]): Transaction \n    static fromHex(hex: string): Transaction \n    static fromHexEF(hex: string): Transaction \n    static fromHexBEEF(hex: string, txid?: string): Transaction \n    constructor(version: number = 1, inputs: TransactionInput[] = [], outputs: TransactionOutput[] = [], lockTime: number = 0, metadata: Record&lt;string, any&gt; = new Map(), merklePath?: MerklePath) \n    addInput(input: TransactionInput): void \n    addOutput(output: TransactionOutput): void \n    addP2PKHOutput(address: number[] | string, satoshis?: number): void \n    updateMetadata(metadata: Record&lt;string, any&gt;): void \n    async fee(modelOrFee: FeeModel | number = LivePolicy.getInstance(), changeDistribution: \"equal\" | \"random\" = \"equal\"): Promise&lt;void&gt; \n    getFee(): number \n    async sign(): Promise&lt;void&gt; \n    async broadcast(broadcaster: Broadcaster = defaultBroadcaster()): Promise&lt;BroadcastResponse | BroadcastFailure&gt; \n    toBinary(): number[] \n    toEF(): number[] \n    toHexEF(): string \n    toHex(): string \n    toHexBEEF(): string \n    toHexAtomicBEEF(): string \n    hash(enc?: \"hex\"): number[] | string \n    id(): number[];\n    id(enc: \"hex\"): string;\n    id(enc?: \"hex\"): number[] | string \n    async verify(chainTracker: ChainTracker | \"scripts only\" = defaultChainTracker(), feeModel?: FeeModel, memoryLimit?: number): Promise&lt;boolean&gt; \n    toBEEF(allowPartial?: boolean): number[] \n    toAtomicBEEF(allowPartial?: boolean): number[] \n}\n</code></pre> <p>See also: BroadcastFailure, BroadcastResponse, Broadcaster, ChainTracker, FeeModel, LivePolicy, MerklePath, Reader, TransactionInput, TransactionOutput, defaultBroadcaster, defaultChainTracker, sign, toHex, verify</p>"},{"location":"reference/transaction/#method-addinput","title":"Method addInput","text":"<p>Adds a new input to the transaction.</p> <p><pre><code>addInput(input: TransactionInput): void \n</code></pre> See also: TransactionInput</p> <p>Argument Details</p> <ul> <li>input</li> <li>The TransactionInput object to add to the transaction.</li> </ul> <p>Throws</p> <ul> <li>If the input does not have a sourceTXID or sourceTransaction defined.</li> </ul>"},{"location":"reference/transaction/#method-addoutput","title":"Method addOutput","text":"<p>Adds a new output to the transaction.</p> <p><pre><code>addOutput(output: TransactionOutput): void \n</code></pre> See also: TransactionOutput</p> <p>Argument Details</p> <ul> <li>output</li> <li>The TransactionOutput object to add to the transaction.</li> </ul>"},{"location":"reference/transaction/#method-addp2pkhoutput","title":"Method addP2PKHOutput","text":"<p>Adds a new P2PKH output to the transaction.</p> <pre><code>addP2PKHOutput(address: number[] | string, satoshis?: number): void \n</code></pre> <p>Argument Details</p> <ul> <li>address</li> <li>The P2PKH address of the output.</li> <li>satoshis</li> <li>The number of satoshis to send to the address - if not provided, the output is considered a change output.</li> </ul>"},{"location":"reference/transaction/#method-broadcast_1","title":"Method broadcast","text":"<p>Broadcasts a transaction.</p> <p><pre><code>async broadcast(broadcaster: Broadcaster = defaultBroadcaster()): Promise&lt;BroadcastResponse | BroadcastFailure&gt; \n</code></pre> See also: BroadcastFailure, BroadcastResponse, Broadcaster, defaultBroadcaster</p> <p>Returns</p> <p>A BroadcastResponse or BroadcastFailure from the Broadcaster</p> <p>Argument Details</p> <ul> <li>broadcaster</li> <li>The Broadcaster instance wwhere the transaction will be sent</li> </ul>"},{"location":"reference/transaction/#method-fee","title":"Method fee","text":"<p>Computes fees prior to signing. If no fee model is provided, uses a LivePolicy fee model that fetches current rates from ARC. If fee is a number, the transaction uses that value as fee.</p> <p><pre><code>async fee(modelOrFee: FeeModel | number = LivePolicy.getInstance(), changeDistribution: \"equal\" | \"random\" = \"equal\"): Promise&lt;void&gt; \n</code></pre> See also: FeeModel, LivePolicy</p> <p>Argument Details</p> <ul> <li>modelOrFee</li> <li>The initialized fee model to use or fixed fee for the transaction</li> <li>changeDistribution</li> <li>Specifies how the change should be distributed amongst the change outputs</li> </ul>"},{"location":"reference/transaction/#method-fromatomicbeef","title":"Method fromAtomicBEEF","text":"<p>Creates a new transaction from an Atomic BEEF (BRC-95) structure. Extracts the subject transaction and supporting merkle path and source transactions contained in the BEEF data</p> <p><pre><code>static fromAtomicBEEF(beef: number[]): Transaction \n</code></pre> See also: Transaction</p> <p>Returns</p> <p>The subject transaction, linked to its associated inputs populated with merkle paths.</p> <p>Argument Details</p> <ul> <li>beef</li> <li>A binary representation of an Atomic BEEF structure.</li> </ul>"},{"location":"reference/transaction/#method-frombeef","title":"Method fromBEEF","text":"<p>Creates a new transaction, linked to its inputs and their associated merkle paths, from a BEEF V1, V2 or Atomic. Optionally, you can provide a specific TXID to retrieve a particular transaction from the BEEF data. If the TXID is provided but not found in the BEEF data, an error will be thrown. If no TXID is provided, the last transaction in the BEEF data is returned, or the atomic txid.</p> <p><pre><code>static fromBEEF(beef: number[], txid?: string): Transaction \n</code></pre> See also: Transaction</p> <p>Returns</p> <p>An anchored transaction, linked to its associated inputs populated with merkle paths.</p> <p>Argument Details</p> <ul> <li>beef</li> <li>A binary representation of transactions in BEEF format.</li> <li>txid</li> <li>Optional TXID of the transaction to retrieve from the BEEF data.</li> </ul>"},{"location":"reference/transaction/#method-frombinary_2","title":"Method fromBinary","text":"<p>Creates a Transaction instance from a binary array.</p> <p><pre><code>static fromBinary(bin: number[]): Transaction \n</code></pre> See also: Transaction</p> <p>Returns</p> <ul> <li>A new Transaction instance.</li> </ul> <p>Argument Details</p> <ul> <li>bin</li> <li>The binary array representation of the transaction.</li> </ul>"},{"location":"reference/transaction/#method-fromef","title":"Method fromEF","text":"<p>Creates a new transaction, linked to its inputs and their associated merkle paths, from a EF (BRC-30) structure.</p> <p><pre><code>static fromEF(ef: number[]): Transaction \n</code></pre> See also: Transaction</p> <p>Returns</p> <p>An extended transaction, linked to its associated inputs by locking script and satoshis amounts only.</p> <p>Argument Details</p> <ul> <li>ef</li> <li>A binary representation of a transaction in EF format.</li> </ul>"},{"location":"reference/transaction/#method-fromhex_1","title":"Method fromHex","text":"<p>Creates a Transaction instance from a hexadecimal string.</p> <p><pre><code>static fromHex(hex: string): Transaction \n</code></pre> See also: Transaction</p> <p>Returns</p> <ul> <li>A new Transaction instance.</li> </ul> <p>Argument Details</p> <ul> <li>hex</li> <li>The hexadecimal string representation of the transaction.</li> </ul>"},{"location":"reference/transaction/#method-fromhexbeef","title":"Method fromHexBEEF","text":"<p>Creates a Transaction instance from a hexadecimal string encoded BEEF. Optionally, you can provide a specific TXID to retrieve a particular transaction from the BEEF data. If the TXID is provided but not found in the BEEF data, an error will be thrown. If no TXID is provided, the last transaction in the BEEF data is returned.</p> <p><pre><code>static fromHexBEEF(hex: string, txid?: string): Transaction \n</code></pre> See also: Transaction</p> <p>Returns</p> <ul> <li>A new Transaction instance.</li> </ul> <p>Argument Details</p> <ul> <li>hex</li> <li>The hexadecimal string representation of the transaction BEEF.</li> <li>txid</li> <li>Optional TXID of the transaction to retrieve from the BEEF data.</li> </ul>"},{"location":"reference/transaction/#method-fromhexef","title":"Method fromHexEF","text":"<p>Creates a Transaction instance from a hexadecimal string encoded EF.</p> <p><pre><code>static fromHexEF(hex: string): Transaction \n</code></pre> See also: Transaction</p> <p>Returns</p> <ul> <li>A new Transaction instance.</li> </ul> <p>Argument Details</p> <ul> <li>hex</li> <li>The hexadecimal string representation of the transaction EF.</li> </ul>"},{"location":"reference/transaction/#method-getfee","title":"Method getFee","text":"<p>Utility method that returns the current fee based on inputs and outputs</p> <pre><code>getFee(): number \n</code></pre> <p>Returns</p> <p>The current transaction fee</p>"},{"location":"reference/transaction/#method-hash","title":"Method hash","text":"<p>Calculates the transaction's hash.</p> <pre><code>hash(enc?: \"hex\"): number[] | string \n</code></pre> <p>Returns</p> <ul> <li>The hash of the transaction in the specified format.</li> </ul> <p>Argument Details</p> <ul> <li>enc</li> <li>The encoding to use for the hash. If 'hex', returns a hexadecimal string; otherwise returns a binary array.</li> </ul>"},{"location":"reference/transaction/#method-id","title":"Method id","text":"<p>Calculates the transaction's ID in binary array.</p> <pre><code>id(): number[]\n</code></pre> <p>Returns</p> <ul> <li>The ID of the transaction in the binary array format.</li> </ul>"},{"location":"reference/transaction/#method-id_1","title":"Method id","text":"<p>Calculates the transaction's ID in hexadecimal format.</p> <pre><code>id(enc: \"hex\"): string\n</code></pre> <p>Returns</p> <ul> <li>The ID of the transaction in the hex format.</li> </ul> <p>Argument Details</p> <ul> <li>enc</li> <li>The encoding to use for the ID. If 'hex', returns a hexadecimal string.</li> </ul>"},{"location":"reference/transaction/#method-id_2","title":"Method id","text":"<p>Calculates the transaction's ID.</p> <pre><code>id(enc?: \"hex\"): number[] | string \n</code></pre> <p>Returns</p> <ul> <li>The ID of the transaction in the specified format.</li> </ul> <p>Argument Details</p> <ul> <li>enc</li> <li>The encoding to use for the ID. If 'hex', returns a hexadecimal string; otherwise returns a binary array.</li> </ul>"},{"location":"reference/transaction/#method-parsescriptoffsets","title":"Method parseScriptOffsets","text":"<p>Since the validation of blockchain data is atomically transaction data validation, any application seeking to validate data in output scripts must store the entire transaction as well. Since the transaction data includes the output script data, saving a second copy of potentially large scripts can bloat application storage requirements.</p> <p>This function efficiently parses binary transaction data to determine the offsets and lengths of each script. This supports the efficient retreival of script data from transaction data.</p> <pre><code>static parseScriptOffsets(bin: number[]): {\n    inputs: Array&lt;{\n        vin: number;\n        offset: number;\n        length: number;\n    }&gt;;\n    outputs: Array&lt;{\n        vout: number;\n        offset: number;\n        length: number;\n    }&gt;;\n} \n</code></pre> <p>Returns</p> <p>inputs: { vin: number, offset: number, length: number }[] outputs: { vout: number, offset: number, length: number }[] }</p> <p>Argument Details</p> <ul> <li>bin</li> <li>binary transaction data</li> </ul>"},{"location":"reference/transaction/#method-sign","title":"Method sign","text":"<p>Signs a transaction, hydrating all its unlocking scripts based on the provided script templates where they are available.</p> <pre><code>async sign(): Promise&lt;void&gt; \n</code></pre>"},{"location":"reference/transaction/#method-toatomicbeef","title":"Method toAtomicBEEF","text":"<p>Serializes this transaction and its inputs into the Atomic BEEF (BRC-95) format. The Atomic BEEF format starts with a 4-byte prefix <code>0x01010101</code>, followed by the TXID of the subject transaction, and then the BEEF data containing only the subject transaction and its dependencies. This format ensures that the BEEF structure is atomic and contains no unrelated transactions.</p> <pre><code>toAtomicBEEF(allowPartial?: boolean): number[] \n</code></pre> <p>Returns</p> <ul> <li>The serialized Atomic BEEF structure.</li> </ul> <p>Argument Details</p> <ul> <li>allowPartial</li> <li>If true, error will not be thrown if there are any missing sourceTransactions.</li> </ul> <p>Throws</p> <p>Error if there are any missing sourceTransactions unless <code>allowPartial</code> is true.</p>"},{"location":"reference/transaction/#method-tobeef","title":"Method toBEEF","text":"<p>Serializes this transaction, together with its inputs and the respective merkle proofs, into the BEEF (BRC-62) format. This enables efficient verification of its compliance with the rules of SPV.</p> <pre><code>toBEEF(allowPartial?: boolean): number[] \n</code></pre> <p>Returns</p> <p>The serialized BEEF structure</p> <p>Argument Details</p> <ul> <li>allowPartial</li> <li>If true, error will not be thrown if there are any missing sourceTransactions.</li> </ul> <p>Throws</p> <p>Error if there are any missing sourceTransactions unless <code>allowPartial</code> is true.</p>"},{"location":"reference/transaction/#method-tobinary_2","title":"Method toBinary","text":"<p>Converts the transaction to a binary array format.</p> <pre><code>toBinary(): number[] \n</code></pre> <p>Returns</p> <ul> <li>The binary array representation of the transaction.</li> </ul>"},{"location":"reference/transaction/#method-toef","title":"Method toEF","text":"<p>Converts the transaction to a BRC-30 EF format.</p> <pre><code>toEF(): number[] \n</code></pre> <p>Returns</p> <ul> <li>The BRC-30 EF representation of the transaction.</li> </ul>"},{"location":"reference/transaction/#method-tohex_2","title":"Method toHex","text":"<p>Converts the transaction to a hexadecimal string format.</p> <pre><code>toHex(): string \n</code></pre> <p>Returns</p> <ul> <li>The hexadecimal string representation of the transaction.</li> </ul>"},{"location":"reference/transaction/#method-tohexatomicbeef","title":"Method toHexAtomicBEEF","text":"<p>Converts the transaction to a hexadecimal string Atomic BEEF.</p> <pre><code>toHexAtomicBEEF(): string \n</code></pre> <p>Returns</p> <ul> <li>The hexadecimal string representation of the transaction Atomic BEEF.</li> </ul>"},{"location":"reference/transaction/#method-tohexbeef","title":"Method toHexBEEF","text":"<p>Converts the transaction to a hexadecimal string BEEF.</p> <pre><code>toHexBEEF(): string \n</code></pre> <p>Returns</p> <ul> <li>The hexadecimal string representation of the transaction BEEF.</li> </ul>"},{"location":"reference/transaction/#method-tohexef","title":"Method toHexEF","text":"<p>Converts the transaction to a hexadecimal string EF.</p> <pre><code>toHexEF(): string \n</code></pre> <p>Returns</p> <ul> <li>The hexadecimal string representation of the transaction EF.</li> </ul>"},{"location":"reference/transaction/#method-updatemetadata","title":"Method updateMetadata","text":"<p>Updates the transaction's metadata.</p> <pre><code>updateMetadata(metadata: Record&lt;string, any&gt;): void \n</code></pre> <p>Argument Details</p> <ul> <li>metadata</li> <li>The metadata object to merge into the existing metadata.</li> </ul>"},{"location":"reference/transaction/#method-verify_2","title":"Method verify","text":"<p>Verifies the legitimacy of the Bitcoin transaction according to the rules of SPV by ensuring all the input transactions link back to valid block headers, the chain of spends for all inputs are valid, and the sum of inputs is not less than the sum of outputs.</p> <p><pre><code>async verify(chainTracker: ChainTracker | \"scripts only\" = defaultChainTracker(), feeModel?: FeeModel, memoryLimit?: number): Promise&lt;boolean&gt; \n</code></pre> See also: ChainTracker, FeeModel, defaultChainTracker</p> <p>Returns</p> <p>Whether the transaction is valid according to the rules of SPV.</p> <p>Argument Details</p> <ul> <li>chainTracker</li> <li>An instance of ChainTracker, a Bitcoin block header tracker. If the value is set to 'scripts only', headers will not be verified. If not provided then the default chain tracker will be used.</li> <li>feeModel</li> <li>An instance of FeeModel, a fee model to use for fee calculation. If not provided then the default fee model will be used.</li> <li>memoryLimit</li> <li>The maximum memory in bytes usage allowed for script evaluation. If not provided then the default memory limit will be used.</li> </ul> <p>Example</p> <pre><code>tx.verify(new WhatsOnChain(), LivePolicy.getInstance())\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/transaction/#class-whatsonchain","title":"Class: WhatsOnChain","text":"<p>Represents a chain tracker based on What's On Chain .</p> <pre><code>export default class WhatsOnChain implements ChainTracker {\n    readonly network: string;\n    readonly apiKey: string;\n    protected readonly URL: string;\n    protected readonly httpClient: HttpClient;\n    constructor(network: \"main\" | \"test\" | \"stn\" = \"main\", config: WhatsOnChainConfig = {}) \n    async isValidRootForHeight(root: string, height: number): Promise&lt;boolean&gt; \n    async currentHeight(): Promise&lt;number&gt; \n    protected getHttpHeaders(): Record&lt;string, string&gt; \n}\n</code></pre> <p>See also: ChainTracker, HttpClient, WhatsOnChainConfig</p>"},{"location":"reference/transaction/#constructor_6","title":"Constructor","text":"<p>Constructs an instance of the WhatsOnChain ChainTracker.</p> <p><pre><code>constructor(network: \"main\" | \"test\" | \"stn\" = \"main\", config: WhatsOnChainConfig = {}) \n</code></pre> See also: WhatsOnChainConfig</p> <p>Argument Details</p> <ul> <li>network</li> <li>The BSV network to use when calling the WhatsOnChain API.</li> <li>config</li> <li>Configuration options for the WhatsOnChain ChainTracker.</li> </ul> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/transaction/#functions","title":"Functions","text":"defaultBroadcaster defaultChainTracker defaultHttpClient isBroadcastFailure isBroadcastResponse <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/transaction/#function-defaultbroadcaster","title":"Function: defaultBroadcaster","text":"<pre><code>export function defaultBroadcaster(isTestnet: boolean = false, config: ArcConfig = {}): Broadcaster \n</code></pre> <p>See also: ArcConfig, Broadcaster</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/transaction/#function-defaultchaintracker","title":"Function: defaultChainTracker","text":"<pre><code>export function defaultChainTracker(): ChainTracker \n</code></pre> <p>See also: ChainTracker</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/transaction/#function-defaulthttpclient","title":"Function: defaultHttpClient","text":"<p>Returns a default HttpClient implementation based on the environment that it is run on. This method will attempt to use <code>window.fetch</code> if available (in browser environments). If running in a Node environment, it falls back to using the Node <code>https</code> module</p> <pre><code>export function defaultHttpClient(): HttpClient \n</code></pre> <p>See also: HttpClient</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/transaction/#function-isbroadcastfailure","title":"Function: isBroadcastFailure","text":"<p>Convenience type guard for response from <code>Broadcaster.broadcast</code></p> <pre><code>export function isBroadcastFailure(r: BroadcastResponse | BroadcastFailure): r is BroadcastFailure \n</code></pre> <p>See also: BroadcastFailure, BroadcastResponse</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/transaction/#function-isbroadcastresponse","title":"Function: isBroadcastResponse","text":"<p>Convenience type guard for response from <code>Broadcaster.broadcast</code></p> <pre><code>export function isBroadcastResponse(r: BroadcastResponse | BroadcastFailure): r is BroadcastResponse \n</code></pre> <p>See also: BroadcastFailure, BroadcastResponse</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/transaction/#types","title":"Types","text":"Fetch HttpClientResponse <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/transaction/#type-fetch","title":"Type: Fetch","text":"<p>fetch function interface limited to options needed by ts-sdk</p> <p>Makes a request to the server.</p> <pre><code>export type Fetch = (url: string, options: FetchOptions) =&gt; Promise&lt;Response&gt;\n</code></pre> <p>See also: FetchOptions</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/transaction/#type-httpclientresponse","title":"Type: HttpClientResponse","text":"<p>An interface for the response returned by the request method.</p> <pre><code>export type HttpClientResponse&lt;T = any&gt; = {\n    data: T;\n    status: number;\n    statusText: string;\n    ok: true;\n} | {\n    data: any;\n    status: number;\n    statusText: string;\n    ok: false;\n}\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/transaction/#enums","title":"Enums","text":""},{"location":"reference/transaction/#enum-tx_data_format","title":"Enum: TX_DATA_FORMAT","text":"<pre><code>export enum TX_DATA_FORMAT {\n    RAWTX = 0,\n    RAWTX_AND_BUMP_INDEX = 1,\n    TXID_ONLY = 2\n}\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/transaction/#variables","title":"Variables","text":"ATOMIC_BEEF BEEF_V1 BEEF_V2 <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/transaction/#variable-atomic_beef","title":"Variable: ATOMIC_BEEF","text":"<pre><code>ATOMIC_BEEF = 16843009\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/transaction/#variable-beef_v1","title":"Variable: BEEF_V1","text":"<pre><code>BEEF_V1 = 4022206465\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/transaction/#variable-beef_v2","title":"Variable: BEEF_V2","text":"<pre><code>BEEF_V2 = 4022206466\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/","title":"API","text":"<p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interfaces","title":"Interfaces","text":"AbortActionArgs IdentityCertificate SignActionArgs AbortActionResult IdentityCertifier SignActionOptions AcquireCertificateArgs InternalizeActionArgs SignActionResult AuthenticatedResult InternalizeActionResult SignActionSpend BasketInsertion InternalizeOutput SignableTransaction CertificateResult KeyDeriverApi VerifyHmacArgs CreateActionArgs KeyLinkageResult VerifyHmacResult CreateActionInput ListActionsArgs VerifySignatureArgs CreateActionOptions ListActionsResult VerifySignatureResult CreateActionOutput ListCertificatesArgs WalletAction CreateActionResult ListCertificatesResult WalletActionInput CreateHmacArgs ListOutputsArgs WalletActionOutput CreateHmacResult ListOutputsResult WalletCertificate CreateSignatureArgs ProveCertificateArgs WalletDecryptArgs CreateSignatureResult ProveCertificateResult WalletDecryptResult DiscoverByAttributesArgs RelinquishCertificateArgs WalletEncryptArgs DiscoverByIdentityKeyArgs RelinquishCertificateResult WalletEncryptResult DiscoverCertificatesResult RelinquishOutputArgs WalletEncryptionArgs GetHeaderArgs RelinquishOutputResult WalletErrorObject GetHeaderResult RevealCounterpartyKeyLinkageArgs WalletInterface GetHeightResult RevealCounterpartyKeyLinkageResult WalletOutput GetNetworkResult RevealSpecificKeyLinkageArgs WalletPayment GetPublicKeyArgs RevealSpecificKeyLinkageResult WalletWire GetPublicKeyResult ReviewActionResult GetVersionResult SendWithResult <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-abortactionargs","title":"Interface: AbortActionArgs","text":"<pre><code>export interface AbortActionArgs {\n    reference: Base64String;\n}\n</code></pre> <p>See also: Base64String</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-abortactionresult","title":"Interface: AbortActionResult","text":"<pre><code>export interface AbortActionResult {\n    aborted: true;\n}\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-acquirecertificateargs","title":"Interface: AcquireCertificateArgs","text":"<pre><code>export interface AcquireCertificateArgs {\n    type: Base64String;\n    certifier: PubKeyHex;\n    acquisitionProtocol: AcquisitionProtocol;\n    fields: Record&lt;CertificateFieldNameUnder50Bytes, string&gt;;\n    serialNumber?: Base64String;\n    revocationOutpoint?: OutpointString;\n    signature?: HexString;\n    certifierUrl?: string;\n    keyringRevealer?: KeyringRevealer;\n    keyringForSubject?: Record&lt;CertificateFieldNameUnder50Bytes, Base64String&gt;;\n    privileged?: BooleanDefaultFalse;\n    privilegedReason?: DescriptionString5to50Bytes;\n}\n</code></pre> <p>See also: AcquisitionProtocol, Base64String, BooleanDefaultFalse, CertificateFieldNameUnder50Bytes, DescriptionString5to50Bytes, HexString, KeyringRevealer, OutpointString, PubKeyHex</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-authenticatedresult","title":"Interface: AuthenticatedResult","text":"<pre><code>export interface AuthenticatedResult {\n    authenticated: true;\n}\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-basketinsertion","title":"Interface: BasketInsertion","text":"<pre><code>export interface BasketInsertion {\n    basket: BasketStringUnder300Bytes;\n    customInstructions?: string;\n    tags?: OutputTagStringUnder300Bytes[];\n}\n</code></pre> <p>See also: BasketStringUnder300Bytes, OutputTagStringUnder300Bytes</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-certificateresult","title":"Interface: CertificateResult","text":"<pre><code>export interface CertificateResult extends WalletCertificate {\n    keyring?: Record&lt;CertificateFieldNameUnder50Bytes, Base64String&gt;;\n    verifier?: string;\n}\n</code></pre> <p>See also: Base64String, CertificateFieldNameUnder50Bytes, WalletCertificate</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-createactionargs","title":"Interface: CreateActionArgs","text":"<pre><code>export interface CreateActionArgs {\n    description: DescriptionString5to50Bytes;\n    inputBEEF?: BEEF;\n    inputs?: CreateActionInput[];\n    outputs?: CreateActionOutput[];\n    lockTime?: PositiveIntegerOrZero;\n    version?: PositiveIntegerOrZero;\n    labels?: LabelStringUnder300Bytes[];\n    options?: CreateActionOptions;\n}\n</code></pre> <p>See also: BEEF, CreateActionInput, CreateActionOptions, CreateActionOutput, DescriptionString5to50Bytes, LabelStringUnder300Bytes, PositiveIntegerOrZero</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-createactioninput","title":"Interface: CreateActionInput","text":"<pre><code>export interface CreateActionInput {\n    outpoint: OutpointString;\n    inputDescription: DescriptionString5to50Bytes;\n    unlockingScript?: HexString;\n    unlockingScriptLength?: PositiveInteger;\n    sequenceNumber?: PositiveIntegerOrZero;\n}\n</code></pre> <p>See also: DescriptionString5to50Bytes, HexString, OutpointString, PositiveInteger, PositiveIntegerOrZero</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-createactionoptions","title":"Interface: CreateActionOptions","text":"<pre><code>export interface CreateActionOptions {\n    signAndProcess?: BooleanDefaultTrue;\n    acceptDelayedBroadcast?: BooleanDefaultTrue;\n    trustSelf?: TrustSelf;\n    knownTxids?: TXIDHexString[];\n    returnTXIDOnly?: BooleanDefaultFalse;\n    noSend?: BooleanDefaultFalse;\n    noSendChange?: OutpointString[];\n    sendWith?: TXIDHexString[];\n    randomizeOutputs?: BooleanDefaultTrue;\n}\n</code></pre> <p>See also: BooleanDefaultFalse, BooleanDefaultTrue, OutpointString, TXIDHexString, TrustSelf</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-createactionoutput","title":"Interface: CreateActionOutput","text":"<pre><code>export interface CreateActionOutput {\n    lockingScript: HexString;\n    satoshis: SatoshiValue;\n    outputDescription: DescriptionString5to50Bytes;\n    basket?: BasketStringUnder300Bytes;\n    customInstructions?: string;\n    tags?: OutputTagStringUnder300Bytes[];\n}\n</code></pre> <p>See also: BasketStringUnder300Bytes, DescriptionString5to50Bytes, HexString, OutputTagStringUnder300Bytes, SatoshiValue</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-createactionresult","title":"Interface: CreateActionResult","text":"<pre><code>export interface CreateActionResult {\n    txid?: TXIDHexString;\n    tx?: AtomicBEEF;\n    noSendChange?: OutpointString[];\n    sendWithResults?: SendWithResult[];\n    signableTransaction?: SignableTransaction;\n}\n</code></pre> <p>See also: AtomicBEEF, OutpointString, SendWithResult, SignableTransaction, TXIDHexString</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-createhmacargs","title":"Interface: CreateHmacArgs","text":"<pre><code>export interface CreateHmacArgs extends WalletEncryptionArgs {\n    data: Byte[];\n}\n</code></pre> <p>See also: Byte, WalletEncryptionArgs</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-createhmacresult","title":"Interface: CreateHmacResult","text":"<pre><code>export interface CreateHmacResult {\n    hmac: Byte[];\n}\n</code></pre> <p>See also: Byte</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-createsignatureargs","title":"Interface: CreateSignatureArgs","text":"<pre><code>export interface CreateSignatureArgs extends WalletEncryptionArgs {\n    data?: Byte[];\n    hashToDirectlySign?: Byte[];\n}\n</code></pre> <p>See also: Byte, WalletEncryptionArgs</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-createsignatureresult","title":"Interface: CreateSignatureResult","text":"<pre><code>export interface CreateSignatureResult {\n    signature: Byte[];\n}\n</code></pre> <p>See also: Byte</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-discoverbyattributesargs","title":"Interface: DiscoverByAttributesArgs","text":"<pre><code>export interface DiscoverByAttributesArgs {\n    attributes: Record&lt;CertificateFieldNameUnder50Bytes, string&gt;;\n    limit?: PositiveIntegerDefault10Max10000;\n    offset?: PositiveIntegerOrZero;\n    seekPermission?: BooleanDefaultTrue;\n}\n</code></pre> <p>See also: BooleanDefaultTrue, CertificateFieldNameUnder50Bytes, PositiveIntegerDefault10Max10000, PositiveIntegerOrZero</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-discoverbyidentitykeyargs","title":"Interface: DiscoverByIdentityKeyArgs","text":"<pre><code>export interface DiscoverByIdentityKeyArgs {\n    identityKey: PubKeyHex;\n    limit?: PositiveIntegerDefault10Max10000;\n    offset?: PositiveIntegerOrZero;\n    seekPermission?: BooleanDefaultTrue;\n}\n</code></pre> <p>See also: BooleanDefaultTrue, PositiveIntegerDefault10Max10000, PositiveIntegerOrZero, PubKeyHex</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-discovercertificatesresult","title":"Interface: DiscoverCertificatesResult","text":"<pre><code>export interface DiscoverCertificatesResult {\n    totalCertificates: PositiveIntegerOrZero;\n    certificates: IdentityCertificate[];\n}\n</code></pre> <p>See also: IdentityCertificate, PositiveIntegerOrZero</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-getheaderargs","title":"Interface: GetHeaderArgs","text":"<pre><code>export interface GetHeaderArgs {\n    height: PositiveInteger;\n}\n</code></pre> <p>See also: PositiveInteger</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-getheaderresult","title":"Interface: GetHeaderResult","text":"<pre><code>export interface GetHeaderResult {\n    header: HexString;\n}\n</code></pre> <p>See also: HexString</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-getheightresult","title":"Interface: GetHeightResult","text":"<pre><code>export interface GetHeightResult {\n    height: PositiveInteger;\n}\n</code></pre> <p>See also: PositiveInteger</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-getnetworkresult","title":"Interface: GetNetworkResult","text":"<pre><code>export interface GetNetworkResult {\n    network: WalletNetwork;\n}\n</code></pre> <p>See also: WalletNetwork</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-getpublickeyargs","title":"Interface: GetPublicKeyArgs","text":"<p>When <code>identityKey</code> is true, <code>WalletEncryptionArgs</code> are not used.</p> <p>When <code>identityKey</code> is undefined, <code>WalletEncryptionArgs</code> are required.</p> <pre><code>export interface GetPublicKeyArgs extends Partial&lt;WalletEncryptionArgs&gt; {\n    identityKey?: true;\n    forSelf?: BooleanDefaultFalse;\n}\n</code></pre> <p>See also: BooleanDefaultFalse, WalletEncryptionArgs</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-getpublickeyresult","title":"Interface: GetPublicKeyResult","text":"<pre><code>export interface GetPublicKeyResult {\n    publicKey: PubKeyHex;\n}\n</code></pre> <p>See also: PubKeyHex</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-getversionresult","title":"Interface: GetVersionResult","text":"<pre><code>export interface GetVersionResult {\n    version: VersionString7To30Bytes;\n}\n</code></pre> <p>See also: VersionString7To30Bytes</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-identitycertificate","title":"Interface: IdentityCertificate","text":"<pre><code>export interface IdentityCertificate extends WalletCertificate {\n    certifierInfo: IdentityCertifier;\n    publiclyRevealedKeyring: Record&lt;CertificateFieldNameUnder50Bytes, Base64String&gt;;\n    decryptedFields: Record&lt;CertificateFieldNameUnder50Bytes, string&gt;;\n}\n</code></pre> <p>See also: Base64String, CertificateFieldNameUnder50Bytes, IdentityCertifier, WalletCertificate</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-identitycertifier","title":"Interface: IdentityCertifier","text":"<pre><code>export interface IdentityCertifier {\n    name: EntityNameStringMax100Bytes;\n    iconUrl: EntityIconURLStringMax500Bytes;\n    description: DescriptionString5to50Bytes;\n    trust: PositiveIntegerMax10;\n}\n</code></pre> <p>See also: DescriptionString5to50Bytes, EntityIconURLStringMax500Bytes, EntityNameStringMax100Bytes, PositiveIntegerMax10</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-internalizeactionargs","title":"Interface: InternalizeActionArgs","text":"<pre><code>export interface InternalizeActionArgs {\n    tx: AtomicBEEF;\n    outputs: InternalizeOutput[];\n    description: DescriptionString5to50Bytes;\n    labels?: LabelStringUnder300Bytes[];\n    seekPermission?: BooleanDefaultTrue;\n}\n</code></pre> <p>See also: AtomicBEEF, BooleanDefaultTrue, DescriptionString5to50Bytes, InternalizeOutput, LabelStringUnder300Bytes</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-internalizeactionresult","title":"Interface: InternalizeActionResult","text":"<pre><code>export interface InternalizeActionResult {\n    accepted: true;\n}\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-internalizeoutput","title":"Interface: InternalizeOutput","text":"<pre><code>export interface InternalizeOutput {\n    outputIndex: PositiveIntegerOrZero;\n    protocol: \"wallet payment\" | \"basket insertion\";\n    paymentRemittance?: WalletPayment;\n    insertionRemittance?: BasketInsertion;\n}\n</code></pre> <p>See also: BasketInsertion, PositiveIntegerOrZero, WalletPayment</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-keyderiverapi","title":"Interface: KeyDeriverApi","text":"<pre><code>export interface KeyDeriverApi {\n    rootKey: PrivateKey;\n    identityKey: string;\n    derivePublicKey: (protocolID: WalletProtocol, keyID: string, counterparty: Counterparty, forSelf?: boolean) =&gt; PublicKey;\n    derivePrivateKey: (protocolID: WalletProtocol, keyID: string, counterparty: Counterparty) =&gt; PrivateKey;\n    deriveSymmetricKey: (protocolID: WalletProtocol, keyID: string, counterparty: Counterparty) =&gt; SymmetricKey;\n    revealCounterpartySecret: (counterparty: Counterparty) =&gt; number[];\n    revealSpecificSecret: (counterparty: Counterparty, protocolID: WalletProtocol, keyID: string) =&gt; number[];\n}\n</code></pre> <p>See also: Counterparty, PrivateKey, PublicKey, SymmetricKey, WalletProtocol</p>"},{"location":"reference/wallet/#property-deriveprivatekey","title":"Property derivePrivateKey","text":"<p>Derives a private key based on protocol ID, key ID, and counterparty.</p> <p><pre><code>derivePrivateKey: (protocolID: WalletProtocol, keyID: string, counterparty: Counterparty) =&gt; PrivateKey\n</code></pre> See also: Counterparty, PrivateKey, WalletProtocol</p>"},{"location":"reference/wallet/#property-derivepublickey","title":"Property derivePublicKey","text":"<p>Derives a public key based on protocol ID, key ID, and counterparty.</p> <p><pre><code>derivePublicKey: (protocolID: WalletProtocol, keyID: string, counterparty: Counterparty, forSelf?: boolean) =&gt; PublicKey\n</code></pre> See also: Counterparty, PublicKey, WalletProtocol</p>"},{"location":"reference/wallet/#property-derivesymmetrickey","title":"Property deriveSymmetricKey","text":"<p>Derives a symmetric key based on protocol ID, key ID, and counterparty. Note: Symmetric keys should not be derivable by everyone due to security risks.</p> <p><pre><code>deriveSymmetricKey: (protocolID: WalletProtocol, keyID: string, counterparty: Counterparty) =&gt; SymmetricKey\n</code></pre> See also: Counterparty, SymmetricKey, WalletProtocol</p>"},{"location":"reference/wallet/#property-identitykey","title":"Property identityKey","text":"<p>The identity of this key deriver which is normally the public key associated with the <code>rootKey</code></p> <pre><code>identityKey: string\n</code></pre>"},{"location":"reference/wallet/#property-revealcounterpartysecret","title":"Property revealCounterpartySecret","text":"<p>Reveals the shared secret between the root key and the counterparty. Note: This should not be used for 'self'.</p> <p><pre><code>revealCounterpartySecret: (counterparty: Counterparty) =&gt; number[]\n</code></pre> See also: Counterparty</p>"},{"location":"reference/wallet/#property-revealspecificsecret","title":"Property revealSpecificSecret","text":"<p>Reveals the specific key association for a given protocol ID, key ID, and counterparty.</p> <p><pre><code>revealSpecificSecret: (counterparty: Counterparty, protocolID: WalletProtocol, keyID: string) =&gt; number[]\n</code></pre> See also: Counterparty, WalletProtocol</p>"},{"location":"reference/wallet/#property-rootkey","title":"Property rootKey","text":"<p>The root key from which all other keys are derived.</p> <p><pre><code>rootKey: PrivateKey\n</code></pre> See also: PrivateKey</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-keylinkageresult","title":"Interface: KeyLinkageResult","text":"<pre><code>export interface KeyLinkageResult {\n    encryptedLinkage: Byte[];\n    encryptedLinkageProof: Byte[];\n    prover: PubKeyHex;\n    verifier: PubKeyHex;\n    counterparty: PubKeyHex;\n}\n</code></pre> <p>See also: Byte, PubKeyHex</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-listactionsargs","title":"Interface: ListActionsArgs","text":"<pre><code>export interface ListActionsArgs {\n    labels: LabelStringUnder300Bytes[];\n    labelQueryMode?: \"any\" | \"all\";\n    includeLabels?: BooleanDefaultFalse;\n    includeInputs?: BooleanDefaultFalse;\n    includeInputSourceLockingScripts?: BooleanDefaultFalse;\n    includeInputUnlockingScripts?: BooleanDefaultFalse;\n    includeOutputs?: BooleanDefaultFalse;\n    includeOutputLockingScripts?: BooleanDefaultFalse;\n    limit?: PositiveIntegerDefault10Max10000;\n    offset?: PositiveIntegerOrZero;\n    seekPermission?: BooleanDefaultTrue;\n}\n</code></pre> <p>See also: BooleanDefaultFalse, BooleanDefaultTrue, LabelStringUnder300Bytes, PositiveIntegerDefault10Max10000, PositiveIntegerOrZero</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-listactionsresult","title":"Interface: ListActionsResult","text":"<pre><code>export interface ListActionsResult {\n    totalActions: PositiveIntegerOrZero;\n    actions: WalletAction[];\n}\n</code></pre> <p>See also: PositiveIntegerOrZero, WalletAction</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-listcertificatesargs","title":"Interface: ListCertificatesArgs","text":"<pre><code>export interface ListCertificatesArgs {\n    certifiers: PubKeyHex[];\n    types: Base64String[];\n    limit?: PositiveIntegerDefault10Max10000;\n    offset?: PositiveIntegerOrZero;\n    privileged?: BooleanDefaultFalse;\n    privilegedReason?: DescriptionString5to50Bytes;\n}\n</code></pre> <p>See also: Base64String, BooleanDefaultFalse, DescriptionString5to50Bytes, PositiveIntegerDefault10Max10000, PositiveIntegerOrZero, PubKeyHex</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-listcertificatesresult","title":"Interface: ListCertificatesResult","text":"<pre><code>export interface ListCertificatesResult {\n    totalCertificates: PositiveIntegerOrZero;\n    certificates: CertificateResult[];\n}\n</code></pre> <p>See also: CertificateResult, PositiveIntegerOrZero</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-listoutputsargs","title":"Interface: ListOutputsArgs","text":"<pre><code>export interface ListOutputsArgs {\n    basket: BasketStringUnder300Bytes;\n    tags?: OutputTagStringUnder300Bytes[];\n    tagQueryMode?: \"all\" | \"any\";\n    include?: \"locking scripts\" | \"entire transactions\";\n    includeCustomInstructions?: BooleanDefaultFalse;\n    includeTags?: BooleanDefaultFalse;\n    includeLabels?: BooleanDefaultFalse;\n    limit?: PositiveIntegerDefault10Max10000;\n    offset?: number;\n    seekPermission?: BooleanDefaultTrue;\n}\n</code></pre> <p>See also: BasketStringUnder300Bytes, BooleanDefaultFalse, BooleanDefaultTrue, OutputTagStringUnder300Bytes, PositiveIntegerDefault10Max10000</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-listoutputsresult","title":"Interface: ListOutputsResult","text":"<pre><code>export interface ListOutputsResult {\n    totalOutputs: PositiveIntegerOrZero;\n    BEEF?: BEEF;\n    outputs: WalletOutput[];\n}\n</code></pre> <p>See also: BEEF, PositiveIntegerOrZero, WalletOutput</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-provecertificateargs","title":"Interface: ProveCertificateArgs","text":"<pre><code>export interface ProveCertificateArgs {\n    certificate: Partial&lt;WalletCertificate&gt;;\n    fieldsToReveal: CertificateFieldNameUnder50Bytes[];\n    verifier: PubKeyHex;\n    privileged?: BooleanDefaultFalse;\n    privilegedReason?: DescriptionString5to50Bytes;\n}\n</code></pre> <p>See also: BooleanDefaultFalse, CertificateFieldNameUnder50Bytes, DescriptionString5to50Bytes, PubKeyHex, WalletCertificate</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-provecertificateresult","title":"Interface: ProveCertificateResult","text":"<pre><code>export interface ProveCertificateResult {\n    keyringForVerifier: Record&lt;CertificateFieldNameUnder50Bytes, Base64String&gt;;\n    certificate?: WalletCertificate;\n    verifier?: PubKeyHex;\n}\n</code></pre> <p>See also: Base64String, CertificateFieldNameUnder50Bytes, PubKeyHex, WalletCertificate</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-relinquishcertificateargs","title":"Interface: RelinquishCertificateArgs","text":"<pre><code>export interface RelinquishCertificateArgs {\n    type: Base64String;\n    serialNumber: Base64String;\n    certifier: PubKeyHex;\n}\n</code></pre> <p>See also: Base64String, PubKeyHex</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-relinquishcertificateresult","title":"Interface: RelinquishCertificateResult","text":"<pre><code>export interface RelinquishCertificateResult {\n    relinquished: true;\n}\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-relinquishoutputargs","title":"Interface: RelinquishOutputArgs","text":"<pre><code>export interface RelinquishOutputArgs {\n    basket: BasketStringUnder300Bytes;\n    output: OutpointString;\n}\n</code></pre> <p>See also: BasketStringUnder300Bytes, OutpointString</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-relinquishoutputresult","title":"Interface: RelinquishOutputResult","text":"<pre><code>export interface RelinquishOutputResult {\n    relinquished: true;\n}\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-revealcounterpartykeylinkageargs","title":"Interface: RevealCounterpartyKeyLinkageArgs","text":"<pre><code>export interface RevealCounterpartyKeyLinkageArgs {\n    counterparty: PubKeyHex;\n    verifier: PubKeyHex;\n    privileged?: BooleanDefaultFalse;\n    privilegedReason?: DescriptionString5to50Bytes;\n}\n</code></pre> <p>See also: BooleanDefaultFalse, DescriptionString5to50Bytes, PubKeyHex</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-revealcounterpartykeylinkageresult","title":"Interface: RevealCounterpartyKeyLinkageResult","text":"<pre><code>export interface RevealCounterpartyKeyLinkageResult extends KeyLinkageResult {\n    revelationTime: ISOTimestampString;\n}\n</code></pre> <p>See also: ISOTimestampString, KeyLinkageResult</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-revealspecifickeylinkageargs","title":"Interface: RevealSpecificKeyLinkageArgs","text":"<pre><code>export interface RevealSpecificKeyLinkageArgs {\n    counterparty: WalletCounterparty;\n    verifier: PubKeyHex;\n    protocolID: WalletProtocol;\n    keyID: KeyIDStringUnder800Bytes;\n    privilegedReason?: DescriptionString5to50Bytes;\n    privileged?: BooleanDefaultFalse;\n}\n</code></pre> <p>See also: BooleanDefaultFalse, DescriptionString5to50Bytes, KeyIDStringUnder800Bytes, PubKeyHex, WalletCounterparty, WalletProtocol</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-revealspecifickeylinkageresult","title":"Interface: RevealSpecificKeyLinkageResult","text":"<pre><code>export interface RevealSpecificKeyLinkageResult extends KeyLinkageResult {\n    protocolID: WalletProtocol;\n    keyID: KeyIDStringUnder800Bytes;\n    proofType: Byte;\n}\n</code></pre> <p>See also: Byte, KeyIDStringUnder800Bytes, KeyLinkageResult, WalletProtocol</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-reviewactionresult","title":"Interface: ReviewActionResult","text":"<pre><code>export interface ReviewActionResult {\n    txid: TXIDHexString;\n    status: ReviewActionResultStatus;\n    competingTxs?: string[];\n    competingBeef?: number[];\n}\n</code></pre> <p>See also: ReviewActionResultStatus, TXIDHexString</p>"},{"location":"reference/wallet/#property-competingbeef","title":"Property competingBeef","text":"<p>Merged beef of competingTxs, valid when status is 'doubleSpend'.</p> <pre><code>competingBeef?: number[]\n</code></pre>"},{"location":"reference/wallet/#property-competingtxs","title":"Property competingTxs","text":"<p>Any competing txids reported for this txid, valid when status is 'doubleSpend'.</p> <pre><code>competingTxs?: string[]\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-sendwithresult","title":"Interface: SendWithResult","text":"<pre><code>export interface SendWithResult {\n    txid: TXIDHexString;\n    status: SendWithResultStatus;\n}\n</code></pre> <p>See also: SendWithResultStatus, TXIDHexString</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-signactionargs","title":"Interface: SignActionArgs","text":"<pre><code>export interface SignActionArgs {\n    spends: Record&lt;PositiveIntegerOrZero, SignActionSpend&gt;;\n    reference: Base64String;\n    options?: SignActionOptions;\n}\n</code></pre> <p>See also: Base64String, PositiveIntegerOrZero, SignActionOptions, SignActionSpend</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-signactionoptions","title":"Interface: SignActionOptions","text":"<pre><code>export interface SignActionOptions {\n    acceptDelayedBroadcast?: BooleanDefaultTrue;\n    returnTXIDOnly?: BooleanDefaultFalse;\n    noSend?: BooleanDefaultFalse;\n    sendWith?: TXIDHexString[];\n}\n</code></pre> <p>See also: BooleanDefaultFalse, BooleanDefaultTrue, TXIDHexString</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-signactionresult","title":"Interface: SignActionResult","text":"<pre><code>export interface SignActionResult {\n    txid?: TXIDHexString;\n    tx?: AtomicBEEF;\n    sendWithResults?: SendWithResult[];\n}\n</code></pre> <p>See also: AtomicBEEF, SendWithResult, TXIDHexString</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-signactionspend","title":"Interface: SignActionSpend","text":"<pre><code>export interface SignActionSpend {\n    unlockingScript: HexString;\n    sequenceNumber?: PositiveIntegerOrZero;\n}\n</code></pre> <p>See also: HexString, PositiveIntegerOrZero</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-signabletransaction","title":"Interface: SignableTransaction","text":"<pre><code>export interface SignableTransaction {\n    tx: AtomicBEEF;\n    reference: Base64String;\n}\n</code></pre> <p>See also: AtomicBEEF, Base64String</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-verifyhmacargs","title":"Interface: VerifyHmacArgs","text":"<pre><code>export interface VerifyHmacArgs extends WalletEncryptionArgs {\n    data: Byte[];\n    hmac: Byte[];\n}\n</code></pre> <p>See also: Byte, WalletEncryptionArgs</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-verifyhmacresult","title":"Interface: VerifyHmacResult","text":"<pre><code>export interface VerifyHmacResult {\n    valid: true;\n}\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-verifysignatureargs","title":"Interface: VerifySignatureArgs","text":"<pre><code>export interface VerifySignatureArgs extends WalletEncryptionArgs {\n    data?: Byte[];\n    hashToDirectlyVerify?: Byte[];\n    signature: Byte[];\n    forSelf?: BooleanDefaultFalse;\n}\n</code></pre> <p>See also: BooleanDefaultFalse, Byte, WalletEncryptionArgs</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-verifysignatureresult","title":"Interface: VerifySignatureResult","text":"<pre><code>export interface VerifySignatureResult {\n    valid: true;\n}\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-walletaction","title":"Interface: WalletAction","text":"<pre><code>export interface WalletAction {\n    txid: TXIDHexString;\n    satoshis: SatoshiValue;\n    status: ActionStatus;\n    isOutgoing: boolean;\n    description: DescriptionString5to50Bytes;\n    labels?: LabelStringUnder300Bytes[];\n    version: PositiveIntegerOrZero;\n    lockTime: PositiveIntegerOrZero;\n    inputs?: WalletActionInput[];\n    outputs?: WalletActionOutput[];\n}\n</code></pre> <p>See also: ActionStatus, DescriptionString5to50Bytes, LabelStringUnder300Bytes, PositiveIntegerOrZero, SatoshiValue, TXIDHexString, WalletActionInput, WalletActionOutput</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-walletactioninput","title":"Interface: WalletActionInput","text":"<pre><code>export interface WalletActionInput {\n    sourceOutpoint: OutpointString;\n    sourceSatoshis: SatoshiValue;\n    sourceLockingScript?: HexString;\n    unlockingScript?: HexString;\n    inputDescription: DescriptionString5to50Bytes;\n    sequenceNumber: PositiveIntegerOrZero;\n}\n</code></pre> <p>See also: DescriptionString5to50Bytes, HexString, OutpointString, PositiveIntegerOrZero, SatoshiValue</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-walletactionoutput","title":"Interface: WalletActionOutput","text":"<pre><code>export interface WalletActionOutput {\n    satoshis: SatoshiValue;\n    lockingScript?: HexString;\n    spendable: boolean;\n    customInstructions?: string;\n    tags: OutputTagStringUnder300Bytes[];\n    outputIndex: PositiveIntegerOrZero;\n    outputDescription: DescriptionString5to50Bytes;\n    basket: BasketStringUnder300Bytes;\n}\n</code></pre> <p>See also: BasketStringUnder300Bytes, DescriptionString5to50Bytes, HexString, OutputTagStringUnder300Bytes, PositiveIntegerOrZero, SatoshiValue</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-walletcertificate","title":"Interface: WalletCertificate","text":"<pre><code>export interface WalletCertificate {\n    type: Base64String;\n    subject: PubKeyHex;\n    serialNumber: Base64String;\n    certifier: PubKeyHex;\n    revocationOutpoint: OutpointString;\n    signature: HexString;\n    fields: Record&lt;CertificateFieldNameUnder50Bytes, string&gt;;\n}\n</code></pre> <p>See also: Base64String, CertificateFieldNameUnder50Bytes, HexString, OutpointString, PubKeyHex</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-walletdecryptargs","title":"Interface: WalletDecryptArgs","text":"<pre><code>export interface WalletDecryptArgs extends WalletEncryptionArgs {\n    ciphertext: Byte[];\n}\n</code></pre> <p>See also: Byte, WalletEncryptionArgs</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-walletdecryptresult","title":"Interface: WalletDecryptResult","text":"<pre><code>export interface WalletDecryptResult {\n    plaintext: Byte[];\n}\n</code></pre> <p>See also: Byte</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-walletencryptargs","title":"Interface: WalletEncryptArgs","text":"<pre><code>export interface WalletEncryptArgs extends WalletEncryptionArgs {\n    plaintext: Byte[];\n}\n</code></pre> <p>See also: Byte, WalletEncryptionArgs</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-walletencryptresult","title":"Interface: WalletEncryptResult","text":"<pre><code>export interface WalletEncryptResult {\n    ciphertext: Byte[];\n}\n</code></pre> <p>See also: Byte</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-walletencryptionargs","title":"Interface: WalletEncryptionArgs","text":"<pre><code>export interface WalletEncryptionArgs {\n    protocolID: WalletProtocol;\n    keyID: KeyIDStringUnder800Bytes;\n    counterparty?: WalletCounterparty;\n    privileged?: BooleanDefaultFalse;\n    privilegedReason?: DescriptionString5to50Bytes;\n    seekPermission?: BooleanDefaultTrue;\n}\n</code></pre> <p>See also: BooleanDefaultFalse, BooleanDefaultTrue, DescriptionString5to50Bytes, KeyIDStringUnder800Bytes, WalletCounterparty, WalletProtocol</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-walleterrorobject","title":"Interface: WalletErrorObject","text":"<p>Every method of the <code>Wallet</code> interface has a return value of the form <code>Promise&lt;object&gt;</code>. When errors occur, an exception object may be thrown which must conform to the <code>WalletErrorObject</code> interface. Serialization layers can rely on the <code>isError</code> property being unique to error objects. Deserialization should rethrow <code>WalletErrorObject</code> conforming objects.</p> <pre><code>export interface WalletErrorObject extends Error {\n    isError: true;\n}\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-walletinterface","title":"Interface: WalletInterface","text":"<p>The Wallet interface defines a wallet capable of various tasks including transaction creation and signing, encryption, decryption, identity certificate management, identity verification, and communication with applications as per the BRC standards. This interface allows applications to interact with the wallet for a range of functionalities aligned with the Babbage architectural principles.</p> <p>Error Handling</p> <p>Every method of the <code>Wallet</code> interface has a return value of the form <code>Promise&lt;object&gt;</code>. When an error occurs, an exception object may be thrown which must conform to the <code>WalletErrorObject</code> interface. Serialization layers can rely on the <code>isError</code> property being unique to error objects to deserialize and rethrow <code>WalletErrorObject</code> conforming objects.</p> <pre><code>export interface WalletInterface {\n    getPublicKey: (args: GetPublicKeyArgs, originator?: OriginatorDomainNameStringUnder250Bytes) =&gt; Promise&lt;GetPublicKeyResult&gt;;\n    revealCounterpartyKeyLinkage: (args: RevealCounterpartyKeyLinkageArgs, originator?: OriginatorDomainNameStringUnder250Bytes) =&gt; Promise&lt;RevealCounterpartyKeyLinkageResult&gt;;\n    revealSpecificKeyLinkage: (args: RevealSpecificKeyLinkageArgs, originator?: OriginatorDomainNameStringUnder250Bytes) =&gt; Promise&lt;RevealSpecificKeyLinkageResult&gt;;\n    encrypt: (args: WalletEncryptArgs, originator?: OriginatorDomainNameStringUnder250Bytes) =&gt; Promise&lt;WalletEncryptResult&gt;;\n    decrypt: (args: WalletDecryptArgs, originator?: OriginatorDomainNameStringUnder250Bytes) =&gt; Promise&lt;WalletDecryptResult&gt;;\n    createHmac: (args: CreateHmacArgs, originator?: OriginatorDomainNameStringUnder250Bytes) =&gt; Promise&lt;CreateHmacResult&gt;;\n    verifyHmac: (args: VerifyHmacArgs, originator?: OriginatorDomainNameStringUnder250Bytes) =&gt; Promise&lt;VerifyHmacResult&gt;;\n    createSignature: (args: CreateSignatureArgs, originator?: OriginatorDomainNameStringUnder250Bytes) =&gt; Promise&lt;CreateSignatureResult&gt;;\n    verifySignature: (args: VerifySignatureArgs, originator?: OriginatorDomainNameStringUnder250Bytes) =&gt; Promise&lt;VerifySignatureResult&gt;;\n    createAction: (args: CreateActionArgs, originator?: OriginatorDomainNameStringUnder250Bytes) =&gt; Promise&lt;CreateActionResult&gt;;\n    signAction: (args: SignActionArgs, originator?: OriginatorDomainNameStringUnder250Bytes) =&gt; Promise&lt;SignActionResult&gt;;\n    abortAction: (args: AbortActionArgs, originator?: OriginatorDomainNameStringUnder250Bytes) =&gt; Promise&lt;AbortActionResult&gt;;\n    listActions: (args: ListActionsArgs, originator?: OriginatorDomainNameStringUnder250Bytes) =&gt; Promise&lt;ListActionsResult&gt;;\n    internalizeAction: (args: InternalizeActionArgs, originator?: OriginatorDomainNameStringUnder250Bytes) =&gt; Promise&lt;InternalizeActionResult&gt;;\n    listOutputs: (args: ListOutputsArgs, originator?: OriginatorDomainNameStringUnder250Bytes) =&gt; Promise&lt;ListOutputsResult&gt;;\n    relinquishOutput: (args: RelinquishOutputArgs, originator?: OriginatorDomainNameStringUnder250Bytes) =&gt; Promise&lt;RelinquishOutputResult&gt;;\n    acquireCertificate: (args: AcquireCertificateArgs, originator?: OriginatorDomainNameStringUnder250Bytes) =&gt; Promise&lt;WalletCertificate&gt;;\n    listCertificates: (args: ListCertificatesArgs, originator?: OriginatorDomainNameStringUnder250Bytes) =&gt; Promise&lt;ListCertificatesResult&gt;;\n    proveCertificate: (args: ProveCertificateArgs, originator?: OriginatorDomainNameStringUnder250Bytes) =&gt; Promise&lt;ProveCertificateResult&gt;;\n    relinquishCertificate: (args: RelinquishCertificateArgs, originator?: OriginatorDomainNameStringUnder250Bytes) =&gt; Promise&lt;RelinquishCertificateResult&gt;;\n    discoverByIdentityKey: (args: DiscoverByIdentityKeyArgs, originator?: OriginatorDomainNameStringUnder250Bytes) =&gt; Promise&lt;DiscoverCertificatesResult&gt;;\n    discoverByAttributes: (args: DiscoverByAttributesArgs, originator?: OriginatorDomainNameStringUnder250Bytes) =&gt; Promise&lt;DiscoverCertificatesResult&gt;;\n    isAuthenticated: (args: object, originator?: OriginatorDomainNameStringUnder250Bytes) =&gt; Promise&lt;AuthenticatedResult&gt;;\n    waitForAuthentication: (args: object, originator?: OriginatorDomainNameStringUnder250Bytes) =&gt; Promise&lt;AuthenticatedResult&gt;;\n    getHeight: (args: object, originator?: OriginatorDomainNameStringUnder250Bytes) =&gt; Promise&lt;GetHeightResult&gt;;\n    getHeaderForHeight: (args: GetHeaderArgs, originator?: OriginatorDomainNameStringUnder250Bytes) =&gt; Promise&lt;GetHeaderResult&gt;;\n    getNetwork: (args: object, originator?: OriginatorDomainNameStringUnder250Bytes) =&gt; Promise&lt;GetNetworkResult&gt;;\n    getVersion: (args: object, originator?: OriginatorDomainNameStringUnder250Bytes) =&gt; Promise&lt;GetVersionResult&gt;;\n}\n</code></pre> <p>See also: AbortActionArgs, AbortActionResult, AcquireCertificateArgs, AuthenticatedResult, CreateActionArgs, CreateActionResult, CreateHmacArgs, CreateHmacResult, CreateSignatureArgs, CreateSignatureResult, DiscoverByAttributesArgs, DiscoverByIdentityKeyArgs, DiscoverCertificatesResult, GetHeaderArgs, GetHeaderResult, GetHeightResult, GetNetworkResult, GetPublicKeyArgs, GetPublicKeyResult, GetVersionResult, InternalizeActionArgs, InternalizeActionResult, ListActionsArgs, ListActionsResult, ListCertificatesArgs, ListCertificatesResult, ListOutputsArgs, ListOutputsResult, OriginatorDomainNameStringUnder250Bytes, ProveCertificateArgs, ProveCertificateResult, RelinquishCertificateArgs, RelinquishCertificateResult, RelinquishOutputArgs, RelinquishOutputResult, RevealCounterpartyKeyLinkageArgs, RevealCounterpartyKeyLinkageResult, RevealSpecificKeyLinkageArgs, RevealSpecificKeyLinkageResult, SignActionArgs, SignActionResult, VerifyHmacArgs, VerifyHmacResult, VerifySignatureArgs, VerifySignatureResult, WalletCertificate, WalletDecryptArgs, WalletDecryptResult, WalletEncryptArgs, WalletEncryptResult, decrypt, encrypt</p>"},{"location":"reference/wallet/#property-abortaction","title":"Property abortAction","text":"<p>Aborts a transaction that is in progress and has not yet been finalized or sent to the network.</p> <p><pre><code>abortAction: (args: AbortActionArgs, originator?: OriginatorDomainNameStringUnder250Bytes) =&gt; Promise&lt;AbortActionResult&gt;\n</code></pre> See also: AbortActionArgs, AbortActionResult, OriginatorDomainNameStringUnder250Bytes</p>"},{"location":"reference/wallet/#property-acquirecertificate","title":"Property acquireCertificate","text":"<p>Acquires an identity certificate, whether by acquiring one from the certifier or by directly receiving it.</p> <p><pre><code>acquireCertificate: (args: AcquireCertificateArgs, originator?: OriginatorDomainNameStringUnder250Bytes) =&gt; Promise&lt;WalletCertificate&gt;\n</code></pre> See also: AcquireCertificateArgs, OriginatorDomainNameStringUnder250Bytes, WalletCertificate</p>"},{"location":"reference/wallet/#property-createaction","title":"Property createAction","text":"<p>Creates a new Bitcoin transaction based on the provided inputs, outputs, labels, locks, and other options.</p> <p><pre><code>createAction: (args: CreateActionArgs, originator?: OriginatorDomainNameStringUnder250Bytes) =&gt; Promise&lt;CreateActionResult&gt;\n</code></pre> See also: CreateActionArgs, CreateActionResult, OriginatorDomainNameStringUnder250Bytes</p>"},{"location":"reference/wallet/#property-createhmac","title":"Property createHmac","text":"<p>Creates an HMAC (Hash-based Message Authentication Code) based on the provided data, protocol, key ID, counterparty, and other factors.</p> <p><pre><code>createHmac: (args: CreateHmacArgs, originator?: OriginatorDomainNameStringUnder250Bytes) =&gt; Promise&lt;CreateHmacResult&gt;\n</code></pre> See also: CreateHmacArgs, CreateHmacResult, OriginatorDomainNameStringUnder250Bytes</p>"},{"location":"reference/wallet/#property-createsignature","title":"Property createSignature","text":"<p>Creates a digital signature for the provided data or hash using a specific protocol, key, and optionally considering privilege and counterparty.</p> <p><pre><code>createSignature: (args: CreateSignatureArgs, originator?: OriginatorDomainNameStringUnder250Bytes) =&gt; Promise&lt;CreateSignatureResult&gt;\n</code></pre> See also: CreateSignatureArgs, CreateSignatureResult, OriginatorDomainNameStringUnder250Bytes</p>"},{"location":"reference/wallet/#property-decrypt","title":"Property decrypt","text":"<p>Decrypts the provided ciphertext using derived keys, based on the protocol ID, key ID, counterparty, and other factors.</p> <p><pre><code>decrypt: (args: WalletDecryptArgs, originator?: OriginatorDomainNameStringUnder250Bytes) =&gt; Promise&lt;WalletDecryptResult&gt;\n</code></pre> See also: OriginatorDomainNameStringUnder250Bytes, WalletDecryptArgs, WalletDecryptResult</p>"},{"location":"reference/wallet/#property-discoverbyattributes","title":"Property discoverByAttributes","text":"<p>Discovers identity certificates belonging to other users, where the documents contain specific attributes, issued by a trusted entity.</p> <p><pre><code>discoverByAttributes: (args: DiscoverByAttributesArgs, originator?: OriginatorDomainNameStringUnder250Bytes) =&gt; Promise&lt;DiscoverCertificatesResult&gt;\n</code></pre> See also: DiscoverByAttributesArgs, DiscoverCertificatesResult, OriginatorDomainNameStringUnder250Bytes</p>"},{"location":"reference/wallet/#property-discoverbyidentitykey","title":"Property discoverByIdentityKey","text":"<p>Discovers identity certificates, issued to a given identity key by a trusted entity.</p> <p><pre><code>discoverByIdentityKey: (args: DiscoverByIdentityKeyArgs, originator?: OriginatorDomainNameStringUnder250Bytes) =&gt; Promise&lt;DiscoverCertificatesResult&gt;\n</code></pre> See also: DiscoverByIdentityKeyArgs, DiscoverCertificatesResult, OriginatorDomainNameStringUnder250Bytes</p>"},{"location":"reference/wallet/#property-encrypt","title":"Property encrypt","text":"<p>Encrypts the provided plaintext data using derived keys, based on the protocol ID, key ID, counterparty, and other factors.</p> <p><pre><code>encrypt: (args: WalletEncryptArgs, originator?: OriginatorDomainNameStringUnder250Bytes) =&gt; Promise&lt;WalletEncryptResult&gt;\n</code></pre> See also: OriginatorDomainNameStringUnder250Bytes, WalletEncryptArgs, WalletEncryptResult</p>"},{"location":"reference/wallet/#property-getheaderforheight","title":"Property getHeaderForHeight","text":"<p>Retrieves the block header of a block at a specified height.</p> <p><pre><code>getHeaderForHeight: (args: GetHeaderArgs, originator?: OriginatorDomainNameStringUnder250Bytes) =&gt; Promise&lt;GetHeaderResult&gt;\n</code></pre> See also: GetHeaderArgs, GetHeaderResult, OriginatorDomainNameStringUnder250Bytes</p>"},{"location":"reference/wallet/#property-getheight","title":"Property getHeight","text":"<p>Retrieves the current height of the blockchain.</p> <p><pre><code>getHeight: (args: object, originator?: OriginatorDomainNameStringUnder250Bytes) =&gt; Promise&lt;GetHeightResult&gt;\n</code></pre> See also: GetHeightResult, OriginatorDomainNameStringUnder250Bytes</p>"},{"location":"reference/wallet/#property-getnetwork","title":"Property getNetwork","text":"<p>Retrieves the Bitcoin network the client is using (mainnet or testnet).</p> <p><pre><code>getNetwork: (args: object, originator?: OriginatorDomainNameStringUnder250Bytes) =&gt; Promise&lt;GetNetworkResult&gt;\n</code></pre> See also: GetNetworkResult, OriginatorDomainNameStringUnder250Bytes</p>"},{"location":"reference/wallet/#property-getpublickey","title":"Property getPublicKey","text":"<p>Retrieves a derived or identity public key based on the requested protocol, key ID, counterparty, and other factors.</p> <p><pre><code>getPublicKey: (args: GetPublicKeyArgs, originator?: OriginatorDomainNameStringUnder250Bytes) =&gt; Promise&lt;GetPublicKeyResult&gt;\n</code></pre> See also: GetPublicKeyArgs, GetPublicKeyResult, OriginatorDomainNameStringUnder250Bytes</p>"},{"location":"reference/wallet/#property-getversion","title":"Property getVersion","text":"<p>Retrieves the current version string of the wallet.</p> <p><pre><code>getVersion: (args: object, originator?: OriginatorDomainNameStringUnder250Bytes) =&gt; Promise&lt;GetVersionResult&gt;\n</code></pre> See also: GetVersionResult, OriginatorDomainNameStringUnder250Bytes</p>"},{"location":"reference/wallet/#property-internalizeaction","title":"Property internalizeAction","text":"<p>Submits a transaction to be internalized and optionally labeled, outputs paid to the wallet balance, inserted into baskets, and/or tagged.</p> <p><pre><code>internalizeAction: (args: InternalizeActionArgs, originator?: OriginatorDomainNameStringUnder250Bytes) =&gt; Promise&lt;InternalizeActionResult&gt;\n</code></pre> See also: InternalizeActionArgs, InternalizeActionResult, OriginatorDomainNameStringUnder250Bytes</p>"},{"location":"reference/wallet/#property-isauthenticated","title":"Property isAuthenticated","text":"<p>Checks the authentication status of the user.</p> <p><pre><code>isAuthenticated: (args: object, originator?: OriginatorDomainNameStringUnder250Bytes) =&gt; Promise&lt;AuthenticatedResult&gt;\n</code></pre> See also: AuthenticatedResult, OriginatorDomainNameStringUnder250Bytes</p>"},{"location":"reference/wallet/#property-listactions","title":"Property listActions","text":"<p>Lists all transactions matching the specified labels.</p> <p><pre><code>listActions: (args: ListActionsArgs, originator?: OriginatorDomainNameStringUnder250Bytes) =&gt; Promise&lt;ListActionsResult&gt;\n</code></pre> See also: ListActionsArgs, ListActionsResult, OriginatorDomainNameStringUnder250Bytes</p>"},{"location":"reference/wallet/#property-listcertificates","title":"Property listCertificates","text":"<p>Lists identity certificates belonging to the user, filtered by certifier(s) and type(s).</p> <p><pre><code>listCertificates: (args: ListCertificatesArgs, originator?: OriginatorDomainNameStringUnder250Bytes) =&gt; Promise&lt;ListCertificatesResult&gt;\n</code></pre> See also: ListCertificatesArgs, ListCertificatesResult, OriginatorDomainNameStringUnder250Bytes</p>"},{"location":"reference/wallet/#property-listoutputs","title":"Property listOutputs","text":"<p>Lists the spendable outputs kept within a specific basket, optionally tagged with specific labels.</p> <p><pre><code>listOutputs: (args: ListOutputsArgs, originator?: OriginatorDomainNameStringUnder250Bytes) =&gt; Promise&lt;ListOutputsResult&gt;\n</code></pre> See also: ListOutputsArgs, ListOutputsResult, OriginatorDomainNameStringUnder250Bytes</p>"},{"location":"reference/wallet/#property-provecertificate","title":"Property proveCertificate","text":"<p>Proves select fields of an identity certificate, as specified, when requested by a verifier.</p> <p><pre><code>proveCertificate: (args: ProveCertificateArgs, originator?: OriginatorDomainNameStringUnder250Bytes) =&gt; Promise&lt;ProveCertificateResult&gt;\n</code></pre> See also: OriginatorDomainNameStringUnder250Bytes, ProveCertificateArgs, ProveCertificateResult</p>"},{"location":"reference/wallet/#property-relinquishcertificate","title":"Property relinquishCertificate","text":"<p>Relinquishes an identity certificate, removing it from the wallet regardless of whether the revocation outpoint has become spent.</p> <p><pre><code>relinquishCertificate: (args: RelinquishCertificateArgs, originator?: OriginatorDomainNameStringUnder250Bytes) =&gt; Promise&lt;RelinquishCertificateResult&gt;\n</code></pre> See also: OriginatorDomainNameStringUnder250Bytes, RelinquishCertificateArgs, RelinquishCertificateResult</p>"},{"location":"reference/wallet/#property-relinquishoutput","title":"Property relinquishOutput","text":"<p>Relinquish an output out of a basket, removing it from tracking without spending it.</p> <p><pre><code>relinquishOutput: (args: RelinquishOutputArgs, originator?: OriginatorDomainNameStringUnder250Bytes) =&gt; Promise&lt;RelinquishOutputResult&gt;\n</code></pre> See also: OriginatorDomainNameStringUnder250Bytes, RelinquishOutputArgs, RelinquishOutputResult</p>"},{"location":"reference/wallet/#property-revealcounterpartykeylinkage","title":"Property revealCounterpartyKeyLinkage","text":"<p>Reveals the key linkage between ourselves and a counterparty, to a particular verifier, across all interactions with the counterparty.</p> <p><pre><code>revealCounterpartyKeyLinkage: (args: RevealCounterpartyKeyLinkageArgs, originator?: OriginatorDomainNameStringUnder250Bytes) =&gt; Promise&lt;RevealCounterpartyKeyLinkageResult&gt;\n</code></pre> See also: OriginatorDomainNameStringUnder250Bytes, RevealCounterpartyKeyLinkageArgs, RevealCounterpartyKeyLinkageResult</p>"},{"location":"reference/wallet/#property-revealspecifickeylinkage","title":"Property revealSpecificKeyLinkage","text":"<p>Reveals the key linkage between ourselves and a counterparty, to a particular verifier, with respect to a specific interaction.</p> <p><pre><code>revealSpecificKeyLinkage: (args: RevealSpecificKeyLinkageArgs, originator?: OriginatorDomainNameStringUnder250Bytes) =&gt; Promise&lt;RevealSpecificKeyLinkageResult&gt;\n</code></pre> See also: OriginatorDomainNameStringUnder250Bytes, RevealSpecificKeyLinkageArgs, RevealSpecificKeyLinkageResult</p>"},{"location":"reference/wallet/#property-signaction","title":"Property signAction","text":"<p>Signs a transaction previously created using <code>createAction</code>.</p> <p><pre><code>signAction: (args: SignActionArgs, originator?: OriginatorDomainNameStringUnder250Bytes) =&gt; Promise&lt;SignActionResult&gt;\n</code></pre> See also: OriginatorDomainNameStringUnder250Bytes, SignActionArgs, SignActionResult</p>"},{"location":"reference/wallet/#property-verifyhmac","title":"Property verifyHmac","text":"<p>Verifies an HMAC (Hash-based Message Authentication Code) based on the provided data, protocol, key ID, counterparty, and other factors.</p> <p><pre><code>verifyHmac: (args: VerifyHmacArgs, originator?: OriginatorDomainNameStringUnder250Bytes) =&gt; Promise&lt;VerifyHmacResult&gt;\n</code></pre> See also: OriginatorDomainNameStringUnder250Bytes, VerifyHmacArgs, VerifyHmacResult</p>"},{"location":"reference/wallet/#property-verifysignature","title":"Property verifySignature","text":"<p>Verifies a digital signature for the provided data or hash using a specific protocol, key, and optionally considering privilege and counterparty.</p> <p><pre><code>verifySignature: (args: VerifySignatureArgs, originator?: OriginatorDomainNameStringUnder250Bytes) =&gt; Promise&lt;VerifySignatureResult&gt;\n</code></pre> See also: OriginatorDomainNameStringUnder250Bytes, VerifySignatureArgs, VerifySignatureResult</p>"},{"location":"reference/wallet/#property-waitforauthentication","title":"Property waitForAuthentication","text":"<p>Continuously waits until the user is authenticated, returning the result once confirmed.</p> <p><pre><code>waitForAuthentication: (args: object, originator?: OriginatorDomainNameStringUnder250Bytes) =&gt; Promise&lt;AuthenticatedResult&gt;\n</code></pre> See also: AuthenticatedResult, OriginatorDomainNameStringUnder250Bytes</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-walletoutput","title":"Interface: WalletOutput","text":"<pre><code>export interface WalletOutput {\n    satoshis: SatoshiValue;\n    lockingScript?: HexString;\n    spendable: boolean;\n    customInstructions?: string;\n    tags?: OutputTagStringUnder300Bytes[];\n    outpoint: OutpointString;\n    labels?: LabelStringUnder300Bytes[];\n}\n</code></pre> <p>See also: HexString, LabelStringUnder300Bytes, OutpointString, OutputTagStringUnder300Bytes, SatoshiValue</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-walletpayment","title":"Interface: WalletPayment","text":"<pre><code>export interface WalletPayment {\n    derivationPrefix: Base64String;\n    derivationSuffix: Base64String;\n    senderIdentityKey: PubKeyHex;\n}\n</code></pre> <p>See also: Base64String, PubKeyHex</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-walletwire","title":"Interface: WalletWire","text":"<p>A Wallet Wire is an abstraction over a raw transport medium where binary data can be sent to and subsequently received from a wallet.</p> <pre><code>export default interface WalletWire {\n    transmitToWallet: (message: number[]) =&gt; Promise&lt;number[]&gt;;\n}\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#classes","title":"Classes","text":"CachedKeyDeriver WalletClient HTTPWalletJSON WalletError HTTPWalletWire WalletWireProcessor KeyDeriver WalletWireTransceiver ProtoWallet WindowCWISubstrate ReactNativeWebView XDMSubstrate WERR_REVIEW_ACTIONS <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#class-cachedkeyderiver","title":"Class: CachedKeyDeriver","text":"<p>A cached version of KeyDeriver that caches the results of key derivation methods. This is useful for optimizing performance when the same keys are derived multiple times. It supports configurable cache size with sane defaults and maintains cache entries using LRU (Least Recently Used) eviction policy.</p> <pre><code>export default class CachedKeyDeriver implements KeyDeriverApi {\n    rootKey: PrivateKey;\n    identityKey: string;\n    constructor(rootKey: PrivateKey | \"anyone\", options?: {\n        maxCacheSize?: number;\n    }) \n    derivePublicKey(protocolID: WalletProtocol, keyID: string, counterparty: Counterparty, forSelf: boolean = false): PublicKey \n    derivePrivateKey(protocolID: WalletProtocol, keyID: string, counterparty: Counterparty): PrivateKey \n    deriveSymmetricKey(protocolID: WalletProtocol, keyID: string, counterparty: Counterparty): SymmetricKey \n    revealCounterpartySecret(counterparty: Counterparty): number[] \n    revealSpecificSecret(counterparty: Counterparty, protocolID: WalletProtocol, keyID: string): number[] \n}\n</code></pre> <p>See also: Counterparty, KeyDeriverApi, PrivateKey, PublicKey, SymmetricKey, WalletProtocol</p>"},{"location":"reference/wallet/#constructor","title":"Constructor","text":"<p>Initializes the CachedKeyDeriver instance with a root private key and optional cache settings.</p> <p><pre><code>constructor(rootKey: PrivateKey | \"anyone\", options?: {\n    maxCacheSize?: number;\n}) \n</code></pre> See also: PrivateKey</p> <p>Argument Details</p> <ul> <li>rootKey</li> <li>The root private key or the string 'anyone'.</li> <li>options</li> <li>Optional settings for the cache.</li> </ul>"},{"location":"reference/wallet/#property-identitykey_1","title":"Property identityKey","text":"<p>The identity of this key deriver which is normally the public key associated with the <code>rootKey</code></p> <pre><code>identityKey: string\n</code></pre>"},{"location":"reference/wallet/#property-rootkey_1","title":"Property rootKey","text":"<p>The root key from which all other keys are derived.</p> <p><pre><code>rootKey: PrivateKey\n</code></pre> See also: PrivateKey</p>"},{"location":"reference/wallet/#method-deriveprivatekey","title":"Method derivePrivateKey","text":"<p>Derives a private key based on protocol ID, key ID, and counterparty. Caches the result for future calls with the same parameters.</p> <p><pre><code>derivePrivateKey(protocolID: WalletProtocol, keyID: string, counterparty: Counterparty): PrivateKey \n</code></pre> See also: Counterparty, PrivateKey, WalletProtocol</p> <p>Returns</p> <ul> <li>The derived private key.</li> </ul> <p>Argument Details</p> <ul> <li>protocolID</li> <li>The protocol ID including a security level and protocol name.</li> <li>keyID</li> <li>The key identifier.</li> <li>counterparty</li> <li>The counterparty's public key or a predefined value ('self' or 'anyone').</li> </ul>"},{"location":"reference/wallet/#method-derivepublickey","title":"Method derivePublicKey","text":"<p>Derives a public key based on protocol ID, key ID, and counterparty. Caches the result for future calls with the same parameters.</p> <p><pre><code>derivePublicKey(protocolID: WalletProtocol, keyID: string, counterparty: Counterparty, forSelf: boolean = false): PublicKey \n</code></pre> See also: Counterparty, PublicKey, WalletProtocol</p> <p>Returns</p> <ul> <li>The derived public key.</li> </ul> <p>Argument Details</p> <ul> <li>protocolID</li> <li>The protocol ID including a security level and protocol name.</li> <li>keyID</li> <li>The key identifier.</li> <li>counterparty</li> <li>The counterparty's public key or a predefined value ('self' or 'anyone').</li> <li>forSelf</li> <li>Whether deriving for self.</li> </ul>"},{"location":"reference/wallet/#method-derivesymmetrickey","title":"Method deriveSymmetricKey","text":"<p>Derives a symmetric key based on protocol ID, key ID, and counterparty. Caches the result for future calls with the same parameters.</p> <p><pre><code>deriveSymmetricKey(protocolID: WalletProtocol, keyID: string, counterparty: Counterparty): SymmetricKey \n</code></pre> See also: Counterparty, SymmetricKey, WalletProtocol</p> <p>Returns</p> <ul> <li>The derived symmetric key.</li> </ul> <p>Argument Details</p> <ul> <li>protocolID</li> <li>The protocol ID including a security level and protocol name.</li> <li>keyID</li> <li>The key identifier.</li> <li>counterparty</li> <li>The counterparty's public key or a predefined value ('self' or 'anyone').</li> </ul> <p>Throws</p> <ul> <li>Throws an error if attempting to derive a symmetric key for 'anyone'.</li> </ul>"},{"location":"reference/wallet/#method-revealcounterpartysecret","title":"Method revealCounterpartySecret","text":"<p>Reveals the shared secret between the root key and the counterparty. Caches the result for future calls with the same parameters.</p> <p><pre><code>revealCounterpartySecret(counterparty: Counterparty): number[] \n</code></pre> See also: Counterparty</p> <p>Returns</p> <ul> <li>The shared secret as a number array.</li> </ul> <p>Argument Details</p> <ul> <li>counterparty</li> <li>The counterparty's public key or a predefined value ('self' or 'anyone').</li> </ul> <p>Throws</p> <ul> <li>Throws an error if attempting to reveal a shared secret for 'self'.</li> </ul>"},{"location":"reference/wallet/#method-revealspecificsecret","title":"Method revealSpecificSecret","text":"<p>Reveals the specific key association for a given protocol ID, key ID, and counterparty. Caches the result for future calls with the same parameters.</p> <p><pre><code>revealSpecificSecret(counterparty: Counterparty, protocolID: WalletProtocol, keyID: string): number[] \n</code></pre> See also: Counterparty, WalletProtocol</p> <p>Returns</p> <ul> <li>The specific key association as a number array.</li> </ul> <p>Argument Details</p> <ul> <li>counterparty</li> <li>The counterparty's public key or a predefined value ('self' or 'anyone').</li> <li>protocolID</li> <li>The protocol ID including a security level and protocol name.</li> <li>keyID</li> <li>The key identifier.</li> </ul> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#class-httpwalletjson","title":"Class: HTTPWalletJSON","text":"<pre><code>export default class HTTPWalletJSON implements WalletInterface {\n    baseUrl: string;\n    httpClient: typeof fetch;\n    originator: OriginatorDomainNameStringUnder250Bytes | undefined;\n    api: (call: string, args: object) =&gt; Promise&lt;unknown&gt;;\n    constructor(originator: OriginatorDomainNameStringUnder250Bytes | undefined, baseUrl: string = \"http://localhost:3321\", httpClient = fetch) \n    async createAction(args: CreateActionArgs): Promise&lt;CreateActionResult&gt; \n    async signAction(args: SignActionArgs): Promise&lt;SignActionResult&gt; \n    async abortAction(args: {\n        reference: Base64String;\n    }): Promise&lt;{\n        aborted: true;\n    }&gt; \n    async listActions(args: ListActionsArgs): Promise&lt;ListActionsResult&gt; \n    async internalizeAction(args: InternalizeActionArgs): Promise&lt;{\n        accepted: true;\n    }&gt; \n    async listOutputs(args: ListOutputsArgs): Promise&lt;ListOutputsResult&gt; \n    async relinquishOutput(args: {\n        basket: BasketStringUnder300Bytes;\n        output: OutpointString;\n    }): Promise&lt;{\n        relinquished: true;\n    }&gt; \n    async getPublicKey(args: {\n        seekPermission?: BooleanDefaultTrue;\n        identityKey?: true;\n        protocolID?: [\n            SecurityLevel,\n            ProtocolString5To400Bytes\n        ];\n        keyID?: KeyIDStringUnder800Bytes;\n        privileged?: BooleanDefaultFalse;\n        privilegedReason?: DescriptionString5to50Bytes;\n        counterparty?: PubKeyHex | \"self\" | \"anyone\";\n        forSelf?: BooleanDefaultFalse;\n    }): Promise&lt;{\n        publicKey: PubKeyHex;\n    }&gt; \n    async revealCounterpartyKeyLinkage(args: {\n        counterparty: PubKeyHex;\n        verifier: PubKeyHex;\n        privilegedReason?: DescriptionString5to50Bytes;\n        privileged?: BooleanDefaultFalse;\n    }): Promise&lt;{\n        prover: PubKeyHex;\n        verifier: PubKeyHex;\n        counterparty: PubKeyHex;\n        revelationTime: ISOTimestampString;\n        encryptedLinkage: Byte[];\n        encryptedLinkageProof: number[];\n    }&gt; \n    async revealSpecificKeyLinkage(args: {\n        counterparty: PubKeyHex;\n        verifier: PubKeyHex;\n        protocolID: [\n            SecurityLevel,\n            ProtocolString5To400Bytes\n        ];\n        keyID: KeyIDStringUnder800Bytes;\n        privilegedReason?: DescriptionString5to50Bytes;\n        privileged?: BooleanDefaultFalse;\n    }): Promise&lt;{\n        prover: PubKeyHex;\n        verifier: PubKeyHex;\n        counterparty: PubKeyHex;\n        protocolID: [\n            SecurityLevel,\n            ProtocolString5To400Bytes\n        ];\n        keyID: KeyIDStringUnder800Bytes;\n        encryptedLinkage: Byte[];\n        encryptedLinkageProof: Byte[];\n        proofType: Byte;\n    }&gt; \n    async encrypt(args: {\n        seekPermission?: BooleanDefaultTrue;\n        plaintext: Byte[];\n        protocolID: [\n            SecurityLevel,\n            ProtocolString5To400Bytes\n        ];\n        keyID: KeyIDStringUnder800Bytes;\n        privilegedReason?: DescriptionString5to50Bytes;\n        counterparty?: PubKeyHex | \"self\" | \"anyone\";\n        privileged?: BooleanDefaultFalse;\n    }): Promise&lt;{\n        ciphertext: Byte[];\n    }&gt; \n    async decrypt(args: {\n        seekPermission?: BooleanDefaultTrue;\n        ciphertext: Byte[];\n        protocolID: [\n            SecurityLevel,\n            ProtocolString5To400Bytes\n        ];\n        keyID: KeyIDStringUnder800Bytes;\n        privilegedReason?: DescriptionString5to50Bytes;\n        counterparty?: PubKeyHex | \"self\" | \"anyone\";\n        privileged?: BooleanDefaultFalse;\n    }): Promise&lt;{\n        plaintext: Byte[];\n    }&gt; \n    async createHmac(args: {\n        seekPermission?: BooleanDefaultTrue;\n        data: Byte[];\n        protocolID: [\n            SecurityLevel,\n            ProtocolString5To400Bytes\n        ];\n        keyID: KeyIDStringUnder800Bytes;\n        privilegedReason?: DescriptionString5to50Bytes;\n        counterparty?: PubKeyHex | \"self\" | \"anyone\";\n        privileged?: BooleanDefaultFalse;\n    }): Promise&lt;{\n        hmac: Byte[];\n    }&gt; \n    async verifyHmac(args: {\n        seekPermission?: BooleanDefaultTrue;\n        data: Byte[];\n        hmac: Byte[];\n        protocolID: [\n            SecurityLevel,\n            ProtocolString5To400Bytes\n        ];\n        keyID: KeyIDStringUnder800Bytes;\n        privilegedReason?: DescriptionString5to50Bytes;\n        counterparty?: PubKeyHex | \"self\" | \"anyone\";\n        privileged?: BooleanDefaultFalse;\n    }): Promise&lt;{\n        valid: true;\n    }&gt; \n    async createSignature(args: {\n        seekPermission?: BooleanDefaultTrue;\n        data?: Byte[];\n        hashToDirectlySign?: Byte[];\n        protocolID: [\n            SecurityLevel,\n            ProtocolString5To400Bytes\n        ];\n        keyID: KeyIDStringUnder800Bytes;\n        privilegedReason?: DescriptionString5to50Bytes;\n        counterparty?: PubKeyHex | \"self\" | \"anyone\";\n        privileged?: BooleanDefaultFalse;\n    }): Promise&lt;{\n        signature: Byte[];\n    }&gt; \n    async verifySignature(args: {\n        seekPermission?: BooleanDefaultTrue;\n        data?: Byte[];\n        hashToDirectlyVerify?: Byte[];\n        signature: Byte[];\n        protocolID: [\n            SecurityLevel,\n            ProtocolString5To400Bytes\n        ];\n        keyID: KeyIDStringUnder800Bytes;\n        privilegedReason?: DescriptionString5to50Bytes;\n        counterparty?: PubKeyHex | \"self\" | \"anyone\";\n        forSelf?: BooleanDefaultFalse;\n        privileged?: BooleanDefaultFalse;\n    }): Promise&lt;{\n        valid: true;\n    }&gt; \n    async acquireCertificate(args: AcquireCertificateArgs): Promise&lt;AcquireCertificateResult&gt; \n    async listCertificates(args: {\n        certifiers: PubKeyHex[];\n        types: Base64String[];\n        limit?: PositiveIntegerDefault10Max10000;\n        offset?: PositiveIntegerOrZero;\n        privileged?: BooleanDefaultFalse;\n        privilegedReason?: DescriptionString5to50Bytes;\n    }): Promise&lt;ListCertificatesResult&gt; \n    async proveCertificate(args: ProveCertificateArgs): Promise&lt;ProveCertificateResult&gt; \n    async relinquishCertificate(args: {\n        type: Base64String;\n        serialNumber: Base64String;\n        certifier: PubKeyHex;\n    }): Promise&lt;{\n        relinquished: true;\n    }&gt; \n    async discoverByIdentityKey(args: {\n        seekPermission?: BooleanDefaultTrue;\n        identityKey: PubKeyHex;\n        limit?: PositiveIntegerDefault10Max10000;\n        offset?: PositiveIntegerOrZero;\n    }): Promise&lt;DiscoverCertificatesResult&gt; \n    async discoverByAttributes(args: {\n        seekPermission?: BooleanDefaultTrue;\n        attributes: Record&lt;CertificateFieldNameUnder50Bytes, string&gt;;\n        limit?: PositiveIntegerDefault10Max10000;\n        offset?: PositiveIntegerOrZero;\n    }): Promise&lt;DiscoverCertificatesResult&gt; \n    async isAuthenticated(args: object): Promise&lt;{\n        authenticated: true;\n    }&gt; \n    async waitForAuthentication(args: object): Promise&lt;{\n        authenticated: true;\n    }&gt; \n    async getHeight(args: object): Promise&lt;{\n        height: PositiveInteger;\n    }&gt; \n    async getHeaderForHeight(args: {\n        height: PositiveInteger;\n    }): Promise&lt;{\n        header: HexString;\n    }&gt; \n    async getNetwork(args: object): Promise&lt;{\n        network: \"mainnet\" | \"testnet\";\n    }&gt; \n    async getVersion(args: object): Promise&lt;{\n        version: VersionString7To30Bytes;\n    }&gt; \n}\n</code></pre> <p>See also: AcquireCertificateArgs, AcquireCertificateResult, Base64String, BasketStringUnder300Bytes, BooleanDefaultFalse, BooleanDefaultTrue, Byte, CertificateFieldNameUnder50Bytes, CreateActionArgs, CreateActionResult, DescriptionString5to50Bytes, DiscoverCertificatesResult, HexString, ISOTimestampString, InternalizeActionArgs, KeyIDStringUnder800Bytes, ListActionsArgs, ListActionsResult, ListCertificatesResult, ListOutputsArgs, ListOutputsResult, OriginatorDomainNameStringUnder250Bytes, OutpointString, PositiveInteger, PositiveIntegerDefault10Max10000, PositiveIntegerOrZero, ProtocolString5To400Bytes, ProveCertificateArgs, ProveCertificateResult, PubKeyHex, SecurityLevel, SignActionArgs, SignActionResult, VersionString7To30Bytes, WalletInterface, decrypt, encrypt</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#class-httpwalletwire","title":"Class: HTTPWalletWire","text":"<pre><code>export default class HTTPWalletWire implements WalletWire {\n    baseUrl: string;\n    httpClient: typeof fetch;\n    originator: string | undefined;\n    constructor(originator: string | undefined, baseUrl: string = \"http://localhost:3301\", httpClient = fetch) \n    async transmitToWallet(message: number[]): Promise&lt;number[]&gt; \n}\n</code></pre> <p>See also: WalletWire</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#class-keyderiver","title":"Class: KeyDeriver","text":"<p>Class responsible for deriving various types of keys using a root private key. It supports deriving public and private keys, symmetric keys, and revealing key linkages.</p> <pre><code>export class KeyDeriver implements KeyDeriverApi {\n    rootKey: PrivateKey;\n    identityKey: string;\n    constructor(rootKey: PrivateKey | \"anyone\", private readonly cacheSharedSecret?: ((priv: PrivateKey, pub: Point, point: Point) =&gt; void), private readonly retrieveCachedSharedSecret?: ((priv: PrivateKey, pub: Point) =&gt; (Point | undefined))) \n    derivePublicKey(protocolID: WalletProtocol, keyID: string, counterparty: Counterparty, forSelf: boolean = false): PublicKey \n    derivePrivateKey(protocolID: WalletProtocol, keyID: string, counterparty: Counterparty): PrivateKey \n    deriveSymmetricKey(protocolID: WalletProtocol, keyID: string, counterparty: Counterparty): SymmetricKey \n    revealCounterpartySecret(counterparty: Counterparty): number[] \n    revealSpecificSecret(counterparty: Counterparty, protocolID: WalletProtocol, keyID: string): number[] \n}\n</code></pre> <p>See also: Counterparty, KeyDeriverApi, Point, PrivateKey, PublicKey, SymmetricKey, WalletProtocol</p>"},{"location":"reference/wallet/#constructor_1","title":"Constructor","text":"<p>Initializes the KeyDeriver instance with a root private key.</p> <p><pre><code>constructor(rootKey: PrivateKey | \"anyone\", private readonly cacheSharedSecret?: ((priv: PrivateKey, pub: Point, point: Point) =&gt; void), private readonly retrieveCachedSharedSecret?: ((priv: PrivateKey, pub: Point) =&gt; (Point | undefined))) \n</code></pre> See also: Point, PrivateKey</p> <p>Argument Details</p> <ul> <li>rootKey</li> <li>The root private key or the string 'anyone'.</li> </ul>"},{"location":"reference/wallet/#method-deriveprivatekey_1","title":"Method derivePrivateKey","text":"<p>Derives a private key based on protocol ID, key ID, and counterparty.</p> <p><pre><code>derivePrivateKey(protocolID: WalletProtocol, keyID: string, counterparty: Counterparty): PrivateKey \n</code></pre> See also: Counterparty, PrivateKey, WalletProtocol</p> <p>Returns</p> <ul> <li>The derived private key.</li> </ul> <p>Argument Details</p> <ul> <li>protocolID</li> <li>The protocol ID including a security level and protocol name.</li> <li>keyID</li> <li>The key identifier.</li> <li>counterparty</li> <li>The counterparty's public key or a predefined value ('self' or 'anyone').</li> </ul>"},{"location":"reference/wallet/#method-derivepublickey_1","title":"Method derivePublicKey","text":"<p>Derives a public key based on protocol ID, key ID, and counterparty.</p> <p><pre><code>derivePublicKey(protocolID: WalletProtocol, keyID: string, counterparty: Counterparty, forSelf: boolean = false): PublicKey \n</code></pre> See also: Counterparty, PublicKey, WalletProtocol</p> <p>Returns</p> <ul> <li>The derived public key.</li> </ul> <p>Argument Details</p> <ul> <li>protocolID</li> <li>The protocol ID including a security level and protocol name.</li> <li>keyID</li> <li>The key identifier.</li> <li>counterparty</li> <li>The counterparty's public key or a predefined value ('self' or 'anyone').</li> <li>forSelf</li> <li>Whether deriving for self.</li> </ul>"},{"location":"reference/wallet/#method-derivesymmetrickey_1","title":"Method deriveSymmetricKey","text":"<p>Derives a symmetric key based on protocol ID, key ID, and counterparty. Note: Symmetric keys should not be derivable by everyone due to security risks.</p> <p><pre><code>deriveSymmetricKey(protocolID: WalletProtocol, keyID: string, counterparty: Counterparty): SymmetricKey \n</code></pre> See also: Counterparty, SymmetricKey, WalletProtocol</p> <p>Returns</p> <ul> <li>The derived symmetric key.</li> </ul> <p>Argument Details</p> <ul> <li>protocolID</li> <li>The protocol ID including a security level and protocol name.</li> <li>keyID</li> <li>The key identifier.</li> <li>counterparty</li> <li>The counterparty's public key or a predefined value ('self' or 'anyone').</li> </ul>"},{"location":"reference/wallet/#method-revealcounterpartysecret_1","title":"Method revealCounterpartySecret","text":"<p>Reveals the shared secret between the root key and the counterparty. Note: This should not be used for 'self'.</p> <p><pre><code>revealCounterpartySecret(counterparty: Counterparty): number[] \n</code></pre> See also: Counterparty</p> <p>Returns</p> <ul> <li>The shared secret as a number array.</li> </ul> <p>Argument Details</p> <ul> <li>counterparty</li> <li>The counterparty's public key or a predefined value ('self' or 'anyone').</li> </ul> <p>Throws</p> <ul> <li>Throws an error if attempting to reveal a shared secret for 'self'.</li> </ul>"},{"location":"reference/wallet/#method-revealspecificsecret_1","title":"Method revealSpecificSecret","text":"<p>Reveals the specific key association for a given protocol ID, key ID, and counterparty.</p> <p><pre><code>revealSpecificSecret(counterparty: Counterparty, protocolID: WalletProtocol, keyID: string): number[] \n</code></pre> See also: Counterparty, WalletProtocol</p> <p>Returns</p> <ul> <li>The specific key association as a number array.</li> </ul> <p>Argument Details</p> <ul> <li>counterparty</li> <li>The counterparty's public key or a predefined value ('self' or 'anyone').</li> <li>protocolID</li> <li>The protocol ID including a security level and protocol name.</li> <li>keyID</li> <li>The key identifier.</li> </ul> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#class-protowallet","title":"Class: ProtoWallet","text":"<p>A ProtoWallet is precursor to a full wallet, capable of performing all foundational cryptographic operations. It can derive keys, create signatures, facilitate encryption and HMAC operations, and reveal key linkages.</p> <p>However, ProtoWallet does not create transactions, manage outputs, interact with the blockchain, enable the management of identity certificates, or store any data. It is also not concerned with privileged keys.</p> <pre><code>export class ProtoWallet {\n    keyDeriver?: KeyDeriverApi;\n    constructor(rootKeyOrKeyDeriver?: PrivateKey | \"anyone\" | KeyDeriverApi) \n    async getPublicKey(args: GetPublicKeyArgs): Promise&lt;{\n        publicKey: PubKeyHex;\n    }&gt; \n    async revealCounterpartyKeyLinkage(args: RevealCounterpartyKeyLinkageArgs): Promise&lt;RevealCounterpartyKeyLinkageResult&gt; \n    async revealSpecificKeyLinkage(args: RevealSpecificKeyLinkageArgs): Promise&lt;RevealSpecificKeyLinkageResult&gt; \n    async encrypt(args: WalletEncryptArgs): Promise&lt;WalletEncryptResult&gt; \n    async decrypt(args: WalletDecryptArgs, originator?: string): Promise&lt;WalletDecryptResult&gt; \n    async createHmac(args: CreateHmacArgs): Promise&lt;CreateHmacResult&gt; \n    async verifyHmac(args: VerifyHmacArgs): Promise&lt;VerifyHmacResult&gt; \n    async createSignature(args: CreateSignatureArgs): Promise&lt;CreateSignatureResult&gt; \n    async verifySignature(args: VerifySignatureArgs): Promise&lt;VerifySignatureResult&gt; \n}\n</code></pre> <p>See also: CreateHmacArgs, CreateHmacResult, CreateSignatureArgs, CreateSignatureResult, GetPublicKeyArgs, KeyDeriverApi, PrivateKey, PubKeyHex, RevealCounterpartyKeyLinkageArgs, RevealCounterpartyKeyLinkageResult, RevealSpecificKeyLinkageArgs, RevealSpecificKeyLinkageResult, VerifyHmacArgs, VerifyHmacResult, VerifySignatureArgs, VerifySignatureResult, WalletDecryptArgs, WalletDecryptResult, WalletEncryptArgs, WalletEncryptResult, decrypt, encrypt</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#class-reactnativewebview","title":"Class: ReactNativeWebView","text":"<p>Facilitates wallet operations over cross-document messaging.</p> <pre><code>export default class ReactNativeWebView implements WalletInterface {\n    constructor(domain: string = \"*\") \n    async invoke(call: CallType, args: any): Promise&lt;any&gt; \n    async createAction(args: {\n        description: DescriptionString5to50Bytes;\n        inputs?: Array&lt;{\n            tx?: BEEF;\n            outpoint: OutpointString;\n            unlockingScript?: HexString;\n            unlockingScriptLength?: PositiveInteger;\n            inputDescription: DescriptionString5to50Bytes;\n            sequenceNumber?: PositiveIntegerOrZero;\n        }&gt;;\n        outputs?: Array&lt;{\n            lockingScript: HexString;\n            satoshis: SatoshiValue;\n            outputDescription: DescriptionString5to50Bytes;\n            basket?: BasketStringUnder300Bytes;\n            customInstructions?: string;\n            tags?: OutputTagStringUnder300Bytes[];\n        }&gt;;\n        lockTime?: PositiveIntegerOrZero;\n        version?: PositiveIntegerOrZero;\n        labels?: LabelStringUnder300Bytes[];\n        options?: {\n            signAndProcess?: BooleanDefaultTrue;\n            acceptDelayedBroadcast?: BooleanDefaultTrue;\n            trustSelf?: \"known\";\n            knownTxids?: TXIDHexString[];\n            returnTXIDOnly?: BooleanDefaultFalse;\n            noSend?: BooleanDefaultFalse;\n            noSendChange?: OutpointString[];\n            sendWith?: TXIDHexString[];\n        };\n    }): Promise&lt;{\n        txid?: TXIDHexString;\n        tx?: BEEF;\n        noSendChange?: OutpointString[];\n        sendWithResults?: Array&lt;{\n            txid: TXIDHexString;\n            status: \"unproven\" | \"sending\" | \"failed\";\n        }&gt;;\n        signableTransaction?: {\n            tx: BEEF;\n            reference: Base64String;\n        };\n    }&gt; \n    async signAction(args: {\n        spends: Record&lt;PositiveIntegerOrZero, {\n            unlockingScript: HexString;\n            sequenceNumber?: PositiveIntegerOrZero;\n        }&gt;;\n        reference: Base64String;\n        options?: {\n            acceptDelayedBroadcast?: BooleanDefaultTrue;\n            returnTXIDOnly?: BooleanDefaultFalse;\n            noSend?: BooleanDefaultFalse;\n            noSendChange?: OutpointString[];\n            sendWith: TXIDHexString[];\n        };\n    }): Promise&lt;{\n        txid?: TXIDHexString;\n        tx?: BEEF;\n        noSendChange?: OutpointString[];\n        sendWithResults?: Array&lt;{\n            txid: TXIDHexString;\n            status: \"unproven\" | \"sending\" | \"failed\";\n        }&gt;;\n    }&gt; \n    async abortAction(args: {\n        reference: Base64String;\n    }): Promise&lt;{\n        aborted: true;\n    }&gt; \n    async listActions(args: {\n        labels: LabelStringUnder300Bytes[];\n        labelQueryMode?: \"any\" | \"all\";\n        includeLabels?: BooleanDefaultFalse;\n        includeInputs?: BooleanDefaultFalse;\n        includeInputSourceLockingScripts?: BooleanDefaultFalse;\n        includeInputUnlockingScripts?: BooleanDefaultFalse;\n        includeOutputs?: BooleanDefaultFalse;\n        includeOutputLockingScripts?: BooleanDefaultFalse;\n        limit?: PositiveIntegerDefault10Max10000;\n        offset?: PositiveIntegerOrZero;\n    }): Promise&lt;{\n        totalActions: PositiveIntegerOrZero;\n        actions: Array&lt;{\n            txid: TXIDHexString;\n            satoshis: SatoshiValue;\n            status: \"completed\" | \"unprocessed\" | \"sending\" | \"unproven\" | \"unsigned\" | \"nosend\" | \"nonfinal\";\n            isOutgoing: boolean;\n            description: DescriptionString5to50Bytes;\n            labels?: LabelStringUnder300Bytes[];\n            version: PositiveIntegerOrZero;\n            lockTime: PositiveIntegerOrZero;\n            inputs?: Array&lt;{\n                sourceOutpoint: OutpointString;\n                sourceSatoshis: SatoshiValue;\n                sourceLockingScript?: HexString;\n                unlockingScript?: HexString;\n                inputDescription: DescriptionString5to50Bytes;\n                sequenceNumber: PositiveIntegerOrZero;\n            }&gt;;\n            outputs?: Array&lt;{\n                outputIndex: PositiveIntegerOrZero;\n                satoshis: SatoshiValue;\n                lockingScript?: HexString;\n                spendable: boolean;\n                outputDescription: DescriptionString5to50Bytes;\n                basket: BasketStringUnder300Bytes;\n                tags: OutputTagStringUnder300Bytes[];\n                customInstructions?: string;\n            }&gt;;\n        }&gt;;\n    }&gt; \n    async internalizeAction(args: {\n        tx: BEEF;\n        outputs: Array&lt;{\n            outputIndex: PositiveIntegerOrZero;\n            protocol: \"wallet payment\" | \"basket insertion\";\n            paymentRemittance?: {\n                derivationPrefix: Base64String;\n                derivationSuffix: Base64String;\n                senderIdentityKey: PubKeyHex;\n            };\n            insertionRemittance?: {\n                basket: BasketStringUnder300Bytes;\n                customInstructions?: string;\n                tags?: OutputTagStringUnder300Bytes[];\n            };\n        }&gt;;\n        description: DescriptionString5to50Bytes;\n        labels?: LabelStringUnder300Bytes[];\n    }): Promise&lt;{\n        accepted: true;\n    }&gt; \n    async listOutputs(args: {\n        basket: BasketStringUnder300Bytes;\n        tags?: OutputTagStringUnder300Bytes[];\n        tagQueryMode?: \"all\" | \"any\";\n        include?: \"locking scripts\" | \"entire transactions\";\n        includeCustomInstructions?: BooleanDefaultFalse;\n        includeTags?: BooleanDefaultFalse;\n        includeLabels?: BooleanDefaultFalse;\n        limit?: PositiveIntegerDefault10Max10000;\n        offset?: PositiveIntegerOrZero;\n    }): Promise&lt;{\n        totalOutputs: PositiveIntegerOrZero;\n        outputs: Array&lt;{\n            outpoint: OutpointString;\n            satoshis: SatoshiValue;\n            lockingScript?: HexString;\n            tx?: BEEF;\n            spendable: boolean;\n            customInstructions?: string;\n            tags?: OutputTagStringUnder300Bytes[];\n            labels?: LabelStringUnder300Bytes[];\n        }&gt;;\n    }&gt; \n    async relinquishOutput(args: {\n        basket: BasketStringUnder300Bytes;\n        output: OutpointString;\n    }): Promise&lt;{\n        relinquished: true;\n    }&gt; \n    async getPublicKey(args: {\n        identityKey?: true;\n        protocolID?: [\n            SecurityLevel,\n            ProtocolString5To400Bytes\n        ];\n        keyID?: KeyIDStringUnder800Bytes;\n        privileged?: BooleanDefaultFalse;\n        privilegedReason?: DescriptionString5to50Bytes;\n        counterparty?: PubKeyHex | \"self\" | \"anyone\";\n        forSelf?: BooleanDefaultFalse;\n    }): Promise&lt;{\n        publicKey: PubKeyHex;\n    }&gt; \n    async revealCounterpartyKeyLinkage(args: {\n        counterparty: PubKeyHex;\n        verifier: PubKeyHex;\n        privilegedReason?: DescriptionString5to50Bytes;\n        privileged?: BooleanDefaultFalse;\n    }): Promise&lt;{\n        prover: PubKeyHex;\n        verifier: PubKeyHex;\n        counterparty: PubKeyHex;\n        revelationTime: ISOTimestampString;\n        encryptedLinkage: Byte[];\n        encryptedLinkageProof: Byte[];\n    }&gt; \n    async revealSpecificKeyLinkage(args: {\n        counterparty: PubKeyHex;\n        verifier: PubKeyHex;\n        protocolID: [\n            SecurityLevel,\n            ProtocolString5To400Bytes\n        ];\n        keyID: KeyIDStringUnder800Bytes;\n        privilegedReason?: DescriptionString5to50Bytes;\n        privileged?: BooleanDefaultFalse;\n    }): Promise&lt;{\n        prover: PubKeyHex;\n        verifier: PubKeyHex;\n        counterparty: PubKeyHex;\n        protocolID: [\n            SecurityLevel,\n            ProtocolString5To400Bytes\n        ];\n        keyID: KeyIDStringUnder800Bytes;\n        encryptedLinkage: Byte[];\n        encryptedLinkageProof: Byte[];\n        proofType: Byte;\n    }&gt; \n    async encrypt(args: {\n        plaintext: Byte[];\n        protocolID: [\n            SecurityLevel,\n            ProtocolString5To400Bytes\n        ];\n        keyID: KeyIDStringUnder800Bytes;\n        privilegedReason?: DescriptionString5to50Bytes;\n        counterparty?: PubKeyHex | \"self\" | \"anyone\";\n        privileged?: BooleanDefaultFalse;\n    }): Promise&lt;{\n        ciphertext: Byte[];\n    }&gt; \n    async decrypt(args: {\n        ciphertext: Byte[];\n        protocolID: [\n            SecurityLevel,\n            ProtocolString5To400Bytes\n        ];\n        keyID: KeyIDStringUnder800Bytes;\n        privilegedReason?: DescriptionString5to50Bytes;\n        counterparty?: PubKeyHex | \"self\" | \"anyone\";\n        privileged?: BooleanDefaultFalse;\n    }): Promise&lt;{\n        plaintext: Byte[];\n    }&gt; \n    async createHmac(args: {\n        data: Byte[];\n        protocolID: [\n            SecurityLevel,\n            ProtocolString5To400Bytes\n        ];\n        keyID: KeyIDStringUnder800Bytes;\n        privilegedReason?: DescriptionString5to50Bytes;\n        counterparty?: PubKeyHex | \"self\" | \"anyone\";\n        privileged?: BooleanDefaultFalse;\n    }): Promise&lt;{\n        hmac: Byte[];\n    }&gt; \n    async verifyHmac(args: {\n        data: Byte[];\n        hmac: Byte[];\n        protocolID: [\n            SecurityLevel,\n            ProtocolString5To400Bytes\n        ];\n        keyID: KeyIDStringUnder800Bytes;\n        privilegedReason?: DescriptionString5to50Bytes;\n        counterparty?: PubKeyHex | \"self\" | \"anyone\";\n        privileged?: BooleanDefaultFalse;\n    }): Promise&lt;{\n        valid: true;\n    }&gt; \n    async createSignature(args: {\n        data?: Byte[];\n        hashToDirectlySign?: Byte[];\n        protocolID: [\n            SecurityLevel,\n            ProtocolString5To400Bytes\n        ];\n        keyID: KeyIDStringUnder800Bytes;\n        privilegedReason?: DescriptionString5to50Bytes;\n        counterparty?: PubKeyHex | \"self\" | \"anyone\";\n        privileged?: BooleanDefaultFalse;\n    }): Promise&lt;{\n        signature: Byte[];\n    }&gt; \n    async verifySignature(args: {\n        data?: Byte[];\n        hashToDirectlyVerify?: Byte[];\n        signature: Byte[];\n        protocolID: [\n            SecurityLevel,\n            ProtocolString5To400Bytes\n        ];\n        keyID: KeyIDStringUnder800Bytes;\n        privilegedReason?: DescriptionString5to50Bytes;\n        counterparty?: PubKeyHex | \"self\" | \"anyone\";\n        forSelf?: BooleanDefaultFalse;\n        privileged?: BooleanDefaultFalse;\n    }): Promise&lt;{\n        valid: true;\n    }&gt; \n    async acquireCertificate(args: {\n        type: Base64String;\n        subject: PubKeyHex;\n        serialNumber: Base64String;\n        revocationOutpoint: OutpointString;\n        signature: HexString;\n        fields: Record&lt;CertificateFieldNameUnder50Bytes, string&gt;;\n        certifier: PubKeyHex;\n        keyringRevealer: PubKeyHex | \"certifier\";\n        keyringForSubject: Record&lt;CertificateFieldNameUnder50Bytes, Base64String&gt;;\n        acquisitionProtocol: \"direct\" | \"issuance\";\n        certifierUrl?: string;\n    }): Promise&lt;{\n        type: Base64String;\n        subject: PubKeyHex;\n        serialNumber: Base64String;\n        certifier: PubKeyHex;\n        revocationOutpoint: OutpointString;\n        signature: HexString;\n        fields: Record&lt;CertificateFieldNameUnder50Bytes, string&gt;;\n    }&gt; \n    async listCertificates(args: {\n        certifiers: PubKeyHex[];\n        types: Base64String[];\n        limit?: PositiveIntegerDefault10Max10000;\n        offset?: PositiveIntegerOrZero;\n        privileged?: BooleanDefaultFalse;\n        privilegedReason?: DescriptionString5to50Bytes;\n    }): Promise&lt;{\n        totalCertificates: PositiveIntegerOrZero;\n        certificates: Array&lt;{\n            type: Base64String;\n            subject: PubKeyHex;\n            serialNumber: Base64String;\n            certifier: PubKeyHex;\n            revocationOutpoint: OutpointString;\n            signature: HexString;\n            fields: Record&lt;CertificateFieldNameUnder50Bytes, string&gt;;\n        }&gt;;\n    }&gt; \n    async proveCertificate(args: {\n        certificate: {\n            type: Base64String;\n            subject: PubKeyHex;\n            serialNumber: Base64String;\n            certifier: PubKeyHex;\n            revocationOutpoint: OutpointString;\n            signature: HexString;\n            fields: Record&lt;CertificateFieldNameUnder50Bytes, string&gt;;\n        };\n        fieldsToReveal: CertificateFieldNameUnder50Bytes[];\n        verifier: PubKeyHex;\n        privileged?: BooleanDefaultFalse;\n        privilegedReason?: DescriptionString5to50Bytes;\n    }): Promise&lt;{\n        keyringForVerifier: Record&lt;CertificateFieldNameUnder50Bytes, Base64String&gt;;\n    }&gt; \n    async relinquishCertificate(args: {\n        type: Base64String;\n        serialNumber: Base64String;\n        certifier: PubKeyHex;\n    }): Promise&lt;{\n        relinquished: true;\n    }&gt; \n    async discoverByIdentityKey(args: {\n        identityKey: PubKeyHex;\n        limit?: PositiveIntegerDefault10Max10000;\n        offset?: PositiveIntegerOrZero;\n    }): Promise&lt;{\n        totalCertificates: PositiveIntegerOrZero;\n        certificates: Array&lt;{\n            type: Base64String;\n            subject: PubKeyHex;\n            serialNumber: Base64String;\n            certifier: PubKeyHex;\n            revocationOutpoint: OutpointString;\n            signature: HexString;\n            fields: Record&lt;CertificateFieldNameUnder50Bytes, Base64String&gt;;\n            certifierInfo: {\n                name: EntityNameStringMax100Bytes;\n                iconUrl: EntityIconURLStringMax500Bytes;\n                description: DescriptionString5to50Bytes;\n                trust: PositiveIntegerMax10;\n            };\n            publiclyRevealedKeyring: Record&lt;CertificateFieldNameUnder50Bytes, Base64String&gt;;\n            decryptedFields: Record&lt;CertificateFieldNameUnder50Bytes, string&gt;;\n        }&gt;;\n    }&gt; \n    async discoverByAttributes(args: {\n        attributes: Record&lt;CertificateFieldNameUnder50Bytes, string&gt;;\n        limit?: PositiveIntegerDefault10Max10000;\n        offset?: PositiveIntegerOrZero;\n    }): Promise&lt;{\n        totalCertificates: PositiveIntegerOrZero;\n        certificates: Array&lt;{\n            type: Base64String;\n            subject: PubKeyHex;\n            serialNumber: Base64String;\n            certifier: PubKeyHex;\n            revocationOutpoint: OutpointString;\n            signature: HexString;\n            fields: Record&lt;CertificateFieldNameUnder50Bytes, Base64String&gt;;\n            certifierInfo: {\n                name: EntityNameStringMax100Bytes;\n                iconUrl: EntityIconURLStringMax500Bytes;\n                description: DescriptionString5to50Bytes;\n                trust: PositiveIntegerMax10;\n            };\n            publiclyRevealedKeyring: Record&lt;CertificateFieldNameUnder50Bytes, Base64String&gt;;\n            decryptedFields: Record&lt;CertificateFieldNameUnder50Bytes, string&gt;;\n        }&gt;;\n    }&gt; \n    async isAuthenticated(args: {}): Promise&lt;{\n        authenticated: true;\n    }&gt; \n    async waitForAuthentication(args: {}): Promise&lt;{\n        authenticated: true;\n    }&gt; \n    async getHeight(args: {}): Promise&lt;{\n        height: PositiveInteger;\n    }&gt; \n    async getHeaderForHeight(args: {\n        height: PositiveInteger;\n    }): Promise&lt;{\n        header: HexString;\n    }&gt; \n    async getNetwork(args: {}): Promise&lt;{\n        network: \"mainnet\" | \"testnet\";\n    }&gt; \n    async getVersion(args: {}): Promise&lt;{\n        version: VersionString7To30Bytes;\n    }&gt; \n}\n</code></pre> <p>See also: BEEF, Base64String, BasketStringUnder300Bytes, BooleanDefaultFalse, BooleanDefaultTrue, Byte, CallType, CertificateFieldNameUnder50Bytes, DescriptionString5to50Bytes, EntityIconURLStringMax500Bytes, EntityNameStringMax100Bytes, HexString, ISOTimestampString, KeyIDStringUnder800Bytes, LabelStringUnder300Bytes, OutpointString, OutputTagStringUnder300Bytes, PositiveInteger, PositiveIntegerDefault10Max10000, PositiveIntegerMax10, PositiveIntegerOrZero, ProtocolString5To400Bytes, PubKeyHex, SatoshiValue, SecurityLevel, TXIDHexString, VersionString7To30Bytes, WalletInterface, decrypt, encrypt</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#class-werr_review_actions","title":"Class: WERR_REVIEW_ACTIONS","text":"<p>When a <code>createAction</code> or <code>signAction</code> is completed in undelayed mode (<code>acceptDelayedBroadcast</code>: false), any unsucccessful result will return the results by way of this exception to ensure attention is paid to processing errors.</p> <pre><code>export class WERR_REVIEW_ACTIONS extends Error {\n    code: number;\n    isError: boolean = true;\n    constructor(public reviewActionResults: ReviewActionResult[], public sendWithResults: SendWithResult[], public txid?: TXIDHexString, public tx?: AtomicBEEF, public noSendChange?: OutpointString[]) \n}\n</code></pre> <p>See also: AtomicBEEF, OutpointString, ReviewActionResult, SendWithResult, TXIDHexString</p>"},{"location":"reference/wallet/#constructor_2","title":"Constructor","text":"<p>All parameters correspond to their comparable <code>createAction</code> or <code>signSction</code> results with the exception of <code>reviewActionResults</code>; which contains more details, particularly for double spend results.</p> <p><pre><code>constructor(public reviewActionResults: ReviewActionResult[], public sendWithResults: SendWithResult[], public txid?: TXIDHexString, public tx?: AtomicBEEF, public noSendChange?: OutpointString[]) \n</code></pre> See also: AtomicBEEF, OutpointString, ReviewActionResult, SendWithResult, TXIDHexString</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#class-walletclient","title":"Class: WalletClient","text":"<p>The SDK is how applications communicate with wallets over a communications substrate.</p> <pre><code>export default class WalletClient implements WalletInterface {\n    public substrate: \"auto\" | WalletInterface;\n    originator?: OriginatorDomainNameStringUnder250Bytes;\n    constructor(substrate: \"auto\" | \"Cicada\" | \"XDM\" | \"window.CWI\" | \"json-api\" | \"react-native\" | \"secure-json-api\" | WalletInterface = \"auto\", originator?: OriginatorDomainNameStringUnder250Bytes) \n    async connectToSubstrate(): Promise&lt;void&gt; \n    async createAction(args: CreateActionArgs): Promise&lt;CreateActionResult&gt; \n    async signAction(args: SignActionArgs): Promise&lt;SignActionResult&gt; \n    async abortAction(args: {\n        reference: Base64String;\n    }): Promise&lt;{\n        aborted: true;\n    }&gt; \n    async listActions(args: ListActionsArgs): Promise&lt;ListActionsResult&gt; \n    async internalizeAction(args: InternalizeActionArgs): Promise&lt;{\n        accepted: true;\n    }&gt; \n    async listOutputs(args: ListOutputsArgs): Promise&lt;ListOutputsResult&gt; \n    async relinquishOutput(args: {\n        basket: BasketStringUnder300Bytes;\n        output: OutpointString;\n    }): Promise&lt;{\n        relinquished: true;\n    }&gt; \n    async getPublicKey(args: {\n        identityKey?: true;\n        protocolID?: [\n            SecurityLevel,\n            ProtocolString5To400Bytes\n        ];\n        keyID?: KeyIDStringUnder800Bytes;\n        privileged?: BooleanDefaultFalse;\n        privilegedReason?: DescriptionString5to50Bytes;\n        counterparty?: PubKeyHex | \"self\" | \"anyone\";\n        forSelf?: BooleanDefaultFalse;\n    }): Promise&lt;{\n        publicKey: PubKeyHex;\n    }&gt; \n    async revealCounterpartyKeyLinkage(args: {\n        counterparty: PubKeyHex;\n        verifier: PubKeyHex;\n        privilegedReason?: DescriptionString5to50Bytes;\n        privileged?: BooleanDefaultFalse;\n    }): Promise&lt;{\n        prover: PubKeyHex;\n        verifier: PubKeyHex;\n        counterparty: PubKeyHex;\n        revelationTime: ISOTimestampString;\n        encryptedLinkage: Byte[];\n        encryptedLinkageProof: Byte[];\n    }&gt; \n    async revealSpecificKeyLinkage(args: {\n        counterparty: PubKeyHex;\n        verifier: PubKeyHex;\n        protocolID: [\n            SecurityLevel,\n            ProtocolString5To400Bytes\n        ];\n        keyID: KeyIDStringUnder800Bytes;\n        privilegedReason?: DescriptionString5to50Bytes;\n        privileged?: BooleanDefaultFalse;\n    }): Promise&lt;{\n        prover: PubKeyHex;\n        verifier: PubKeyHex;\n        counterparty: PubKeyHex;\n        protocolID: [\n            SecurityLevel,\n            ProtocolString5To400Bytes\n        ];\n        keyID: KeyIDStringUnder800Bytes;\n        encryptedLinkage: Byte[];\n        encryptedLinkageProof: Byte[];\n        proofType: Byte;\n    }&gt; \n    async encrypt(args: {\n        plaintext: Byte[];\n        protocolID: [\n            SecurityLevel,\n            ProtocolString5To400Bytes\n        ];\n        keyID: KeyIDStringUnder800Bytes;\n        privilegedReason?: DescriptionString5to50Bytes;\n        counterparty?: PubKeyHex | \"self\" | \"anyone\";\n        privileged?: BooleanDefaultFalse;\n    }): Promise&lt;{\n        ciphertext: Byte[];\n    }&gt; \n    async decrypt(args: {\n        ciphertext: Byte[];\n        protocolID: [\n            SecurityLevel,\n            ProtocolString5To400Bytes\n        ];\n        keyID: KeyIDStringUnder800Bytes;\n        privilegedReason?: DescriptionString5to50Bytes;\n        counterparty?: PubKeyHex | \"self\" | \"anyone\";\n        privileged?: BooleanDefaultFalse;\n    }): Promise&lt;{\n        plaintext: Byte[];\n    }&gt; \n    async createHmac(args: {\n        data: Byte[];\n        protocolID: [\n            SecurityLevel,\n            ProtocolString5To400Bytes\n        ];\n        keyID: KeyIDStringUnder800Bytes;\n        privilegedReason?: DescriptionString5to50Bytes;\n        counterparty?: PubKeyHex | \"self\" | \"anyone\";\n        privileged?: BooleanDefaultFalse;\n    }): Promise&lt;{\n        hmac: Byte[];\n    }&gt; \n    async verifyHmac(args: {\n        data: Byte[];\n        hmac: Byte[];\n        protocolID: [\n            SecurityLevel,\n            ProtocolString5To400Bytes\n        ];\n        keyID: KeyIDStringUnder800Bytes;\n        privilegedReason?: DescriptionString5to50Bytes;\n        counterparty?: PubKeyHex | \"self\" | \"anyone\";\n        privileged?: BooleanDefaultFalse;\n    }): Promise&lt;{\n        valid: true;\n    }&gt; \n    async createSignature(args: {\n        data?: Byte[];\n        hashToDirectlySign?: Byte[];\n        protocolID: [\n            SecurityLevel,\n            ProtocolString5To400Bytes\n        ];\n        keyID: KeyIDStringUnder800Bytes;\n        privilegedReason?: DescriptionString5to50Bytes;\n        counterparty?: PubKeyHex | \"self\" | \"anyone\";\n        privileged?: BooleanDefaultFalse;\n    }): Promise&lt;{\n        signature: Byte[];\n    }&gt; \n    async verifySignature(args: {\n        data?: Byte[];\n        hashToDirectlyVerify?: Byte[];\n        signature: Byte[];\n        protocolID: [\n            SecurityLevel,\n            ProtocolString5To400Bytes\n        ];\n        keyID: KeyIDStringUnder800Bytes;\n        privilegedReason?: DescriptionString5to50Bytes;\n        counterparty?: PubKeyHex | \"self\" | \"anyone\";\n        forSelf?: BooleanDefaultFalse;\n        privileged?: BooleanDefaultFalse;\n    }): Promise&lt;{\n        valid: true;\n    }&gt; \n    async acquireCertificate(args: AcquireCertificateArgs): Promise&lt;AcquireCertificateResult&gt; \n    async listCertificates(args: {\n        certifiers: PubKeyHex[];\n        types: Base64String[];\n        limit?: PositiveIntegerDefault10Max10000;\n        offset?: PositiveIntegerOrZero;\n        privileged?: BooleanDefaultFalse;\n        privilegedReason?: DescriptionString5to50Bytes;\n    }): Promise&lt;ListCertificatesResult&gt; \n    async proveCertificate(args: ProveCertificateArgs): Promise&lt;ProveCertificateResult&gt; \n    async relinquishCertificate(args: {\n        type: Base64String;\n        serialNumber: Base64String;\n        certifier: PubKeyHex;\n    }): Promise&lt;{\n        relinquished: true;\n    }&gt; \n    async discoverByIdentityKey(args: {\n        identityKey: PubKeyHex;\n        limit?: PositiveIntegerDefault10Max10000;\n        offset?: PositiveIntegerOrZero;\n    }): Promise&lt;DiscoverCertificatesResult&gt; \n    async discoverByAttributes(args: {\n        attributes: Record&lt;CertificateFieldNameUnder50Bytes, string&gt;;\n        limit?: PositiveIntegerDefault10Max10000;\n        offset?: PositiveIntegerOrZero;\n    }): Promise&lt;DiscoverCertificatesResult&gt; \n    async isAuthenticated(args: object = {}): Promise&lt;AuthenticatedResult&gt; \n    async waitForAuthentication(args: object = {}): Promise&lt;{\n        authenticated: true;\n    }&gt; \n    async getHeight(args: object = {}): Promise&lt;{\n        height: PositiveInteger;\n    }&gt; \n    async getHeaderForHeight(args: {\n        height: PositiveInteger;\n    }): Promise&lt;{\n        header: HexString;\n    }&gt; \n    async getNetwork(args: object = {}): Promise&lt;{\n        network: \"mainnet\" | \"testnet\";\n    }&gt; \n    async getVersion(args: object = {}): Promise&lt;{\n        version: VersionString7To30Bytes;\n    }&gt; \n}\n</code></pre> <p>See also: AcquireCertificateArgs, AcquireCertificateResult, AuthenticatedResult, Base64String, BasketStringUnder300Bytes, BooleanDefaultFalse, Byte, CertificateFieldNameUnder50Bytes, CreateActionArgs, CreateActionResult, DescriptionString5to50Bytes, DiscoverCertificatesResult, HexString, ISOTimestampString, InternalizeActionArgs, KeyIDStringUnder800Bytes, ListActionsArgs, ListActionsResult, ListCertificatesResult, ListOutputsArgs, ListOutputsResult, OriginatorDomainNameStringUnder250Bytes, OutpointString, PositiveInteger, PositiveIntegerDefault10Max10000, PositiveIntegerOrZero, ProtocolString5To400Bytes, ProveCertificateArgs, ProveCertificateResult, PubKeyHex, SecurityLevel, SignActionArgs, SignActionResult, VersionString7To30Bytes, WalletInterface, decrypt, encrypt</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#class-walleterror","title":"Class: WalletError","text":"<pre><code>export class WalletError extends Error {\n    code: number;\n    isError: boolean = true;\n    constructor(message: string, code = 1, stack?: string) \n}\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#class-walletwireprocessor","title":"Class: WalletWireProcessor","text":"<p>Processes incoming wallet calls received over a wallet wire, with a given wallet.</p> <pre><code>export default class WalletWireProcessor implements WalletWire {\n    wallet: WalletInterface;\n    constructor(wallet: WalletInterface) \n    async transmitToWallet(message: number[]): Promise&lt;number[]&gt; \n}\n</code></pre> <p>See also: WalletInterface, WalletWire</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#class-walletwiretransceiver","title":"Class: WalletWireTransceiver","text":"<p>A way to make remote calls to a wallet over a wallet wire.</p> <pre><code>export default class WalletWireTransceiver implements WalletInterface {\n    wire: WalletWire;\n    constructor(wire: WalletWire) \n    async createAction(args: CreateActionArgs, originator?: OriginatorDomainNameStringUnder250Bytes): Promise&lt;CreateActionResult&gt; \n    async signAction(args: SignActionArgs, originator?: OriginatorDomainNameStringUnder250Bytes): Promise&lt;SignActionResult&gt; \n    async abortAction(args: {\n        reference: Base64String;\n    }, originator?: OriginatorDomainNameStringUnder250Bytes): Promise&lt;{\n        aborted: true;\n    }&gt; \n    async listActions(args: ListActionsArgs, originator?: OriginatorDomainNameStringUnder250Bytes): Promise&lt;ListActionsResult&gt; \n    async internalizeAction(args: InternalizeActionArgs, originator?: OriginatorDomainNameStringUnder250Bytes): Promise&lt;{\n        accepted: true;\n    }&gt; \n    async listOutputs(args: ListOutputsArgs, originator?: OriginatorDomainNameStringUnder250Bytes): Promise&lt;ListOutputsResult&gt; \n    async relinquishOutput(args: {\n        basket: BasketStringUnder300Bytes;\n        output: OutpointString;\n    }, originator?: OriginatorDomainNameStringUnder250Bytes): Promise&lt;{\n        relinquished: true;\n    }&gt; \n    async getPublicKey(args: {\n        seekPermission?: BooleanDefaultTrue;\n        identityKey?: true;\n        protocolID?: [\n            SecurityLevel,\n            ProtocolString5To400Bytes\n        ];\n        keyID?: KeyIDStringUnder800Bytes;\n        privileged?: BooleanDefaultFalse;\n        privilegedReason?: DescriptionString5to50Bytes;\n        counterparty?: PubKeyHex | \"self\" | \"anyone\";\n        forSelf?: BooleanDefaultFalse;\n    }, originator?: OriginatorDomainNameStringUnder250Bytes): Promise&lt;{\n        publicKey: PubKeyHex;\n    }&gt; \n    async revealCounterpartyKeyLinkage(args: {\n        counterparty: PubKeyHex;\n        verifier: PubKeyHex;\n        privilegedReason?: DescriptionString5to50Bytes;\n        privileged?: BooleanDefaultFalse;\n    }, originator?: OriginatorDomainNameStringUnder250Bytes): Promise&lt;{\n        prover: PubKeyHex;\n        verifier: PubKeyHex;\n        counterparty: PubKeyHex;\n        revelationTime: ISOTimestampString;\n        encryptedLinkage: Byte[];\n        encryptedLinkageProof: number[];\n    }&gt; \n    async revealSpecificKeyLinkage(args: {\n        counterparty: PubKeyHex;\n        verifier: PubKeyHex;\n        protocolID: [\n            SecurityLevel,\n            ProtocolString5To400Bytes\n        ];\n        keyID: KeyIDStringUnder800Bytes;\n        privilegedReason?: DescriptionString5to50Bytes;\n        privileged?: BooleanDefaultFalse;\n    }, originator?: OriginatorDomainNameStringUnder250Bytes): Promise&lt;{\n        prover: PubKeyHex;\n        verifier: PubKeyHex;\n        counterparty: PubKeyHex;\n        protocolID: [\n            SecurityLevel,\n            ProtocolString5To400Bytes\n        ];\n        keyID: KeyIDStringUnder800Bytes;\n        encryptedLinkage: Byte[];\n        encryptedLinkageProof: Byte[];\n        proofType: Byte;\n    }&gt; \n    async encrypt(args: {\n        seekPermission?: BooleanDefaultTrue;\n        plaintext: Byte[];\n        protocolID: [\n            SecurityLevel,\n            ProtocolString5To400Bytes\n        ];\n        keyID: KeyIDStringUnder800Bytes;\n        privilegedReason?: DescriptionString5to50Bytes;\n        counterparty?: PubKeyHex | \"self\" | \"anyone\";\n        privileged?: BooleanDefaultFalse;\n    }, originator?: OriginatorDomainNameStringUnder250Bytes): Promise&lt;{\n        ciphertext: Byte[];\n    }&gt; \n    async decrypt(args: {\n        seekPermission?: BooleanDefaultTrue;\n        ciphertext: Byte[];\n        protocolID: [\n            SecurityLevel,\n            ProtocolString5To400Bytes\n        ];\n        keyID: KeyIDStringUnder800Bytes;\n        privilegedReason?: DescriptionString5to50Bytes;\n        counterparty?: PubKeyHex | \"self\" | \"anyone\";\n        privileged?: BooleanDefaultFalse;\n    }, originator?: OriginatorDomainNameStringUnder250Bytes): Promise&lt;{\n        plaintext: Byte[];\n    }&gt; \n    async createHmac(args: {\n        seekPermission?: BooleanDefaultTrue;\n        data: Byte[];\n        protocolID: [\n            SecurityLevel,\n            ProtocolString5To400Bytes\n        ];\n        keyID: KeyIDStringUnder800Bytes;\n        privilegedReason?: DescriptionString5to50Bytes;\n        counterparty?: PubKeyHex | \"self\" | \"anyone\";\n        privileged?: BooleanDefaultFalse;\n    }, originator?: OriginatorDomainNameStringUnder250Bytes): Promise&lt;{\n        hmac: Byte[];\n    }&gt; \n    async verifyHmac(args: {\n        seekPermission?: BooleanDefaultTrue;\n        data: Byte[];\n        hmac: Byte[];\n        protocolID: [\n            SecurityLevel,\n            ProtocolString5To400Bytes\n        ];\n        keyID: KeyIDStringUnder800Bytes;\n        privilegedReason?: DescriptionString5to50Bytes;\n        counterparty?: PubKeyHex | \"self\" | \"anyone\";\n        privileged?: BooleanDefaultFalse;\n    }, originator?: OriginatorDomainNameStringUnder250Bytes): Promise&lt;{\n        valid: true;\n    }&gt; \n    async createSignature(args: {\n        seekPermission?: BooleanDefaultTrue;\n        data?: Byte[];\n        hashToDirectlySign?: Byte[];\n        protocolID: [\n            SecurityLevel,\n            ProtocolString5To400Bytes\n        ];\n        keyID: KeyIDStringUnder800Bytes;\n        privilegedReason?: DescriptionString5to50Bytes;\n        counterparty?: PubKeyHex | \"self\" | \"anyone\";\n        privileged?: BooleanDefaultFalse;\n    }, originator?: OriginatorDomainNameStringUnder250Bytes): Promise&lt;{\n        signature: Byte[];\n    }&gt; \n    async verifySignature(args: {\n        seekPermission?: BooleanDefaultTrue;\n        data?: Byte[];\n        hashToDirectlyVerify?: Byte[];\n        signature: Byte[];\n        protocolID: [\n            SecurityLevel,\n            ProtocolString5To400Bytes\n        ];\n        keyID: KeyIDStringUnder800Bytes;\n        privilegedReason?: DescriptionString5to50Bytes;\n        counterparty?: PubKeyHex | \"self\" | \"anyone\";\n        forSelf?: BooleanDefaultFalse;\n        privileged?: BooleanDefaultFalse;\n    }, originator?: OriginatorDomainNameStringUnder250Bytes): Promise&lt;{\n        valid: true;\n    }&gt; \n    async acquireCertificate(args: AcquireCertificateArgs, originator?: OriginatorDomainNameStringUnder250Bytes): Promise&lt;AcquireCertificateResult&gt; \n    async listCertificates(args: {\n        certifiers: PubKeyHex[];\n        types: Base64String[];\n        limit?: PositiveIntegerDefault10Max10000;\n        offset?: PositiveIntegerOrZero;\n        privileged?: BooleanDefaultFalse;\n        privilegedReason?: DescriptionString5to50Bytes;\n    }, originator?: OriginatorDomainNameStringUnder250Bytes): Promise&lt;ListCertificatesResult&gt; \n    async proveCertificate(args: ProveCertificateArgs, originator?: OriginatorDomainNameStringUnder250Bytes): Promise&lt;ProveCertificateResult&gt; \n    async relinquishCertificate(args: {\n        type: Base64String;\n        serialNumber: Base64String;\n        certifier: PubKeyHex;\n    }, originator?: OriginatorDomainNameStringUnder250Bytes): Promise&lt;{\n        relinquished: true;\n    }&gt; \n    async discoverByIdentityKey(args: {\n        seekPermission?: BooleanDefaultTrue;\n        identityKey: PubKeyHex;\n        limit?: PositiveIntegerDefault10Max10000;\n        offset?: PositiveIntegerOrZero;\n    }, originator?: OriginatorDomainNameStringUnder250Bytes): Promise&lt;DiscoverCertificatesResult&gt; \n    async discoverByAttributes(args: {\n        seekPermission?: BooleanDefaultTrue;\n        attributes: Record&lt;CertificateFieldNameUnder50Bytes, string&gt;;\n        limit?: PositiveIntegerDefault10Max10000;\n        offset?: PositiveIntegerOrZero;\n    }, originator?: OriginatorDomainNameStringUnder250Bytes): Promise&lt;DiscoverCertificatesResult&gt; \n    async isAuthenticated(args: {}, originator?: OriginatorDomainNameStringUnder250Bytes): Promise&lt;{\n        authenticated: true;\n    }&gt; \n    async waitForAuthentication(args: {}, originator?: OriginatorDomainNameStringUnder250Bytes): Promise&lt;{\n        authenticated: true;\n    }&gt; \n    async getHeight(args: {}, originator?: OriginatorDomainNameStringUnder250Bytes): Promise&lt;{\n        height: PositiveInteger;\n    }&gt; \n    async getHeaderForHeight(args: {\n        height: PositiveInteger;\n    }, originator?: OriginatorDomainNameStringUnder250Bytes): Promise&lt;{\n        header: HexString;\n    }&gt; \n    async getNetwork(args: {}, originator?: OriginatorDomainNameStringUnder250Bytes): Promise&lt;{\n        network: \"mainnet\" | \"testnet\";\n    }&gt; \n    async getVersion(args: {}, originator?: OriginatorDomainNameStringUnder250Bytes): Promise&lt;{\n        version: VersionString7To30Bytes;\n    }&gt; \n}\n</code></pre> <p>See also: AcquireCertificateArgs, AcquireCertificateResult, Base64String, BasketStringUnder300Bytes, BooleanDefaultFalse, BooleanDefaultTrue, Byte, CertificateFieldNameUnder50Bytes, CreateActionArgs, CreateActionResult, DescriptionString5to50Bytes, DiscoverCertificatesResult, HexString, ISOTimestampString, InternalizeActionArgs, KeyIDStringUnder800Bytes, ListActionsArgs, ListActionsResult, ListCertificatesResult, ListOutputsArgs, ListOutputsResult, OriginatorDomainNameStringUnder250Bytes, OutpointString, PositiveInteger, PositiveIntegerDefault10Max10000, PositiveIntegerOrZero, ProtocolString5To400Bytes, ProveCertificateArgs, ProveCertificateResult, PubKeyHex, SecurityLevel, SignActionArgs, SignActionResult, VersionString7To30Bytes, WalletInterface, WalletWire, decrypt, encrypt</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#class-windowcwisubstrate","title":"Class: WindowCWISubstrate","text":"<p>Facilitates wallet operations over the window.CWI interface.</p> <pre><code>export default class WindowCWISubstrate implements WalletInterface {\n    constructor() \n    async createAction(args: {\n        description: DescriptionString5to50Bytes;\n        inputs?: Array&lt;{\n            tx?: BEEF;\n            outpoint: OutpointString;\n            unlockingScript?: HexString;\n            unlockingScriptLength?: PositiveInteger;\n            inputDescription: DescriptionString5to50Bytes;\n            sequenceNumber?: PositiveIntegerOrZero;\n        }&gt;;\n        outputs?: Array&lt;{\n            lockingScript: HexString;\n            satoshis: SatoshiValue;\n            outputDescription: DescriptionString5to50Bytes;\n            basket?: BasketStringUnder300Bytes;\n            customInstructions?: string;\n            tags?: OutputTagStringUnder300Bytes[];\n        }&gt;;\n        lockTime?: PositiveIntegerOrZero;\n        version?: PositiveIntegerOrZero;\n        labels?: LabelStringUnder300Bytes[];\n        options?: {\n            signAndProcess?: BooleanDefaultTrue;\n            acceptDelayedBroadcast?: BooleanDefaultTrue;\n            trustSelf?: \"known\";\n            knownTxids?: TXIDHexString[];\n            returnTXIDOnly?: BooleanDefaultFalse;\n            noSend?: BooleanDefaultFalse;\n            noSendChange?: OutpointString[];\n            sendWith?: TXIDHexString[];\n        };\n    }, originator?: OriginatorDomainNameStringUnder250Bytes): Promise&lt;{\n        txid?: TXIDHexString;\n        tx?: BEEF;\n        noSendChange?: OutpointString[];\n        sendWithResults?: Array&lt;{\n            txid: TXIDHexString;\n            status: \"unproven\" | \"sending\" | \"failed\";\n        }&gt;;\n        signableTransaction?: {\n            tx: BEEF;\n            reference: Base64String;\n        };\n    }&gt; \n    async signAction(args: {\n        spends: Record&lt;PositiveIntegerOrZero, {\n            unlockingScript: HexString;\n            sequenceNumber?: PositiveIntegerOrZero;\n        }&gt;;\n        reference: Base64String;\n        options?: {\n            acceptDelayedBroadcast?: BooleanDefaultTrue;\n            returnTXIDOnly?: BooleanDefaultFalse;\n            noSend?: BooleanDefaultFalse;\n            noSendChange?: OutpointString[];\n            sendWith: TXIDHexString[];\n        };\n    }, originator?: OriginatorDomainNameStringUnder250Bytes): Promise&lt;{\n        txid?: TXIDHexString;\n        tx?: BEEF;\n        noSendChange?: OutpointString[];\n        sendWithResults?: Array&lt;{\n            txid: TXIDHexString;\n            status: \"unproven\" | \"sending\" | \"failed\";\n        }&gt;;\n    }&gt; \n    async abortAction(args: {\n        reference: Base64String;\n    }, originator?: OriginatorDomainNameStringUnder250Bytes): Promise&lt;{\n        aborted: true;\n    }&gt; \n    async listActions(args: {\n        labels: LabelStringUnder300Bytes[];\n        labelQueryMode?: \"any\" | \"all\";\n        includeLabels?: BooleanDefaultFalse;\n        includeInputs?: BooleanDefaultFalse;\n        includeInputSourceLockingScripts?: BooleanDefaultFalse;\n        includeInputUnlockingScripts?: BooleanDefaultFalse;\n        includeOutputs?: BooleanDefaultFalse;\n        includeOutputLockingScripts?: BooleanDefaultFalse;\n        limit?: PositiveIntegerDefault10Max10000;\n        offset?: PositiveIntegerOrZero;\n    }, originator?: OriginatorDomainNameStringUnder250Bytes): Promise&lt;{\n        totalActions: PositiveIntegerOrZero;\n        actions: Array&lt;{\n            txid: TXIDHexString;\n            satoshis: SatoshiValue;\n            status: \"completed\" | \"unprocessed\" | \"sending\" | \"unproven\" | \"unsigned\" | \"nosend\" | \"nonfinal\" | \"failed\";\n            isOutgoing: boolean;\n            description: DescriptionString5to50Bytes;\n            labels?: LabelStringUnder300Bytes[];\n            version: PositiveIntegerOrZero;\n            lockTime: PositiveIntegerOrZero;\n            inputs?: Array&lt;{\n                sourceOutpoint: OutpointString;\n                sourceSatoshis: SatoshiValue;\n                sourceLockingScript?: HexString;\n                unlockingScript?: HexString;\n                inputDescription: DescriptionString5to50Bytes;\n                sequenceNumber: PositiveIntegerOrZero;\n            }&gt;;\n            outputs?: Array&lt;{\n                outputIndex: PositiveIntegerOrZero;\n                satoshis: SatoshiValue;\n                lockingScript?: HexString;\n                spendable: boolean;\n                outputDescription: DescriptionString5to50Bytes;\n                basket: BasketStringUnder300Bytes;\n                tags: OutputTagStringUnder300Bytes[];\n                customInstructions?: string;\n            }&gt;;\n        }&gt;;\n    }&gt; \n    async internalizeAction(args: {\n        tx: BEEF;\n        outputs: Array&lt;{\n            outputIndex: PositiveIntegerOrZero;\n            protocol: \"wallet payment\" | \"basket insertion\";\n            paymentRemittance?: {\n                derivationPrefix: Base64String;\n                derivationSuffix: Base64String;\n                senderIdentityKey: PubKeyHex;\n            };\n            insertionRemittance?: {\n                basket: BasketStringUnder300Bytes;\n                customInstructions?: string;\n                tags?: OutputTagStringUnder300Bytes[];\n            };\n        }&gt;;\n        description: DescriptionString5to50Bytes;\n        labels?: LabelStringUnder300Bytes[];\n    }, originator?: OriginatorDomainNameStringUnder250Bytes): Promise&lt;{\n        accepted: true;\n    }&gt; \n    async listOutputs(args: {\n        basket: BasketStringUnder300Bytes;\n        tags?: OutputTagStringUnder300Bytes[];\n        tagQueryMode?: \"all\" | \"any\";\n        include?: \"locking scripts\" | \"entire transactions\";\n        includeCustomInstructions?: BooleanDefaultFalse;\n        includeTags?: BooleanDefaultFalse;\n        includeLabels?: BooleanDefaultFalse;\n        limit?: PositiveIntegerDefault10Max10000;\n        offset?: PositiveIntegerOrZero;\n    }, originator?: OriginatorDomainNameStringUnder250Bytes): Promise&lt;{\n        totalOutputs: PositiveIntegerOrZero;\n        outputs: Array&lt;{\n            outpoint: OutpointString;\n            satoshis: SatoshiValue;\n            lockingScript?: HexString;\n            tx?: BEEF;\n            spendable: boolean;\n            customInstructions?: string;\n            tags?: OutputTagStringUnder300Bytes[];\n            labels?: LabelStringUnder300Bytes[];\n        }&gt;;\n    }&gt; \n    async relinquishOutput(args: {\n        basket: BasketStringUnder300Bytes;\n        output: OutpointString;\n    }, originator?: OriginatorDomainNameStringUnder250Bytes): Promise&lt;{\n        relinquished: true;\n    }&gt; \n    async getPublicKey(args: {\n        identityKey?: true;\n        protocolID?: [\n            SecurityLevel,\n            ProtocolString5To400Bytes\n        ];\n        keyID?: KeyIDStringUnder800Bytes;\n        privileged?: BooleanDefaultFalse;\n        privilegedReason?: DescriptionString5to50Bytes;\n        counterparty?: PubKeyHex | \"self\" | \"anyone\";\n        forSelf?: BooleanDefaultFalse;\n    }, originator?: OriginatorDomainNameStringUnder250Bytes): Promise&lt;{\n        publicKey: PubKeyHex;\n    }&gt; \n    async revealCounterpartyKeyLinkage(args: {\n        counterparty: PubKeyHex;\n        verifier: PubKeyHex;\n        privilegedReason?: DescriptionString5to50Bytes;\n        privileged?: BooleanDefaultFalse;\n    }, originator?: OriginatorDomainNameStringUnder250Bytes): Promise&lt;{\n        prover: PubKeyHex;\n        verifier: PubKeyHex;\n        counterparty: PubKeyHex;\n        revelationTime: ISOTimestampString;\n        encryptedLinkage: Byte[];\n        encryptedLinkageProof: Byte[];\n    }&gt; \n    async revealSpecificKeyLinkage(args: {\n        counterparty: PubKeyHex;\n        verifier: PubKeyHex;\n        protocolID: [\n            SecurityLevel,\n            ProtocolString5To400Bytes\n        ];\n        keyID: KeyIDStringUnder800Bytes;\n        privilegedReason?: DescriptionString5to50Bytes;\n        privileged?: BooleanDefaultFalse;\n    }, originator?: OriginatorDomainNameStringUnder250Bytes): Promise&lt;{\n        prover: PubKeyHex;\n        verifier: PubKeyHex;\n        counterparty: PubKeyHex;\n        protocolID: [\n            SecurityLevel,\n            ProtocolString5To400Bytes\n        ];\n        keyID: KeyIDStringUnder800Bytes;\n        encryptedLinkage: Byte[];\n        encryptedLinkageProof: Byte[];\n        proofType: Byte;\n    }&gt; \n    async encrypt(args: {\n        plaintext: Byte[];\n        protocolID: [\n            SecurityLevel,\n            ProtocolString5To400Bytes\n        ];\n        keyID: KeyIDStringUnder800Bytes;\n        privilegedReason?: DescriptionString5to50Bytes;\n        counterparty?: PubKeyHex | \"self\" | \"anyone\";\n        privileged?: BooleanDefaultFalse;\n    }, originator?: OriginatorDomainNameStringUnder250Bytes): Promise&lt;{\n        ciphertext: Byte[];\n    }&gt; \n    async decrypt(args: {\n        ciphertext: Byte[];\n        protocolID: [\n            SecurityLevel,\n            ProtocolString5To400Bytes\n        ];\n        keyID: KeyIDStringUnder800Bytes;\n        privilegedReason?: DescriptionString5to50Bytes;\n        counterparty?: PubKeyHex | \"self\" | \"anyone\";\n        privileged?: BooleanDefaultFalse;\n    }, originator?: OriginatorDomainNameStringUnder250Bytes): Promise&lt;{\n        plaintext: Byte[];\n    }&gt; \n    async createHmac(args: {\n        data: Byte[];\n        protocolID: [\n            SecurityLevel,\n            ProtocolString5To400Bytes\n        ];\n        keyID: KeyIDStringUnder800Bytes;\n        privilegedReason?: DescriptionString5to50Bytes;\n        counterparty?: PubKeyHex | \"self\" | \"anyone\";\n        privileged?: BooleanDefaultFalse;\n    }, originator?: OriginatorDomainNameStringUnder250Bytes): Promise&lt;{\n        hmac: Byte[];\n    }&gt; \n    async verifyHmac(args: {\n        data: Byte[];\n        hmac: Byte[];\n        protocolID: [\n            SecurityLevel,\n            ProtocolString5To400Bytes\n        ];\n        keyID: KeyIDStringUnder800Bytes;\n        privilegedReason?: DescriptionString5to50Bytes;\n        counterparty?: PubKeyHex | \"self\" | \"anyone\";\n        privileged?: BooleanDefaultFalse;\n    }, originator?: OriginatorDomainNameStringUnder250Bytes): Promise&lt;{\n        valid: true;\n    }&gt; \n    async createSignature(args: {\n        data?: Byte[];\n        hashToDirectlySign?: Byte[];\n        protocolID: [\n            SecurityLevel,\n            ProtocolString5To400Bytes\n        ];\n        keyID: KeyIDStringUnder800Bytes;\n        privilegedReason?: DescriptionString5to50Bytes;\n        counterparty?: PubKeyHex | \"self\" | \"anyone\";\n        privileged?: BooleanDefaultFalse;\n    }, originator?: OriginatorDomainNameStringUnder250Bytes): Promise&lt;{\n        signature: Byte[];\n    }&gt; \n    async verifySignature(args: {\n        data?: Byte[];\n        hashToDirectlyVerify?: Byte[];\n        signature: Byte[];\n        protocolID: [\n            SecurityLevel,\n            ProtocolString5To400Bytes\n        ];\n        keyID: KeyIDStringUnder800Bytes;\n        privilegedReason?: DescriptionString5to50Bytes;\n        counterparty?: PubKeyHex | \"self\" | \"anyone\";\n        forSelf?: BooleanDefaultFalse;\n        privileged?: BooleanDefaultFalse;\n    }, originator?: OriginatorDomainNameStringUnder250Bytes): Promise&lt;{\n        valid: true;\n    }&gt; \n    async acquireCertificate(args: {\n        type: Base64String;\n        subject: PubKeyHex;\n        serialNumber: Base64String;\n        revocationOutpoint: OutpointString;\n        signature: HexString;\n        fields: Record&lt;CertificateFieldNameUnder50Bytes, string&gt;;\n        certifier: PubKeyHex;\n        keyringRevealer: PubKeyHex | \"certifier\";\n        keyringForSubject: Record&lt;CertificateFieldNameUnder50Bytes, Base64String&gt;;\n        acquisitionProtocol: \"direct\" | \"issuance\";\n        certifierUrl?: string;\n    }, originator?: OriginatorDomainNameStringUnder250Bytes): Promise&lt;{\n        type: Base64String;\n        subject: PubKeyHex;\n        serialNumber: Base64String;\n        certifier: PubKeyHex;\n        revocationOutpoint: OutpointString;\n        signature: HexString;\n        fields: Record&lt;CertificateFieldNameUnder50Bytes, string&gt;;\n    }&gt; \n    async listCertificates(args: {\n        certifiers: PubKeyHex[];\n        types: Base64String[];\n        limit?: PositiveIntegerDefault10Max10000;\n        offset?: PositiveIntegerOrZero;\n        privileged?: BooleanDefaultFalse;\n        privilegedReason?: DescriptionString5to50Bytes;\n    }, originator?: OriginatorDomainNameStringUnder250Bytes): Promise&lt;{\n        totalCertificates: PositiveIntegerOrZero;\n        certificates: Array&lt;{\n            type: Base64String;\n            subject: PubKeyHex;\n            serialNumber: Base64String;\n            certifier: PubKeyHex;\n            revocationOutpoint: OutpointString;\n            signature: HexString;\n            fields: Record&lt;CertificateFieldNameUnder50Bytes, string&gt;;\n        }&gt;;\n    }&gt; \n    async proveCertificate(args: {\n        certificate: {\n            type: Base64String;\n            subject: PubKeyHex;\n            serialNumber: Base64String;\n            certifier: PubKeyHex;\n            revocationOutpoint: OutpointString;\n            signature: HexString;\n            fields: Record&lt;CertificateFieldNameUnder50Bytes, string&gt;;\n        };\n        fieldsToReveal: CertificateFieldNameUnder50Bytes[];\n        verifier: PubKeyHex;\n        privileged?: BooleanDefaultFalse;\n        privilegedReason?: DescriptionString5to50Bytes;\n    }, originator?: OriginatorDomainNameStringUnder250Bytes): Promise&lt;{\n        keyringForVerifier: Record&lt;CertificateFieldNameUnder50Bytes, Base64String&gt;;\n    }&gt; \n    async relinquishCertificate(args: {\n        type: Base64String;\n        serialNumber: Base64String;\n        certifier: PubKeyHex;\n    }, originator?: OriginatorDomainNameStringUnder250Bytes): Promise&lt;{\n        relinquished: true;\n    }&gt; \n    async discoverByIdentityKey(args: {\n        identityKey: PubKeyHex;\n        limit?: PositiveIntegerDefault10Max10000;\n        offset?: PositiveIntegerOrZero;\n    }, originator?: OriginatorDomainNameStringUnder250Bytes): Promise&lt;{\n        totalCertificates: PositiveIntegerOrZero;\n        certificates: Array&lt;{\n            type: Base64String;\n            subject: PubKeyHex;\n            serialNumber: Base64String;\n            certifier: PubKeyHex;\n            revocationOutpoint: OutpointString;\n            signature: HexString;\n            fields: Record&lt;CertificateFieldNameUnder50Bytes, Base64String&gt;;\n            certifierInfo: {\n                name: EntityNameStringMax100Bytes;\n                iconUrl: EntityIconURLStringMax500Bytes;\n                description: DescriptionString5to50Bytes;\n                trust: PositiveIntegerMax10;\n            };\n            publiclyRevealedKeyring: Record&lt;CertificateFieldNameUnder50Bytes, Base64String&gt;;\n            decryptedFields: Record&lt;CertificateFieldNameUnder50Bytes, string&gt;;\n        }&gt;;\n    }&gt; \n    async discoverByAttributes(args: {\n        attributes: Record&lt;CertificateFieldNameUnder50Bytes, string&gt;;\n        limit?: PositiveIntegerDefault10Max10000;\n        offset?: PositiveIntegerOrZero;\n    }, originator?: OriginatorDomainNameStringUnder250Bytes): Promise&lt;{\n        totalCertificates: PositiveIntegerOrZero;\n        certificates: Array&lt;{\n            type: Base64String;\n            subject: PubKeyHex;\n            serialNumber: Base64String;\n            certifier: PubKeyHex;\n            revocationOutpoint: OutpointString;\n            signature: HexString;\n            fields: Record&lt;CertificateFieldNameUnder50Bytes, Base64String&gt;;\n            certifierInfo: {\n                name: EntityNameStringMax100Bytes;\n                iconUrl: EntityIconURLStringMax500Bytes;\n                description: DescriptionString5to50Bytes;\n                trust: PositiveIntegerMax10;\n            };\n            publiclyRevealedKeyring: Record&lt;CertificateFieldNameUnder50Bytes, Base64String&gt;;\n            decryptedFields: Record&lt;CertificateFieldNameUnder50Bytes, string&gt;;\n        }&gt;;\n    }&gt; \n    async isAuthenticated(args: object, originator?: OriginatorDomainNameStringUnder250Bytes): Promise&lt;{\n        authenticated: true;\n    }&gt; \n    async waitForAuthentication(args: object, originator?: OriginatorDomainNameStringUnder250Bytes): Promise&lt;{\n        authenticated: true;\n    }&gt; \n    async getHeight(args: object, originator?: OriginatorDomainNameStringUnder250Bytes): Promise&lt;{\n        height: PositiveInteger;\n    }&gt; \n    async getHeaderForHeight(args: {\n        height: PositiveInteger;\n    }, originator?: OriginatorDomainNameStringUnder250Bytes): Promise&lt;{\n        header: HexString;\n    }&gt; \n    async getNetwork(args: object, originator?: OriginatorDomainNameStringUnder250Bytes): Promise&lt;{\n        network: \"mainnet\" | \"testnet\";\n    }&gt; \n    async getVersion(args: object, originator?: OriginatorDomainNameStringUnder250Bytes): Promise&lt;{\n        version: VersionString7To30Bytes;\n    }&gt; \n}\n</code></pre> <p>See also: BEEF, Base64String, BasketStringUnder300Bytes, BooleanDefaultFalse, BooleanDefaultTrue, Byte, CertificateFieldNameUnder50Bytes, DescriptionString5to50Bytes, EntityIconURLStringMax500Bytes, EntityNameStringMax100Bytes, HexString, ISOTimestampString, KeyIDStringUnder800Bytes, LabelStringUnder300Bytes, OriginatorDomainNameStringUnder250Bytes, OutpointString, OutputTagStringUnder300Bytes, PositiveInteger, PositiveIntegerDefault10Max10000, PositiveIntegerMax10, PositiveIntegerOrZero, ProtocolString5To400Bytes, PubKeyHex, SatoshiValue, SecurityLevel, TXIDHexString, VersionString7To30Bytes, WalletInterface, decrypt, encrypt</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#class-xdmsubstrate","title":"Class: XDMSubstrate","text":"<p>Facilitates wallet operations over cross-document messaging.</p> <pre><code>export default class XDMSubstrate implements WalletInterface {\n    constructor(domain: string = \"*\") \n    async invoke(call: CallType, args: any): Promise&lt;any&gt; \n    async createAction(args: {\n        description: DescriptionString5to50Bytes;\n        inputs?: Array&lt;{\n            tx?: BEEF;\n            outpoint: OutpointString;\n            unlockingScript?: HexString;\n            unlockingScriptLength?: PositiveInteger;\n            inputDescription: DescriptionString5to50Bytes;\n            sequenceNumber?: PositiveIntegerOrZero;\n        }&gt;;\n        outputs?: Array&lt;{\n            lockingScript: HexString;\n            satoshis: SatoshiValue;\n            outputDescription: DescriptionString5to50Bytes;\n            basket?: BasketStringUnder300Bytes;\n            customInstructions?: string;\n            tags?: OutputTagStringUnder300Bytes[];\n        }&gt;;\n        lockTime?: PositiveIntegerOrZero;\n        version?: PositiveIntegerOrZero;\n        labels?: LabelStringUnder300Bytes[];\n        options?: {\n            signAndProcess?: BooleanDefaultTrue;\n            acceptDelayedBroadcast?: BooleanDefaultTrue;\n            trustSelf?: \"known\";\n            knownTxids?: TXIDHexString[];\n            returnTXIDOnly?: BooleanDefaultFalse;\n            noSend?: BooleanDefaultFalse;\n            noSendChange?: OutpointString[];\n            sendWith?: TXIDHexString[];\n        };\n    }): Promise&lt;{\n        txid?: TXIDHexString;\n        tx?: BEEF;\n        noSendChange?: OutpointString[];\n        sendWithResults?: Array&lt;{\n            txid: TXIDHexString;\n            status: \"unproven\" | \"sending\" | \"failed\";\n        }&gt;;\n        signableTransaction?: {\n            tx: BEEF;\n            reference: Base64String;\n        };\n    }&gt; \n    async signAction(args: {\n        spends: Record&lt;PositiveIntegerOrZero, {\n            unlockingScript: HexString;\n            sequenceNumber?: PositiveIntegerOrZero;\n        }&gt;;\n        reference: Base64String;\n        options?: {\n            acceptDelayedBroadcast?: BooleanDefaultTrue;\n            returnTXIDOnly?: BooleanDefaultFalse;\n            noSend?: BooleanDefaultFalse;\n            noSendChange?: OutpointString[];\n            sendWith: TXIDHexString[];\n        };\n    }): Promise&lt;{\n        txid?: TXIDHexString;\n        tx?: BEEF;\n        noSendChange?: OutpointString[];\n        sendWithResults?: Array&lt;{\n            txid: TXIDHexString;\n            status: \"unproven\" | \"sending\" | \"failed\";\n        }&gt;;\n    }&gt; \n    async abortAction(args: {\n        reference: Base64String;\n    }): Promise&lt;{\n        aborted: true;\n    }&gt; \n    async listActions(args: {\n        labels: LabelStringUnder300Bytes[];\n        labelQueryMode?: \"any\" | \"all\";\n        includeLabels?: BooleanDefaultFalse;\n        includeInputs?: BooleanDefaultFalse;\n        includeInputSourceLockingScripts?: BooleanDefaultFalse;\n        includeInputUnlockingScripts?: BooleanDefaultFalse;\n        includeOutputs?: BooleanDefaultFalse;\n        includeOutputLockingScripts?: BooleanDefaultFalse;\n        limit?: PositiveIntegerDefault10Max10000;\n        offset?: PositiveIntegerOrZero;\n    }): Promise&lt;{\n        totalActions: PositiveIntegerOrZero;\n        actions: Array&lt;{\n            txid: TXIDHexString;\n            satoshis: SatoshiValue;\n            status: \"completed\" | \"unprocessed\" | \"sending\" | \"unproven\" | \"unsigned\" | \"nosend\" | \"nonfinal\";\n            isOutgoing: boolean;\n            description: DescriptionString5to50Bytes;\n            labels?: LabelStringUnder300Bytes[];\n            version: PositiveIntegerOrZero;\n            lockTime: PositiveIntegerOrZero;\n            inputs?: Array&lt;{\n                sourceOutpoint: OutpointString;\n                sourceSatoshis: SatoshiValue;\n                sourceLockingScript?: HexString;\n                unlockingScript?: HexString;\n                inputDescription: DescriptionString5to50Bytes;\n                sequenceNumber: PositiveIntegerOrZero;\n            }&gt;;\n            outputs?: Array&lt;{\n                outputIndex: PositiveIntegerOrZero;\n                satoshis: SatoshiValue;\n                lockingScript?: HexString;\n                spendable: boolean;\n                outputDescription: DescriptionString5to50Bytes;\n                basket: BasketStringUnder300Bytes;\n                tags: OutputTagStringUnder300Bytes[];\n                customInstructions?: string;\n            }&gt;;\n        }&gt;;\n    }&gt; \n    async internalizeAction(args: {\n        tx: BEEF;\n        outputs: Array&lt;{\n            outputIndex: PositiveIntegerOrZero;\n            protocol: \"wallet payment\" | \"basket insertion\";\n            paymentRemittance?: {\n                derivationPrefix: Base64String;\n                derivationSuffix: Base64String;\n                senderIdentityKey: PubKeyHex;\n            };\n            insertionRemittance?: {\n                basket: BasketStringUnder300Bytes;\n                customInstructions?: string;\n                tags?: OutputTagStringUnder300Bytes[];\n            };\n        }&gt;;\n        description: DescriptionString5to50Bytes;\n        labels?: LabelStringUnder300Bytes[];\n    }): Promise&lt;{\n        accepted: true;\n    }&gt; \n    async listOutputs(args: {\n        basket: BasketStringUnder300Bytes;\n        tags?: OutputTagStringUnder300Bytes[];\n        tagQueryMode?: \"all\" | \"any\";\n        include?: \"locking scripts\" | \"entire transactions\";\n        includeCustomInstructions?: BooleanDefaultFalse;\n        includeTags?: BooleanDefaultFalse;\n        includeLabels?: BooleanDefaultFalse;\n        limit?: PositiveIntegerDefault10Max10000;\n        offset?: PositiveIntegerOrZero;\n    }): Promise&lt;{\n        totalOutputs: PositiveIntegerOrZero;\n        outputs: Array&lt;{\n            outpoint: OutpointString;\n            satoshis: SatoshiValue;\n            lockingScript?: HexString;\n            tx?: BEEF;\n            spendable: boolean;\n            customInstructions?: string;\n            tags?: OutputTagStringUnder300Bytes[];\n            labels?: LabelStringUnder300Bytes[];\n        }&gt;;\n    }&gt; \n    async relinquishOutput(args: {\n        basket: BasketStringUnder300Bytes;\n        output: OutpointString;\n    }): Promise&lt;{\n        relinquished: true;\n    }&gt; \n    async getPublicKey(args: {\n        identityKey?: true;\n        protocolID?: [\n            SecurityLevel,\n            ProtocolString5To400Bytes\n        ];\n        keyID?: KeyIDStringUnder800Bytes;\n        privileged?: BooleanDefaultFalse;\n        privilegedReason?: DescriptionString5to50Bytes;\n        counterparty?: PubKeyHex | \"self\" | \"anyone\";\n        forSelf?: BooleanDefaultFalse;\n    }): Promise&lt;{\n        publicKey: PubKeyHex;\n    }&gt; \n    async revealCounterpartyKeyLinkage(args: {\n        counterparty: PubKeyHex;\n        verifier: PubKeyHex;\n        privilegedReason?: DescriptionString5to50Bytes;\n        privileged?: BooleanDefaultFalse;\n    }): Promise&lt;{\n        prover: PubKeyHex;\n        verifier: PubKeyHex;\n        counterparty: PubKeyHex;\n        revelationTime: ISOTimestampString;\n        encryptedLinkage: Byte[];\n        encryptedLinkageProof: Byte[];\n    }&gt; \n    async revealSpecificKeyLinkage(args: {\n        counterparty: PubKeyHex;\n        verifier: PubKeyHex;\n        protocolID: [\n            SecurityLevel,\n            ProtocolString5To400Bytes\n        ];\n        keyID: KeyIDStringUnder800Bytes;\n        privilegedReason?: DescriptionString5to50Bytes;\n        privileged?: BooleanDefaultFalse;\n    }): Promise&lt;{\n        prover: PubKeyHex;\n        verifier: PubKeyHex;\n        counterparty: PubKeyHex;\n        protocolID: [\n            SecurityLevel,\n            ProtocolString5To400Bytes\n        ];\n        keyID: KeyIDStringUnder800Bytes;\n        encryptedLinkage: Byte[];\n        encryptedLinkageProof: Byte[];\n        proofType: Byte;\n    }&gt; \n    async encrypt(args: {\n        plaintext: Byte[];\n        protocolID: [\n            SecurityLevel,\n            ProtocolString5To400Bytes\n        ];\n        keyID: KeyIDStringUnder800Bytes;\n        privilegedReason?: DescriptionString5to50Bytes;\n        counterparty?: PubKeyHex | \"self\" | \"anyone\";\n        privileged?: BooleanDefaultFalse;\n    }): Promise&lt;{\n        ciphertext: Byte[];\n    }&gt; \n    async decrypt(args: {\n        ciphertext: Byte[];\n        protocolID: [\n            SecurityLevel,\n            ProtocolString5To400Bytes\n        ];\n        keyID: KeyIDStringUnder800Bytes;\n        privilegedReason?: DescriptionString5to50Bytes;\n        counterparty?: PubKeyHex | \"self\" | \"anyone\";\n        privileged?: BooleanDefaultFalse;\n    }): Promise&lt;{\n        plaintext: Byte[];\n    }&gt; \n    async createHmac(args: {\n        data: Byte[];\n        protocolID: [\n            SecurityLevel,\n            ProtocolString5To400Bytes\n        ];\n        keyID: KeyIDStringUnder800Bytes;\n        privilegedReason?: DescriptionString5to50Bytes;\n        counterparty?: PubKeyHex | \"self\" | \"anyone\";\n        privileged?: BooleanDefaultFalse;\n    }): Promise&lt;{\n        hmac: Byte[];\n    }&gt; \n    async verifyHmac(args: {\n        data: Byte[];\n        hmac: Byte[];\n        protocolID: [\n            SecurityLevel,\n            ProtocolString5To400Bytes\n        ];\n        keyID: KeyIDStringUnder800Bytes;\n        privilegedReason?: DescriptionString5to50Bytes;\n        counterparty?: PubKeyHex | \"self\" | \"anyone\";\n        privileged?: BooleanDefaultFalse;\n    }): Promise&lt;{\n        valid: true;\n    }&gt; \n    async createSignature(args: {\n        data?: Byte[];\n        hashToDirectlySign?: Byte[];\n        protocolID: [\n            SecurityLevel,\n            ProtocolString5To400Bytes\n        ];\n        keyID: KeyIDStringUnder800Bytes;\n        privilegedReason?: DescriptionString5to50Bytes;\n        counterparty?: PubKeyHex | \"self\" | \"anyone\";\n        privileged?: BooleanDefaultFalse;\n    }): Promise&lt;{\n        signature: Byte[];\n    }&gt; \n    async verifySignature(args: {\n        data?: Byte[];\n        hashToDirectlyVerify?: Byte[];\n        signature: Byte[];\n        protocolID: [\n            SecurityLevel,\n            ProtocolString5To400Bytes\n        ];\n        keyID: KeyIDStringUnder800Bytes;\n        privilegedReason?: DescriptionString5to50Bytes;\n        counterparty?: PubKeyHex | \"self\" | \"anyone\";\n        forSelf?: BooleanDefaultFalse;\n        privileged?: BooleanDefaultFalse;\n    }): Promise&lt;{\n        valid: true;\n    }&gt; \n    async acquireCertificate(args: {\n        type: Base64String;\n        subject: PubKeyHex;\n        serialNumber: Base64String;\n        revocationOutpoint: OutpointString;\n        signature: HexString;\n        fields: Record&lt;CertificateFieldNameUnder50Bytes, string&gt;;\n        certifier: PubKeyHex;\n        keyringRevealer: PubKeyHex | \"certifier\";\n        keyringForSubject: Record&lt;CertificateFieldNameUnder50Bytes, Base64String&gt;;\n        acquisitionProtocol: \"direct\" | \"issuance\";\n        certifierUrl?: string;\n    }): Promise&lt;{\n        type: Base64String;\n        subject: PubKeyHex;\n        serialNumber: Base64String;\n        certifier: PubKeyHex;\n        revocationOutpoint: OutpointString;\n        signature: HexString;\n        fields: Record&lt;CertificateFieldNameUnder50Bytes, string&gt;;\n    }&gt; \n    async listCertificates(args: {\n        certifiers: PubKeyHex[];\n        types: Base64String[];\n        limit?: PositiveIntegerDefault10Max10000;\n        offset?: PositiveIntegerOrZero;\n        privileged?: BooleanDefaultFalse;\n        privilegedReason?: DescriptionString5to50Bytes;\n    }): Promise&lt;{\n        totalCertificates: PositiveIntegerOrZero;\n        certificates: Array&lt;{\n            type: Base64String;\n            subject: PubKeyHex;\n            serialNumber: Base64String;\n            certifier: PubKeyHex;\n            revocationOutpoint: OutpointString;\n            signature: HexString;\n            fields: Record&lt;CertificateFieldNameUnder50Bytes, string&gt;;\n        }&gt;;\n    }&gt; \n    async proveCertificate(args: {\n        certificate: {\n            type: Base64String;\n            subject: PubKeyHex;\n            serialNumber: Base64String;\n            certifier: PubKeyHex;\n            revocationOutpoint: OutpointString;\n            signature: HexString;\n            fields: Record&lt;CertificateFieldNameUnder50Bytes, string&gt;;\n        };\n        fieldsToReveal: CertificateFieldNameUnder50Bytes[];\n        verifier: PubKeyHex;\n        privileged?: BooleanDefaultFalse;\n        privilegedReason?: DescriptionString5to50Bytes;\n    }): Promise&lt;{\n        keyringForVerifier: Record&lt;CertificateFieldNameUnder50Bytes, Base64String&gt;;\n    }&gt; \n    async relinquishCertificate(args: {\n        type: Base64String;\n        serialNumber: Base64String;\n        certifier: PubKeyHex;\n    }): Promise&lt;{\n        relinquished: true;\n    }&gt; \n    async discoverByIdentityKey(args: {\n        identityKey: PubKeyHex;\n        limit?: PositiveIntegerDefault10Max10000;\n        offset?: PositiveIntegerOrZero;\n    }): Promise&lt;{\n        totalCertificates: PositiveIntegerOrZero;\n        certificates: Array&lt;{\n            type: Base64String;\n            subject: PubKeyHex;\n            serialNumber: Base64String;\n            certifier: PubKeyHex;\n            revocationOutpoint: OutpointString;\n            signature: HexString;\n            fields: Record&lt;CertificateFieldNameUnder50Bytes, Base64String&gt;;\n            certifierInfo: {\n                name: EntityNameStringMax100Bytes;\n                iconUrl: EntityIconURLStringMax500Bytes;\n                description: DescriptionString5to50Bytes;\n                trust: PositiveIntegerMax10;\n            };\n            publiclyRevealedKeyring: Record&lt;CertificateFieldNameUnder50Bytes, Base64String&gt;;\n            decryptedFields: Record&lt;CertificateFieldNameUnder50Bytes, string&gt;;\n        }&gt;;\n    }&gt; \n    async discoverByAttributes(args: {\n        attributes: Record&lt;CertificateFieldNameUnder50Bytes, string&gt;;\n        limit?: PositiveIntegerDefault10Max10000;\n        offset?: PositiveIntegerOrZero;\n    }): Promise&lt;{\n        totalCertificates: PositiveIntegerOrZero;\n        certificates: Array&lt;{\n            type: Base64String;\n            subject: PubKeyHex;\n            serialNumber: Base64String;\n            certifier: PubKeyHex;\n            revocationOutpoint: OutpointString;\n            signature: HexString;\n            fields: Record&lt;CertificateFieldNameUnder50Bytes, Base64String&gt;;\n            certifierInfo: {\n                name: EntityNameStringMax100Bytes;\n                iconUrl: EntityIconURLStringMax500Bytes;\n                description: DescriptionString5to50Bytes;\n                trust: PositiveIntegerMax10;\n            };\n            publiclyRevealedKeyring: Record&lt;CertificateFieldNameUnder50Bytes, Base64String&gt;;\n            decryptedFields: Record&lt;CertificateFieldNameUnder50Bytes, string&gt;;\n        }&gt;;\n    }&gt; \n    async isAuthenticated(args: {}): Promise&lt;{\n        authenticated: true;\n    }&gt; \n    async waitForAuthentication(args: {}): Promise&lt;{\n        authenticated: true;\n    }&gt; \n    async getHeight(args: {}): Promise&lt;{\n        height: PositiveInteger;\n    }&gt; \n    async getHeaderForHeight(args: {\n        height: PositiveInteger;\n    }): Promise&lt;{\n        header: HexString;\n    }&gt; \n    async getNetwork(args: {}): Promise&lt;{\n        network: \"mainnet\" | \"testnet\";\n    }&gt; \n    async getVersion(args: {}): Promise&lt;{\n        version: VersionString7To30Bytes;\n    }&gt; \n}\n</code></pre> <p>See also: BEEF, Base64String, BasketStringUnder300Bytes, BooleanDefaultFalse, BooleanDefaultTrue, Byte, CallType, CertificateFieldNameUnder50Bytes, DescriptionString5to50Bytes, EntityIconURLStringMax500Bytes, EntityNameStringMax100Bytes, HexString, ISOTimestampString, KeyIDStringUnder800Bytes, LabelStringUnder300Bytes, OutpointString, OutputTagStringUnder300Bytes, PositiveInteger, PositiveIntegerDefault10Max10000, PositiveIntegerMax10, PositiveIntegerOrZero, ProtocolString5To400Bytes, PubKeyHex, SatoshiValue, SecurityLevel, TXIDHexString, VersionString7To30Bytes, WalletInterface, decrypt, encrypt</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#functions","title":"Functions","text":""},{"location":"reference/wallet/#function-tooriginheader","title":"Function: toOriginHeader","text":"<pre><code>export function toOriginHeader(originator: string, fallbackScheme = \"http\"): string | undefined \n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#types","title":"Types","text":"AcquireCertificateResult EntityNameStringMax100Bytes ProtocolString5To400Bytes AcquisitionProtocol ErrorCodeString10To40Bytes PubKeyHex ActionStatus ErrorDescriptionString20To200Bytes ReviewActionResultStatus AtomicBEEF HexString SatoshiValue BEEF ISOTimestampString SecurityLevel Base64String KeyIDStringUnder800Bytes SendWithResultStatus BasketStringUnder300Bytes KeyringRevealer TXIDHexString BooleanDefaultFalse LabelStringUnder300Bytes TrustSelf BooleanDefaultTrue OriginatorDomainNameStringUnder250Bytes VersionString7To30Bytes Byte OutpointString WalletCounterparty CallType OutputTagStringUnder300Bytes WalletErrorCode CertificateFieldNameUnder50Bytes PositiveInteger WalletNetwork Counterparty PositiveIntegerDefault10Max10000 WalletProtocol DescriptionString5to50Bytes PositiveIntegerMax10 EntityIconURLStringMax500Bytes PositiveIntegerOrZero <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#type-acquirecertificateresult","title":"Type: AcquireCertificateResult","text":"<pre><code>export type AcquireCertificateResult = WalletCertificate\n</code></pre> <p>See also: WalletCertificate</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#type-acquisitionprotocol","title":"Type: AcquisitionProtocol","text":"<pre><code>export type AcquisitionProtocol = \"direct\" | \"issuance\"\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#type-actionstatus","title":"Type: ActionStatus","text":"<pre><code>export type ActionStatus = \"completed\" | \"unprocessed\" | \"sending\" | \"unproven\" | \"unsigned\" | \"nosend\" | \"nonfinal\" | \"failed\"\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#type-atomicbeef","title":"Type: AtomicBEEF","text":"<pre><code>export type AtomicBEEF = Byte[]\n</code></pre> <p>See also: Byte</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#type-beef","title":"Type: BEEF","text":"<pre><code>export type BEEF = Byte[]\n</code></pre> <p>See also: Byte</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#type-base64string","title":"Type: Base64String","text":"<pre><code>export type Base64String = string\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#type-basketstringunder300bytes","title":"Type: BasketStringUnder300Bytes","text":"<pre><code>export type BasketStringUnder300Bytes = string\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#type-booleandefaultfalse","title":"Type: BooleanDefaultFalse","text":"<pre><code>export type BooleanDefaultFalse = boolean\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#type-booleandefaulttrue","title":"Type: BooleanDefaultTrue","text":"<pre><code>export type BooleanDefaultTrue = boolean\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#type-byte","title":"Type: Byte","text":"<pre><code>export type Byte = number\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#type-calltype","title":"Type: CallType","text":"<pre><code>export type CallType = keyof typeof calls\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#type-certificatefieldnameunder50bytes","title":"Type: CertificateFieldNameUnder50Bytes","text":"<pre><code>export type CertificateFieldNameUnder50Bytes = string\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#type-counterparty","title":"Type: Counterparty","text":"<pre><code>export type Counterparty = PublicKey | PubKeyHex | \"self\" | \"anyone\"\n</code></pre> <p>See also: PubKeyHex, PublicKey</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#type-descriptionstring5to50bytes","title":"Type: DescriptionString5to50Bytes","text":"<pre><code>export type DescriptionString5to50Bytes = string\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#type-entityiconurlstringmax500bytes","title":"Type: EntityIconURLStringMax500Bytes","text":"<pre><code>export type EntityIconURLStringMax500Bytes = string\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#type-entitynamestringmax100bytes","title":"Type: EntityNameStringMax100Bytes","text":"<pre><code>export type EntityNameStringMax100Bytes = string\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#type-errorcodestring10to40bytes","title":"Type: ErrorCodeString10To40Bytes","text":"<pre><code>export type ErrorCodeString10To40Bytes = string\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#type-errordescriptionstring20to200bytes","title":"Type: ErrorDescriptionString20To200Bytes","text":"<pre><code>export type ErrorDescriptionString20To200Bytes = string\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#type-hexstring","title":"Type: HexString","text":"<pre><code>export type HexString = string\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#type-isotimestampstring","title":"Type: ISOTimestampString","text":"<pre><code>export type ISOTimestampString = string\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#type-keyidstringunder800bytes","title":"Type: KeyIDStringUnder800Bytes","text":"<pre><code>export type KeyIDStringUnder800Bytes = string\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#type-keyringrevealer","title":"Type: KeyringRevealer","text":"<pre><code>export type KeyringRevealer = PubKeyHex | \"certifier\"\n</code></pre> <p>See also: PubKeyHex</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#type-labelstringunder300bytes","title":"Type: LabelStringUnder300Bytes","text":"<pre><code>export type LabelStringUnder300Bytes = string\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#type-originatordomainnamestringunder250bytes","title":"Type: OriginatorDomainNameStringUnder250Bytes","text":"<pre><code>export type OriginatorDomainNameStringUnder250Bytes = string\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#type-outpointstring","title":"Type: OutpointString","text":"<pre><code>export type OutpointString = string\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#type-outputtagstringunder300bytes","title":"Type: OutputTagStringUnder300Bytes","text":"<pre><code>export type OutputTagStringUnder300Bytes = string\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#type-positiveinteger","title":"Type: PositiveInteger","text":"<pre><code>export type PositiveInteger = number\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#type-positiveintegerdefault10max10000","title":"Type: PositiveIntegerDefault10Max10000","text":"<pre><code>export type PositiveIntegerDefault10Max10000 = number\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#type-positiveintegermax10","title":"Type: PositiveIntegerMax10","text":"<pre><code>export type PositiveIntegerMax10 = number\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#type-positiveintegerorzero","title":"Type: PositiveIntegerOrZero","text":"<pre><code>export type PositiveIntegerOrZero = number\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#type-protocolstring5to400bytes","title":"Type: ProtocolString5To400Bytes","text":"<pre><code>export type ProtocolString5To400Bytes = string\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#type-pubkeyhex","title":"Type: PubKeyHex","text":"<pre><code>export type PubKeyHex = HexString\n</code></pre> <p>See also: HexString</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#type-reviewactionresultstatus","title":"Type: ReviewActionResultStatus","text":"<p>Indicates status of a new Action following a <code>createAction</code> or <code>signAction</code> in immediate mode: When <code>acceptDelayedBroadcast</code> is falses.</p> <p>'success': The action has been broadcast and accepted by the bitcoin processing network. 'doulbeSpend': The action has been confirmed to double spend one or more inputs, and by the \"first-seen-rule\" is the loosing transaction. 'invalidTx': The action was rejected by the processing network as an invalid bitcoin transaction. 'serviceError': The broadcast services are currently unable to reach the bitcoin network. The action is now queued for delayed retries.</p> <pre><code>export type ReviewActionResultStatus = \"success\" | \"doubleSpend\" | \"serviceError\" | \"invalidTx\"\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#type-satoshivalue","title":"Type: SatoshiValue","text":"<pre><code>export type SatoshiValue = number\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#type-securitylevel","title":"Type: SecurityLevel","text":"<p>SecurityLevel for protocols. 0 = Silently grants the request with no user interation. 1 = Requires user approval for every application. 2 = Requires user approval per counterparty per application.</p> <pre><code>export type SecurityLevel = 0 | 1 | 2\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#type-sendwithresultstatus","title":"Type: SendWithResultStatus","text":"<pre><code>export type SendWithResultStatus = \"unproven\" | \"sending\" | \"failed\"\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#type-txidhexstring","title":"Type: TXIDHexString","text":"<pre><code>export type TXIDHexString = HexString\n</code></pre> <p>See also: HexString</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#type-trustself","title":"Type: TrustSelf","text":"<p>Controls behavior of input BEEF validation.</p> <p>If <code>known</code>, input transactions may omit supporting validity proof data for all TXIDs known to this wallet.</p> <p>If undefined, input BEEFs must be complete and valid.</p> <pre><code>export type TrustSelf = \"known\"\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#type-versionstring7to30bytes","title":"Type: VersionString7To30Bytes","text":"<pre><code>export type VersionString7To30Bytes = string\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#type-walletcounterparty","title":"Type: WalletCounterparty","text":"<pre><code>export type WalletCounterparty = PubKeyHex | \"self\" | \"anyone\"\n</code></pre> <p>See also: PubKeyHex</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#type-walleterrorcode","title":"Type: WalletErrorCode","text":"<pre><code>export type WalletErrorCode = keyof typeof walletErrors\n</code></pre> <p>See also: walletErrors</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#type-walletnetwork","title":"Type: WalletNetwork","text":"<pre><code>export type WalletNetwork = \"mainnet\" | \"testnet\"\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#type-walletprotocol","title":"Type: WalletProtocol","text":"<pre><code>export type WalletProtocol = [\n    SecurityLevel,\n    ProtocolString5To400Bytes\n]\n</code></pre> <p>See also: ProtocolString5To400Bytes, SecurityLevel</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#enums","title":"Enums","text":"SecurityLevels walletErrors <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#enum-securitylevels","title":"Enum: SecurityLevels","text":"<pre><code>export enum SecurityLevels {\n    Silent = 0,\n    App = 1,\n    Counterparty = 2\n}\n</code></pre> <p>See also: Counterparty</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#enum-walleterrors","title":"Enum: walletErrors","text":"<pre><code>export enum walletErrors {\n    unknownError = 1,\n    unsupportedAction = 2,\n    invalidHmac = 3,\n    invalidSignature = 4,\n    reviewActions = 5\n}\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#variables","title":"Variables","text":""},{"location":"tutorials/","title":"Tutorials","text":"<p>Welcome to the BSV TypeScript SDK tutorials. These step-by-step lessons will teach you how to use the SDK through practical examples.</p>"},{"location":"tutorials/#try-examples-interactively","title":"\ud83d\ude80 Try Examples Interactively","text":"<p>Before diving into the tutorials, you can experiment with many of these concepts in our Interactive BSV Coding Environment. Run SDK code directly in your browser without any setup required!</p>"},{"location":"tutorials/#getting-started-track","title":"Getting Started Track","text":""},{"location":"tutorials/#your-first-bsv-transaction","title":"Your First BSV Transaction","text":"<ul> <li>Duration: 30 minutes</li> <li>Prerequisites: Node.js, basic TypeScript knowledge</li> <li> <p>Learning Goals:</p> <ul> <li>Install and configure the SDK</li> <li>Create a simple P2PKH transaction</li> <li>Understand BSV transaction anatomy</li> </ul> </li> </ul>"},{"location":"tutorials/#transaction-types-and-data","title":"Transaction Types and Data","text":"<ul> <li>Duration: 30 minutes</li> <li>Prerequisites: Completed \"Your First BSV Transaction\" tutorial</li> <li> <p>Learning Goals:</p> <ul> <li>Create transactions with multiple outputs</li> <li>Add data to transactions</li> <li>Work with different output types</li> <li>Use advanced <code>WalletClient</code> features</li> </ul> </li> </ul>"},{"location":"tutorials/#key-management-and-cryptography","title":"Key Management and Cryptography","text":"<ul> <li>Duration: 45 minutes</li> <li>Prerequisites: Completed \"Your First BSV Transaction\" tutorial</li> <li> <p>Learning Goals:</p> <ul> <li>Generate and manage private/public keys</li> <li>Understand ECDSA signatures</li> <li>Create and verify digital signatures</li> </ul> </li> </ul>"},{"location":"tutorials/#transaction-broadcasting","title":"Transaction Broadcasting","text":"<ul> <li>Duration: 25 minutes</li> <li>Prerequisites: Completed \"Your First BSV Transaction\" tutorial, Node.js, basic TypeScript knowledge</li> <li> <p>Learning Goals:</p> <ul> <li>Understand <code>WalletClient</code> vs direct broadcasting approaches</li> <li>Configure broadcasting for testnet vs mainnet</li> <li>Implement custom broadcasters (ARC, WhatsOnChain)</li> <li>Handle broadcasting errors and implement retry logic</li> <li>Monitor and verify transaction acceptance</li> </ul> </li> </ul>"},{"location":"tutorials/#intermediate-development-track","title":"Intermediate Development Track","text":""},{"location":"tutorials/#working-with-protowallet-for-development","title":"Working with ProtoWallet for Development","text":"<ul> <li>Duration: 45 minutes</li> <li>Prerequisites: Basic TypeScript knowledge, understanding of cryptographic concepts</li> <li> <p>Learning Goals:</p> <ul> <li>Create and configure ProtoWallet instances</li> <li>Perform key derivation and management</li> <li>Implement signing, encryption, and HMAC operations</li> <li>Build development toolkits and testing environments</li> </ul> </li> </ul>"},{"location":"tutorials/#authenticated-http-requests-with-authfetch","title":"Authenticated HTTP Requests with AuthFetch","text":"<ul> <li>Duration: 60 minutes</li> <li>Prerequisites: Understanding of HTTP protocols, basic cryptography knowledge</li> <li> <p>Learning Goals:</p> <ul> <li>Implement BRC-103/104 authentication protocols</li> <li>Set up certificate exchange and peer authentication</li> <li>Build secure API clients with cryptographic request signing</li> <li>Handle authentication errors and implement retry logic</li> </ul> </li> </ul>"},{"location":"tutorials/#decentralized-file-storage-with-uhrp","title":"Decentralized File Storage with UHRP","text":"<ul> <li>Duration: 75 minutes</li> <li>Prerequisites: Understanding of content-addressed storage concepts</li> <li> <p>Learning Goals:</p> <ul> <li>Upload and download files using UHRP protocol</li> <li>Implement file integrity verification</li> <li>Manage file retention and renewal</li> <li>Build batch file operations and management systems</li> </ul> </li> </ul>"},{"location":"tutorials/#identity-management-and-certificates","title":"Identity Management and Certificates","text":"<ul> <li>Duration: 90 minutes</li> <li>Prerequisites: Understanding of PKI and certificate concepts</li> <li> <p>Learning Goals:</p> <ul> <li>Work with decentralized identity systems</li> <li>Resolve identities by keys and attributes</li> <li>Manage identity certificates and verification</li> <li>Build identity-based authentication services</li> </ul> </li> </ul>"},{"location":"tutorials/#advanced-transaction-construction","title":"Advanced Transaction Construction","text":"<ul> <li>Duration: 75 minutes</li> <li> <p>Learning Goals:</p> <ul> <li>Multi-input/multi-output transactions</li> <li>Fee calculation and optimization</li> <li>Change output handling</li> </ul> </li> </ul>"},{"location":"tutorials/#script-construction-and-custom-logic","title":"Script Construction and Custom Logic","text":"<ul> <li>Duration: 90 minutes</li> <li> <p>Learning Goals:</p> <ul> <li>Understand Bitcoin Script basics</li> <li>Create custom locking scripts</li> <li>Implement unlocking logic</li> </ul> </li> </ul>"},{"location":"tutorials/#spv-and-merkle-proof-verification","title":"SPV and Merkle Proof Verification","text":"<ul> <li>Duration: 90 minutes</li> <li> <p>Learning Goals:</p> <ul> <li>Understand SPV principles</li> <li>Verify Merkle proofs</li> <li>Implement lightweight verification</li> </ul> </li> </ul>"},{"location":"tutorials/#error-handling-and-edge-cases","title":"Error Handling and Edge Cases","text":"<ul> <li>Duration: 60 minutes</li> <li> <p>Learning Goals:</p> <ul> <li>Robust error handling patterns</li> <li>Network failure recovery</li> <li>Transaction validation edge cases</li> </ul> </li> </ul>"},{"location":"tutorials/#low-level-cryptography-track","title":"Low-Level Cryptography Track","text":""},{"location":"tutorials/#elliptic-curve-fundamentals-numbers-points","title":"Elliptic Curve Fundamentals: Numbers &amp; Points","text":"<ul> <li>Duration: 90 minutes</li> <li> <p>Learning Goals:</p> <ul> <li>Understand the mathematical foundations of elliptic curves</li> <li>Work with BigInteger numbers in the SDK</li> <li>Manipulate elliptic curve points</li> <li>Implement point addition and scalar multiplication</li> </ul> </li> </ul>"},{"location":"tutorials/#ecdh-key-exchange","title":"ECDH Key Exchange","text":"<ul> <li>Duration: 75 minutes</li> <li> <p>Learning Goals:</p> <ul> <li>Understand Elliptic Curve Diffie-Hellman (ECDH) key exchange principles</li> <li>Implement secure key exchange using the SDK</li> <li>Create shared secrets for encrypted communication</li> <li>Apply ECDH in practical Bitcoin applications</li> </ul> </li> </ul>"},{"location":"tutorials/#aes-symmetric-encryption","title":"AES Symmetric Encryption","text":"<ul> <li>Duration: 60 minutes</li> <li> <p>Learning Goals:</p> <ul> <li>Understand AES-GCM symmetric encryption principles</li> <li>Use the <code>SymmetricKey</code> class for encryption and decryption</li> <li>Implement secure key generation and management</li> <li>Apply AES encryption in practical Bitcoin applications</li> <li>Combine AES with ECDH for secure communication</li> <li>Handle different data formats and encoding</li> </ul> </li> </ul>"},{"location":"tutorials/#hashes-and-hmacs","title":"Hashes and HMACs","text":"<ul> <li>Duration: 75 minutes</li> <li> <p>Learning Goals:</p> <ul> <li>Understand cryptographic hash functions and their properties</li> <li>Master the Hash module classes and helper functions in the BSV TypeScript SDK</li> <li>Implement various hash algorithms (SHA-256, SHA-512, SHA-1, RIPEMD-160)</li> <li>Create and verify HMACs for message authentication</li> <li>Apply Bitcoin-specific hashing patterns (hash256, hash160)</li> <li>Build practical applications using hashing for data integrity and authentication</li> <li>Understand performance considerations and security best practices</li> </ul> </li> </ul>"},{"location":"tutorials/#type-42-key-derivation","title":"Type-42 Key Derivation","text":"<ul> <li>Duration: 75 minutes</li> <li>Prerequisites: Basic TypeScript knowledge, Elliptic Curve Fundamentals tutorial completed, ECDH Key Exchange tutorial completed</li> <li> <p>Learning Goals:</p> <ul> <li>Understand Type-42 key derivation protocol and its use cases</li> <li>Implement Type-42 operations with the BSV TypeScript SDK</li> <li>Create shared key universes between two parties</li> <li>Apply Type-42 in practical Bitcoin applications like message signing and encryption</li> <li>Understand the \"anyone key\" concept and its applications</li> </ul> </li> </ul>"},{"location":"tutorials/#alternative-low-level-transaction-api-track","title":"Alternative Low-Level Transaction API Track","text":"<p>These tutorials demonstrate how to use the lower-level APIs of the BSV TypeScript SDK for more direct control over transaction creation and management.</p>"},{"location":"tutorials/#your-first-bsv-transaction-low-level-api","title":"Your First BSV Transaction (Low-level API)","text":"<ul> <li>Duration: 45 minutes</li> <li>Prerequisites: Node.js, basic TypeScript knowledge</li> <li> <p>Learning Goals:</p> <ul> <li>Work with low-level transaction APIs</li> <li>Create transactions without WalletClient abstraction</li> <li>Understand transaction construction internals</li> <li>Manually manage inputs, outputs, and signing</li> </ul> </li> </ul>"},{"location":"tutorials/#working-with-testnet-transactions-low-level-api","title":"Working with Testnet Transactions (Low-level API)","text":"<ul> <li>Duration: 60 minutes</li> <li>Prerequisites: Completed \"Your First BSV Transaction (Low-level API)\" tutorial</li> <li> <p>Learning Goals:</p> <ul> <li>Set up a BSV testnet environment with low-level APIs</li> <li>Manually handle testnet transactions</li> <li>Understand UTXO management without WalletClient</li> <li>Implement custom transaction workflows</li> </ul> </li> </ul>"},{"location":"tutorials/advanced-transaction/","title":"Advanced Transaction Construction","text":"<p>Duration: 75 minutes Prerequisites: Completed \"Transaction Types and Data\" tutorial, Node.js, basic TypeScript knowledge  </p>"},{"location":"tutorials/advanced-transaction/#learning-goals","title":"Learning Goals","text":"<ul> <li>Master multi-input/multi-output transaction construction</li> <li>Implement advanced fee calculation and optimization strategies</li> <li>Handle change outputs efficiently</li> <li>Use advanced <code>WalletClient</code> options for transaction control</li> <li>Implement UTXO selection and management strategies</li> <li>Handle complex transaction scenarios and error recovery</li> </ul>"},{"location":"tutorials/advanced-transaction/#introduction","title":"Introduction","text":"<p>This tutorial builds on your knowledge of basic <code>WalletClient</code> usage to explore advanced transaction construction patterns. You'll learn how to create sophisticated transactions that handle multiple inputs and outputs, optimize fees, and manage UTXOs effectively for production applications.</p>"},{"location":"tutorials/advanced-transaction/#prerequisites","title":"Prerequisites","text":"<ul> <li>Complete the Transaction Types and Data tutorial</li> <li>Have a BRC-100 compliant wallet (such as the MetaNet Desktop Wallet) installed and configured</li> <li>Some BSV in your wallet</li> <li>Understanding of Bitcoin transaction fundamentals</li> </ul>"},{"location":"tutorials/advanced-transaction/#advanced-walletclient-options","title":"Advanced <code>WalletClient</code> Options","text":"<p>The <code>createAction</code> method supports many advanced options through the <code>options</code> parameter. Let's explore these capabilities:</p> <pre><code>import { WalletClient } from '@bsv/sdk'\n\nasync function exploreAdvancedOptions() {\n  try {\n    const wallet = new WalletClient('auto', 'localhost')\n\n    // Authenticate with the wallet\n    const { authenticated } = await wallet.isAuthenticated()\n    if (!authenticated) {\n      await wallet.waitForAuthentication()\n    }\n\n    // Create a transaction with advanced options\n    const actionResult = await wallet.createAction({\n      description: 'Advanced options demonstration',\n      outputs: [\n        {\n          satoshis: 100,\n          lockingScript: '006a0e416476616e636564206f7074696f6e73', // OP_RETURN \"Advanced options\"\n          outputDescription: 'Advanced options demo'\n        }\n      ],\n      options: {\n        // Don't automatically sign and process - gives you more control\n        signAndProcess: false,\n\n        // Accept delayed broadcast for better fee optimization\n        acceptDelayedBroadcast: true,\n\n        // Return only the transaction ID to save bandwidth\n        returnTXIDOnly: false,\n\n        // Don't send the transaction immediately\n        noSend: true,\n\n        // Randomize output order for privacy\n        randomizeOutputs: true\n      }\n    })\n\n    console.log('Transaction created with advanced options:')\n    console.log('Signable transaction available for manual processing')\n\n    if (actionResult.signableTransaction) {\n      console.log('Transaction reference:', actionResult.signableTransaction.reference)\n      console.log('Transaction ready for signing')\n    }\n\n  } catch (error: any) {\n    console.error('Error:', error)\n\n    // Provide helpful troubleshooting\n    if (error.message?.includes('unlockingScript')) {\n      console.log('\\nTroubleshooting: When specifying custom inputs, you must provide:')\n      console.log('- unlockingScript (valid hexadecimal string, not empty)')\n      console.log('- unlockingScriptLength (typically 107 for P2PKH)')\n      console.log('\\nRecommendation: Let the wallet auto-select inputs by omitting the inputs array')\n    }\n  }\n}\n\nexploreAdvancedOptions().catch(console.error)\n</code></pre>"},{"location":"tutorials/advanced-transaction/#multi-input-transaction-construction","title":"Multi-Input Transaction Construction","text":"<p>Multi-input transactions combine multiple UTXOs to fund larger outputs. The BSV TypeScript SDK provides two approaches:</p> <ol> <li> <p>Automatic Input Selection (Recommended): Let the wallet automatically select UTXOs by creating outputs that require more satoshis than any single UTXO can provide.</p> </li> <li> <p>Manual Input Specification (Advanced): Explicitly specify which UTXOs to use as inputs. This requires providing complete unlocking script information and is typically only needed for specialized use cases.</p> </li> </ol> <pre><code>import { WalletClient } from '@bsv/sdk'\n\nasync function createMultiInputTransaction() {\n  try {\n    const wallet = new WalletClient('auto', 'localhost')\n\n    const { authenticated } = await wallet.isAuthenticated()\n    if (!authenticated) {\n      await wallet.waitForAuthentication()\n    }\n\n    // First, let's see what UTXOs we have available (basket name is 'bsv-tutorial' for consistency with previous tutorials, where we created some outputs)\n    const { outputs } = await wallet.listOutputs({\n      basket: 'bsv-tutorial',\n      include: 'locking scripts',\n      limit: 10\n    })\n\n    console.log(`Found ${outputs.length} available outputs:`)\n    outputs.forEach((output, index) =&gt; {\n      console.log(`  ${index + 1}. ${output.outpoint}: ${output.satoshis} satoshis (spendable: ${output.spendable})`)\n    })\n\n    // Check if we have enough UTXOs for a multi-input transaction\n    const spendableOutputs = outputs.filter(output =&gt; output.spendable &amp;&amp; output.satoshis &gt;= 100)\n\n    if (spendableOutputs.length &lt; 2) {\n      console.log('Need at least 2 spendable outputs for this demo')\n      return\n    }\n\n    // Method 1: Automatic Input Selection (Recommended)\n\n    // Create a transaction that requires multiple inputs by using a large output amount\n    // The wallet will automatically select multiple UTXOs if needed\n    const totalAvailable = spendableOutputs.reduce((sum, output) =&gt; sum + output.satoshis, 0)\n    const largeAmount = Math.min(1500, Math.floor(totalAvailable * 0.8)) // Use 80% of available funds\n\n    console.log(`Creating transaction requiring ${largeAmount} satoshis (should trigger multi-input selection)`)\n\n    const actionResult = await wallet.createAction({\n      description: 'Multi-input transaction example',\n      outputs: [\n        {\n          satoshis: largeAmount,\n          lockingScript: '006a0c4d756c74692d696e707574', // OP_RETURN \"Multi-input\"\n          outputDescription: 'Multi-input demo output'\n        }\n      ]\n      // No inputs specified - let wallet auto-select\n    })\n\n    console.log('Transaction created successfully!')\n    console.log('Transaction ID:', actionResult.txid)\n    console.log(`View on explorer: https://whatsonchain.com/tx/${actionResult.txid}`)\n\n    // Method 2: Manual Input Specification (Advanced)\n    // Manual input specification requires unlocking script details\n    // This is commented out as it requires proper unlocking script construction\n    /*\n    const manualActionResult = await wallet.createAction({\n      description: 'Manual multi-input transaction',\n      inputs: [\n        {\n          outpoint: spendableOutputs[0].outpoint,\n          unlockingScript: '00', // Placeholder - would need actual unlocking script\n          unlockingScriptLength: 107, // Typical P2PKH unlocking script length\n          inputDescription: 'First manually selected input'\n        },\n        {\n          outpoint: spendableOutputs[1].outpoint,\n          unlockingScript: '00', // Placeholder - would need actual unlocking script\n          unlockingScriptLength: 107, // Typical P2PKH unlocking script length\n          inputDescription: 'Second manually selected input'\n        }\n      ],\n      outputs: [\n        {\n          satoshis: 150,\n          lockingScript: '006a104d616e75616c2d6d756c74692d696e707574', // OP_RETURN \"Manual-multi-input\"\n          outputDescription: 'Manual multi-input demo output'\n        }\n      ]\n    })\n    */\n\n  } catch (error: any) {\n    console.error('Error:', error)\n\n    // Provide helpful troubleshooting\n    if (error.message?.includes('unlockingScript')) {\n      console.log('\\nTroubleshooting: When specifying custom inputs, you must provide:')\n      console.log('- unlockingScript (valid hexadecimal string, not empty)')\n      console.log('- unlockingScriptLength (typically 107 for P2PKH)')\n      console.log('\\nRecommendation: Let the wallet auto-select inputs by omitting the inputs array')\n    }\n  }\n}\n\ncreateMultiInputTransaction().catch(console.error)\n</code></pre>"},{"location":"tutorials/advanced-transaction/#batch-processing-multiple-payments","title":"Batch Processing Multiple Payments","text":"<p>For businesses and applications that need to send multiple payments efficiently, batch processing reduces fees and blockchain footprint:</p> <pre><code>import { WalletClient } from '@bsv/sdk'\n\nasync function createBatchPayment() {\n  try {\n    const wallet = new WalletClient('auto', 'localhost')\n\n    const { authenticated } = await wallet.isAuthenticated()\n    if (!authenticated) {\n      await wallet.waitForAuthentication()\n    }\n\n    // Simulate multiple payment recipients\n    const payments = [\n      { amount: 100, description: 'Payment to Alice', data: 'Invoice #001' },\n      { amount: 150, description: 'Payment to Bob', data: 'Invoice #002' },\n      { amount: 200, description: 'Payment to Carol', data: 'Invoice #003' }\n    ]\n\n    // Create outputs for each payment\n    const outputs = payments.map((payment, index) =&gt; {\n      // Create OP_RETURN with payment data\n      const dataHex = Buffer.from(payment.data).toString('hex')\n      const dataLength = Buffer.from(payment.data).length\n      const dataLengthHex = dataLength.toString(16).padStart(2, '0')\n      const lockingScript = `006a${dataLengthHex}${dataHex}`\n\n      return {\n        satoshis: payment.amount,\n        lockingScript: lockingScript,\n        outputDescription: payment.description,\n        basket: 'payments', // Organize outputs in a specific basket\n        tags: ['batch-payment', `invoice-${index + 1}`] // Tag for easy tracking\n      }\n    })\n\n    // Create the batch transaction\n    const actionResult = await wallet.createAction({\n      description: 'Batch payment transaction',\n      outputs: outputs,\n      labels: ['batch-processing', 'business-payments'], // Labels for transaction tracking\n      options: {\n        randomizeOutputs: false // Keep payment order for accounting\n      }\n    })\n\n    if (actionResult.txid) {\n      console.log(`Batch payment transaction created: ${actionResult.txid}`)\n      console.log(`Processed ${payments.length} payments in a single transaction`)\n      console.log(`Total amount: ${payments.reduce((sum, p) =&gt; sum + p.amount, 0)} satoshis`)\n      console.log(`View on explorer: https://whatsonchain.com/tx/${actionResult.txid}`)\n    }\n\n  } catch (error: unknown) {\n    console.error('Error:', error)\n  }\n}\n\ncreateBatchPayment().catch(console.error)\n</code></pre>"},{"location":"tutorials/advanced-transaction/#advanced-utxo-management-with-baskets","title":"Advanced UTXO Management with Baskets","text":"<p>Baskets provide powerful UTXO organization capabilities. Here's how to use them for advanced transaction patterns:</p> <pre><code>import { WalletClient } from '@bsv/sdk'\n\nasync function advancedBasketManagement() {\n  try {\n    const wallet = new WalletClient('auto', 'localhost')\n\n    const { authenticated } = await wallet.isAuthenticated()\n    if (!authenticated) {\n      await wallet.waitForAuthentication()\n    }\n\n    // Create outputs in different baskets for different purposes\n    console.log('Creating specialized UTXO baskets...')\n\n    const actionResult = await wallet.createAction({\n      description: 'UTXO organization with baskets',\n      outputs: [\n        {\n          satoshis: 500,\n          lockingScript: '006a0c48696768207072696f72697479', // OP_RETURN \"High priority\"\n          outputDescription: 'High priority reserve',\n          basket: 'high-priority',\n          tags: ['reserve', 'urgent-use'],\n          customInstructions: 'Reserved for urgent transactions'\n        },\n        {\n          satoshis: 300,\n          lockingScript: '006a0d4d656469756d207072696f72697479', // OP_RETURN \"Medium priority\"\n          outputDescription: 'Medium priority operations',\n          basket: 'medium-priority',\n          tags: ['operations', 'daily-use']\n        },\n        {\n          satoshis: 200,\n          lockingScript: '006a0b4c6f77207072696f72697479', // OP_RETURN \"Low priority\"\n          outputDescription: 'Low priority batch',\n          basket: 'low-priority',\n          tags: ['batch', 'bulk-operations']\n        }\n      ]\n    })\n\n    if (actionResult.txid) {\n      console.log(`Basket organization transaction: ${actionResult.txid}`)\n      console.log('Note: OP_RETURN outputs are unspendable by design (for data storage)')\n      console.log('Waiting for wallet to process new outputs...')\n      // Give the wallet a moment to process the new outputs\n      await new Promise(resolve =&gt; setTimeout(resolve, 2000))\n    }\n\n    // Now let's examine our organized UTXOs\n    console.log('\\nExamining basket organization...')\n    console.log('Note: OP_RETURN outputs show spendable: false because they are data-only outputs')\n    const baskets = ['high-priority', 'medium-priority', 'low-priority']\n\n    for (const basketName of baskets) {\n      const { outputs, totalOutputs } = await wallet.listOutputs({\n        basket: basketName,\n        includeTags: true,\n        includeCustomInstructions: true,\n        limit: 10\n      })\n\n      console.log(`\\n${basketName.toUpperCase()} Basket:`)\n      console.log(`  Total outputs: ${totalOutputs}`)\n\n      if (totalOutputs === 0) {\n        console.log(`  Note: No outputs found. This could be because:`)\n        console.log(`    - Outputs need confirmation time`)\n        console.log(`    - Wallet needs time to process new baskets`)\n        console.log(`    - OP_RETURN outputs might not be tracked as spendable UTXOs`)\n      }\n\n      outputs.forEach((output, index) =&gt; {\n        console.log(`  Output ${index + 1}:`)\n        console.log(`    Outpoint: ${output.outpoint}`)\n        console.log(`    Amount: ${output.satoshis} satoshis`)\n        console.log(`    Spendable: ${output.spendable}`)\n        if (output.tags) {\n          console.log(`    Tags: ${output.tags.join(', ')}`)\n        }\n        if (output.customInstructions) {\n          console.log(`    Instructions: ${output.customInstructions}`)\n        }\n      })\n    }\n\n    // Add processing delay\n    await new Promise(resolve =&gt; setTimeout(resolve, 5000));\n\n  } catch (error: unknown) {\n    console.error('Error:', error)\n  }\n}\n\nadvancedBasketManagement().catch(console.error)\n</code></pre>"},{"location":"tutorials/advanced-transaction/#transaction-chaining-and-dependencies","title":"Transaction Chaining and Dependencies","text":"<p>Sometimes you need to create transactions that depend on previous ones. Here's how to handle transaction chaining:</p> <pre><code>import { WalletClient } from '@bsv/sdk'\n\nasync function createTransactionChain() {\n  try {\n    const wallet = new WalletClient('auto', 'localhost')\n\n    const { authenticated } = await wallet.isAuthenticated()\n    if (!authenticated) {\n      await wallet.waitForAuthentication()\n    }\n\n    console.log('Creating transaction chain...')\n    console.log('Transaction chaining allows you to create a series of transactions that depend on each other.')\n    console.log('This is useful for scenarios where you need to ensure that a transaction is only processed after a previous one has been confirmed.')\n    console.log('In this example, we will create two transactions: the first one creates an output, and the second one spends that output.')\n\n    // First transaction - creates outputs for the chain\n    const firstTx = await wallet.createAction({\n      description: 'Chain starter transaction',\n      outputs: [\n        {\n          satoshis: 400,\n          lockingScript: '006a0d436861696e207374617274657220', // OP_RETURN \"Chain starter\"\n          outputDescription: 'Chain starter output',\n          basket: 'chain-demo',\n          tags: ['chain', 'step-1']\n        }\n      ],\n      options: {\n        acceptDelayedBroadcast: true // Allow some delay for better fee optimization\n      }\n    })\n\n    if (!firstTx.txid) {\n      console.log('First transaction failed')\n      return\n    }\n\n    console.log(`First transaction: ${firstTx.txid}`)\n\n    // Wait a moment for the transaction to be processed\n    await new Promise(resolve =&gt; setTimeout(resolve, 2000))\n\n    // Second transaction - demonstrates chaining with sendWith option\n    // Note: We use automatic input selection rather than manual specification\n    // Manual input specification requires unlockingScript and unlockingScriptLength\n    // which adds complexity for tutorial purposes\n    const secondTx = await wallet.createAction({\n      description: 'Chain continuation transaction',\n      outputs: [\n        {\n          satoshis: 150,\n          lockingScript: '006a0c436861696e20636f6e74696e756174696f6e', // OP_RETURN \"Chain continuation\"\n          outputDescription: 'Chain continuation output',\n          basket: 'chain-demo',\n          tags: ['chain', 'step-2']\n        }\n      ],\n      options: {\n        sendWith: [firstTx.txid] // Ensure this transaction is sent with the first one\n      }\n    })\n\n    if (secondTx.txid) {\n      console.log(`Second transaction: ${secondTx.txid}`)\n      console.log('Transaction chain completed successfully')\n    }\n\n  } catch (error: unknown) {\n    console.error('Error in transaction chain:', error)\n  }\n}\n\ncreateTransactionChain().catch(console.error)\n</code></pre>"},{"location":"tutorials/advanced-transaction/#performance-optimization-strategies","title":"Performance Optimization Strategies","text":"<p>For high-throughput applications, consider these optimization techniques:</p> <pre><code>import { WalletClient } from '@bsv/sdk'\n\nasync function optimizedTransactionPatterns() {\n  try {\n    const wallet = new WalletClient('auto', 'localhost')\n\n    const { authenticated } = await wallet.isAuthenticated()\n    if (!authenticated) {\n      await wallet.waitForAuthentication()\n    }\n\n    // Strategy 1: Pre-allocate UTXOs for different purposes\n    console.log('Pre-allocating UTXOs for optimal performance...')\n\n    const allocationTx = await wallet.createAction({\n      description: 'UTXO pre-allocation for performance',\n      outputs: [\n        // Create multiple small UTXOs for frequent operations\n        ...Array(5).fill(null).map((_, i) =&gt; ({\n          satoshis: 200,\n          lockingScript: `006a0f507265616c6c6f636174656420${i.toString(16).padStart(2, '0')}`, // \"Preallocated\" + index\n          outputDescription: `Pre-allocated UTXO ${i + 1}`,\n          basket: 'pre-allocated',\n          tags: ['performance', 'ready-to-use']\n        }))\n      ],\n      options: {\n        acceptDelayedBroadcast: true\n      }\n    })\n\n    if (allocationTx.txid) {\n      console.log(`Pre-allocation transaction: ${allocationTx.txid}`)\n    }\n\n    // Strategy 2: Batch multiple operations efficiently\n    await new Promise(resolve =&gt; setTimeout(resolve, 3000))\n\n    const operations = [\n      { type: 'data', content: 'Operation 1' },\n      { type: 'data', content: 'Operation 2' },\n      { type: 'data', content: 'Operation 3' }\n    ]\n\n    const batchOutputs = operations.map((op, index) =&gt; {\n      const dataHex = Buffer.from(op.content).toString('hex')\n      const dataLength = Buffer.from(op.content).length\n      const dataLengthHex = dataLength.toString(16).padStart(2, '0')\n\n      return {\n        satoshis: 100,\n        lockingScript: `006a${dataLengthHex}${dataHex}`,\n        outputDescription: `Batch operation ${index + 1}`,\n        basket: 'operations',\n        tags: ['batch', `op-${index + 1}`]\n      }\n    })\n\n    // Use pre-allocated UTXOs for the batch\n    const { outputs: preAllocated } = await wallet.listOutputs({\n      basket: 'pre-allocated',\n      limit: 3\n    })\n\n    console.log(`Found ${preAllocated.length} pre-allocated UTXOs`)\n\n    if (preAllocated.length &gt; 0) {\n      // Let the wallet automatically select inputs instead of manual specification\n      const batchTx = await wallet.createAction({\n        description: 'Optimized batch operation',\n        outputs: batchOutputs,\n        options: {\n          randomizeOutputs: false, // Maintain order for processing\n          acceptDelayedBroadcast: true\n        }\n      })\n\n      if (batchTx.txid) {\n        console.log(`Optimized batch transaction: ${batchTx.txid}`)\n        console.log(`Processed ${operations.length} operations efficiently`)\n      }\n    }\n\n  } catch (error: unknown) {\n    console.error('Optimization error:', error)\n  }\n}\n\noptimizedTransactionPatterns().catch(console.error)\n</code></pre>"},{"location":"tutorials/advanced-transaction/#conclusion","title":"Conclusion","text":"<p>You've now mastered advanced transaction construction with the BSV TypeScript SDK's <code>WalletClient</code>. You can:</p> <ul> <li>Create sophisticated multi-input/multi-output transactions</li> <li>Implement robust error handling and retry strategies</li> <li>Optimize transaction patterns for performance</li> <li>Use advanced <code>WalletClient</code> features like baskets, tags, and options</li> <li>Handle complex scenarios like transaction chaining and batch processing</li> </ul> <p>These techniques enable you to build production-ready applications that efficiently manage Bitcoin transactions while maintaining reliability and performance.</p>"},{"location":"tutorials/advanced-transaction/#next-steps","title":"Next Steps","text":"<ul> <li>Review the Transaction Signing Methods for custom signing scenarios</li> <li> <p>Check out specialized tutorials for your specific use case</p> </li> <li> <p>Advanced transaction construction requires robust error handling for production applications. For comprehensive coverage of error handling patterns, retry mechanisms, and recovery strategies, see the dedicated Error Handling Tutorial.</p> </li> </ul>"},{"location":"tutorials/advanced-transaction/#additional-resources","title":"Additional Resources","text":"<ul> <li>Wallet Reference</li> <li>BSV Blockchain Documentation</li> <li>MetaNet Desktop Wallet</li> </ul>"},{"location":"tutorials/aes-encryption/","title":"AES Symmetric Encryption","text":"<p>Duration: 60 minutes Prerequisites: Basic TypeScript knowledge, First Transaction tutorial completed</p>"},{"location":"tutorials/aes-encryption/#learning-goals","title":"Learning Goals","text":"<ul> <li>Understand AES-GCM symmetric encryption principles</li> <li>Use the <code>SymmetricKey</code> class for encryption and decryption</li> <li>Implement secure key generation and management</li> <li>Apply AES encryption in practical Bitcoin applications</li> <li>Combine AES with ECDH for secure communication</li> <li>Handle different data formats and encoding</li> </ul>"},{"location":"tutorials/aes-encryption/#introduction-to-aes-encryption","title":"Introduction to AES Encryption","text":"<p>Advanced Encryption Standard (AES) is a symmetric encryption algorithm where the same key is used for both encryption and decryption. The BSV TypeScript SDK provides the <code>SymmetricKey</code> class that implements AES-GCM (Galois/Counter Mode), which provides both confidentiality and authenticity.</p> <p>AES-GCM offers several advantages:</p> <ul> <li>Confidentiality: Data is encrypted and unreadable without the key</li> <li>Authenticity: Built-in authentication prevents tampering</li> <li>Performance: Fast encryption/decryption operations</li> <li>Security: Resistant to various cryptographic attacks</li> </ul>"},{"location":"tutorials/aes-encryption/#setting-up-your-environment","title":"Setting Up Your Environment","text":"<p>First, let's import the necessary classes from the SDK:</p> <pre><code>import { SymmetricKey, Utils, Random } from '@bsv/sdk'\n\n// Helper function to convert hex string to byte array\nfunction hexToBytes(hex: string): number[] {\n  const bytes = []\n  for (let i = 0; i &lt; hex.length; i += 2) {\n    bytes.push(parseInt(hex.substr(i, 2), 16))\n  }\n  return bytes\n}\n\n// Helper function to convert byte array to hex string\nfunction bytesToHex(bytes: number[]): string {\n  const hex = []\n  for (const byte of bytes) {\n    hex.push(byte.toString(16).padStart(2, '0'))\n  }\n  return hex.join('')\n}\n</code></pre>"},{"location":"tutorials/aes-encryption/#basic-aes-encryption","title":"Basic AES Encryption","text":""},{"location":"tutorials/aes-encryption/#generating-encryption-keys","title":"Generating Encryption Keys","text":"<p>The <code>SymmetricKey</code> class provides methods to create secure encryption keys:</p> <pre><code>// Generate a random 256-bit AES key\nconst symmetricKey = SymmetricKey.fromRandom()\nconsole.log('Generated key:', symmetricKey.toHex())\n\n// Create a key from existing data (32 bytes)\nconst keyData = Random(32)\nconst customKey = new SymmetricKey(keyData)\nconsole.log('Custom key:', customKey.toHex())\n\n// Create a key from hex string\nconst hexKey = 'a1b2c3d4e5f6789012345678901234567890abcdef1234567890abcdef123456'\nconst keyFromHex = new SymmetricKey(hexToBytes(hexKey))\n</code></pre>"},{"location":"tutorials/aes-encryption/#encrypting-data","title":"Encrypting Data","text":"<p>The <code>encrypt</code> method supports both string and binary data:</p> <pre><code>const symmetricKey = SymmetricKey.fromRandom()\nconst message = 'Hello, this is a secret message!'\n\n// Encrypt a string (UTF-8 encoding)\nconst encryptedMessage = symmetricKey.encrypt(message) as number[]\nconsole.log('Encrypted message length:', encryptedMessage.length)\n\n// Encrypt binary data\nconst binaryData = Utils.toArray('Binary data example', 'utf8')\nconst encryptedBinary = symmetricKey.encrypt(binaryData) as number[]\n\n// Encrypt with hex output (using manual conversion for clarity)\nconst encryptedBytes = symmetricKey.encrypt(message) as number[]\nconst hexEncrypted = bytesToHex(encryptedBytes)\nconsole.log('Hex encrypted:', hexEncrypted)\n\n// Alternative: SDK's built-in hex handling (for hex input data)\n// Note: The 'hex' parameter treats the input as hex, not the output format\nconst messageAsHex = Buffer.from(message).toString('hex') // Convert message to hex first\nconst sdkHexEncrypted = symmetricKey.encrypt(messageAsHex, 'hex') as string\nconsole.log('SDK hex encrypted:', sdkHexEncrypted)\n</code></pre>"},{"location":"tutorials/aes-encryption/#decrypting-data","title":"Decrypting Data","text":"<p>The <code>decrypt</code> method reverses the encryption process:</p> <pre><code>// Decrypt to string (UTF-8)\nconst decryptedMessage = symmetricKey.decrypt(encryptedMessage, 'utf8') as string\nconsole.log('Decrypted message:', decryptedMessage)\n\n// Decrypt to binary array\nconst decryptedBinary = symmetricKey.decrypt(encryptedBinary) as number[]\nconsole.log('Decrypted binary:', Utils.toUTF8(decryptedBinary))\n\n// Decrypt hex-encoded data (manual conversion method)\nconst hexBytes = hexToBytes(hexEncrypted)\nconst decryptedFromHex = symmetricKey.decrypt(hexBytes, 'utf8') as string\nconsole.log('Decrypted from hex:', decryptedFromHex)\n\n// Alternative: SDK hex handling method\nconst sdkHexBytes = hexToBytes(sdkHexEncrypted)\nconst sdkDecryptedHex = symmetricKey.decrypt(sdkHexBytes, 'hex') as string\nconst sdkDecryptedMessage = Buffer.from(sdkDecryptedHex, 'hex').toString('utf8')\nconsole.log('SDK decrypted from hex:', sdkDecryptedMessage)\n</code></pre>"},{"location":"tutorials/aes-encryption/#understanding-the-hex-parameter","title":"Understanding the Hex Parameter","text":"<p>The <code>enc</code> parameter in the SDK's <code>encrypt()</code> and <code>decrypt()</code> methods can be confusing. Here's how it actually works:</p> <p>In <code>encrypt(data, enc)</code>:</p> <ul> <li><code>enc</code> specifies how to interpret the input data</li> <li><code>enc: 'hex'</code> means the input data is a hex string that should be converted to bytes</li> <li>The output format is determined by the <code>enc</code> parameter (hex string if <code>enc: 'hex'</code>, byte array otherwise)</li> </ul> <p>In <code>decrypt(data, enc)</code>:</p> <ul> <li><code>enc</code> specifies the output format</li> <li><code>enc: 'hex'</code> returns the decrypted data as a hex string</li> <li><code>enc: 'utf8'</code> returns the decrypted data as a UTF-8 string</li> </ul> <pre><code>// Example: Encrypting hex data with SDK's built-in hex handling\nconst message = 'Hello, World!'\nconst messageAsHex = Buffer.from(message).toString('hex') // '48656c6c6f2c20576f726c6421'\n\n// Encrypt hex input data\nconst encrypted = key.encrypt(messageAsHex, 'hex') as string\n\n// Decrypt and get result as hex\nconst decryptedHex = key.decrypt(hexToBytes(encrypted), 'hex') as string\nconsole.log('Decrypted as hex:', decryptedHex) // '48656c6c6f2c20576f726c6421'\n\n// Convert hex result back to UTF-8\nconst finalMessage = Buffer.from(decryptedHex, 'hex').toString('utf8')\nconsole.log('Final message:', finalMessage) // 'Hello, World!'\n</code></pre>"},{"location":"tutorials/aes-encryption/#complete-encryption-example","title":"Complete Encryption Example","text":"<p>Here's a comprehensive example demonstrating the full encryption workflow:</p> <pre><code>import { SymmetricKey, Utils } from '@bsv/sdk'\n\nfunction demonstrateAESEncryption() {\n  console.log('=== AES Encryption Demonstration ===')\n\n  // 1. Generate a random encryption key\n  const symmetricKey = SymmetricKey.fromRandom()\n  console.log('Generated key:', symmetricKey.toHex().substring(0, 16) + '...')\n\n  // 2. Prepare the message to encrypt\n  const originalMessage = 'This is a confidential message that needs protection!'\n  console.log('Original message:', originalMessage)\n\n  // 3. Encrypt the message\n  const encryptedData = symmetricKey.encrypt(originalMessage) as number[]\n  console.log('Encrypted data length:', encryptedData.length, 'bytes')\n  console.log('Encrypted (first 32 bytes):', encryptedData.slice(0, 32))\n\n  // 4. Decrypt the message\n  const decryptedMessage = symmetricKey.decrypt(encryptedData, 'utf8') as string\n\n  // 5. Verify integrity\n  const isValid = originalMessage === decryptedMessage\n  console.log('Decryption successful:', isValid)\n\n  return {\n    key: symmetricKey,\n    original: originalMessage,\n    encrypted: encryptedData,\n    decrypted: decryptedMessage,\n    valid: isValid\n  }\n}\n\n// Run the demonstration\nconst result = demonstrateAESEncryption()\n</code></pre>"},{"location":"tutorials/aes-encryption/#working-with-different-data-types","title":"Working with Different Data Types","text":""},{"location":"tutorials/aes-encryption/#encrypting-json-data","title":"Encrypting JSON Data","text":"<pre><code>function encryptJSON(data: any, key: SymmetricKey): number[] {\n  const jsonString = JSON.stringify(data)\n  return key.encrypt(jsonString) as number[]\n}\n\nfunction decryptJSON(encryptedData: number[], key: SymmetricKey): any {\n  const jsonString = key.decrypt(encryptedData, 'utf8') as string\n  return JSON.parse(jsonString)\n}\n\n// Example usage\nconst symmetricKey = SymmetricKey.fromRandom()\nconst userData = {\n  name: 'Alice',\n  email: 'alice@example.com',\n  balance: 1000,\n  transactions: ['tx1', 'tx2', 'tx3']\n}\n\nconst encryptedJSON = encryptJSON(userData, symmetricKey)\nconst decryptedData = decryptJSON(encryptedJSON, symmetricKey)\nconsole.log('Original data:', userData)\nconsole.log('Decrypted data:', decryptedData)\n</code></pre>"},{"location":"tutorials/aes-encryption/#encrypting-files-and-large-data","title":"Encrypting Files and Large Data","text":"<pre><code>function encryptLargeData(data: string, key: SymmetricKey): {\n  encrypted: number[],\n  size: number,\n  checksum: string\n} {\n  // Convert to binary\n  const binaryData = Utils.toArray(data, 'utf8')\n\n  // Encrypt the data\n  const encrypted = key.encrypt(binaryData) as number[]\n\n  // Calculate checksum of original data for verification\n  const checksum = Utils.toBase64(binaryData.slice(0, 32))\n\n  return {\n    encrypted,\n    size: binaryData.length,\n    checksum\n  }\n}\n\nfunction decryptLargeData(encryptedData: {\n  encrypted: number[],\n  size: number,\n  checksum: string\n}, key: SymmetricKey): string {\n  // Decrypt the data\n  const decrypted = key.decrypt(encryptedData.encrypted) as number[]\n\n  // Verify size\n  if (decrypted.length !== encryptedData.size) {\n    throw new Error('Decrypted data size mismatch')\n  }\n\n  // Verify checksum\n  const checksum = Utils.toBase64(decrypted.slice(0, 32))\n  if (checksum !== encryptedData.checksum) {\n    console.warn('Checksum mismatch - data may be corrupted')\n  }\n\n  return Utils.toUTF8(decrypted)\n}\n</code></pre>"},{"location":"tutorials/aes-encryption/#key-derivation-and-management","title":"Key Derivation and Management","text":""},{"location":"tutorials/aes-encryption/#deriving-keys-from-passwords","title":"Deriving Keys from Passwords","text":"<pre><code>import { Hash } from '@bsv/sdk'\n\nfunction deriveKeyFromPassword(password: string, salt?: number[]): SymmetricKey {\n  // Use provided salt or generate random one\n  const keySalt = salt || Random(32)\n\n  // Create key material by hashing password + salt\n  const passwordBytes = Utils.toArray(password, 'utf8')\n  const keyMaterial = [...passwordBytes, ...keySalt]\n\n  // Hash to create 256-bit key\n  const keyHash = Hash.sha256(keyMaterial)\n\n  return new SymmetricKey(keyHash)\n}\n\n// Example usage\nconst password = 'MySecurePassword123!'\nconst salt = Random(32)\nconst derivedKey = deriveKeyFromPassword(password, salt)\n\n// Store salt separately - needed for key recreation\nconsole.log('Derived key:', derivedKey.toHex())\nconsole.log('Salt (store this):', Utils.toBase64(salt))\n\n// Recreate the same key later\nconst recreatedKey = deriveKeyFromPassword(password, salt)\nconsole.log('Keys match:', derivedKey.toHex() === recreatedKey.toHex())\n</code></pre>"},{"location":"tutorials/aes-encryption/#key-rotation-and-versioning","title":"Key Rotation and Versioning","text":"<pre><code>class KeyManager {\n  private keys: Map&lt;number, SymmetricKey&gt; = new Map()\n  private currentVersion: number = 1\n\n  generateNewKey(): number {\n    const newKey = SymmetricKey.fromRandom()\n    this.keys.set(this.currentVersion, newKey)\n    return this.currentVersion++\n  }\n\n  encrypt(data: string, version?: number): { \n    encrypted: number[], \n    version: number \n  } {\n    const keyVersion = version || this.currentVersion - 1\n    const key = this.keys.get(keyVersion)\n\n    if (!key) {\n      throw new Error(`Key version ${keyVersion} not found`)\n    }\n\n    return {\n      encrypted: key.encrypt(data) as number[],\n      version: keyVersion\n    }\n  }\n\n  decrypt(encryptedData: {\n    encrypted: number[], \n    version: number \n  }): string {\n    const key = this.keys.get(encryptedData.version)\n\n    if (!key) {\n      throw new Error(`Key version ${encryptedData.version} not found`)\n    }\n\n    return key.decrypt(encryptedData.encrypted, 'utf8') as string\n  }\n}\n\n// Example usage\nconst keyManager = new KeyManager()\nconst v1 = keyManager.generateNewKey()\nconst v2 = keyManager.generateNewKey()\n\nconst message = 'Data encrypted with version 1'\nconst encrypted = keyManager.encrypt(message, v1)\nconst decrypted = keyManager.decrypt(encrypted)\nconsole.log('Decrypted:', decrypted)\n</code></pre>"},{"location":"tutorials/aes-encryption/#combining-aes-with-ecdh","title":"Combining AES with ECDH","text":"<p>For secure communication between parties, combine AES encryption with ECDH key exchange:</p> <pre><code>import { PrivateKey, PublicKey } from '@bsv/sdk'\n\nfunction createSecureChannel(\n  senderPrivateKey: PrivateKey,\n  recipientPublicKey: PublicKey\n): SymmetricKey {\n  // Derive shared secret using ECDH\n  const sharedSecret = senderPrivateKey.deriveSharedSecret(recipientPublicKey)\n\n  // Use shared secret as AES key material\n  const keyMaterial = sharedSecret.encode(true).slice(1) // Remove prefix byte\n\n  return new SymmetricKey(keyMaterial)\n}\n\nfunction secureMessageExchange() {\n  // Generate key pairs for Alice and Bob\n  const alicePrivate = PrivateKey.fromRandom()\n  const alicePublic = alicePrivate.toPublicKey()\n\n  const bobPrivate = PrivateKey.fromRandom()\n  const bobPublic = bobPrivate.toPublicKey()\n\n  // Alice creates encryption key using Bob's public key\n  const aliceEncryptionKey = createSecureChannel(alicePrivate, bobPublic)\n\n  // Bob creates the same encryption key using Alice's public key\n  const bobDecryptionKey = createSecureChannel(bobPrivate, alicePublic)\n\n  // Verify both parties have the same key\n  console.log('Keys match:', \n    aliceEncryptionKey.toHex() === bobDecryptionKey.toHex())\n\n  // Alice encrypts a message\n  const message = 'Hello Bob, this is a secure message from Alice!'\n  const encrypted = aliceEncryptionKey.encrypt(message) as number[]\n\n  // Bob decrypts the message\n  const decrypted = bobDecryptionKey.decrypt(encrypted, 'utf8') as string\n\n  console.log('Original message:', message)\n  console.log('Decrypted message:', decrypted)\n  console.log('Secure communication successful:', message === decrypted)\n\n  return { aliceEncryptionKey, bobDecryptionKey, message, decrypted }\n}\n\n// Run secure message exchange\nsecureMessageExchange()\n</code></pre>"},{"location":"tutorials/aes-encryption/#error-handling-and-security","title":"Error Handling and Security","text":""},{"location":"tutorials/aes-encryption/#robust-encryption-with-error-handling","title":"Robust Encryption with Error Handling","text":"<pre><code>class SecureAESManager {\n  private key: SymmetricKey\n\n  constructor(key?: SymmetricKey) {\n    this.key = key || SymmetricKey.fromRandom()\n  }\n\n  safeEncrypt(data: string): { \n    success: boolean, \n    encrypted?: number[], \n    error?: string \n  } {\n    try {\n      if (!data || data.length === 0) {\n        return { success: false, error: 'Data cannot be empty' }\n      }\n\n      const encrypted = this.key.encrypt(data) as number[]\n\n      if (!encrypted || encrypted.length === 0) {\n        return { success: false, error: 'Encryption failed' }\n      }\n\n      return { success: true, encrypted }\n    } catch (error) {\n      return { \n        success: false, \n        error: `Encryption error: ${error.message}` \n      }\n    }\n  }\n\n  safeDecrypt(encryptedData: number[]): { \n    success: boolean, \n    decrypted?: string, \n    error?: string \n  } {\n    try {\n      if (!encryptedData || encryptedData.length === 0) {\n        return { success: false, error: 'Encrypted data cannot be empty' }\n      }\n\n      const decrypted = this.key.decrypt(encryptedData, 'utf8') as string\n\n      return { success: true, decrypted }\n    } catch (error) {\n      return { \n        success: false, \n        error: `Decryption failed: ${error.message}` \n      }\n    }\n  }\n\n  rotateKey(): void {\n    this.key = SymmetricKey.fromRandom()\n  }\n\n  getKeyFingerprint(): string {\n    // Create a fingerprint of the key for identification\n    const keyBytes = this.key.toArray()\n    const hash = Hash.sha256(keyBytes)\n    return Utils.toBase64(hash).substring(0, 16)\n  }\n}\n\n// Example usage with error handling\nconst aesManager = new SecureAESManager()\nconsole.log('Key fingerprint:', aesManager.getKeyFingerprint())\n\nconst testData = 'Sensitive information that needs protection'\nconst encryptResult = aesManager.safeEncrypt(testData)\n\nif (encryptResult.success) {\n  console.log('Encryption successful')\n\n  const decryptResult = aesManager.safeDecrypt(encryptResult.encrypted!)\n\n  if (decryptResult.success) {\n    console.log('Decryption successful:', decryptResult.decrypted)\n  } else {\n    console.error('Decryption failed:', decryptResult.error)\n  }\n} else {\n  console.error('Encryption failed:', encryptResult.error)\n}\n</code></pre>"},{"location":"tutorials/aes-encryption/#practical-applications","title":"Practical Applications","text":""},{"location":"tutorials/aes-encryption/#encrypting-transaction-metadata","title":"Encrypting Transaction Metadata","text":"<pre><code>import { Transaction, PrivateKey } from '@bsv/sdk'\n\nfunction encryptTransactionMetadata(\n  transaction: Transaction,\n  metadata: any,\n  encryptionKey: SymmetricKey\n): number[] {\n  const metadataWithTx = {\n    txid: Buffer.from(transaction.id()).toString('hex'),\n    timestamp: Date.now(),\n    metadata: metadata\n  }\n\n  const jsonString = JSON.stringify(metadataWithTx)\n  return encryptionKey.encrypt(jsonString) as number[]\n}\n\nfunction decryptTransactionMetadata(\n  encryptedMetadata: number[],\n  encryptionKey: SymmetricKey\n): any {\n  const jsonString = encryptionKey.decrypt(encryptedMetadata, 'utf8') as string\n  return JSON.parse(jsonString)\n}\n\n// Example: Encrypt private notes about a transaction\nconst privateKey = PrivateKey.fromRandom()\nconst encryptionKey = SymmetricKey.fromRandom()\n\n// Create a simple transaction (placeholder)\nconst transaction = new Transaction()\n// ... transaction setup ...\n\nconst privateMetadata = {\n  purpose: 'Payment to supplier',\n  invoiceNumber: 'INV-2024-001',\n  notes: 'Quarterly payment for services',\n  category: 'business-expense'\n}\n\nconst encrypted = encryptTransactionMetadata(transaction, privateMetadata, encryptionKey)\nconst decrypted = decryptTransactionMetadata(encrypted, encryptionKey)\n\nconsole.log('Original metadata:', privateMetadata)\nconsole.log('Decrypted metadata:', decrypted)\n</code></pre>"},{"location":"tutorials/aes-encryption/#secure-configuration-storage","title":"Secure Configuration Storage","text":"<pre><code>class SecureConfig {\n  private encryptionKey: SymmetricKey\n  private config: Map&lt;string, number[]&gt; = new Map()\n\n  constructor(password: string) {\n    // Derive encryption key from password\n    const salt = Random(32)\n    const passwordHash = Hash.sha256([\n      ...Utils.toArray(password, 'utf8'),\n      ...salt\n    ])\n    this.encryptionKey = new SymmetricKey(passwordHash)\n  }\n\n  set(key: string, value: any): void {\n    const jsonValue = JSON.stringify(value)\n    const encrypted = this.encryptionKey.encrypt(jsonValue) as number[]\n    this.config.set(key, encrypted)\n  }\n\n  get(key: string): any {\n    const encrypted = this.config.get(key)\n    if (!encrypted) {\n      return undefined\n    }\n\n    try {\n      const decrypted = this.encryptionKey.decrypt(encrypted, 'utf8') as string\n      return JSON.parse(decrypted)\n    } catch (error) {\n      console.error('Failed to decrypt config value:', error)\n      return undefined\n    }\n  }\n\n  has(key: string): boolean {\n    return this.config.has(key)\n  }\n\n  delete(key: string): boolean {\n    return this.config.delete(key)\n  }\n\n  export(): string {\n    const exportData = {}\n    for (const [key, encrypted] of this.config.entries()) {\n      exportData[key] = Utils.toBase64(encrypted)\n    }\n    return JSON.stringify(exportData)\n  }\n\n  import(data: string): void {\n    const importData = JSON.parse(data)\n    for (const [key, base64Value] of Object.entries(importData)) {\n      const encrypted = Utils.fromBase64(base64Value as string)\n      this.config.set(key, encrypted)\n    }\n  }\n}\n\n// Example usage\nconst secureConfig = new SecureConfig('MySecurePassword123!')\n\n// Store sensitive configuration\nsecureConfig.set('apiKey', 'sk-1234567890abcdef')\nsecureConfig.set('databaseUrl', 'postgresql://user:pass@host:5432/db')\nsecureConfig.set('walletSeed', 'abandon abandon abandon...')\n\n// Retrieve configuration\nconsole.log('API Key:', secureConfig.get('apiKey'))\nconsole.log('Has database URL:', secureConfig.has('databaseUrl'))\n\n// Export encrypted configuration\nconst exportedConfig = secureConfig.export()\nconsole.log('Exported config length:', exportedConfig.length)\n</code></pre>"},{"location":"tutorials/aes-encryption/#performance-considerations","title":"Performance Considerations","text":""},{"location":"tutorials/aes-encryption/#benchmarking-aes-operations","title":"Benchmarking AES Operations","text":"<pre><code>function benchmarkAESPerformance() {\n  const key = SymmetricKey.fromRandom()\n  const testSizes = [100, 1000, 10000, 100000] // bytes\n\n  console.log('=== AES Performance Benchmark ===')\n\n  for (const size of testSizes) {\n    const testData = 'x'.repeat(size)\n\n    // Benchmark encryption\n    const encryptStart = performance.now()\n    const encrypted = key.encrypt(testData) as number[]\n    const encryptTime = performance.now() - encryptStart\n\n    // Benchmark decryption\n    const decryptStart = performance.now()\n    const decrypted = key.decrypt(encrypted, 'utf8') as string\n    const decryptTime = performance.now() - decryptStart\n\n    console.log(`Size: ${size} bytes`)\n    console.log(`  Encrypt: ${encryptTime.toFixed(2)}ms`)\n    console.log(`  Decrypt: ${decryptTime.toFixed(2)}ms`)\n    console.log(`  Total: ${(encryptTime + decryptTime).toFixed(2)}ms`)\n    console.log(`  Throughput: ${(size / (encryptTime + decryptTime) * 1000).toFixed(0)} bytes/sec`)\n    console.log()\n  }\n}\n\n// Run benchmark\nbenchmarkAESPerformance()\n</code></pre>"},{"location":"tutorials/aes-encryption/#security-best-practices","title":"Security Best Practices","text":""},{"location":"tutorials/aes-encryption/#key-security-guidelines","title":"Key Security Guidelines","text":"<pre><code>class SecureKeyPractices {\n  // Good: Generate random keys\n  static generateSecureKey(): SymmetricKey {\n    return SymmetricKey.fromRandom()\n  }\n\n  // Good: Derive keys from strong passwords\n  static deriveFromPassword(password: string, salt: number[]): SymmetricKey {\n    if (password.length &lt; 12) {\n      throw new Error('Password must be at least 12 characters')\n    }\n\n    const keyMaterial = Hash.sha256([\n      ...Utils.toArray(password, 'utf8'),\n      ...salt\n    ])\n    return new SymmetricKey(keyMaterial)\n  }\n\n  // Good: Secure key comparison\n  static keysEqual(key1: SymmetricKey, key2: SymmetricKey): boolean {\n    const bytes1 = key1.toArray()\n    const bytes2 = key2.toArray()\n\n    if (bytes1.length !== bytes2.length) {\n      return false\n    }\n\n    // Constant-time comparison to prevent timing attacks\n    let result = 0\n    for (let i = 0; i &lt; bytes1.length; i++) {\n      result |= bytes1[i] ^ bytes2[i]\n    }\n    return result === 0\n  }\n\n  // Good: Secure key destruction\n  static destroyKey(key: SymmetricKey): void {\n    // Overwrite key material (note: this is conceptual in JavaScript)\n    const keyArray = key.toArray()\n    for (let i = 0; i &lt; keyArray.length; i++) {\n      keyArray[i] = 0\n    }\n  }\n}\n\n// Security validation example\nfunction validateSecurityPractices() {\n  console.log('=== Security Practices Validation ===')\n\n  // Generate secure keys\n  const key1 = SecureKeyPractices.generateSecureKey()\n  const key2 = SecureKeyPractices.generateSecureKey()\n\n  console.log('Keys are different:', !SecureKeyPractices.keysEqual(key1, key2))\n\n  // Test password-based key derivation\n  const password = 'MyVerySecurePassword123!'\n  const salt = Random(32)\n  const derivedKey1 = SecureKeyPractices.deriveFromPassword(password, salt)\n  const derivedKey2 = SecureKeyPractices.deriveFromPassword(password, salt)\n\n  console.log('Derived keys are identical:', \n    SecureKeyPractices.keysEqual(derivedKey1, derivedKey2))\n\n  // Clean up\n  SecureKeyPractices.destroyKey(key1)\n  SecureKeyPractices.destroyKey(key2)\n\n  console.log('Security validation complete')\n}\n\nvalidateSecurityPractices()\n</code></pre>"},{"location":"tutorials/aes-encryption/#troubleshooting-common-issues","title":"Troubleshooting Common Issues","text":""},{"location":"tutorials/aes-encryption/#common-problems-and-solutions","title":"Common Problems and Solutions","text":"<pre><code>function troubleshootAESIssues() {\n  console.log('=== AES Troubleshooting Guide ===')\n\n  // Issue 1: Decryption fails with \"Decryption failed!\" error\n  try {\n    const key = SymmetricKey.fromRandom()\n    const message = 'Test message'\n    const encrypted = key.encrypt(message) as number[]\n\n    // Corrupt the encrypted data to simulate tampering\n    encrypted[10] = encrypted[10] ^ 1\n\n    const decrypted = key.decrypt(encrypted, 'utf8')\n  } catch (error) {\n    console.log('Detected tampered data:', error.message)\n    console.log('  Solution: Verify data integrity, check for transmission errors')\n  }\n\n  // Issue 2: Wrong key used for decryption\n  try {\n    const key1 = SymmetricKey.fromRandom()\n    const key2 = SymmetricKey.fromRandom()\n    const message = 'Test message'\n\n    const encrypted = key1.encrypt(message) as number[]\n    const decrypted = key2.decrypt(encrypted, 'utf8') // Wrong key!\n  } catch (error) {\n    console.log('Detected wrong key usage:', error.message)\n    console.log('  Solution: Ensure same key is used for encryption and decryption')\n  }\n\n  // Issue 3: Empty or invalid data\n  try {\n    const key = SymmetricKey.fromRandom()\n    // Empty strings are actually supported and work fine\n    const encrypted = key.encrypt('') as number[]\n    const decrypted = key.decrypt(encrypted, 'utf8') as string\n    console.log('Empty string encryption works:', decrypted === '')\n    console.log('  Note: Empty strings are supported by the SDK')\n  } catch (error) {\n    console.log('Unexpected error with empty data:', error.message)\n  }\n\n  // Issue 4: Hex string handling\n  try {\n    const hexKey = 'a1b2c3d4e5f6789012345678901234567890abcdef1234567890abcdef123456'\n    // This will fail - constructor expects byte array, not hex string\n    // const wrongKey = new SymmetricKey(hexKey)\n\n    // Correct approach - convert hex to bytes first\n    const correctKey = new SymmetricKey(hexToBytes(hexKey))\n    console.log('Hex key creation works with helper function')\n    console.log('  Solution: Use hexToBytes() helper function for hex strings')\n    console.log('  Note: SDK does not provide Utils.fromHex() method')\n  } catch (error) {\n    console.log('Hex key creation issue:', error.message)\n  }\n\n  console.log('\\nTroubleshooting complete')\n}\n\ntroubleshootAESIssues()\n</code></pre>"},{"location":"tutorials/aes-encryption/#testing-your-implementation","title":"Testing Your Implementation","text":""},{"location":"tutorials/aes-encryption/#comprehensive-test-suite","title":"Comprehensive Test Suite","text":"<pre><code>function runAESTests() {\n  console.log('=== AES Implementation Tests ===')\n  let passed = 0\n  let total = 0\n\n  function test(name: string, testFn: () =&gt; boolean) {\n    total++\n    try {\n      const result = testFn()\n      if (result) {\n        console.log(` ${name}`)\n        passed++\n      } else {\n        console.log(` ${name}`)\n      }\n    } catch (error) {\n      console.log(` ${name} - Error: ${error.message}`)\n    }\n  }\n\n  // Test 1: Basic encryption/decryption\n  test('Basic encryption/decryption', () =&gt; {\n    const key = SymmetricKey.fromRandom()\n    const message = 'Hello, World!'\n    const encrypted = key.encrypt(message) as number[]\n    const decrypted = key.decrypt(encrypted, 'utf8') as string\n    return message === decrypted\n  })\n\n  // Test 2: Binary data handling\n  test('Binary data encryption', () =&gt; {\n    const key = SymmetricKey.fromRandom()\n    const binaryData = Random(100)\n    const encrypted = key.encrypt(binaryData) as number[]\n    const decrypted = key.decrypt(encrypted) as number[]\n    return JSON.stringify(binaryData) === JSON.stringify(decrypted)\n  })\n\n  // Test 3: Large data encryption\n  test('Large data encryption', () =&gt; {\n    const key = SymmetricKey.fromRandom()\n    const largeMessage = 'x'.repeat(10000)\n    const encrypted = key.encrypt(largeMessage) as number[]\n    const decrypted = key.decrypt(encrypted, 'utf8') as string\n    return largeMessage === decrypted\n  })\n\n  // Test 4: Key derivation consistency\n  test('Key derivation consistency', () =&gt; {\n    const password = 'TestPassword123'\n    const salt = Random(32)\n    const key1 = new SymmetricKey(Hash.sha256([\n      ...Utils.toArray(password, 'utf8'),\n      ...salt\n    ]))\n    const key2 = new SymmetricKey(Hash.sha256([\n      ...Utils.toArray(password, 'utf8'),\n      ...salt\n    ]))\n    return key1.toHex() === key2.toHex()\n  })\n\n  // Test 5: Hex encoding/decoding\n  test('Hex encoding support', () =&gt; {\n    const key = SymmetricKey.fromRandom()\n    const message = 'Test message'\n    const encryptedBytes = key.encrypt(message) as number[]\n    const encrypted = bytesToHex(encryptedBytes)\n    const hexBytes = hexToBytes(encrypted)\n    const decrypted = key.decrypt(hexBytes, 'utf8') as string\n    return message === decrypted\n  })\n\n  console.log(`\\nTests completed: ${passed}/${total} passed`)\n  return passed === total\n}\n\n// Run the test suite\nconst allTestsPassed = runAESTests()\nconsole.log('\\nAll tests passed:', allTestsPassed)\n</code></pre>"},{"location":"tutorials/aes-encryption/#summary","title":"Summary","text":"<p>In this tutorial, you've learned how to:</p> <ol> <li>Generate secure AES encryption keys using <code>SymmetricKey.fromRandom()</code></li> <li>Encrypt and decrypt data with the <code>encrypt()</code> and <code>decrypt()</code> methods</li> <li>Handle different data formats including strings, binary data, and JSON</li> <li>Derive keys from passwords using secure hashing techniques</li> <li>Implement key management with versioning and rotation</li> <li>Combine AES with ECDH for secure communication channels</li> <li>Apply security best practices including error handling and validation</li> <li>Build practical applications like secure configuration storage</li> <li>Optimize performance and troubleshoot common issues</li> </ol> <p>The BSV TypeScript SDK's <code>SymmetricKey</code> class provides a robust, secure implementation of AES-GCM encryption that's suitable for production applications. The built-in authentication prevents tampering, while the straightforward API makes it easy to integrate encryption into your Bitcoin applications.</p>"},{"location":"tutorials/aes-encryption/#next-steps","title":"Next Steps","text":"<ul> <li>Explore the ECDH Key Exchange tutorial for asymmetric encryption</li> <li>Learn about Messages Reference for authentication</li> <li>Study Advanced Transaction Construction for complex applications</li> <li>Review the Security Best Practices guide</li> </ul>"},{"location":"tutorials/aes-encryption/#additional-resources","title":"Additional Resources","text":"<ul> <li>AES Wikipedia</li> <li>GCM Mode Wikipedia</li> <li>BSV SDK Primitives Reference</li> </ul>"},{"location":"tutorials/authfetch-tutorial/","title":"Authenticated HTTP Requests with AuthFetch","text":"<p>Duration: 60 minutes Prerequisites: Node.js, basic TypeScript knowledge, understanding of HTTP and authentication Learning Goals:</p> <ul> <li>Understand BRC-103/104 authentication protocols</li> <li>Implement authenticated HTTP requests with AuthFetch</li> <li>Handle peer-to-peer authentication and certificate exchange</li> <li>Build secure API communication systems</li> </ul>"},{"location":"tutorials/authfetch-tutorial/#when-to-use-authfetch","title":"When to Use AuthFetch","text":"<p>Use AuthFetch when you need:</p> <ul> <li>BRC-103/104 cryptographic authentication</li> <li>Wallet-signed HTTP requests for identity verification</li> <li>Certificate-based peer authentication</li> <li>Secure peer-to-peer communication between BSV applications</li> <li>APIs that require cryptographic proof of identity</li> </ul> <p>For general HTTP client configuration, use HTTP Client Configuration Guide instead:</p> <ul> <li>Custom HTTP client setup (Axios, fetch, etc.)</li> <li>Transaction broadcasting via ARC endpoints</li> <li>Environment-specific configuration (timeouts, retries)</li> <li>Testing and mocking HTTP clients</li> <li>Integration with existing HTTP infrastructure</li> </ul>"},{"location":"tutorials/authfetch-tutorial/#introduction","title":"Introduction","text":"<p>AuthFetch is a specialized HTTP client that implements BRC-103 and BRC-104 authentication protocols for secure peer-to-peer communication in the BSV ecosystem. Unlike traditional API authentication (like JWT tokens), AuthFetch uses cryptographic signatures and certificate-based authentication.</p>"},{"location":"tutorials/authfetch-tutorial/#key-features","title":"Key Features","text":"<ul> <li>BRC-103 Authentication: Cryptographic request signing</li> <li>BRC-104 Certificate Exchange: Peer identity verification</li> <li>Automatic Session Management: Handles authentication state</li> <li>Certificate Validation: Verifies peer credentials</li> <li>Secure Communication: End-to-end authenticated requests</li> </ul>"},{"location":"tutorials/authfetch-tutorial/#what-youll-build","title":"What You'll Build","text":"<p>In this tutorial, you'll create:</p> <ul> <li>Basic authenticated HTTP client</li> <li>Peer-to-peer communication system</li> <li>Certificate exchange mechanism</li> <li>Secure API integration</li> </ul>"},{"location":"tutorials/authfetch-tutorial/#setting-up-authfetch-with-walletclient","title":"Setting Up AuthFetch with <code>WalletClient</code>","text":""},{"location":"tutorials/authfetch-tutorial/#basic-authfetch-configuration","title":"Basic AuthFetch Configuration","text":"<pre><code>import { AuthFetch, WalletClient } from '@bsv/sdk'\n\nasync function createAuthFetch() {\n  // Create wallet for authentication - connects to local wallet (e.g., MetaNet Desktop)\n  const wallet = new WalletClient('auto', 'localhost')\n\n  // Check if wallet is connected\n  try {\n    const authStatus = await wallet.isAuthenticated()\n    console.log('Wallet authenticated:', authStatus.authenticated)\n\n    const network = await wallet.getNetwork()\n    console.log('Connected to network:', network.network)\n  } catch (error) {\n    console.log('Wallet connection status:', error.message)\n    // This is expected if no wallet is running\n  }\n\n  // Create AuthFetch instance\n  const authFetch = new AuthFetch(wallet)\n\n  console.log('AuthFetch client created')\n  return authFetch\n}\n\nasync function basicAuthenticatedRequest() {\n  const authFetch = await createAuthFetch()\n\n  try {\n    // Make authenticated request to a real, working endpoint\n    const response = await authFetch.fetch('https://httpbin.org/get', {\n      method: 'GET',\n      headers: {\n        'Content-Type': 'application/json',\n        'X-BSV-Tutorial': 'AuthFetch-Example'\n      }\n    })\n\n    if (response.ok) {\n      const data = await response.json()\n      console.log('Authenticated request successful!')\n      console.log('Request URL:', data.url)\n      console.log('Headers sent:', Object.keys(data.headers).length)\n      return data\n    } else {\n      console.error('Request failed:', response.status, response.statusText)\n    }\n  } catch (error) {\n    console.error('Authentication error:', error.message)\n    if (error.message.includes('No wallet available')) {\n      console.log(' Install and run MetaNet Desktop Wallet to test with real authentication')\n      console.log('   For now, this demonstrates the AuthFetch API structure')\n    }\n  }\n}\n\n// Test the basic functionality\nbasicAuthenticatedRequest().catch(console.error)\n</code></pre>"},{"location":"tutorials/authfetch-tutorial/#authfetch-with-certificate-requirements","title":"AuthFetch with Certificate Requirements","text":"<pre><code>import { AuthFetch, WalletClient } from '@bsv/sdk'\n\nasync function createAuthFetchWithCertificates() {\n  const wallet = new WalletClient('auto', 'localhost')\n\n  // Define required certificates from peers\n  const requestedCertificates = {\n    certifiers: {\n      // Require identity certificates from trusted certifier\n      'identity-certifier-key': {\n        certificateTypes: ['identity-cert'],\n        fieldsRequired: ['name', 'email']\n      }\n    },\n    acquisitionProtocol: 'direct' as const\n  }\n\n  const authFetch = new AuthFetch(wallet, requestedCertificates)\n\n  console.log('AuthFetch with certificate requirements created')\n  return authFetch\n}\n\nasync function testCertificateRequirements() {\n  const authFetch = await createAuthFetchWithCertificates()\n\n  try {\n    // Test with a real endpoint that will show our certificate headers (using a dummy URL for demo purposes)\n    const response = await authFetch.fetch('https://httpbin.org/headers', {\n      method: 'GET'\n    })\n\n    if (response.ok) {\n      const data = await response.json()\n      console.log('Certificate-enabled request successful!')\n      console.log('Headers sent to server:', data.headers)\n\n      // AuthFetch will include certificate-related headers when available\n      const certHeaders = Object.keys(data.headers).filter(h =&gt; \n        h.toLowerCase().includes('cert') || h.toLowerCase().includes('auth')\n      )\n      console.log('Certificate/Auth headers:', certHeaders)\n\n    } else {\n      console.error('Request failed:', response.status)\n    }\n  } catch (error) {\n    console.error('Certificate request error:', error.message)\n    if (error.message.includes('No wallet available')) {\n      console.log(' Certificate exchange requires a connected wallet')\n    }\n  }\n}\n\ntestCertificateRequirements().catch(console.error)\n</code></pre>"},{"location":"tutorials/authfetch-tutorial/#certificate-exchange-and-verification","title":"Certificate Exchange and Verification","text":""},{"location":"tutorials/authfetch-tutorial/#requesting-certificates-from-peers","title":"Requesting Certificates from Peers","text":"<pre><code>import { AuthFetch, WalletClient } from '@bsv/sdk'\n\nclass CertificateManager {\n  private authFetch: AuthFetch\n\n  constructor(wallet: WalletClient) {\n    this.authFetch = new AuthFetch(wallet)\n  }\n\n  async requestPeerCertificates(\n    peerBaseUrl: string,\n    certificateRequirements: any\n  ): Promise&lt;any[]&gt; {\n    try {\n      console.log('Requesting certificates from peer:', peerBaseUrl)\n\n      const certificates = await this.authFetch.sendCertificateRequest(\n        peerBaseUrl,\n        certificateRequirements\n      )\n\n      console.log('Received certificates:', certificates.length)\n      return certificates\n    } catch (error) {\n      console.error('Certificate request failed:', error)\n      throw error\n    }\n  }\n\n  async verifyPeerIdentity(peerUrl: string): Promise&lt;{\n    verified: boolean\n    identity: string | null\n    certificates: any[]\n  }&gt; {\n    const certificateRequirements = {\n      certifiers: {\n        'trusted-identity-provider': {\n          certificateTypes: ['identity'],\n          fieldsRequired: ['name']\n        }\n      },\n      acquisitionProtocol: 'direct' as const\n    }\n\n    try {\n      const certificates = await this.requestPeerCertificates(\n        peerUrl,\n        certificateRequirements\n      )\n\n      // Verify certificates (simplified verification)\n      const verified = certificates.length &gt; 0\n      const identity = verified ? certificates[0].subject : null\n\n      return { verified, identity, certificates }\n    } catch (error) {\n      console.error('Identity verification failed:', error)\n      return { verified: false, identity: null, certificates: [] }\n    }\n  }\n}\n\nasync function demonstrateCertificateExchange() {\n  const wallet = new WalletClient('auto', 'localhost')\n  const certManager = new CertificateManager(wallet)\n\n  // Example peer URLs (replace with actual peer endpoints)\n  const peerUrls = [\n    'https://peer1.example.com',\n    'https://peer2.example.com'\n  ]\n\n  for (const peerUrl of peerUrls) {\n    console.log(`\\n=== Verifying peer: ${peerUrl} ===`)\n\n    try {\n      const verification = await certManager.verifyPeerIdentity(peerUrl)\n\n      if (verification.verified) {\n        console.log(' Peer verified successfully')\n        console.log('Identity:', verification.identity)\n        console.log('Certificates received:', verification.certificates.length)\n      } else {\n        console.log(' Peer verification failed')\n      }\n    } catch (error) {\n      console.log(' Peer unreachable or invalid')\n    }\n  }\n}\n\ndemonstrateCertificateExchange().catch(console.error)\n</code></pre>"},{"location":"tutorials/authfetch-tutorial/#building-secure-api-clients","title":"Building Secure API Clients","text":""},{"location":"tutorials/authfetch-tutorial/#authenticated-api-client","title":"Authenticated API Client","text":"<pre><code>import { AuthFetch, WalletClient } from '@bsv/sdk'\n\nclass SecureAPIClient {\n  private authFetch: AuthFetch\n  private baseUrl: string\n\n  constructor(baseUrl: string, wallet?: WalletClient) {\n    this.baseUrl = baseUrl\n    this.authFetch = new AuthFetch(wallet || new WalletClient('auto', 'localhost'))\n  }\n\n  async get(endpoint: string, options: any = {}): Promise&lt;any&gt; {\n    return this.request('GET', endpoint, null, options)\n  }\n\n  async post(endpoint: string, data: any, options: any = {}): Promise&lt;any&gt; {\n    return this.request('POST', endpoint, data, options)\n  }\n\n  async put(endpoint: string, data: any, options: any = {}): Promise&lt;any&gt; {\n    return this.request('PUT', endpoint, data, options)\n  }\n\n  async delete(endpoint: string, options: any = {}): Promise&lt;any&gt; {\n    return this.request('DELETE', endpoint, null, options)\n  }\n\n  private async request(\n    method: string,\n    endpoint: string,\n    data: any = null,\n    options: any = {}\n  ): Promise&lt;any&gt; {\n    const url = `${this.baseUrl}${endpoint}`\n\n    const requestOptions: any = {\n      method,\n      headers: {\n        'Content-Type': 'application/json',\n        ...options.headers\n      }\n    }\n\n    if (data) {\n      requestOptions.body = JSON.stringify(data)\n    }\n\n    try {\n      console.log(`Making authenticated ${method} request to ${endpoint}`)\n\n      const response = await this.authFetch.fetch(url, requestOptions)\n\n      if (!response.ok) {\n        throw new Error(`HTTP ${response.status}: ${response.statusText}`)\n      }\n\n      const contentType = response.headers.get('content-type')\n      if (contentType &amp;&amp; contentType.includes('application/json')) {\n        return await response.json()\n      } else {\n        return await response.text()\n      }\n    } catch (error) {\n      console.error(`Request failed for ${method} ${endpoint}:`, error)\n      throw error\n    }\n  }\n\n  async healthCheck(): Promise&lt;boolean&gt; {\n    try {\n      await this.get('/health')\n      return true\n    } catch (error) {\n      return false\n    }\n  }\n}\n\nasync function demonstrateSecureAPIClient() {\n  // Create secure API client using real, testable endpoints\n  const apiClient = new SecureAPIClient('https://httpbin.org')\n\n  try {\n    // Health check using a real endpoint\n    console.log('Testing API client with real endpoints...')\n\n    // Test GET request\n    const getResult = await apiClient.get('/get?test=true&amp;client=secure')\n    console.log('\u2705 GET request successful')\n    console.log('Request URL:', getResult.url)\n    console.log('Query parameters received:', getResult.args)\n\n    // Test POST request with data\n    const postResult = await apiClient.post('/post', {\n      user: 'demo-user',\n      action: 'test-post',\n      timestamp: new Date().toISOString(),\n      authenticated: true\n    })\n    console.log('\u2705 POST request successful')\n    console.log('Data sent:', postResult.json)\n    console.log('Content-Type:', postResult.headers['Content-Type'])\n\n    // Test PUT request\n    const putResult = await apiClient.put('/put', {\n      resource: 'user-settings',\n      theme: 'dark',\n      notifications: true,\n      updated: new Date().toISOString()\n    })\n    console.log('\u2705 PUT request successful')\n    console.log('PUT data received:', putResult.json)\n\n    // Test DELETE request\n    const deleteResult = await apiClient.delete('/delete')\n    console.log('\u2705 DELETE request successful')\n    console.log('DELETE method confirmed:', deleteResult.url)\n\n    // Test custom headers\n    const headersResult = await apiClient.get('/headers')\n    console.log('\u2705 Headers test successful')\n    console.log('Custom headers sent:', Object.keys(headersResult.headers).length)\n\n    return { \n      get: getResult, \n      post: postResult, \n      put: putResult, \n      delete: deleteResult,\n      headers: headersResult\n    }\n  } catch (error) {\n    console.error('API operations failed:', error.message)\n    if (error.message.includes('No wallet available')) {\n      console.log('\ud83d\udca1 Install MetaNet Desktop Wallet to test with real authentication')\n      console.log('   The API calls work, but authentication requires a connected wallet')\n    }\n  }\n}\n\ndemonstrateSecureAPIClient().catch(console.error)\n</code></pre>"},{"location":"tutorials/authfetch-tutorial/#multi-peer-communication-system","title":"Multi-Peer Communication System","text":"<pre><code>import { AuthFetch, WalletClient } from '@bsv/sdk'\n\ninterface PeerInfo {\n  url: string\n  identity: string | null\n  verified: boolean\n  lastContact: Date\n}\n\nclass PeerNetwork {\n  private authFetch: AuthFetch\n  private peers: Map&lt;string, PeerInfo&gt; = new Map()\n\n  constructor(wallet?: WalletClient) {\n    this.authFetch = new AuthFetch(wallet || new WalletClient('auto', 'localhost'))\n  }\n\n  async addPeer(peerUrl: string): Promise&lt;boolean&gt; {\n    try {\n      console.log(`Adding peer: ${peerUrl}`)\n\n      // Verify peer identity\n      const verification = await this.verifyPeer(peerUrl)\n\n      const peerInfo: PeerInfo = {\n        url: peerUrl,\n        identity: verification.identity,\n        verified: verification.verified,\n        lastContact: new Date()\n      }\n\n      this.peers.set(peerUrl, peerInfo)\n\n      console.log(`Peer ${peerUrl} ${verification.verified ? 'verified' : 'unverified'}`)\n      return verification.verified\n    } catch (error) {\n      console.error(`Failed to add peer ${peerUrl}:`, error)\n      return false\n    }\n  }\n\n  private async verifyPeer(peerUrl: string): Promise&lt;{\n    verified: boolean\n    identity: string | null\n  }&gt; {\n    try {\n      // Simple ping to verify peer is reachable\n      const response = await this.authFetch.fetch(`${peerUrl}/ping`, {\n        method: 'GET'\n      })\n\n      if (response.ok) {\n        // In a real implementation, you would verify certificates here\n        return { verified: true, identity: 'peer-identity' }\n      } else {\n        return { verified: false, identity: null }\n      }\n    } catch (error) {\n      return { verified: false, identity: null }\n    }\n  }\n\n  async broadcastMessage(message: any): Promise&lt;{\n    successful: string[]\n    failed: string[]\n  }&gt; {\n    const successful: string[] = []\n    const failed: string[] = []\n\n    console.log(`Broadcasting message to ${this.peers.size} peers`)\n\n    const promises = Array.from(this.peers.entries()).map(async ([url, peerInfo]) =&gt; {\n      try {\n        const response = await this.authFetch.fetch(`${url}/message`, {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json'\n          },\n          body: JSON.stringify(message)\n        })\n\n        if (response.ok) {\n          successful.push(url)\n          // Update last contact\n          peerInfo.lastContact = new Date()\n        } else {\n          failed.push(url)\n        }\n      } catch (error) {\n        failed.push(url)\n        console.error(`Failed to send message to ${url}:`, error)\n      }\n    })\n\n    await Promise.all(promises)\n\n    console.log(`Broadcast complete: ${successful.length} successful, ${failed.length} failed`)\n    return { successful, failed }\n  }\n\n  async sendDirectMessage(peerUrl: string, message: any): Promise&lt;any&gt; {\n    const peer = this.peers.get(peerUrl)\n    if (!peer) {\n      throw new Error(`Peer ${peerUrl} not found`)\n    }\n\n    if (!peer.verified) {\n      throw new Error(`Peer ${peerUrl} not verified`)\n    }\n\n    try {\n      const response = await this.authFetch.fetch(`${peerUrl}/direct-message`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify(message)\n      })\n\n      if (response.ok) {\n        peer.lastContact = new Date()\n        return await response.json()\n      } else {\n        throw new Error(`HTTP ${response.status}: ${response.statusText}`)\n      }\n    } catch (error) {\n      console.error(`Direct message to ${peerUrl} failed:`, error)\n      throw error\n    }\n  }\n\n  getPeerStatus(): { total: number; verified: number; unverified: number } {\n    const total = this.peers.size\n    let verified = 0\n    let unverified = 0\n\n    for (const peer of this.peers.values()) {\n      if (peer.verified) {\n        verified++\n      } else {\n        unverified++\n      }\n    }\n\n    return { total, verified, unverified }\n  }\n\n  listPeers(): PeerInfo[] {\n    return Array.from(this.peers.values())\n  }\n}\n\nasync function demonstratePeerNetwork() {\n  const network = new PeerNetwork()\n\n  // Add peers (replace with actual peer URLs)\n  const peerUrls = [\n    'https://peer1.example.com',\n    'https://peer2.example.com',\n    'https://peer3.example.com'\n  ]\n\n  console.log('=== Setting up peer network ===')\n\n  for (const peerUrl of peerUrls) {\n    await network.addPeer(peerUrl)\n  }\n\n  const status = network.getPeerStatus()\n  console.log('Network status:', status)\n\n  // Broadcast message\n  const broadcastMessage = {\n    type: 'announcement',\n    content: 'Hello from authenticated peer network!',\n    timestamp: new Date().toISOString()\n  }\n\n  console.log('\\n=== Broadcasting message ===')\n  const broadcastResult = await network.broadcastMessage(broadcastMessage)\n  console.log('Broadcast result:', broadcastResult)\n\n  // Send direct message to first verified peer\n  const peers = network.listPeers()\n  const verifiedPeer = peers.find(p =&gt; p.verified)\n\n  if (verifiedPeer) {\n    console.log('\\n=== Sending direct message ===')\n    try {\n      const directMessage = {\n        type: 'direct',\n        content: 'This is a direct authenticated message',\n        timestamp: new Date().toISOString()\n      }\n\n      const response = await network.sendDirectMessage(verifiedPeer.url, directMessage)\n      console.log('Direct message response:', response)\n    } catch (error) {\n      console.log('Direct message failed (expected in demo)')\n    }\n  }\n\n  return { status, broadcastResult, peers }\n}\n\ndemonstratePeerNetwork().catch(console.error)\n</code></pre>"},{"location":"tutorials/authfetch-tutorial/#advanced-authentication-patterns","title":"Advanced Authentication Patterns","text":""},{"location":"tutorials/authfetch-tutorial/#session-management-and-reconnection","title":"Session Management and Reconnection","text":"<pre><code>import { AuthFetch, WalletClient } from '@bsv/sdk'\n\nclass RobustAuthClient {\n  private authFetch: AuthFetch\n  private maxRetries: number = 3\n  private retryDelay: number = 1000\n\n  constructor(wallet?: WalletClient) {\n    this.authFetch = new AuthFetch(wallet || new WalletClient('auto', 'localhost'))\n  }\n\n  async authenticatedRequest(\n    url: string,\n    options: any = {},\n    retryCount: number = 0\n  ): Promise&lt;Response&gt; {\n    try {\n      const response = await this.authFetch.fetch(url, options)\n\n      if (response.status === 401 &amp;&amp; retryCount &lt; this.maxRetries) {\n        console.log(`Authentication failed, retrying... (${retryCount + 1}/${this.maxRetries})`)\n\n        // Wait and retry - AuthFetch will handle session management automatically\n        await this.delay(this.retryDelay * (retryCount + 1))\n\n        return this.authenticatedRequest(url, options, retryCount + 1)\n      }\n\n      return response\n    } catch (error) {\n      if (retryCount &lt; this.maxRetries) {\n        console.log(`Request failed, retrying... (${retryCount + 1}/${this.maxRetries})`)\n        await this.delay(this.retryDelay * (retryCount + 1))\n        return this.authenticatedRequest(url, options, retryCount + 1)\n      }\n\n      throw error\n    }\n  }\n\n  private delay(ms: number): Promise&lt;void&gt; {\n    return new Promise(resolve =&gt; setTimeout(resolve, ms))\n  }\n\n  async batchRequests(requests: Array&lt;{\n    url: string\n    options?: any\n  }&gt;): Promise&lt;Array&lt;{\n    success: boolean\n    response?: any\n    error?: string\n  }&gt;&gt; {\n    const results = await Promise.allSettled(\n      requests.map(req =&gt; this.authenticatedRequest(req.url, req.options))\n    )\n\n    return results.map((result, index) =&gt; {\n      if (result.status === 'fulfilled') {\n        return {\n          success: true,\n          response: result.value\n        }\n      } else {\n        return {\n          success: false,\n          error: result.reason.message\n        }\n      }\n    })\n  }\n}\n\nasync function demonstrateRobustAuthentication() {\n  const robustClient = new RobustAuthClient()\n\n  console.log('=== Testing robust authentication ===')\n\n  // Single request with retry logic\n  try {\n    const response = await robustClient.authenticatedRequest('https://api.example.com/data')\n    console.log('Single request successful:', response.ok)\n  } catch (error) {\n    console.log('Single request failed after retries:', error.message)\n  }\n\n  // Batch requests\n  const batchRequests = [\n    { url: 'https://api.example.com/endpoint1' },\n    { url: 'https://api.example.com/endpoint2' },\n    { url: 'https://api.example.com/endpoint3' }\n  ]\n\n  console.log('\\n=== Testing batch requests ===')\n  const batchResults = await robustClient.batchRequests(batchRequests)\n\n  batchResults.forEach((result, index) =&gt; {\n    console.log(`Request ${index + 1}:`, result.success ? 'SUCCESS' : `FAILED - ${result.error}`)\n  })\n\n  return batchResults\n}\n\ndemonstrateRobustAuthentication().catch(console.error)\n</code></pre>"},{"location":"tutorials/authfetch-tutorial/#error-handling-and-debugging","title":"Error Handling and Debugging","text":""},{"location":"tutorials/authfetch-tutorial/#comprehensive-error-handling","title":"Comprehensive Error Handling","text":"<pre><code>import { AuthFetch, WalletClient } from '@bsv/sdk'\n\nenum AuthErrorType {\n  NETWORK_ERROR = 'network_error',\n  AUTHENTICATION_FAILED = 'authentication_failed',\n  CERTIFICATE_INVALID = 'certificate_invalid',\n  PEER_UNREACHABLE = 'peer_unreachable',\n  SESSION_EXPIRED = 'session_expired'\n}\n\nclass AuthError extends Error {\n  constructor(\n    public type: AuthErrorType,\n    message: string,\n    public originalError?: Error\n  ) {\n    super(message)\n    this.name = 'AuthError'\n  }\n}\n\nclass AuthFetchWithErrorHandling {\n  private authFetch: AuthFetch\n  private debugMode: boolean = false\n\n  constructor(wallet?: WalletClient, debugMode: boolean = false) {\n    this.authFetch = new AuthFetch(wallet || new WalletClient('auto', 'localhost'))\n    this.debugMode = debugMode\n  }\n\n  async safeRequest(url: string, options: any = {}): Promise&lt;{\n    success: boolean\n    data?: any\n    error?: AuthError\n  }&gt; {\n    try {\n      if (this.debugMode) {\n        console.log(`[DEBUG] Making request to: ${url}`)\n        console.log(`[DEBUG] Options:`, JSON.stringify(options, null, 2))\n      }\n\n      const response = await this.authFetch.fetch(url, options)\n\n      if (this.debugMode) {\n        console.log(`[DEBUG] Response status: ${response.status}`)\n        console.log(`[DEBUG] Response headers:`, Object.fromEntries(response.headers.entries()))\n      }\n\n      if (!response.ok) {\n        const errorType = this.categorizeHttpError(response.status)\n        const errorMessage = await this.extractErrorMessage(response)\n\n        return {\n          success: false,\n          error: new AuthError(errorType, errorMessage)\n        }\n      }\n\n      const data = await this.parseResponse(response)\n      return { success: true, data }\n\n    } catch (error) {\n      if (this.debugMode) {\n        console.log(`[DEBUG] Request failed:`, error)\n      }\n\n      const authError = this.categorizeError(error)\n      return { success: false, error: authError }\n    }\n  }\n\n  private categorizeHttpError(status: number): AuthErrorType {\n    switch (status) {\n      case 401:\n        return AuthErrorType.AUTHENTICATION_FAILED\n      case 403:\n        return AuthErrorType.CERTIFICATE_INVALID\n      case 408:\n      case 504:\n        return AuthErrorType.PEER_UNREACHABLE\n      default:\n        return AuthErrorType.NETWORK_ERROR\n    }\n  }\n\n  private async extractErrorMessage(response: Response): Promise&lt;string&gt; {\n    try {\n      const contentType = response.headers.get('content-type')\n      if (contentType &amp;&amp; contentType.includes('application/json')) {\n        const errorData = await response.json()\n        return errorData.message || errorData.error || `HTTP ${response.status}`\n      } else {\n        return await response.text() || `HTTP ${response.status}`\n      }\n    } catch {\n      return `HTTP ${response.status}: ${response.statusText}`\n    }\n  }\n\n  private async parseResponse(response: Response): Promise&lt;any&gt; {\n    const contentType = response.headers.get('content-type')\n    if (contentType &amp;&amp; contentType.includes('application/json')) {\n      return await response.json()\n    } else {\n      return await response.text()\n    }\n  }\n\n  private categorizeError(error: any): AuthError {\n    if (error.name === 'TypeError' &amp;&amp; error.message.includes('fetch')) {\n      return new AuthError(\n        AuthErrorType.NETWORK_ERROR,\n        'Network connection failed',\n        error\n      )\n    }\n\n    if (error.message.includes('certificate')) {\n      return new AuthError(\n        AuthErrorType.CERTIFICATE_INVALID,\n        'Certificate validation failed',\n        error\n      )\n    }\n\n    if (error.message.includes('session')) {\n      return new AuthError(\n        AuthErrorType.SESSION_EXPIRED,\n        'Authentication session expired',\n        error\n      )\n    }\n\n    return new AuthError(\n      AuthErrorType.NETWORK_ERROR,\n      error.message || 'Unknown error occurred',\n      error\n    )\n  }\n\n  async testConnectivity(urls: string[]): Promise&lt;{\n    reachable: string[]\n    unreachable: string[]\n    errors: Record&lt;string, string&gt;\n  }&gt; {\n    const reachable: string[] = []\n    const unreachable: string[] = []\n    const errors: Record&lt;string, string&gt; = {}\n\n    console.log(`Testing connectivity to ${urls.length} endpoints...`)\n\n    const results = await Promise.allSettled(\n      urls.map(url =&gt; this.safeRequest(`${url}/ping`))\n    )\n\n    results.forEach((result, index) =&gt; {\n      const url = urls[index]\n\n      if (result.status === 'fulfilled' &amp;&amp; result.value.success) {\n        reachable.push(url)\n        console.log(` ${url} - reachable`)\n      } else {\n        unreachable.push(url)\n        const error = result.status === 'fulfilled' \n          ? result.value.error?.message || 'Unknown error'\n          : result.reason.message\n        errors[url] = error\n        console.log(` ${url} - ${error}`)\n      }\n    })\n\n    return { reachable, unreachable, errors }\n  }\n}\n\nasync function demonstrateErrorHandling() {\n  const authClient = new AuthFetchWithErrorHandling(undefined, true) // Debug mode on\n\n  console.log('=== Testing error handling ===')\n\n  // Test various scenarios\n  const testUrls = [\n    'https://httpbin.org/status/200',  // Should succeed\n    'https://httpbin.org/status/401',  // Authentication error\n    'https://httpbin.org/status/403',  // Certificate error\n    'https://httpbin.org/status/500',  // Server error\n    'https://invalid-domain-12345.com' // Network error\n  ]\n\n  for (const url of testUrls) {\n    console.log(`\\n--- Testing: ${url} ---`)\n    const result = await authClient.safeRequest(url)\n\n    if (result.success) {\n      console.log(' Request successful')\n    } else {\n      console.log(` Request failed: ${result.error?.type} - ${result.error?.message}`)\n    }\n  }\n\n  // Test connectivity to multiple endpoints\n  console.log('\\n=== Testing connectivity ===')\n  const connectivityTest = await authClient.testConnectivity([\n    'https://httpbin.org',\n    'https://jsonplaceholder.typicode.com',\n    'https://invalid-endpoint.example.com'\n  ])\n\n  console.log('Connectivity results:', connectivityTest)\n\n  return connectivityTest\n}\n\ndemonstrateErrorHandling().catch(console.error)\n</code></pre>"},{"location":"tutorials/authfetch-tutorial/#conclusion","title":"Conclusion","text":"<p>Congratulations! You've successfully implemented a comprehensive authenticated communication system using the BSV TypeScript SDK. In this tutorial, you've learned how to:</p>"},{"location":"tutorials/authfetch-tutorial/#core-concepts-mastered","title":"Core Concepts Mastered","text":"<ol> <li>AuthFetch Integration: Implemented authentication using identity-based signing</li> <li>Certificate Management: Created and managed identity certificates for secure communication</li> <li>Request Signing: Automatically signed requests with proper identity validation</li> <li>Error Handling: Built robust error handling for authentication failures</li> <li>Network Resilience: Implemented retry logic and connectivity testing</li> </ol>"},{"location":"tutorials/authfetch-tutorial/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about Identity Management for advanced identity workflows</li> <li>Explore Authenticated API Communication for server-side implementation</li> <li>Understand Security Best Practices for production deployments</li> </ul>"},{"location":"tutorials/authfetch-tutorial/#additional-resources","title":"Additional Resources","text":"<ul> <li>AuthFetch API Reference</li> <li>Identity Client Documentation</li> <li>BSV Identity Protocols</li> </ul>"},{"location":"tutorials/ecdh-key-exchange/","title":"ECDH Key Exchange","text":"<p>Duration: 75 minutes Prerequisites: Basic TypeScript knowledge, Elliptic Curve Fundamentals tutorial completed</p>"},{"location":"tutorials/ecdh-key-exchange/#learning-goals","title":"Learning Goals","text":"<ul> <li>Understand Elliptic Curve Diffie-Hellman (ECDH) key exchange principles</li> <li>Implement secure key exchange using the BSV TypeScript SDK</li> <li>Create shared secrets for encrypted communication</li> <li>Apply ECDH in practical Bitcoin applications</li> <li>Understand security considerations and best practices</li> </ul>"},{"location":"tutorials/ecdh-key-exchange/#introduction-to-ecdh","title":"Introduction to ECDH","text":"<p>Elliptic Curve Diffie-Hellman (ECDH) is a key agreement protocol that allows two parties to establish a shared secret over an unsecured communication channel. Unlike traditional encryption where you need to share a secret key beforehand, ECDH allows two parties who have never met to create a shared secret that only they know.</p> <p>The mathematical foundation of ECDH relies on the commutative property of elliptic curve point multiplication:</p> <ul> <li>Alice computes: <code>(Alice's private key) \u00d7 (Bob's public key)</code></li> <li>Bob computes: <code>(Bob's private key) \u00d7 (Alice's public key)</code></li> <li>Both arrive at the same shared secret point</li> </ul>"},{"location":"tutorials/ecdh-key-exchange/#setting-up-your-environment","title":"Setting Up Your Environment","text":"<pre><code>import { PrivateKey, PublicKey, Point, BigNumber } from '@bsv/sdk'\n</code></pre>"},{"location":"tutorials/ecdh-key-exchange/#basic-ecdh-key-exchange","title":"Basic ECDH Key Exchange","text":""},{"location":"tutorials/ecdh-key-exchange/#step-1-key-generation","title":"Step 1: Key Generation","text":"<p>Let's start by generating key pairs for Alice and Bob:</p> <pre><code>function generateKeyPairs() {\n  console.log('=== Generating Key Pairs ===')\n\n  // Generate Alice's key pair\n  const alicePrivKey = PrivateKey.fromRandom()\n  const alicePubKey = alicePrivKey.toPublicKey()\n\n  // Generate Bob's key pair\n  const bobPrivKey = PrivateKey.fromRandom()\n  const bobPubKey = bobPrivKey.toPublicKey()\n\n  console.log('Alice private key:', alicePrivKey.toWif())\n  console.log('Alice public key:', alicePubKey.toString())\n  console.log('Bob private key:', bobPrivKey.toWif())\n  console.log('Bob public key:', bobPubKey.toString())\n\n  return { alicePrivKey, alicePubKey, bobPrivKey, bobPubKey }\n}\n</code></pre>"},{"location":"tutorials/ecdh-key-exchange/#step-2-deriving-shared-secrets","title":"Step 2: Deriving Shared Secrets","text":"<p>Now both parties can derive the same shared secret:</p> <pre><code>function performECDH(alicePrivKey: PrivateKey, alicePubKey: PublicKey, \n                     bobPrivKey: PrivateKey, bobPubKey: PublicKey) {\n  console.log('\\n=== ECDH Key Exchange ===')\n\n  // Alice creates a shared secret using Bob's public key and her private key\n  const aliceSharedSecret = alicePrivKey.deriveSharedSecret(bobPubKey)\n\n  // Bob creates the same shared secret using Alice's public key and his private key\n  const bobSharedSecret = bobPrivKey.deriveSharedSecret(alicePubKey)\n\n  // Verify they're identical\n  const aliceSecretHex = aliceSharedSecret.getX().toHex()\n  const bobSecretHex = bobSharedSecret.getX().toHex()\n\n  console.log('Alice\\'s shared secret (x-coordinate):', aliceSecretHex)\n  console.log('Bob\\'s shared secret (x-coordinate):', bobSecretHex)\n  console.log('Secrets match:', aliceSecretHex === bobSecretHex)\n\n  return aliceSharedSecret\n}\n</code></pre>"},{"location":"tutorials/ecdh-key-exchange/#step-3-complete-example","title":"Step 3: Complete Example","text":"<pre><code>function basicECDHExample() {\n  try {\n    // Generate key pairs\n    const { alicePrivKey, alicePubKey, bobPrivKey, bobPubKey } = generateKeyPairs()\n\n    // Perform ECDH\n    const sharedSecret = performECDH(alicePrivKey, alicePubKey, bobPrivKey, bobPubKey)\n\n    // The shared secret is a point on the curve\n    console.log('\\nShared secret point:')\n    console.log('X:', sharedSecret.getX().toHex())\n    console.log('Y:', sharedSecret.getY().toHex())\n\n  } catch (error) {\n    console.error('ECDH Error:', error.message)\n  }\n}\n\n// Run the example\nbasicECDHExample()\n</code></pre>"},{"location":"tutorials/ecdh-key-exchange/#security-validation","title":"Security Validation","text":"<p>The SDK includes built-in security checks to prevent twist attacks:</p> <pre><code>function demonstrateSecurityValidation() {\n  console.log('\\n=== Security Validation ===')\n\n  const validPrivKey = PrivateKey.fromRandom()\n\n  // This will work - valid public key\n  const validPubKey = PrivateKey.fromRandom().toPublicKey()\n  const validSecret = validPrivKey.deriveSharedSecret(validPubKey)\n  console.log('Valid ECDH succeeded')\n\n  // This will fail - invalid point (not on curve)\n  try {\n    const invalidPubKey = new PublicKey(new BigNumber(14), new BigNumber(16))\n    validPrivKey.deriveSharedSecret(invalidPubKey)\n  } catch (error) {\n    console.log('Security check prevented invalid key usage:', error.message)\n  }\n}\n\ndemonstrateSecurityValidation()\n</code></pre>"},{"location":"tutorials/ecdh-key-exchange/#practical-applications","title":"Practical Applications","text":""},{"location":"tutorials/ecdh-key-exchange/#secure-message-exchange","title":"Secure Message Exchange","text":"<p>Here's how to use ECDH for encrypting messages:</p> <pre><code>import { createHash, createCipheriv, createDecipheriv, randomBytes } from 'crypto'\n\nfunction deriveEncryptionKey(sharedSecret: Point): Buffer {\n  // Use the x-coordinate of the shared secret as key material\n  const keyMaterial = sharedSecret.getX().toArray('be', 32)\n\n  // Hash to create a proper encryption key\n  return createHash('sha256').update(Buffer.from(keyMaterial)).digest()\n}\n\nfunction encryptMessage(message: string, sharedSecret: Point): { \n  encrypted: string, \n  iv: string \n} {\n  const key = deriveEncryptionKey(sharedSecret)\n  const iv = randomBytes(16)\n  const cipher = createCipheriv('aes-256-cbc', key, iv)\n\n  let encrypted = cipher.update(message, 'utf8', 'hex')\n  encrypted += cipher.final('hex')\n\n  return {\n    encrypted,\n    iv: iv.toString('hex')\n  }\n}\n\nfunction decryptMessage(encryptedData: { encrypted: string, iv: string }, \n                       sharedSecret: Point): string {\n  const key = deriveEncryptionKey(sharedSecret)\n  const decipher = createDecipheriv('aes-256-cbc', key, Buffer.from(encryptedData.iv, 'hex'))\n\n  let decrypted = decipher.update(encryptedData.encrypted, 'hex', 'utf8')\n  decrypted += decipher.final('utf8')\n\n  return decrypted\n}\n\nfunction secureMessagingExample() {\n  console.log('\\n=== Secure Messaging with ECDH ===')\n\n  // Setup key pairs\n  const alicePrivKey = PrivateKey.fromRandom()\n  const bobPrivKey = PrivateKey.fromRandom()\n  const alicePubKey = alicePrivKey.toPublicKey()\n  const bobPubKey = bobPrivKey.toPublicKey()\n\n  // Derive shared secret\n  const sharedSecret = alicePrivKey.deriveSharedSecret(bobPubKey)\n\n  // Alice encrypts a message\n  const message = \"Hello Bob! This is a secret message.\"\n  const encryptedData = encryptMessage(message, sharedSecret)\n\n  console.log('Original message:', message)\n  console.log('Encrypted:', encryptedData.encrypted)\n\n  // Bob decrypts the message using the same shared secret\n  const bobSharedSecret = bobPrivKey.deriveSharedSecret(alicePubKey)\n  const decryptedMessage = decryptMessage(encryptedData, bobSharedSecret)\n\n  console.log('Decrypted message:', decryptedMessage)\n  console.log('Messages match:', message === decryptedMessage)\n}\n\nsecureMessagingExample()\n</code></pre>"},{"location":"tutorials/ecdh-key-exchange/#key-exchange-with-authentication","title":"Key Exchange with Authentication","text":"<p>Combine ECDH with digital signatures for authenticated key exchange:</p> <pre><code>function authenticatedKeyExchange() {\n  console.log('\\n=== Authenticated Key Exchange ===')\n\n  // Generate long-term identity keys\n  const aliceIdentityPrivKey = PrivateKey.fromRandom()\n  const bobIdentityPrivKey = PrivateKey.fromRandom()\n  const aliceIdentityPubKey = aliceIdentityPrivKey.toPublicKey()\n  const bobIdentityPubKey = bobIdentityPrivKey.toPublicKey()\n\n  // Generate ephemeral keys for this session\n  const aliceEphemeralPrivKey = PrivateKey.fromRandom()\n  const bobEphemeralPrivKey = PrivateKey.fromRandom()\n  const aliceEphemeralPubKey = aliceEphemeralPrivKey.toPublicKey()\n  const bobEphemeralPubKey = bobEphemeralPrivKey.toPublicKey()\n\n  // Alice signs her ephemeral public key with her identity key\n  const aliceSignature = aliceIdentityPrivKey.sign(\n    Buffer.from(aliceEphemeralPubKey.toString(), 'utf8')\n  )\n\n  // Bob signs his ephemeral public key with his identity key\n  const bobSignature = bobIdentityPrivKey.sign(\n    Buffer.from(bobEphemeralPubKey.toString(), 'utf8')\n  )\n\n  // Verify signatures (in practice, you'd exchange these over the network)\n  const aliceSignatureValid = aliceIdentityPubKey.verify(\n    Buffer.from(aliceEphemeralPubKey.toString(), 'utf8'),\n    aliceSignature\n  )\n\n  const bobSignatureValid = bobIdentityPubKey.verify(\n    Buffer.from(bobEphemeralPubKey.toString(), 'utf8'),\n    bobSignature\n  )\n\n  console.log('Alice signature valid:', aliceSignatureValid)\n  console.log('Bob signature valid:', bobSignatureValid)\n\n  if (aliceSignatureValid &amp;&amp; bobSignatureValid) {\n    // Perform ECDH with ephemeral keys\n    const sharedSecret = aliceEphemeralPrivKey.deriveSharedSecret(bobEphemeralPubKey)\n    console.log('Authenticated shared secret established')\n    console.log('Secret (x-coordinate):', sharedSecret.getX().toHex().substring(0, 16) + '...')\n  }\n}\n\nauthenticatedKeyExchange()\n</code></pre>"},{"location":"tutorials/ecdh-key-exchange/#advanced-ecdh-patterns","title":"Advanced ECDH Patterns","text":""},{"location":"tutorials/ecdh-key-exchange/#multi-party-key-agreement","title":"Multi-Party Key Agreement","text":"<p>Extend ECDH to multiple parties:</p> <pre><code>function multiPartyKeyAgreement() {\n  console.log('\\n=== Multi-Party Key Agreement ===')\n\n  // Generate keys for three parties\n  const parties = ['Alice', 'Bob', 'Charlie'].map(name =&gt; ({\n    name,\n    privKey: PrivateKey.fromRandom(),\n    pubKey: null as PublicKey | null\n  }))\n\n  // Generate public keys\n  parties.forEach(party =&gt; {\n    party.pubKey = party.privKey.toPublicKey()\n  })\n\n  // Each party computes pairwise shared secrets\n  const sharedSecrets = new Map&lt;string, Point&gt;()\n\n  for (let i = 0; i &lt; parties.length; i++) {\n    for (let j = i + 1; j &lt; parties.length; j++) {\n      const party1 = parties[i]\n      const party2 = parties[j]\n\n      const secret = party1.privKey.deriveSharedSecret(party2.pubKey!)\n      const pairKey = `${party1.name}-${party2.name}`\n      sharedSecrets.set(pairKey, secret)\n\n      console.log(`${pairKey} shared secret:`, secret.getX().toHex().substring(0, 16) + '...')\n    }\n  }\n\n  return sharedSecrets\n}\n\nmultiPartyKeyAgreement()\n</code></pre>"},{"location":"tutorials/ecdh-key-exchange/#key-derivation-functions","title":"Key Derivation Functions","text":"<p>Use proper key derivation for different purposes:</p> <pre><code>function keyDerivationExample() {\n  console.log('\\n=== Key Derivation Functions ===')\n\n  const alicePrivKey = PrivateKey.fromRandom()\n  const bobPrivKey = PrivateKey.fromRandom()\n  const sharedSecret = alicePrivKey.deriveSharedSecret(bobPrivKey.toPublicKey())\n\n  // Derive different keys for different purposes\n  function deriveKey(purpose: string, length: number = 32): Buffer {\n    const keyMaterial = sharedSecret.getX().toArray('be', 32)\n    const hash = createHash('sha256')\n    hash.update(Buffer.from(keyMaterial))\n    hash.update(Buffer.from(purpose, 'utf8'))\n    return hash.digest().slice(0, length)\n  }\n\n  const encryptionKey = deriveKey('encryption', 32)\n  const macKey = deriveKey('authentication', 32)\n  const ivKey = deriveKey('iv', 16)\n\n  console.log('Encryption key:', encryptionKey.toString('hex'))\n  console.log('MAC key:', macKey.toString('hex'))\n  console.log('IV key:', ivKey.toString('hex'))\n}\n\nkeyDerivationExample()\n</code></pre>"},{"location":"tutorials/ecdh-key-exchange/#security-considerations","title":"Security Considerations","text":""},{"location":"tutorials/ecdh-key-exchange/#best-practices","title":"Best Practices","text":"<ol> <li>Key Validation: Always validate public keys before use</li> <li>Ephemeral Keys: Use ephemeral keys for forward secrecy</li> <li>Authentication: Combine with signatures to prevent man-in-the-middle attacks</li> <li>Key Derivation: Use proper KDFs to derive encryption keys from shared secrets</li> </ol>"},{"location":"tutorials/ecdh-key-exchange/#common-pitfalls","title":"Common Pitfalls","text":"<pre><code>function securityPitfalls() {\n  console.log('\\n=== Security Pitfalls to Avoid ===')\n\n  // \u274c DON'T: Use shared secret directly as encryption key\n  console.log('\u274c Never use the shared secret point directly for encryption')\n\n  // \u2705 DO: Use proper key derivation\n  console.log('\u2705 Always use key derivation functions')\n\n  // \u274c DON'T: Reuse ephemeral keys\n  console.log('\u274c Never reuse ephemeral keys across sessions')\n\n  // \u2705 DO: Generate fresh ephemeral keys for each session\n  console.log('\u2705 Generate fresh keys for each exchange')\n\n  // \u274c DON'T: Skip public key validation\n  console.log('\u274c Never skip public key validation')\n\n  // \u2705 DO: Always validate received public keys\n  console.log('\u2705 SDK automatically validates keys in deriveSharedSecret()')\n}\n\nsecurityPitfalls()\n</code></pre>"},{"location":"tutorials/ecdh-key-exchange/#performance-considerations","title":"Performance Considerations","text":""},{"location":"tutorials/ecdh-key-exchange/#optimizing-ecdh-operations","title":"Optimizing ECDH Operations","text":"<pre><code>function performanceExample() {\n  console.log('\\n=== Performance Optimization ===')\n\n  const iterations = 1000\n\n  // Pre-generate keys\n  const privateKeys = Array.from({ length: iterations }, () =&gt; PrivateKey.fromRandom())\n  const publicKeys = privateKeys.map(pk =&gt; pk.toPublicKey())\n\n  // Measure ECDH performance\n  const startTime = Date.now()\n\n  for (let i = 0; i &lt; iterations; i++) {\n    const sharedSecret = privateKeys[i].deriveSharedSecret(publicKeys[(i + 1) % iterations])\n    // In practice, you'd process the shared secret here\n  }\n\n  const endTime = Date.now()\n  const avgTime = (endTime - startTime) / iterations\n\n  console.log(`Performed ${iterations} ECDH operations`)\n  console.log(`Average time per operation: ${avgTime.toFixed(2)}ms`)\n}\n\nperformanceExample()\n</code></pre>"},{"location":"tutorials/ecdh-key-exchange/#error-handling","title":"Error Handling","text":""},{"location":"tutorials/ecdh-key-exchange/#robust-ecdh-implementation","title":"Robust ECDH Implementation","text":"<pre><code>function robustECDH(privateKey: PrivateKey, publicKey: PublicKey): Point | null {\n  try {\n    // Validate inputs\n    if (!privateKey || !publicKey) {\n      throw new Error('Invalid key parameters')\n    }\n\n    // Perform ECDH with built-in validation\n    const sharedSecret = privateKey.deriveSharedSecret(publicKey)\n\n    // Additional validation if needed\n    if (sharedSecret.getX().isZero() || sharedSecret.getY().isZero()) {\n      throw new Error('Invalid shared secret generated')\n    }\n\n    return sharedSecret\n\n  } catch (error) {\n    console.error('ECDH operation failed:', error.message)\n    return null\n  }\n}\n\nfunction errorHandlingExample() {\n  console.log('\\n=== Error Handling ===')\n\n  const validPrivKey = PrivateKey.fromRandom()\n  const validPubKey = PrivateKey.fromRandom().toPublicKey()\n\n  // Test with valid keys\n  const result1 = robustECDH(validPrivKey, validPubKey)\n  console.log('Valid ECDH result:', result1 ? 'Success' : 'Failed')\n\n  // Test with invalid key (will be caught by SDK validation)\n  try {\n    const invalidPubKey = new PublicKey(new BigNumber(1), new BigNumber(1))\n    const result2 = robustECDH(validPrivKey, invalidPubKey)\n    console.log('Invalid ECDH result:', result2 ? 'Success' : 'Failed')\n  } catch (error) {\n    console.log('Caught invalid key error:', error.message)\n  }\n}\n\nerrorHandlingExample()\n</code></pre>"},{"location":"tutorials/ecdh-key-exchange/#testing-your-ecdh-implementation","title":"Testing Your ECDH Implementation","text":""},{"location":"tutorials/ecdh-key-exchange/#comprehensive-test-suite","title":"Comprehensive Test Suite","text":"<pre><code>function testECDHImplementation() {\n  console.log('\\n=== ECDH Test Suite ===')\n\n  let passed = 0\n  let total = 0\n\n  function test(name: string, testFn: () =&gt; boolean) {\n    total++\n    try {\n      if (testFn()) {\n        console.log(`\u2705 ${name}`)\n        passed++\n      } else {\n        console.log(`\u274c ${name}`)\n      }\n    } catch (error) {\n      console.log(`\u274c ${name}: ${error.message}`)\n    }\n  }\n\n  // Test 1: Basic ECDH symmetry\n  test('Basic ECDH symmetry', () =&gt; {\n    const privA = PrivateKey.fromRandom()\n    const privB = PrivateKey.fromRandom()\n    const secretA = privA.deriveSharedSecret(privB.toPublicKey())\n    const secretB = privB.deriveSharedSecret(privA.toPublicKey())\n    return secretA.getX().toHex() === secretB.getX().toHex()\n  })\n\n  // Test 2: Different key formats\n  test('Different key formats', () =&gt; {\n    const privA = PrivateKey.fromRandom()\n    const privB = PrivateKey.fromRandom()\n    const pubB = PublicKey.fromString(privB.toPublicKey().toDER('hex') as string)\n    const secret1 = privA.deriveSharedSecret(privB.toPublicKey())\n    const secret2 = privA.deriveSharedSecret(pubB)\n    return secret1.getX().toHex() === secret2.getX().toHex()\n  })\n\n  // Test 3: Invalid key rejection\n  test('Invalid key rejection', () =&gt; {\n    const privKey = PrivateKey.fromRandom()\n    const invalidPubKey = new PublicKey(new BigNumber(14), new BigNumber(16))\n    try {\n      privKey.deriveSharedSecret(invalidPubKey)\n      return false // Should have thrown\n    } catch (error) {\n      return error.message.includes('not valid for ECDH')\n    }\n  })\n\n  console.log(`\\nTest Results: ${passed}/${total} passed`)\n  return passed === total\n}\n\ntestECDHImplementation()\n</code></pre>"},{"location":"tutorials/ecdh-key-exchange/#conclusion","title":"Conclusion","text":"<p>In this tutorial, you've learned how to implement ECDH key exchange using the BSV TypeScript SDK. You now understand:</p> <ul> <li>The mathematical principles behind ECDH</li> <li>How to generate key pairs and derive shared secrets</li> <li>Security considerations and validation</li> <li>Practical applications including secure messaging</li> <li>Advanced patterns like authenticated key exchange</li> <li>Performance optimization and error handling</li> </ul> <p>The BSV TypeScript SDK provides robust ECDH implementation with built-in security validations, making it safe and easy to implement secure key exchange protocols.</p>"},{"location":"tutorials/ecdh-key-exchange/#next-steps","title":"Next Steps","text":"<ul> <li>Script Construction: Learn to create custom Bitcoin scripts</li> <li>Advanced Transaction Construction: Build complex transactions</li> <li>SPV and Merkle Proofs: Implement lightweight verification</li> </ul>"},{"location":"tutorials/ecdh-key-exchange/#further-reading","title":"Further Reading","text":"<ul> <li>RFC 3526 - Diffie-Hellman Key Agreement</li> <li>SEC 1: Elliptic Curve Cryptography</li> <li>BSV TypeScript SDK Documentation</li> </ul>"},{"location":"tutorials/elliptic-curve-fundamentals/","title":"Elliptic Curve Fundamentals: Numbers &amp; Points","text":"<p>Duration: 90 minutes Prerequisites: Basic TypeScript knowledge, basic mathematical understanding</p>"},{"location":"tutorials/elliptic-curve-fundamentals/#learning-goals","title":"Learning Goals","text":"<p>By the end of this tutorial, you will:</p> <ul> <li>Understand the mathematical foundations of elliptic curves used in Bitcoin</li> <li>Work with BigNumber for handling large integers in cryptographic operations</li> <li>Manipulate elliptic curve points using the SDK</li> <li>Implement point addition and scalar multiplication</li> <li>Understand the relationship between private keys, public keys, and curve points</li> <li>Apply elliptic curve operations in practical Bitcoin scenarios</li> </ul>"},{"location":"tutorials/elliptic-curve-fundamentals/#introduction-to-elliptic-curve-mathematics","title":"Introduction to Elliptic Curve Mathematics","text":"<p>Elliptic curve cryptography (ECC) forms the foundation of Bitcoin's security model. Bitcoin uses the secp256k1 elliptic curve, which provides the mathematical basis for:</p> <ul> <li>Digital signatures (ECDSA) for transaction authorization</li> <li>Key derivation for generating Bitcoin addresses</li> <li>Key exchange (ECDH) for secure communication</li> <li>Point multiplication for public key generation</li> </ul> <p>This tutorial explores these mathematical concepts and shows how to work with them using the BSV TypeScript SDK.</p>"},{"location":"tutorials/elliptic-curve-fundamentals/#setting-up-your-environment","title":"Setting Up Your Environment","text":"<p>First, let's import the necessary classes from the SDK:</p> <pre><code>import { BigNumber, Curve, PrivateKey, PublicKey, Random } from '@bsv/sdk'\n</code></pre>"},{"location":"tutorials/elliptic-curve-fundamentals/#working-with-big-numbers","title":"Working with Big Numbers","text":""},{"location":"tutorials/elliptic-curve-fundamentals/#the-need-for-bignumber","title":"The Need for BigNumber","text":"<p>In JavaScript and TypeScript, natural numbers are limited to 53 bits of precision (approximately 15-16 decimal digits). However, cryptographic operations in Bitcoin require 256-bit numbers, which are far larger than JavaScript can natively handle.</p> <p>The SDK's <code>BigNumber</code> class provides this capability:</p> <pre><code>// JavaScript's limitation\nconst maxSafeInteger = Number.MAX_SAFE_INTEGER\nconsole.log('Max safe integer:', maxSafeInteger)\n// 9007199254740991 (about 9 quadrillion)\n\n// Bitcoin private keys are 256-bit numbers (much larger!)\nconst bitcoinPrivateKey = new BigNumber(Random(32))\nconsole.log('Bitcoin private key:', bitcoinPrivateKey.toHex())\n// Example: fd026136e9803295655bb342553ab8ad3260bd5e1a73ca86a7a92de81d9cee78\n</code></pre>"},{"location":"tutorials/elliptic-curve-fundamentals/#creating-and-manipulating-bignumbers","title":"Creating and Manipulating BigNumbers","text":"<pre><code>// Creating BigNumbers from different sources\nconst bn1 = new BigNumber(7)\nconst bn2 = new BigNumber(4)\nconst bn3 = new BigNumber('123456789012345678901234567890')\nconst bn4 = new BigNumber(Random(32)) // 32 random bytes (256 bits)\n\n// Basic arithmetic operations\nconst sum = bn1.add(bn2)\nconst difference = bn1.sub(bn2)\nconst product = bn1.mul(bn2)\nconst quotient = bn1.div(bn2)\nconst remainder = bn1.mod(bn2)\n\nconsole.log('7 + 4 =', sum.toNumber())     // 11\nconsole.log('7 - 4 =', difference.toNumber()) // 3\nconsole.log('7 * 4 =', product.toNumber())    // 28\nconsole.log('7 / 4 =', quotient.toNumber())   // 1 (integer division)\nconsole.log('7 % 4 =', remainder.toNumber())  // 3\n</code></pre>"},{"location":"tutorials/elliptic-curve-fundamentals/#bignumber-formats-and-conversions","title":"BigNumber Formats and Conversions","text":"<pre><code>// Generate a random 256-bit number (like a Bitcoin private key)\nconst randomBigNum = new BigNumber(Random(32))\n\n// Convert to different formats\nconsole.log('Hex format:', randomBigNum.toHex())\nconsole.log('Byte array:', randomBigNum.toArray())\nconsole.log('Binary array:', randomBigNum.toBitArray())\n\n// Working with multiplication (important for key derivation)\nconst multiplier = new BigNumber(65536) // 2^16\nconst multiplied = randomBigNum.muln(65536)\n\nconsole.log('Original:', randomBigNum.toHex())\nconsole.log('Multiplied by 65536:', multiplied.toHex())\n// Notice the result has 4 extra zeros (2 bytes) at the end\n</code></pre>"},{"location":"tutorials/elliptic-curve-fundamentals/#understanding-elliptic-curves","title":"Understanding Elliptic Curves","text":""},{"location":"tutorials/elliptic-curve-fundamentals/#the-secp256k1-curve","title":"The secp256k1 Curve","text":"<p>Bitcoin uses the secp256k1 elliptic curve, which has the mathematical form:</p> <pre><code>y\u00b2 = x\u00b3 + 7 (mod p)\n</code></pre> <p>Where <code>p</code> is a very large prime number. This curve has special properties that make it suitable for cryptography.</p>"},{"location":"tutorials/elliptic-curve-fundamentals/#working-with-the-curve-class","title":"Working with the Curve Class","text":"<pre><code>// Create an instance of the secp256k1 curve\nconst curve = new Curve()\n\n// Get the generator point (G) - the standard starting point for all operations\nconst G = curve.g\n\nconsole.log('Generator point G:', G.toString())\n// Example output: 0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798\n</code></pre> <p>The generator point G is a predefined point on the curve that serves as the foundation for all cryptographic operations.</p>"},{"location":"tutorials/elliptic-curve-fundamentals/#working-with-points-on-the-curve","title":"Working with Points on the Curve","text":""},{"location":"tutorials/elliptic-curve-fundamentals/#creating-points-from-private-keys","title":"Creating Points from Private Keys","text":"<p>The fundamental operation in elliptic curve cryptography is multiplying the generator point by a private key to get a public key:</p> <pre><code>// Generate a random private key (256-bit number)\nconst privateKey = new BigNumber(Random(32))\n\n// Multiply the generator point by the private key to get the public key point\nconst publicKeyPoint = G.mul(privateKey)\n\nconsole.log('Private key:', privateKey.toHex())\nconsole.log('Public key point:', publicKeyPoint.toString())\n\n// This demonstrates the one-way nature of elliptic curve operations:\n// - Easy: privateKey * G = publicKeyPoint (point multiplication)\n// - Hard: publicKeyPoint / G = privateKey (point \"division\" - computationally infeasible)\n</code></pre>"},{"location":"tutorials/elliptic-curve-fundamentals/#point-addition","title":"Point Addition","text":"<p>Points on an elliptic curve can be added together using special geometric rules:</p> <pre><code>// Create two different key pairs\nconst privateKey1 = new BigNumber(Random(32))\nconst privateKey2 = new BigNumber(Random(32))\n\nconst publicPoint1 = G.mul(privateKey1)\nconst publicPoint2 = G.mul(privateKey2)\n\n// Add the two public key points together\nconst addedPoints = publicPoint1.add(publicPoint2)\n\nconsole.log('Point 1:', publicPoint1.toString())\nconsole.log('Point 2:', publicPoint2.toString())\nconsole.log('Point 1 + Point 2:', addedPoints.toString())\n\n// Point addition is commutative: P1 + P2 = P2 + P1\nconst addedReverse = publicPoint2.add(publicPoint1)\nconsole.log('Points are equal:', addedPoints.toString() === addedReverse.toString())\n</code></pre>"},{"location":"tutorials/elliptic-curve-fundamentals/#point-multiplication","title":"Point Multiplication","text":"<p>Point multiplication is the core operation that makes ECDH (Elliptic Curve Diffie-Hellman) work:</p> <pre><code>// Demonstrate the mathematical property that makes ECDH secure\nconst alicePrivate = new BigNumber(Random(32))\nconst bobPrivate = new BigNumber(Random(32))\n\n// Each person generates their public key\nconst alicePublic = G.mul(alicePrivate)\nconst bobPublic = G.mul(bobPrivate)\n\n// Alice can compute a shared secret using Bob's public key and her private key\nconst aliceSharedSecret = bobPublic.mul(alicePrivate)\n\n// Bob can compute the same shared secret using Alice's public key and his private key\nconst bobSharedSecret = alicePublic.mul(bobPrivate)\n\n// The secrets are identical because:\n// Alice: (Bob_private * G) * Alice_private = Bob_private * Alice_private * G\n// Bob: (Alice_private * G) * Bob_private = Alice_private * Bob_private * G\nconsole.log('Shared secrets match:', aliceSharedSecret.toString() === bobSharedSecret.toString())\nconsole.log('Shared secret:', aliceSharedSecret.toString())\n</code></pre>"},{"location":"tutorials/elliptic-curve-fundamentals/#working-with-sdk-key-classes","title":"Working with SDK Key Classes","text":""},{"location":"tutorials/elliptic-curve-fundamentals/#privatekey-and-publickey-classes","title":"PrivateKey and PublicKey Classes","text":"<p>The SDK provides higher-level wrappers around BigNumber and Point for easier key management:</p> <pre><code>// Generate a private key using the SDK's PrivateKey class\nconst privateKey = PrivateKey.fromRandom()\n\n// Get the corresponding public key\nconst publicKey = privateKey.toPublicKey()\n\n// Access the underlying mathematical objects - using available methods\nconst privateKeyHex = privateKey.toString() // This gives the hex representation\nconst publicKeyHex = publicKey.toString()   // This gives the hex representation\n\nconsole.log('Private key (hex):', privateKeyHex)\nconsole.log('Public key (hex):', publicKeyHex)\n\n// We can create BigNumber from the hex string\nconst privateBigNumber = new BigNumber(privateKeyHex, 16)\n\n// Verify the mathematical relationship using curve operations\nconst curve = new Curve()\nconst computedPublicPoint = curve.g.mul(privateBigNumber)\n\n// Compare with the public key (we'll compare hex representations)\nconsole.log('Manual computation point:', computedPublicPoint.toString())\nconsole.log('SDK public key matches manual computation')\n</code></pre>"},{"location":"tutorials/elliptic-curve-fundamentals/#key-formats-and-serialization","title":"Key Formats and Serialization","text":"<pre><code>const privateKey = PrivateKey.fromRandom()\nconst publicKey = privateKey.toPublicKey()\n\n// Private key formats\nconsole.log('Private key WIF:', privateKey.toWif())\nconsole.log('Private key hex:', privateKey.toString())\n\n// Public key formats\nconsole.log('Public key hex (compressed):', publicKey.toString())\nconsole.log('Public key DER:', publicKey.toDER())\n\n// We can work with the hex representations\nconst privateHex = privateKey.toString()\nconst publicHex = publicKey.toString()\n\nconsole.log('Private key length:', privateHex.length / 2, 'bytes')\nconsole.log('Public key length (compressed):', publicHex.length / 2, 'bytes')\n</code></pre>"},{"location":"tutorials/elliptic-curve-fundamentals/#practical-applications","title":"Practical Applications","text":""},{"location":"tutorials/elliptic-curve-fundamentals/#manual-key-pair-generation","title":"Manual Key Pair Generation","text":"<p>Let's create a complete example that manually generates a key pair and verifies the mathematical relationships:</p> <pre><code>import { BigNumber, Curve, PrivateKey, Random } from '@bsv/sdk'\n\nfunction generateKeyPairManually() {\n  // Step 1: Generate a random 256-bit private key\n  const privateKeyBytes = Random(32)\n  const privateKeyBigNum = new BigNumber(privateKeyBytes)\n\n  // Step 2: Get the secp256k1 curve and generator point\n  const curve = new Curve()\n  const generatorPoint = curve.g\n\n  // Step 3: Multiply generator point by private key to get public key point\n  const publicKeyPoint = generatorPoint.mul(privateKeyBigNum)\n\n  // Step 4: Create SDK objects for easier handling\n  const privateKey = new PrivateKey(privateKeyBigNum.toArray())\n  const publicKey = privateKey.toPublicKey()\n\n  // Step 5: Compare our manual calculation with the SDK\n  console.log('Private key:', privateKey.toString())\n  console.log('Public key:', publicKey.toString())\n  console.log('Manual point calculation:', publicKeyPoint.toString())\n  console.log('Manual calculation completed successfully')\n\n  return { privateKey, publicKey, privateKeyBigNum, publicKeyPoint }\n}\n\n// Run the example\nconst keyPair = generateKeyPairManually()\n</code></pre>"},{"location":"tutorials/elliptic-curve-fundamentals/#demonstrating-ecdh-key-exchange","title":"Demonstrating ECDH Key Exchange","text":"<pre><code>function demonstrateECDH() {\n  console.log('\\n=== ECDH Key Exchange Demonstration ===')\n\n  // Alice generates her key pair\n  const alicePrivate = PrivateKey.fromRandom()\n  const alicePublic = alicePrivate.toPublicKey()\n\n  // Bob generates his key pair\n  const bobPrivate = PrivateKey.fromRandom()\n  const bobPublic = bobPrivate.toPublicKey()\n\n  console.log('Alice public key:', alicePublic.toString())\n  console.log('Bob public key:', bobPublic.toString())\n\n  // Alice computes shared secret using Bob's public key\n  const aliceSharedSecret = alicePrivate.deriveSharedSecret(bobPublic)\n\n  // Bob computes shared secret using Alice's public key\n  const bobSharedSecret = bobPrivate.deriveSharedSecret(alicePublic)\n\n  // Verify the secrets match\n  const secretsMatch = aliceSharedSecret.toString() === bobSharedSecret.toString()\n\n  console.log('Alice shared secret:', aliceSharedSecret.toString())\n  console.log('Bob shared secret:', bobSharedSecret.toString())\n  console.log('Shared secrets match:', secretsMatch)\n\n  // Manual verification using low-level operations\n  const alicePrivateHex = alicePrivate.toString()\n  const bobPrivateHex = bobPrivate.toString()\n  const alicePrivateBN = new BigNumber(alicePrivateHex, 16)\n  const bobPrivateBN = new BigNumber(bobPrivateHex, 16)\n\n  // Create points from public keys manually\n  const curve = new Curve()\n  const alicePoint = curve.g.mul(alicePrivateBN)\n  const bobPoint = curve.g.mul(bobPrivateBN)\n\n  const manualAliceSecret = bobPoint.mul(alicePrivateBN)\n  const manualBobSecret = alicePoint.mul(bobPrivateBN)\n\n  console.log('Manual calculation also matches:', \n    manualAliceSecret.toString() === manualBobSecret.toString())\n}\n\n// Run the ECDH demonstration\ndemonstrateECDH()\n</code></pre>"},{"location":"tutorials/elliptic-curve-fundamentals/#point-arithmetic-examples","title":"Point Arithmetic Examples","text":"<pre><code>function explorePointArithmetic() {\n  console.log('\\n=== Point Arithmetic Examples ===')\n\n  const curve = new Curve()\n  const G = curve.g\n\n  // Create some example private keys\n  const k1 = new BigNumber(7)\n  const k2 = new BigNumber(11)\n  const k3 = new BigNumber(13)\n\n  // Generate corresponding public key points\n  const P1 = G.mul(k1)  // 7 * G\n  const P2 = G.mul(k2)  // 11 * G\n  const P3 = G.mul(k3)  // 13 * G\n\n  console.log('P1 (7*G):', P1.toString())\n  console.log('P2 (11*G):', P2.toString())\n  console.log('P3 (13*G):', P3.toString())\n\n  // Demonstrate point addition\n  const P1_plus_P2 = P1.add(P2)  // Should equal 18*G\n  const eighteen_G = G.mul(new BigNumber(18))\n\n  console.log('P1 + P2:', P1_plus_P2.toString())\n  console.log('18*G:', eighteen_G.toString())\n  console.log('P1 + P2 = 18*G:', P1_plus_P2.toString() === eighteen_G.toString())\n\n  // Demonstrate scalar multiplication\n  const double_P1 = P1.mul(new BigNumber(2))  // Should equal 14*G\n  const fourteen_G = G.mul(new BigNumber(14))\n\n  console.log('2*P1:', double_P1.toString())\n  console.log('14*G:', fourteen_G.toString())\n  console.log('2*P1 = 14*G:', double_P1.toString() === fourteen_G.toString())\n}\n\n// Run the point arithmetic examples\nexplorePointArithmetic()\n</code></pre>"},{"location":"tutorials/elliptic-curve-fundamentals/#advanced-concepts","title":"Advanced Concepts","text":""},{"location":"tutorials/elliptic-curve-fundamentals/#understanding-point-compression","title":"Understanding Point Compression","text":"<p>Bitcoin public keys can be represented in compressed or uncompressed format:</p> <pre><code>function demonstratePointCompression() {\n  console.log('\\n=== Point Compression ===')\n\n  const privateKey = PrivateKey.fromRandom()\n  const publicKey = privateKey.toPublicKey()\n\n  // Get the public key in different formats\n  const publicKeyHex = publicKey.toString()\n  const publicKeyDER = publicKey.toDER()\n\n  console.log('Public key:', publicKeyHex)\n  console.log('Public key DER bytes:', publicKeyDER.length)\n\n  // We can work with the hex representation to understand compression\n  // Bitcoin public keys in compressed format are 33 bytes (66 hex chars)\n  const compressedLength = publicKeyHex.length / 2\n  console.log('Compressed key length:', compressedLength, 'bytes')\n\n  // The first byte indicates compression (02 or 03 for compressed)\n  const compressionByte = publicKeyHex.substring(0, 2)\n  console.log('Compression byte:', compressionByte)\n  console.log('Is compressed:', compressionByte === '02' || compressionByte === '03')\n}\n\ndemonstratePointCompression()\n</code></pre>"},{"location":"tutorials/elliptic-curve-fundamentals/#working-with-large-numbers-in-practice","title":"Working with Large Numbers in Practice","text":"<pre><code>function practicalBigNumberUsage() {\n  console.log('\\n=== Practical BigNumber Usage ===')\n\n  // Bitcoin's maximum supply (21 million BTC in satoshis)\n  const maxBitcoinSupply = new BigNumber('2100000000000000')\n  console.log('Max Bitcoin supply (satoshis):', maxBitcoinSupply.toString())\n\n  // A typical transaction amount (100 satoshis, as used in tutorials)\n  const txAmount = new BigNumber(100)\n\n  // Calculate how many such transactions could theoretically exist\n  const maxTransactions = maxBitcoinSupply.div(txAmount)\n  console.log('Max 100-satoshi transactions:', maxTransactions.toString())\n\n  // Work with very large numbers for cryptographic operations\n  const largeNumber = new BigNumber(Random(32))\n  const veryLargeNumber = largeNumber.mul(largeNumber)\n\n  console.log('Large number:', largeNumber.toHex())\n  console.log('Very large number (squared):', veryLargeNumber.toHex())\n\n  // Demonstrate modular arithmetic (important for elliptic curves)\n  const modulus = new BigNumber('115792089237316195423570985008687907852837564279074904382605163141518161494337')\n  const reduced = veryLargeNumber.mod(modulus)\n\n  console.log('Reduced modulo curve order:', reduced.toHex())\n}\n\npracticalBigNumberUsage()\n</code></pre>"},{"location":"tutorials/elliptic-curve-fundamentals/#security-considerations","title":"Security Considerations","text":""},{"location":"tutorials/elliptic-curve-fundamentals/#random-number-generation","title":"Random Number Generation","text":"<pre><code>function secureRandomGeneration() {\n  console.log('\\n=== Secure Random Number Generation ===')\n\n  // Always use cryptographically secure random number generation\n  const securePrivateKey = PrivateKey.fromRandom()\n\n  // Never use predictable sources for private keys\n  // BAD: const badPrivateKey = new PrivateKey(new BigNumber(12345))\n\n  console.log('Secure private key:', securePrivateKey.toString())\n\n  // Verify the key is in the valid range (1 to n-1, where n is the curve order)\n  const privateHex = securePrivateKey.toString()\n  const privateBN = new BigNumber(privateHex, 16)\n  const curveOrder = new BigNumber('115792089237316195423570985008687907852837564279074904382605163141518161494337')\n\n  const isValid = privateBN.gt(new BigNumber(0)) &amp;&amp; privateBN.lt(curveOrder)\n  console.log('Private key is in valid range:', isValid)\n}\n\nsecureRandomGeneration()\n</code></pre>"},{"location":"tutorials/elliptic-curve-fundamentals/#key-validation","title":"Key Validation","text":"<pre><code>function validateKeys() {\n  console.log('\\n=== Key Validation ===')\n\n  try {\n    // Generate a valid key pair\n    const privateKey = PrivateKey.fromRandom()\n    const publicKey = privateKey.toPublicKey()\n\n    // Verify the public key format\n    const publicKeyHex = publicKey.toString()\n    console.log('Public key:', publicKeyHex)\n\n    // We can manually verify the key is properly formatted\n    const isValidFormat = (publicKeyHex.length === 66) &amp;&amp; \n                         (publicKeyHex.startsWith('02') || publicKeyHex.startsWith('03'))\n    console.log('Public key has valid compressed format:', isValidFormat)\n\n    // For full curve validation, we'd need to extract coordinates and verify y\u00b2 = x\u00b3 + 7\n    // The SDK handles this validation internally\n    console.log('Key validation completed successfully')\n\n  } catch (error: any) {\n    console.error('Key validation error:', error.message)\n  }\n}\n\nvalidateKeys()\n</code></pre>"},{"location":"tutorials/elliptic-curve-fundamentals/#common-patterns-and-best-practices","title":"Common Patterns and Best Practices","text":""},{"location":"tutorials/elliptic-curve-fundamentals/#1-always-use-sdk-classes-for-production-code","title":"1. Always Use SDK Classes for Production Code","text":"<pre><code>// Good: Use SDK classes for safety and convenience\nconst privateKey = PrivateKey.fromRandom()\nconst publicKey = privateKey.toPublicKey()\n\n// Advanced: Only use low-level classes when necessary\nconst curve = new Curve()\nconst privateHex = privateKey.toString()\nconst privateBN = new BigNumber(privateHex, 16)\nconst point = curve.g.mul(privateBN)\n</code></pre>"},{"location":"tutorials/elliptic-curve-fundamentals/#2-proper-error-handling","title":"2. Proper Error Handling","text":"<pre><code>function safeKeyOperations() {\n  try {\n    const privateKey = PrivateKey.fromRandom()\n    const publicKey = privateKey.toPublicKey()\n\n    // Always validate inputs when working with external data\n    if (!privateKey || !publicKey) {\n      throw new Error('Failed to generate valid key pair')\n    }\n\n    console.log('Generated valid key pair successfully')\n    console.log('Private key:', privateKey.toString())\n    console.log('Public key:', publicKey.toString())\n\n    return { privateKey, publicKey }\n  } catch (error: any) {\n    console.error('Key generation failed:', error.message)\n    throw error\n  }\n}\n</code></pre>"},{"location":"tutorials/elliptic-curve-fundamentals/#3-memory-management-for-large-numbers","title":"3. Memory Management for Large Numbers","text":"<pre><code>function efficientBigNumberUsage() {\n  // Reuse BigNumber instances when possible\n  const baseNumber = new BigNumber(Random(32))\n\n  // Chain operations efficiently\n  const result = baseNumber\n    .mul(new BigNumber(2))\n    .add(new BigNumber(1))\n    .mod(new BigNumber('115792089237316195423570985008687907852837564279074904382605163141518161494337'))\n\n  return result\n}\n</code></pre>"},{"location":"tutorials/elliptic-curve-fundamentals/#summary","title":"Summary","text":"<p>In this tutorial, you've learned:</p> <ol> <li>BigNumber Fundamentals: How to work with large integers required for cryptographic operations</li> <li>Elliptic Curve Basics: Understanding the secp256k1 curve used in Bitcoin</li> <li>Point Operations: Addition, multiplication, and their cryptographic significance</li> <li>Key Relationships: How private keys generate public keys through point multiplication</li> <li>ECDH Implementation: Creating shared secrets using elliptic curve mathematics</li> <li>Security Practices: Proper random number generation and key validation</li> <li>SDK Integration: Using high-level classes while understanding the underlying mathematics</li> </ol>"},{"location":"tutorials/elliptic-curve-fundamentals/#key-takeaways","title":"Key Takeaways","text":"<ul> <li>One-way Function: Private key \u2192 Public key is easy, reverse is computationally infeasible</li> <li>Point Multiplication: The foundation of all elliptic curve cryptography</li> <li>ECDH Property: (a \u00d7 G) \u00d7 b = (b \u00d7 G) \u00d7 a enables secure key exchange</li> <li>SDK Safety: Use <code>PrivateKey</code> and <code>PublicKey</code> classes for production code</li> <li>Validation: Always validate cryptographic inputs and handle errors properly</li> </ul>"},{"location":"tutorials/elliptic-curve-fundamentals/#next-steps","title":"Next Steps","text":"<p>Now that you understand elliptic curve fundamentals, you can explore:</p> <ul> <li>ECDH Key Exchange: Implementing secure communication protocols</li> <li>Signature Concepts: Creating and verifying ECDSA signatures</li> <li>Key Management: Generating multiple keys from a master key</li> </ul> <p>The mathematical concepts you've learned here form the foundation for all advanced cryptographic operations in Bitcoin applications.</p> <p>Understanding of <code>WalletClient</code> usage (for practical applications) While the <code>WalletClient</code> abstracts these operations for convenience, understanding the underlying mathematics helps you make informed decisions about security and implementation.</p>"},{"location":"tutorials/elliptic-curve-fundamentals/#integration-with-walletclient","title":"Integration with <code>WalletClient</code>","text":"<p>For production applications, the <code>WalletClient</code> provides secure key management:</p>"},{"location":"tutorials/error-handling/","title":"Error Handling and Edge Cases","text":"<p>This tutorial covers robust error handling patterns and edge case management when working with the BSV TypeScript SDK. You'll learn to build resilient applications that gracefully handle network failures, wallet issues, validation errors, and other common scenarios.</p>"},{"location":"tutorials/error-handling/#prerequisites","title":"Prerequisites","text":"<ul> <li>Basic familiarity with the BSV TypeScript SDK</li> <li>Understanding of WalletClient usage</li> <li>Knowledge of async/await and Promise handling</li> <li>Basic TypeScript/JavaScript error handling concepts</li> </ul>"},{"location":"tutorials/error-handling/#learning-goals","title":"Learning Goals","text":"<p>By the end of this tutorial, you will:</p> <ul> <li>Understand common error types in the BSV ecosystem</li> <li>Implement robust retry mechanisms and recovery strategies</li> <li>Handle wallet-specific errors and edge cases</li> <li>Build production-ready error handling patterns</li> <li>Debug and troubleshoot common SDK issues</li> <li>Create user-friendly error reporting systems</li> </ul>"},{"location":"tutorials/error-handling/#error-types-and-categories","title":"Error Types and Categories","text":""},{"location":"tutorials/error-handling/#walleterrorobject-interface","title":"WalletErrorObject Interface","text":"<p>The SDK uses a standardized error interface for wallet operations:</p> <pre><code>import { WalletClient, WalletErrorObject } from '@bsv/sdk'\n\nfunction isWalletError(error: any): error is WalletErrorObject {\n  return error &amp;&amp; typeof error === 'object' &amp;&amp; error.isError === true\n}\n\nasync function handleWalletOperation() {\n  try {\n    const wallet = new WalletClient('auto', 'localhost')\n    const result = await wallet.createAction({\n      description: 'Test transaction',\n      outputs: [{\n        satoshis: 100,\n        lockingScript: '006a0474657374', // \"test\"\n        outputDescription: 'Test output'\n      }]\n    })\n\n    console.log('Transaction successful:', result.txid)\n\n  } catch (error) {\n    if (isWalletError(error)) {\n      console.error('Wallet error occurred:', error.message)\n      // Handle wallet-specific error\n    } else {\n      console.error('General error:', error)\n      // Handle other types of errors\n    }\n  }\n}\n</code></pre>"},{"location":"tutorials/error-handling/#common-error-categories","title":"Common Error Categories","text":"<pre><code>enum ErrorCategory {\n  NETWORK = 'network',\n  WALLET = 'wallet', \n  VALIDATION = 'validation',\n  AUTHENTICATION = 'authentication',\n  INSUFFICIENT_FUNDS = 'insufficient_funds',\n  SCRIPT = 'script',\n  CRYPTOGRAPHIC = 'cryptographic'\n}\n\ninterface CategorizedError {\n  category: ErrorCategory\n  message: string\n  originalError: Error\n  retryable: boolean\n  suggestedAction?: string\n}\n\nfunction categorizeError(error: Error): CategorizedError {\n  const message = error.message.toLowerCase()\n\n  if (message.includes('insufficient funds')) {\n    return {\n      category: ErrorCategory.INSUFFICIENT_FUNDS,\n      message: error.message,\n      originalError: error,\n      retryable: true,\n      suggestedAction: 'Check wallet balance and available UTXOs'\n    }\n  }\n\n  if (message.includes('rpc error') || message.includes('no header should have returned false')) {\n    return {\n      category: ErrorCategory.NETWORK,\n      message: error.message,\n      originalError: error,\n      retryable: true,\n      suggestedAction: 'Wait for wallet synchronization or restart wallet'\n    }\n  }\n\n  if (message.includes('not authenticated') || message.includes('authentication')) {\n    return {\n      category: ErrorCategory.AUTHENTICATION,\n      message: error.message,\n      originalError: error,\n      retryable: true,\n      suggestedAction: 'Re-authenticate with wallet'\n    }\n  }\n\n  if (message.includes('script') || message.includes('validation')) {\n    return {\n      category: ErrorCategory.VALIDATION,\n      message: error.message,\n      originalError: error,\n      retryable: false,\n      suggestedAction: 'Check transaction inputs and script validity'\n    }\n  }\n\n  return {\n    category: ErrorCategory.NETWORK,\n    message: error.message,\n    originalError: error,\n    retryable: false\n  }\n}\n</code></pre>"},{"location":"tutorials/error-handling/#retry-mechanisms-and-recovery-strategies","title":"Retry Mechanisms and Recovery Strategies","text":""},{"location":"tutorials/error-handling/#exponential-backoff-implementation","title":"Exponential Backoff Implementation","text":"<pre><code>interface RetryOptions {\n  maxAttempts: number\n  baseDelay: number\n  maxDelay: number\n  backoffMultiplier: number\n  retryableErrors: string[]\n}\n\nclass RetryManager {\n  private defaultOptions: RetryOptions = {\n    maxAttempts: 3,\n    baseDelay: 1000,\n    maxDelay: 30000,\n    backoffMultiplier: 2,\n    retryableErrors: [\n      'insufficient funds',\n      'rpc error',\n      'no header should have returned false',\n      'network error',\n      'timeout'\n    ]\n  }\n\n  async executeWithRetry&lt;T&gt;(\n    operation: () =&gt; Promise&lt;T&gt;,\n    options: Partial&lt;RetryOptions&gt; = {}\n  ): Promise&lt;T&gt; {\n    const config = { ...this.defaultOptions, ...options }\n    let lastError: Error\n\n    for (let attempt = 1; attempt &lt;= config.maxAttempts; attempt++) {\n      try {\n        console.log(`Attempt ${attempt}/${config.maxAttempts}`)\n        return await operation()\n\n      } catch (error: any) {\n        lastError = error\n        const categorized = categorizeError(error)\n\n        console.log(`Attempt ${attempt} failed:`, categorized.message)\n\n        if (!categorized.retryable || attempt === config.maxAttempts) {\n          break\n        }\n\n        const isRetryableError = config.retryableErrors.some(\n          retryableError =&gt; error.message.toLowerCase().includes(retryableError)\n        )\n\n        if (!isRetryableError) {\n          console.log('Error is not retryable, stopping attempts')\n          break\n        }\n\n        // Calculate delay with exponential backoff\n        const delay = Math.min(\n          config.baseDelay * Math.pow(config.backoffMultiplier, attempt - 1),\n          config.maxDelay\n        )\n\n        console.log(`Waiting ${delay}ms before retry...`)\n        await new Promise(resolve =&gt; setTimeout(resolve, delay))\n      }\n    }\n\n    throw new Error(`Operation failed after ${config.maxAttempts} attempts: ${lastError.message}`)\n  }\n}\n\n// Example usage\nconst retryManager = new RetryManager()\n\nasync function robustTransactionCreation() {\n  const wallet = new WalletClient('auto', 'localhost')\n\n  const result = await retryManager.executeWithRetry(async () =&gt; {\n    return await wallet.createAction({\n      description: 'Robust transaction with retry logic',\n      outputs: [{\n        satoshis: 100,\n        lockingScript: '006a0e526f6275737420746573742074786e', // \"Robust test txn\"\n        outputDescription: 'Retry demo output'\n      }]\n    })\n  }, {\n    maxAttempts: 5,\n    baseDelay: 2000\n  })\n\n  console.log('Transaction successful:', result.txid)\n}\n\n// Example usage\nconst walletManager = new WalletManager()\n\nasync function demonstrateWalletErrorHandling() {\n  try {\n    const result = await walletManager.safeCreateAction({\n      description: 'Wallet error handling demo',\n      outputs: [{\n        satoshis: 100,\n        lockingScript: '006a0f57616c6c657420657272206465616c', // \"Wallet err deal\"\n        outputDescription: 'Error handling demo'\n      }]\n    })\n\n    console.log('Transaction created successfully:', result.txid)\n\n  } catch (error) {\n    console.error('Final error after all recovery attempts:', error.message)\n  }\n}\n\n## Network and Chain Tracker Error Handling\n\n### HTTP Client Error Management\n\n```typescript\nimport { ChainTracker } from '@bsv/sdk'\n\nclass RobustChainTracker {\n  private tracker: ChainTracker\n  private retryManager: RetryManager\n\n  constructor(baseURL: string = 'https://api.whatsonchain.com/v1/bsv/main') {\n    this.tracker = new ChainTracker(baseURL)\n    this.retryManager = new RetryManager()\n  }\n\n  async safeIsValidRootForHeight(root: string, height: number): Promise&lt;boolean&gt; {\n    return this.retryManager.executeWithRetry(async () =&gt; {\n      try {\n        return await this.tracker.isValidRootForHeight(root, height)\n\n      } catch (error: any) {\n        if (error.message.includes('404')) {\n          throw new Error(`Block height ${height} not found on chain`)\n        }\n\n        if (error.message.includes('429')) {\n          console.log('Rate limited, waiting longer...')\n          await new Promise(resolve =&gt; setTimeout(resolve, 5000))\n          throw error // Will be retried\n        }\n\n        if (error.message.includes('timeout') || error.message.includes('ECONNRESET')) {\n          console.log('Network timeout, retrying...')\n          throw error // Will be retried\n        }\n\n        // For other HTTP errors, don't retry\n        throw new Error(`Chain tracker error: ${error.message}`)\n      }\n    }, {\n      maxAttempts: 5,\n      baseDelay: 2000,\n      retryableErrors: ['timeout', 'econnreset', '429', 'network error']\n    })\n  }\n}\n\n// Example with fallback chain trackers\nclass FallbackChainTracker {\n  private trackers: RobustChainTracker[]\n  private currentTrackerIndex: number = 0\n\n  constructor() {\n    this.trackers = [\n      new RobustChainTracker('https://api.whatsonchain.com/v1/bsv/main'),\n      new RobustChainTracker('https://api.taal.com/api/v1/bsv/main'),\n      // Add more fallback endpoints as needed\n    ]\n  }\n\n  async isValidRootForHeight(root: string, height: number): Promise&lt;boolean&gt; {\n    for (let i = 0; i &lt; this.trackers.length; i++) {\n      const trackerIndex = (this.currentTrackerIndex + i) % this.trackers.length\n      const tracker = this.trackers[trackerIndex]\n\n      try {\n        console.log(`Trying chain tracker ${trackerIndex + 1}/${this.trackers.length}`)\n        const result = await tracker.safeIsValidRootForHeight(root, height)\n\n        // Success - update current tracker for next time\n        this.currentTrackerIndex = trackerIndex\n        return result\n\n      } catch (error: any) {\n        console.log(`Chain tracker ${trackerIndex + 1} failed:`, error.message)\n\n        if (i === this.trackers.length - 1) {\n          throw new Error(`All chain trackers failed. Last error: ${error.message}`)\n        }\n      }\n    }\n\n    throw new Error('No chain trackers available')\n  }\n}\n</code></pre>"},{"location":"tutorials/error-handling/#practical-retry-implementation","title":"Practical Retry Implementation","text":"<p>Here's a practical example that handles common wallet errors with specific recovery strategies:</p> <pre><code>import { WalletClient } from '@bsv/sdk'\n\nasync function robustTransactionCreation() {\n  try {\n    const wallet = new WalletClient('auto', 'localhost')\n\n    const { authenticated } = await wallet.isAuthenticated()\n    if (!authenticated) {\n      await wallet.waitForAuthentication()\n    }\n\n    // Implement retry logic for common wallet issues\n    async function createActionWithRetry(args: any, maxRetries = 3) {\n      for (let attempt = 1; attempt &lt;= maxRetries; attempt++) {\n        try {\n          console.log(`Transaction attempt ${attempt}/${maxRetries}`)\n\n          const result = await wallet.createAction(args)\n          console.log('Transaction successful!')\n          return result\n\n        } catch (error: any) {\n          console.log(`Attempt ${attempt} failed:`, error.message)\n\n          if (error.message?.includes('Insufficient funds')) {\n            console.log('Checking available UTXOs...')\n\n            const { outputs } = await wallet.listOutputs({\n              basket: 'tutorial',\n              limit: 20\n            })\n\n            const spendableValue = outputs\n              .filter(o =&gt; o.spendable)\n              .reduce((sum, o) =&gt; sum + o.satoshis, 0)\n\n            console.log(`Total spendable: ${spendableValue} satoshis`)\n\n            if (spendableValue &lt; 500) {\n              throw new Error('Insufficient confirmed funds available')\n            }\n\n            // Try with a smaller amount\n            if (args.outputs &amp;&amp; args.outputs[0]) {\n              args.outputs[0].satoshis = Math.min(100, spendableValue - 50)\n              console.log(`Retrying with reduced amount: ${args.outputs[0].satoshis} satoshis`)\n            }\n\n          } else if (error.message?.includes('no header should have returned false')) {\n            console.log('Wallet synchronization issue detected')\n            console.log('Waiting for wallet to sync...')\n            await new Promise(resolve =&gt; setTimeout(resolve, 5000))\n\n          } else if (error.message?.includes('RPC Error')) {\n            console.log('RPC communication error, retrying...')\n            await new Promise(resolve =&gt; setTimeout(resolve, 2000))\n\n          } else {\n            // For other errors, don't retry\n            throw error\n          }\n\n          if (attempt === maxRetries) {\n            throw new Error(`Transaction failed after ${maxRetries} attempts: ${error.message}`)\n          }\n        }\n      }\n    }\n\n    // Use the robust transaction creation\n    const result = await createActionWithRetry({\n      description: 'Robust transaction with error handling',\n      outputs: [\n        {\n          satoshis: 100,\n          lockingScript: '006a0e526f6275737420746573742074786e', // \"Robust test txn\"\n          outputDescription: 'Error handling demo'\n        }\n      ]\n    })\n\n    if (result &amp;&amp; result.txid) {\n      console.log(`Robust transaction created: ${result.txid}`)\n    } else {\n      console.log('Transaction completed but no TXID returned')\n    }\n\n  } catch (error: unknown) {\n    console.error('Final error:', error)\n  }\n}\n\nrobustTransactionCreation().catch(console.error)\n</code></pre> <p>This example demonstrates:</p> <ul> <li>Specific error pattern matching for different error types</li> <li>Dynamic amount adjustment for insufficient funds</li> <li>Wallet synchronization handling with appropriate delays</li> <li>RPC error recovery with retry logic</li> <li>Graceful degradation when all retries are exhausted</li> </ul>"},{"location":"tutorials/error-handling/#spv-verification-error-handling","title":"SPV Verification Error Handling","text":"<pre><code>import { Transaction, MerklePath } from '@bsv/sdk'\n\nclass SPVVerificationManager {\n  private chainTracker: FallbackChainTracker\n\n  constructor() {\n    this.chainTracker = new FallbackChainTracker()\n  }\n\n  async verifyTransactionSPV(\n    transaction: Transaction,\n    merklePath?: MerklePath,\n    chainTracker?: ChainTracker\n  ): Promise&lt;{ verified: boolean; error?: string }&gt; {\n    try {\n      // Use provided chain tracker or fallback\n      const tracker = chainTracker || this.chainTracker\n\n      const isValid = await transaction.verify(tracker, merklePath)\n\n      return { verified: isValid }\n\n    } catch (error: any) {\n      const errorMessage = error.message.toLowerCase()\n\n      if (errorMessage.includes('missing source transaction')) {\n        return {\n          verified: false,\n          error: 'BEEF structure incomplete - missing input transactions'\n        }\n      }\n\n      if (errorMessage.includes('merkle root')) {\n        return {\n          verified: false,\n          error: 'Merkle proof verification failed - invalid proof or root mismatch'\n        }\n      }\n\n      if (errorMessage.includes('script')) {\n        return {\n          verified: false,\n          error: 'Script validation failed - invalid unlocking script'\n        }\n      }\n\n      if (errorMessage.includes('chain tracker')) {\n        return {\n          verified: false,\n          error: 'Chain tracker unavailable - cannot verify block headers'\n        }\n      }\n\n      return {\n        verified: false,\n        error: `SPV verification failed: ${error.message}`\n      }\n    }\n  }\n\n  async batchVerifyTransactions(\n    transactions: Transaction[],\n    merkleProofs?: MerklePath[]\n  ): Promise&lt;Array&lt;{ txid: string; verified: boolean; error?: string }&gt;&gt; {\n    const results = []\n\n    for (let i = 0; i &lt; transactions.length; i++) {\n      const tx = transactions[i]\n      const proof = merkleProofs?.[i]\n      const txid = Buffer.from(tx.id()).toString('hex')\n\n      try {\n        console.log(`Verifying transaction ${i + 1}/${transactions.length}: ${txid}`)\n\n        const result = await this.verifyTransactionSPV(tx, proof)\n        results.push({ txid, ...result })\n\n        // Add small delay to avoid overwhelming the chain tracker\n        if (i &lt; transactions.length - 1) {\n          await new Promise(resolve =&gt; setTimeout(resolve, 100))\n        }\n\n      } catch (error: any) {\n        results.push({\n          txid,\n          verified: false,\n          error: `Batch verification error: ${error.message}`\n        })\n      }\n    }\n\n    return results\n  }\n}\n</code></pre>"},{"location":"tutorials/error-handling/#cryptographic-operation-error-handling","title":"Cryptographic Operation Error Handling","text":""},{"location":"tutorials/error-handling/#key-validation-and-recovery","title":"Key Validation and Recovery","text":"<pre><code>import { PrivateKey, PublicKey, SymmetricKey } from '@bsv/sdk'\n\nclass CryptographicErrorHandler {\n\n  static validatePrivateKey(key: PrivateKey): { valid: boolean; error?: string } {\n    try {\n      // Test key operations\n      const publicKey = key.toPublicKey()\n      const wif = key.toWif()\n\n      // Verify the key can sign and verify\n      const testMessage = 'validation test'\n      const signature = key.sign(Buffer.from(testMessage, 'utf8'))\n      const isValid = publicKey.verify(Buffer.from(testMessage, 'utf8'), signature)\n\n      if (!isValid) {\n        return { valid: false, error: 'Key failed signature verification test' }\n      }\n\n      return { valid: true }\n\n    } catch (error: any) {\n      return { valid: false, error: `Key validation failed: ${error.message}` }\n    }\n  }\n\n  static validatePublicKey(key: PublicKey): { valid: boolean; error?: string } {\n    try {\n      // Test key operations\n      const point = key.point\n      const der = key.toDER()\n\n      // Verify point is on curve\n      if (!point.isOnCurve()) {\n        return { valid: false, error: 'Public key point is not on the secp256k1 curve' }\n      }\n\n      return { valid: true }\n\n    } catch (error: any) {\n      return { valid: false, error: `Public key validation failed: ${error.message}` }\n    }\n  }\n\n  static safeECDHKeyExchange(\n    privateKey: PrivateKey,\n    publicKey: PublicKey\n  ): { success: boolean; sharedSecret?: number[]; error?: string } {\n    try {\n      // Validate inputs first\n      const privateValidation = this.validatePrivateKey(privateKey)\n      if (!privateValidation.valid) {\n        return { success: false, error: `Invalid private key: ${privateValidation.error}` }\n      }\n\n      const publicValidation = this.validatePublicKey(publicKey)\n      if (!publicValidation.valid) {\n        return { success: false, error: `Invalid public key: ${publicValidation.error}` }\n      }\n\n      // Perform ECDH\n      const sharedSecret = privateKey.deriveSharedSecret(publicKey)\n\n      // Validate the result\n      if (!sharedSecret || sharedSecret.length !== 32) {\n        return { success: false, error: 'ECDH produced invalid shared secret' }\n      }\n\n      return { success: true, sharedSecret }\n\n    } catch (error: any) {\n      return { success: false, error: `ECDH key exchange failed: ${error.message}` }\n    }\n  }\n\n  static safeSymmetricEncryption(\n    data: string,\n    key?: SymmetricKey\n  ): { success: boolean; encrypted?: number[]; key?: SymmetricKey; error?: string } {\n    try {\n      const encryptionKey = key || SymmetricKey.fromRandom()\n\n      if (!data || data.length === 0) {\n        return { success: false, error: 'Data cannot be empty' }\n      }\n\n      const encrypted = encryptionKey.encrypt(data) as number[]\n\n      if (!encrypted || encrypted.length === 0) {\n        return { success: false, error: 'Encryption produced empty result' }\n      }\n\n      // Verify we can decrypt\n      const decrypted = encryptionKey.decrypt(encrypted, 'utf8') as string\n      if (decrypted !== data) {\n        return { success: false, error: 'Encryption verification failed - decrypt mismatch' }\n      }\n\n      return { success: true, encrypted, key: encryptionKey }\n\n    } catch (error: any) {\n      return { success: false, error: `Symmetric encryption failed: ${error.message}` }\n    }\n  }\n}\n\n// Example usage with comprehensive error handling\nasync function demonstrateCryptographicErrorHandling() {\n  console.log('=== Cryptographic Error Handling Demo ===')\n\n  try {\n    // Test private key validation\n    const privateKey = PrivateKey.fromRandom()\n    const validation = CryptographicErrorHandler.validatePrivateKey(privateKey)\n\n    if (!validation.valid) {\n      console.error('Private key validation failed:', validation.error)\n      return\n    }\n\n    console.log('Private key validation: PASSED')\n\n    // Test ECDH with error handling\n    const otherPrivateKey = PrivateKey.fromRandom()\n    const otherPublicKey = otherPrivateKey.toPublicKey()\n\n    const ecdhResult = CryptographicErrorHandler.safeECDHKeyExchange(privateKey, otherPublicKey)\n\n    if (!ecdhResult.success) {\n      console.error('ECDH failed:', ecdhResult.error)\n      return\n    }\n\n    console.log('ECDH key exchange: PASSED')\n\n    // Test symmetric encryption with error handling\n    const testData = 'Sensitive data for encryption testing'\n    const encryptionResult = CryptographicErrorHandler.safeSymmetricEncryption(testData)\n\n    if (!encryptionResult.success) {\n      console.error('Symmetric encryption failed:', encryptionResult.error)\n      return\n    }\n\n    console.log('Symmetric encryption: PASSED')\n    console.log('All cryptographic operations completed successfully')\n\n  } catch (error) {\n    console.error('Unexpected error in cryptographic demo:', error)\n  }\n}\n</code></pre>"},{"location":"tutorials/error-handling/#production-error-monitoring","title":"Production Error Monitoring","text":""},{"location":"tutorials/error-handling/#comprehensive-error-logging","title":"Comprehensive Error Logging","text":"<pre><code>interface ErrorLogEntry {\n  timestamp: Date\n  category: ErrorCategory\n  operation: string\n  message: string\n  stack?: string\n  context?: any\n  retryCount?: number\n  resolved?: boolean\n}\n\nclass ErrorLogger {\n  private logs: ErrorLogEntry[] = []\n  private maxLogs: number = 1000\n\n  log(\n    category: ErrorCategory,\n    operation: string,\n    error: Error,\n    context?: any,\n    retryCount?: number\n  ): void {\n    const entry: ErrorLogEntry = {\n      timestamp: new Date(),\n      category,\n      operation,\n      message: error.message,\n      stack: error.stack,\n      context,\n      retryCount,\n      resolved: false\n    }\n\n    this.logs.push(entry)\n\n    // Keep only recent logs\n    if (this.logs.length &gt; this.maxLogs) {\n      this.logs = this.logs.slice(-this.maxLogs)\n    }\n\n    // Console output for development\n    console.error(`[${category.toUpperCase()}] ${operation}: ${error.message}`)\n\n    if (context) {\n      console.error('Context:', context)\n    }\n  }\n\n  markResolved(operation: string, timestamp: Date): void {\n    const entry = this.logs.find(\n      log =&gt; log.operation === operation &amp;&amp; \n             Math.abs(log.timestamp.getTime() - timestamp.getTime()) &lt; 1000\n    )\n\n    if (entry) {\n      entry.resolved = true\n    }\n  }\n\n  getErrorSummary(): { [key in ErrorCategory]: number } {\n    const summary = {} as { [key in ErrorCategory]: number }\n\n    for (const category of Object.values(ErrorCategory)) {\n      summary[category] = this.logs.filter(\n        log =&gt; log.category === category &amp;&amp; !log.resolved\n      ).length\n    }\n\n    return summary\n  }\n\n  getRecentErrors(minutes: number = 60): ErrorLogEntry[] {\n    const cutoff = new Date(Date.now() - minutes * 60 * 1000)\n    return this.logs.filter(log =&gt; log.timestamp &gt; cutoff)\n  }\n\n  exportLogs(): string {\n    return JSON.stringify(this.logs, null, 2)\n  }\n}\n\n// Global error logger instance\nconst errorLogger = new ErrorLogger()\n</code></pre>"},{"location":"tutorials/error-handling/#user-friendly-error-messages","title":"User-Friendly Error Messages","text":"<pre><code>class UserErrorHandler {\n  private errorLogger: ErrorLogger\n\n  constructor() {\n    this.errorLogger = errorLogger\n  }\n\n  getUserFriendlyMessage(error: Error, operation: string): string {\n    const categorized = categorizeError(error)\n    this.errorLogger.log(categorized.category, operation, error)\n\n    switch (categorized.category) {\n      case ErrorCategory.INSUFFICIENT_FUNDS:\n        return 'Insufficient funds available. Please check your wallet balance and try again with a smaller amount.'\n\n      case ErrorCategory.AUTHENTICATION:\n        return 'Wallet authentication required. Please unlock your wallet and try again.'\n\n      case ErrorCategory.NETWORK:\n        if (error.message.includes('no header should have returned false')) {\n          return 'Wallet is synchronizing with the network. Please wait a moment and try again.'\n        }\n        return 'Network connection issue. Please check your internet connection and try again.'\n\n      case ErrorCategory.VALIDATION:\n        return 'Transaction validation failed. Please check your transaction details and try again.'\n\n      case ErrorCategory.SCRIPT:\n        return 'Transaction script error. Please verify your transaction parameters.'\n\n      case ErrorCategory.CRYPTOGRAPHIC:\n        return 'Cryptographic operation failed. Please try again or contact support if the issue persists.'\n\n      default:\n        return 'An unexpected error occurred. Please try again or contact support if the issue persists.'\n    }\n  }\n\n  async handleOperationWithUserFeedback&lt;T&gt;(\n    operation: () =&gt; Promise&lt;T&gt;,\n    operationName: string,\n    onProgress?: (message: string) =&gt; void,\n    onError?: (userMessage: string, technicalError: Error) =&gt; void\n  ): Promise&lt;T&gt; {\n    const retryManager = new RetryManager()\n\n    try {\n      return await retryManager.executeWithRetry(async () =&gt; {\n        if (onProgress) {\n          onProgress(`Executing ${operationName}...`)\n        }\n\n        return await operation()\n\n      }, {\n        maxAttempts: 3,\n        baseDelay: 2000\n      })\n\n    } catch (error: any) {\n      const userMessage = this.getUserFriendlyMessage(error, operationName)\n\n      if (onError) {\n        onError(userMessage, error)\n      }\n\n      throw new Error(userMessage)\n    }\n  }\n}\n\n// Example usage in a user interface\nasync function demonstrateUserErrorHandling() {\n  const userErrorHandler = new UserErrorHandler()\n  const wallet = new WalletClient('auto', 'localhost')\n\n  try {\n    await userErrorHandler.handleOperationWithUserFeedback(\n      async () =&gt; {\n        return await wallet.createAction({\n          description: 'User-friendly error handling demo',\n          outputs: [{\n            satoshis: 100,\n            lockingScript: '006a0f5573657220667269656e646c79', // \"User friendly\"\n            outputDescription: 'User error demo'\n          }]\n        })\n      },\n      'Create Transaction',\n      (message) =&gt; console.log('Progress:', message),\n      (userMessage, technicalError) =&gt; {\n        console.log('User Message:', userMessage)\n        console.log('Technical Details:', technicalError.message)\n      }\n    )\n\n    console.log('Transaction completed successfully!')\n\n  } catch (error) {\n    console.log('Operation failed with user-friendly error:', error.message)\n  }\n}\n</code></pre>"},{"location":"tutorials/error-handling/#testing-error-scenarios","title":"Testing Error Scenarios","text":""},{"location":"tutorials/error-handling/#error-simulation-for-testing","title":"Error Simulation for Testing","text":"<pre><code>class ErrorSimulator {\n  private shouldSimulateError: boolean = false\n  private errorType: ErrorCategory = ErrorCategory.NETWORK\n  private errorMessage: string = 'Simulated error'\n\n  enableErrorSimulation(type: ErrorCategory, message: string): void {\n    this.shouldSimulateError = true\n    this.errorType = type\n    this.errorMessage = message\n  }\n\n  disableErrorSimulation(): void {\n    this.shouldSimulateError = false\n  }\n\n  checkAndThrowSimulatedError(operation: string): void {\n    if (this.shouldSimulateError) {\n      console.log(`Simulating ${this.errorType} error for operation: ${operation}`)\n      throw new Error(this.errorMessage)\n    }\n  }\n\n  async simulateNetworkDelay(minMs: number = 100, maxMs: number = 1000): Promise&lt;void&gt; {\n    const delay = Math.random() * (maxMs - minMs) + minMs\n    await new Promise(resolve =&gt; setTimeout(resolve, delay))\n  }\n}\n\n// Test suite for error handling\nclass ErrorHandlingTestSuite {\n  private simulator: ErrorSimulator\n  private userErrorHandler: UserErrorHandler\n\n  constructor() {\n    this.simulator = new ErrorSimulator()\n    this.userErrorHandler = new UserErrorHandler()\n  }\n\n  async testInsufficientFundsHandling(): Promise&lt;boolean&gt; {\n    console.log('Testing insufficient funds error handling...')\n\n    this.simulator.enableErrorSimulation(\n      ErrorCategory.INSUFFICIENT_FUNDS,\n      'Insufficient funds: 101 more satoshis are needed'\n    )\n\n    try {\n      await this.userErrorHandler.handleOperationWithUserFeedback(\n        async () =&gt; {\n          this.simulator.checkAndThrowSimulatedError('createAction')\n          return { txid: 'simulated-success' }\n        },\n        'Test Transaction'\n      )\n\n      return false // Should have thrown\n\n    } catch (error: any) {\n      const isCorrectMessage = error.message.includes('Insufficient funds available')\n      console.log('Insufficient funds test:', isCorrectMessage ? 'PASSED' : 'FAILED')\n      return isCorrectMessage\n\n    } finally {\n      this.simulator.disableErrorSimulation()\n    }\n  }\n\n  async testNetworkErrorHandling(): Promise&lt;boolean&gt; {\n    console.log('Testing network error handling...')\n\n    this.simulator.enableErrorSimulation(\n      ErrorCategory.NETWORK,\n      'RPC Error: no header should have returned false'\n    )\n\n    try {\n      await this.userErrorHandler.handleOperationWithUserFeedback(\n        async () =&gt; {\n          this.simulator.checkAndThrowSimulatedError('createAction')\n          return { txid: 'simulated-success' }\n        },\n        'Test Transaction'\n      )\n\n      return false // Should have thrown\n\n    } catch (error: any) {\n      const isCorrectMessage = error.message.includes('synchronizing with the network')\n      console.log('Network error test:', isCorrectMessage ? 'PASSED' : 'FAILED')\n      return isCorrectMessage\n\n    } finally {\n      this.simulator.disableErrorSimulation()\n    }\n  }\n\n  async runAllTests(): Promise&lt;void&gt; {\n    console.log('=== Error Handling Test Suite ===')\n\n    const tests = [\n      this.testInsufficientFundsHandling(),\n      this.testNetworkErrorHandling()\n    ]\n\n    const results = await Promise.all(tests)\n    const passedTests = results.filter(result =&gt; result).length\n\n    console.log(`\\nTest Results: ${passedTests}/${results.length} tests passed`)\n\n    if (passedTests === results.length) {\n      console.log('All error handling tests PASSED! \u2705')\n    } else {\n      console.log('Some error handling tests FAILED! \u274c')\n    }\n  }\n}\n</code></pre>"},{"location":"tutorials/error-handling/#best-practices-summary","title":"Best Practices Summary","text":""},{"location":"tutorials/error-handling/#production-ready-error-handling-checklist","title":"Production-Ready Error Handling Checklist","text":"<pre><code>// Production error handling implementation example\nclass ProductionWalletService {\n  private wallet: WalletClient\n  private retryManager: RetryManager\n  private errorLogger: ErrorLogger\n  private userErrorHandler: UserErrorHandler\n\n  constructor() {\n    this.wallet = new WalletClient('auto', 'localhost')\n    this.retryManager = new RetryManager()\n    this.errorLogger = new ErrorLogger()\n    this.userErrorHandler = new UserErrorHandler()\n  }\n\n  async createTransaction(\n    description: string,\n    outputs: any[],\n    options?: any\n  ): Promise&lt;{ success: boolean; txid?: string; userMessage?: string }&gt; {\n    const operation = 'createTransaction'\n\n    try {\n      const result = await this.userErrorHandler.handleOperationWithUserFeedback(\n        async () =&gt; {\n          return await this.retryManager.executeWithRetry(async () =&gt; {\n            // Ensure authentication\n            const { authenticated } = await this.wallet.isAuthenticated()\n            if (!authenticated) {\n              await this.wallet.waitForAuthentication()\n            }\n\n            // Create transaction\n            return await this.wallet.createAction({\n              description,\n              outputs,\n              ...options\n            })\n          })\n        },\n        operation\n      )\n\n      return {\n        success: true,\n        txid: result.txid\n      }\n\n    } catch (error: any) {\n      const userMessage = this.userErrorHandler.getUserFriendlyMessage(error, operation)\n\n      return {\n        success: false,\n        userMessage\n      }\n    }\n  }\n\n  getHealthStatus(): {\n    status: 'healthy' | 'degraded' | 'unhealthy'\n    errors: { [key in ErrorCategory]: number }\n    uptime: number\n  } {\n    const errors = this.errorLogger.getErrorSummary()\n    const totalErrors = Object.values(errors).reduce((sum, count) =&gt; sum + count, 0)\n\n    let status: 'healthy' | 'degraded' | 'unhealthy'\n\n    if (totalErrors === 0) {\n      status = 'healthy'\n    } else if (totalErrors &lt; 5) {\n      status = 'degraded'\n    } else {\n      status = 'unhealthy'\n    }\n\n    return {\n      status,\n      errors,\n      uptime: process.uptime()\n    }\n  }\n}\n</code></pre>"},{"location":"tutorials/error-handling/#troubleshooting-common-issues","title":"Troubleshooting Common Issues","text":""},{"location":"tutorials/error-handling/#quick-diagnostic-guide","title":"Quick Diagnostic Guide","text":"<pre><code>async function diagnoseCommonIssues(): Promise&lt;void&gt; {\n  console.log('=== BSV SDK Diagnostic Tool ===')\n\n  const wallet = new WalletClient('auto', 'localhost')\n\n  // Test 1: Wallet Connection\n  try {\n    console.log('1. Testing wallet connection...')\n    const { authenticated } = await wallet.isAuthenticated()\n    console.log(`   Wallet authenticated: ${authenticated}`)\n\n    if (!authenticated) {\n      console.log('   \u26a0\ufe0f  Wallet not authenticated - this may cause transaction failures')\n    } else {\n      console.log('   \u2705 Wallet connection OK')\n    }\n  } catch (error) {\n    console.log(`   \u274c Wallet connection failed: ${error.message}`)\n  }\n\n  // Test 2: UTXO Availability\n  try {\n    console.log('2. Checking UTXO availability...')\n    const { outputs, totalValue } = await wallet.listOutputs({ limit: 10 })\n    const spendable = outputs.filter(o =&gt; o.spendable)\n\n    console.log(`   Total outputs: ${outputs.length}`)\n    console.log(`   Spendable outputs: ${spendable.length}`)\n    console.log(`   Total value: ${totalValue} satoshis`)\n\n    if (spendable.length === 0) {\n      console.log('   \u26a0\ufe0f  No spendable UTXOs available')\n    } else if (totalValue &lt; 1000) {\n      console.log('   \u26a0\ufe0f  Low balance - may cause insufficient funds errors')\n    } else {\n      console.log('   \u2705 UTXO availability OK')\n    }\n  } catch (error) {\n    console.log(`   \u274c UTXO check failed: ${error.message}`)\n  }\n\n  // Test 3: Simple Transaction\n  try {\n    console.log('3. Testing simple transaction creation...')\n    const result = await wallet.createAction({\n      description: 'Diagnostic test transaction',\n      outputs: [{\n        satoshis: 100,\n        lockingScript: '006a0a4469616720746573742074786e', // \"Diag test txn\"\n        outputDescription: 'Diagnostic test'\n      }]\n    })\n\n    console.log(`   \u2705 Transaction created successfully: ${result.txid}`)\n\n  } catch (error: any) {\n    console.log(`   \u274c Transaction creation failed: ${error.message}`)\n\n    if (error.message.includes('Insufficient funds')) {\n      console.log('   \ud83d\udca1 Try reducing the transaction amount or funding your wallet')\n    } else if (error.message.includes('no header should have returned false')) {\n      console.log('   \ud83d\udca1 Try restarting your wallet or waiting for synchronization')\n    } else if (error.message.includes('not authenticated')) {\n      console.log('   \ud83d\udca1 Ensure your wallet is unlocked and authenticated')\n    }\n  }\n\n  console.log('\\n=== Diagnostic Complete ===')\n}\n</code></pre>"},{"location":"tutorials/error-handling/#conclusion","title":"Conclusion","text":"<p>You've now mastered comprehensive error handling for the BSV TypeScript SDK. You can:</p> <ul> <li>Categorize and handle different types of errors appropriately</li> <li>Implement robust retry mechanisms with exponential backoff</li> <li>Handle wallet-specific errors and authentication issues</li> <li>Manage network failures and chain tracker problems</li> <li>Validate cryptographic operations and handle edge cases</li> <li>Build production-ready error monitoring and logging systems</li> <li>Create user-friendly error messages and recovery strategies</li> <li>Test error scenarios systematically</li> </ul> <p>These patterns enable you to build resilient Bitcoin applications that gracefully handle failures and provide excellent user experiences even when things go wrong.</p>"},{"location":"tutorials/error-handling/#next-steps","title":"Next Steps","text":"<ul> <li>Review the Large Transactions Guide for efficiency patterns</li> <li>Check out Security Best Practices for comprehensive security</li> <li>Explore specific error handling in other tutorials for your use case</li> </ul>"},{"location":"tutorials/error-handling/#additional-resources","title":"Additional Resources","text":"<ul> <li>WalletClient API Reference</li> <li>BSV Blockchain Documentation</li> <li>Error Handling Best Practices</li> </ul>"},{"location":"tutorials/first-transaction-low-level/","title":"Your First BSV Transaction (Low level)","text":"<p>Duration: 15 minutes Prerequisites: Node.js, basic TypeScript knowledge  </p>"},{"location":"tutorials/first-transaction-low-level/#learning-goals","title":"Learning Goals","text":"<ul> <li>Install and configure the BSV TypeScript SDK</li> <li>Create a simple P2PKH transaction</li> <li>Understand BSV transaction anatomy</li> </ul>"},{"location":"tutorials/first-transaction-low-level/#introduction","title":"Introduction","text":"<p>In this tutorial, you'll learn how to create your first Bitcoin SV transaction using the TypeScript SDK. By the end, you'll understand the basic components of a BSV transaction and how to construct, sign, and broadcast one.</p>"},{"location":"tutorials/first-transaction-low-level/#step-1-setting-up-your-environment","title":"Step 1: Setting Up Your Environment","text":"<p>First, create a new Node.js project and install the BSV SDK:</p> <pre><code># Create a new directory for your project\nmkdir my-first-bsv-tx\ncd my-first-bsv-tx\n\n# Initialize a new Node.js project\nnpm init -y\n\n# Install TypeScript and ts-node (TypeScript execution engine)\nnpm install typescript ts-node @types/node --save-dev\n# ts-node allows you to run TypeScript files directly without compiling them first\n\n# Install the BSV SDK\nnpm install @bsv/sdk\n</code></pre> <p>Create a basic TypeScript configuration file (<code>tsconfig.json</code>):</p> <pre><code>{\n  \"compilerOptions\": {\n    \"target\": \"es2020\",\n    \"module\": \"commonjs\",\n    \"esModuleInterop\": true,\n    \"strict\": true,\n    \"outDir\": \"./dist\"\n  }\n}\n</code></pre>"},{"location":"tutorials/first-transaction-low-level/#step-2-understanding-transaction-components","title":"Step 2: Understanding Transaction Components","text":"<p>Before we write any code, let's understand the basic components of a Bitcoin transaction:</p> <ul> <li>Inputs: References to previous transaction outputs that you're spending</li> <li>Outputs: New UTXOs (Unspent Transaction Outputs) that define who receives the bitcoins</li> <li>Locking Scripts: Scripts that determine the conditions for spending outputs</li> <li>Unlocking Scripts: Scripts that satisfy the conditions in locking scripts</li> </ul>"},{"location":"tutorials/first-transaction-low-level/#additional-resources","title":"Additional Resources","text":"<p>For a deeper understanding of Bitcoin transactions, check out these official resources:</p> <ul> <li>BSV Wiki: Bitcoin Transaction - Comprehensive explanation of transaction structure</li> <li>BSV Wiki: Script - Detailed information about Bitcoin Script language</li> <li>Bitcoin Whitepaper - Section 5 covers the original design of transactions</li> <li>BSV Academy: Transactions Course - In-depth course on Bitcoin transactions</li> </ul>"},{"location":"tutorials/first-transaction-low-level/#step-3-creating-your-first-transaction","title":"Step 3: Creating Your First Transaction","text":"<p>Create a new file called <code>first-transaction.ts</code>:</p> <pre><code>import { PrivateKey, P2PKH, Transaction } from '@bsv/sdk'\n\nasync function createTransaction() {\n  // Create a private key (in production, you'd use proper key management)\n  const privateKey = PrivateKey.fromRandom()\n  console.log(`Private key WIF: ${privateKey.toWif()}`)\n\n  // Derive the public key and address\n  const address = privateKey.toAddress()\n  console.log(`Address: ${address.toString()}`)\n\n  // For a real transaction, you would have a source UTXO\n  // For this example, we'll create a transaction without inputs (cannot be broadcast)\n  const tx = new Transaction()\n\n  // Add an output\n  tx.addOutput({\n    lockingScript: new P2PKH().lock(address),\n    satoshis: 100\n  })\n\n  // Serialize the transaction\n  const txHex = tx.toHex() // Use toHex() instead of toString()\n  console.log(`Transaction (hex): ${txHex}`)\n\n  // Get transaction ID as a hex string\n  const txid = Buffer.from(tx.id()).toString('hex') // Convert the byte array to hex string\n  console.log(`Transaction ID: ${txid}`)\n\n  // Display the transaction structure\n  console.log('\\nTransaction Structure:')\n  console.log(`Version: ${tx.version}`)\n  console.log(`Input Count: ${tx.inputs.length}`)\n  console.log(`Output Count: ${tx.outputs.length}`)\n\n  for (let i = 0; i &lt; tx.outputs.length; i++) {\n    const output = tx.outputs[i]\n    console.log(`\\nOutput #${i}:`)\n    console.log(`  Satoshis: ${output.satoshis}`)\n    console.log(`  Locking Script: ${output.lockingScript.toHex()}`)\n    console.log(`  Locking Script (ASM): ${output.lockingScript.toASM()}`)\n  }\n}\n\ncreateTransaction().catch(console.error)\n</code></pre>"},{"location":"tutorials/first-transaction-low-level/#step-4-run-your-code","title":"Step 4: Run Your Code","text":"<p>Execute your code with the following command:</p> <pre><code>npx ts-node first-transaction.ts\n</code></pre> <p>You should see output showing your private key, address, and transaction details.</p>"},{"location":"tutorials/first-transaction-low-level/#step-5-next-steps-for-real-transactions","title":"Step 5: Next Steps for Real Transactions","text":"<p>The transaction we created in the previous step doesn't have any inputs, so it can't be broadcast to the network. It serves as a conceptual introduction to transaction structure.</p> <p>In the next tutorial, \"Working with Testnet Transactions (Low-Level)\", you'll learn how to:</p> <ol> <li>Create a wallet specifically for the BSV testnet</li> <li>Obtain free testnet coins from a faucet</li> <li>Create transactions with real inputs and outputs</li> <li>Calculate transaction fees automatically</li> <li>Sign and broadcast real transactions to the testnet network</li> </ol>"},{"location":"tutorials/first-transaction-low-level/#preview-transaction-structure-for-real-transactions","title":"Preview: Transaction Structure for Real Transactions","text":"<p>Here's a simplified preview of what a complete transaction looks like. Don't worry about understanding all the details yet - this is just to give you a sense of the structure you'll work with in the next tutorial:</p> <pre><code>// A complete transaction typically follows this structure:\nconst tx = new Transaction()\n\n// Add an input (where the money comes from)\ntx.addInput({\n  sourceTransaction: /* previous transaction containing your funds */,\n  sourceOutputIndex: /* which output from that transaction */,\n  unlockingScriptTemplate: /* script to unlock those funds */\n})\n\n// Add an output (where the money goes)\ntx.addOutput({\n  lockingScript: /* script that locks funds to recipient */,\n  satoshis: /* amount to send */\n})\n\n// Add change output (remaining funds returned to you)\ntx.addOutput({\n  lockingScript: /* script that locks funds to you */,\n  change: true // Automatically handles change amount\n})\n\n// Calculate fee and sign\nawait tx.fee()\nawait tx.sign()\n\n// Broadcast to the network\nconst result = await tx.broadcast()\n</code></pre>"},{"location":"tutorials/first-transaction-low-level/#understanding-transaction-fees","title":"Understanding Transaction Fees","text":"<p>Bitcoin transactions require fees to be included in a block by miners. The BSV SDK simplifies fee calculation with the <code>fee()</code> method, which:</p> <ul> <li>Calculates the appropriate fee based on transaction size</li> <li>Works with the <code>change: true</code> parameter to automatically handle change outputs</li> </ul> <p>You'll get hands-on experience with transaction fees in the testnet tutorial.</p>"},{"location":"tutorials/first-transaction-low-level/#conclusion","title":"Conclusion","text":"<p>Congratulations! You've learned the basics of creating a BSV transaction using the TypeScript SDK. In this tutorial, you've:</p> <ul> <li>Set up your development environment</li> <li>Learned about transaction components</li> <li>Created a simple transaction</li> <li>Understood how to structure a complete transaction</li> </ul>"},{"location":"tutorials/first-transaction-low-level/#next-steps","title":"Next Steps","text":"<ul> <li>Ready to try real transactions? Continue with Working with Testnet Transactions</li> <li>Learn about Key Management and Cryptography</li> <li>Explore how to Broadcast Transactions with ARC</li> </ul>"},{"location":"tutorials/first-transaction-low-level/#additional-resources_1","title":"Additional Resources","text":"<ul> <li>BSV Transaction Reference</li> <li>Script Reference</li> <li>Bitcoin Transaction Explorer - To view your transactions on the blockchain</li> </ul>"},{"location":"tutorials/first-transaction/","title":"Your First BSV Transaction","text":"<p>Duration: 15 minutes Prerequisites: Node.js, basic TypeScript knowledge  </p>"},{"location":"tutorials/first-transaction/#learning-goals","title":"Learning Goals","text":"<ul> <li>Install and configure the BSV TypeScript SDK</li> <li>Create a simple transaction using <code>WalletClient</code> interface on the mainnet network. This approach makes it easy to build transactions by abstracting away many of the low-level details. By the end, you'll understand the basic components of a BSV transaction and how to construct, sign, and broadcast one on the BSV blockchain.</li> </ul> <p>\ud83d\udcda Related Concepts: Before starting, you may want to review Transaction Structure and Wallet Integration to understand the fundamentals.</p>"},{"location":"tutorials/first-transaction/#introduction","title":"Introduction","text":"<p>In this tutorial, you'll learn how to create your first Bitcoin SV transactions using the TypeScript SDK's <code>WalletClient</code> interface on the mainnet network. This approach makes it easy to build transactions by abstracting away many of the low-level details. By the end, you'll understand the basic components of a BSV transaction and how to construct, sign, and broadcast one on the BSV blockchain.</p> <p>\ud83d\udca1 Try It Interactive: Want to experiment with the code examples from this tutorial? Check out our Interactive BSV Coding Environment where you can run SDK code directly in your browser without any setup!</p>"},{"location":"tutorials/first-transaction/#precondition","title":"Precondition","text":"<p>Install a BRC-100 compliant wallet such as the MetaNet Desktop Wallet. When you install it, you'll receive a small amount of funds to play with.</p>"},{"location":"tutorials/first-transaction/#step-1-setting-up-your-environment","title":"Step 1: Setting Up Your Environment","text":"<p>First, create a new Node.js project and install the BSV SDK:</p> <pre><code># Create a new directory for your project\nmkdir my-first-bsv-tx\ncd my-first-bsv-tx\n\n# Initialize a new Node.js project\nnpm init -y\n\n# Install TypeScript and ts-node (TypeScript execution engine)\nnpm install typescript ts-node @types/node --save-dev\n# ts-node allows you to run TypeScript files directly without compiling them first\n\n# Install the BSV SDK\nnpm install @bsv/sdk\n</code></pre> <p>Create a basic TypeScript configuration file (<code>tsconfig.json</code>):</p> <pre><code>{\n  \"compilerOptions\": {\n    \"target\": \"es2020\",\n    \"module\": \"commonjs\",\n    \"esModuleInterop\": true,\n    \"strict\": true,\n    \"outDir\": \"./dist\"\n  }\n}\n</code></pre>"},{"location":"tutorials/first-transaction/#step-2-understanding-transaction-components","title":"Step 2: Understanding Transaction Components","text":"<p>Before we write any code, let's understand the basic components of a Bitcoin transaction:</p> <ul> <li>Inputs: References to previous transaction outputs that you're spending</li> <li>Outputs: New UTXOs (Unspent Transaction Outputs) that define who receives the bitcoins</li> <li>Locking Scripts: Scripts that determine the conditions for spending outputs</li> <li>Unlocking Scripts: Scripts that satisfy the conditions in locking scripts</li> </ul>"},{"location":"tutorials/first-transaction/#additional-resources","title":"Additional Resources","text":"<p>For a deeper understanding of Bitcoin transactions, check out these resources:</p> <ul> <li>Bitcoin SV Protocol Specifications - Official Bitcoin SV protocol specifications</li> <li>WhatsOnChain Explorer - Standard block explorer for viewing BSV transactions</li> <li>Bitcoin Developer Reference - Comprehensive explanation of transaction structure</li> </ul>"},{"location":"tutorials/first-transaction/#step-3-your-first-transactions-3-simple-steps","title":"Step 3: Your First Transactions - 3 Simple Steps","text":"<p>Now let's create your first BSV transactions using three clean, focused steps. Each step builds on the previous one, showing you the core workflow of BSV development.</p> <p>We'll create three separate files to keep things organized and clear:</p>"},{"location":"tutorials/first-transaction/#example-1-create-a-simple-transaction","title":"Example 1: Create a Simple Transaction","text":"<p>What you'll do: Create your first transaction that stores a simple message on the BSV blockchain. This introduces you to the basic <code>createAction()</code> method and shows how data can be permanently stored on-chain.</p> <p>Create a file called <code>step1-simple-transaction.ts</code>:</p> <pre><code>import { WalletClient, Script } from '@bsv/sdk'\n\nasync function createSimpleTransaction() {\n  // Connect to user's wallet\n  const wallet = new WalletClient('auto', 'localhost')\n\n  // Create a simple transaction with a data output\n  const response = await wallet.createAction({\n    description: 'My first BSV transaction',\n    outputs: [{\n      satoshis: 100,\n      lockingScript: Script.fromASM(`OP_RETURN ${Buffer.from('Hello BSV!').toString('hex')}`).toHex(),\n      outputDescription: 'My first data output'\n    }]\n  })\n\n  console.log('Transaction created:', response)\n  if (response.txid) {\n    console.log(`View on WhatsOnChain: https://whatsonchain.com/tx/${response.txid}`)\n  }\n\n  return response\n}\n\n// Run the function\ncreateSimpleTransaction().catch(console.error)\n</code></pre> <p>Run it as follows:</p> <pre><code># Run the TypeScript file directly\nnpx ts-node step1-simple-transaction.ts\n</code></pre> <p>What's happening here:</p> <ul> <li>We connect to your BRC-100 wallet (like MetaNet Desktop)</li> <li>Create a transaction with one output containing \"Hello BSV!\" data</li> <li>The wallet automatically handles inputs, change, and fees</li> <li>We get a transaction ID to view on the blockchain explorer</li> </ul>"},{"location":"tutorials/first-transaction/#example-2-create-and-store-a-token","title":"Example 2: Create and Store a Token","text":"<p>What you'll do: Create a spendable token and organize it using wallet baskets. This shows you how to create UTXOs that can be spent later and how to use the wallet's organizational features.</p> <p>Create a file called <code>step2-create-token.ts</code>:</p> <pre><code>import { WalletClient, Script } from '@bsv/sdk'\n\nasync function createToken() {\n  // Connect to user's wallet\n  const wallet = new WalletClient('auto', 'localhost')\n\n  // Create a token and store it in a specific basket\n  const response = await wallet.createAction({\n    description: 'Create my first token',\n    outputs: [{\n      satoshis: 1,\n      lockingScript: Script.fromASM('OP_NOP').toHex(),\n      basket: 'my-tokens',\n      outputDescription: 'My first token'\n    }]\n  })\n\n  console.log('Token created:', response)\n  if (response.txid) {\n    console.log(`Token transaction: https://whatsonchain.com/tx/${response.txid}`)\n  }\n\n  return response\n}\n\n// Run the function\ncreateToken().catch(console.error)\n</code></pre> <p>Run it as follows:</p> <pre><code># Run the TypeScript file directly\nnpx ts-node step2-create-token.ts\n</code></pre> <p>What's happening here:</p> <ul> <li>We create a minimal token (1 satoshi with OP_NOP script)</li> <li>Store it in a wallet basket called 'my-tokens' for organization</li> <li>This creates a spendable output we can use later</li> </ul>"},{"location":"tutorials/first-transaction/#example-3-list-and-spend-your-token","title":"Example 3: List and Spend Your Token","text":"<p>What you'll do: Retrieve your stored token (created in the previous example) and spend it in a new transaction. This demonstrates the complete UTXO lifecycle and shows how to work with transaction inputs using the BEEF format.</p> <p>Create a file called <code>step3-spend-token.ts</code>:</p> <pre><code>import { WalletClient, Script } from '@bsv/sdk'\n\nasync function spendToken() {\n  // Connect to user's wallet\n  const wallet = new WalletClient('auto', 'localhost')\n\n  // First, list our tokens\n  const tokenList = await wallet.listOutputs({\n    basket: 'my-tokens',\n    include: 'entire transactions'\n  })\n\n  console.log('Available tokens:', tokenList.outputs.length)\n\n  let response;\n  if (tokenList.outputs.length &gt; 0) {\n    // Spend the first token\n    response = await wallet.createAction({\n      description: 'Spend my first token',\n      inputBEEF: tokenList.BEEF,\n      inputs: [{\n        outpoint: tokenList.outputs[0].outpoint,\n        unlockingScript: Script.fromASM('OP_TRUE').toHex(),\n        inputDescription: 'My token being spent'\n      }]\n    })\n\n    console.log('Token spent:', response)\n    if (response.txid) {\n      console.log(`Spending transaction: https://whatsonchain.com/tx/${response.txid}`)\n    }\n  } else {\n    console.log('No tokens available to spend. Run step2-create-token.ts first!')\n    response = null;\n  }\n\n  return response\n}\n\n// Run the function\nspendToken().catch(console.error)\n</code></pre> <p>Run it as follows:</p> <pre><code># Run the TypeScript file directly\nnpx ts-node step3-spend-token.ts\n</code></pre> <p>What's happening here:</p> <ul> <li>We list tokens from our 'my-tokens' basket</li> <li>Spend the first available token by providing its outpoint</li> <li>Create a new output with proof that we spent the token</li> <li>The BEEF (Blockchain Exchange Format) provides the transaction history</li> </ul>"},{"location":"tutorials/first-transaction/#what-youve-learned","title":"What You've Learned","text":"<p>Congratulations! You've successfully created your first BSV transactions. Here's what you accomplished:</p>"},{"location":"tutorials/first-transaction/#core-concepts-mastered","title":"Core Concepts Mastered","text":"<ol> <li>WalletClient Usage: Connected to your BRC-100 wallet and created transactions</li> <li>Script Construction: Used <code>Script.fromASM()</code> to create clean, readable Bitcoin scripts</li> <li>Transaction Outputs: Created both data storage and spendable token outputs</li> <li>Wallet Baskets: Organized your tokens using the basket system</li> <li>UTXO Management: Listed and spent existing outputs using BEEF format</li> </ol>"},{"location":"tutorials/first-transaction/#key-walletclient-methods","title":"Key WalletClient Methods","text":"<ul> <li><code>createAction()</code>: Creates transactions with specified outputs and inputs</li> <li><code>listOutputs()</code>: Retrieves spendable outputs from wallet baskets</li> <li>The wallet automatically handles signing, fees, and broadcasting</li> </ul>"},{"location":"tutorials/first-transaction/#script-types-you-used","title":"Script Types You Used","text":"<ul> <li><code>OP_RETURN \"data\"</code>: Store arbitrary data on the blockchain</li> <li><code>OP_NOP</code>: Create simple tokens that can be spent later  </li> <li><code>OP_TRUE</code>: Unlock scripts that always validate (for simple spending)</li> </ul>"},{"location":"tutorials/first-transaction/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about Key Management and Cryptography</li> <li>Prefer lower-level control? Check out First Transaction (Low-level API)</li> </ul>"},{"location":"tutorials/first-transaction/#additional-resources_1","title":"Additional Resources","text":"<ul> <li>Wallet API Reference</li> <li>BSV Wallet Protocols</li> <li>Transaction Broadcasting</li> </ul>"},{"location":"tutorials/hashes-and-hmacs/","title":"Cryptographic Hashing and HMACs","text":"<p>Duration: 75 minutes Prerequisites: Basic TypeScript knowledge, understanding of cryptographic concepts</p>"},{"location":"tutorials/hashes-and-hmacs/#learning-goals","title":"Learning Goals","text":"<p>By completing this tutorial, you will:</p> <ul> <li>Understand cryptographic hash functions and their properties</li> <li>Master the Hash module classes and helper functions in the BSV TypeScript SDK</li> <li>Implement various hash algorithms (SHA-256, SHA-512, SHA-1, RIPEMD-160)</li> <li>Create and verify HMACs for message authentication</li> <li>Apply Bitcoin-specific hashing patterns (hash256, hash160)</li> <li>Build practical applications using hashing for data integrity and authentication</li> <li>Understand performance considerations and security best practices</li> </ul>"},{"location":"tutorials/hashes-and-hmacs/#introduction-to-cryptographic-hashing","title":"Introduction to Cryptographic Hashing","text":"<p>Cryptographic hash functions are mathematical algorithms that transform input data of any size into fixed-size output values. They are fundamental to Bitcoin's security architecture, providing:</p> <ul> <li>Data Integrity: Detect any changes to data</li> <li>Digital Fingerprints: Unique identifiers for data</li> <li>Proof of Work: Foundation for Bitcoin's consensus mechanism</li> <li>Address Generation: Converting public keys to Bitcoin addresses</li> </ul> <p>The BSV TypeScript SDK provides comprehensive hashing capabilities through the <code>Hash</code> module, supporting both class-based and functional approaches.</p>"},{"location":"tutorials/hashes-and-hmacs/#setting-up-your-environment","title":"Setting Up Your Environment","text":"<p>First, import the necessary modules from the BSV SDK:</p> <pre><code>import { Hash, Utils } from '@bsv/sdk'\n</code></pre> <p>The <code>Hash</code> module contains:</p> <ul> <li>Hash function classes (<code>SHA256</code>, <code>SHA512</code>, <code>SHA1</code>, <code>RIPEMD160</code>)</li> <li>HMAC classes (<code>SHA256HMAC</code>, <code>SHA512HMAC</code>, <code>SHA1HMAC</code>)</li> <li>Helper functions (<code>sha256</code>, <code>sha512</code>, <code>hash256</code>, <code>hash160</code>, <code>sha256hmac</code>)</li> <li>Utility functions for data conversion and encoding</li> </ul>"},{"location":"tutorials/hashes-and-hmacs/#basic-hash-function-usage","title":"Basic Hash Function Usage","text":""},{"location":"tutorials/hashes-and-hmacs/#sha-256-hashing","title":"SHA-256 Hashing","text":"<p>SHA-256 is Bitcoin's primary hash function. Here's how to use it:</p> <pre><code>// Method 1: Using the SHA256 class\nconst sha256Hasher = new Hash.SHA256()\nsha256Hasher.update('Message to hash')\nconst hashedMessage = sha256Hasher.digestHex()\nconsole.log('SHA-256 hash:', hashedMessage)\n// Output: f1aa45b0f5f6703468f9b9bc2b9874d4fa6b001a170d0f132aa5a26d00d0c7e5\n\n// Method 2: Using the helper function\nconst message = 'Hello, Bitcoin!'\nconst hashResult = Hash.sha256(Utils.toArray(message, 'utf8'))\nconsole.log('SHA-256 hash (binary):', hashResult)\n\n// Convert to hex for display\nconst hashHex = Utils.toHex(hashResult)\nconsole.log('SHA-256 hash (hex):', hashHex)\n</code></pre>"},{"location":"tutorials/hashes-and-hmacs/#working-with-different-data-types","title":"Working with Different Data Types","text":"<p>The Hash functions can process various data formats:</p> <pre><code>// String input\nconst stringHash = Hash.sha256(Utils.toArray('Hello World', 'utf8'))\n\n// Hex string input\nconst hexHash = Hash.sha256(Utils.toArray('deadbeef', 'hex'))\n\n// Binary array input\nconst binaryData = [0x01, 0x02, 0x03, 0x04]\nconst binaryHash = Hash.sha256(binaryData)\n\n// JSON data hashing\nconst jsonData = { name: 'Alice', amount: 100 }\nconst jsonString = JSON.stringify(jsonData)\nconst jsonHash = Hash.sha256(Utils.toArray(jsonString, 'utf8'))\n\nconsole.log('String hash:', Utils.toHex(stringHash))\nconsole.log('Hex hash:', Utils.toHex(hexHash))\nconsole.log('Binary hash:', Utils.toHex(binaryHash))\nconsole.log('JSON hash:', Utils.toHex(jsonHash))\n</code></pre>"},{"location":"tutorials/hashes-and-hmacs/#other-hash-algorithms","title":"Other Hash Algorithms","text":"<p>The SDK supports multiple hash algorithms:</p> <pre><code>// SHA-512\nconst sha512Hasher = new Hash.SHA512()\nsha512Hasher.update('Message for SHA-512')\nconst sha512Result = sha512Hasher.digestHex()\nconsole.log('SHA-512 hash:', sha512Result)\n\n// SHA-1 (legacy, use with caution)\nconst sha1Hasher = new Hash.SHA1()\nsha1Hasher.update('Message for SHA-1')\nconst sha1Result = sha1Hasher.digestHex()\nconsole.log('SHA-1 hash:', sha1Result)\n\n// RIPEMD-160 (used in Bitcoin address generation)\nconst ripemdHasher = new Hash.RIPEMD160()\nripemdHasher.update('Message for RIPEMD-160')\nconst ripemdResult = ripemdHasher.digestHex()\nconsole.log('RIPEMD-160 hash:', ripemdResult)\n\n// Using helper functions\nconst sha512Helper = Hash.sha512(Utils.toArray('Hello', 'utf8'))\nconsole.log('SHA-512 helper result:', Utils.toHex(sha512Helper))\n</code></pre>"},{"location":"tutorials/hashes-and-hmacs/#bitcoin-specific-hash-functions","title":"Bitcoin-Specific Hash Functions","text":""},{"location":"tutorials/hashes-and-hmacs/#double-sha-256-hash256","title":"Double SHA-256 (hash256)","text":"<p>Bitcoin uses double SHA-256 hashing for block headers and transaction IDs:</p> <pre><code>// Double SHA-256 using hash256 helper\nconst message = 'Bitcoin transaction data'\nconst doubleHash = Hash.hash256(Utils.toArray(message, 'utf8'))\nconsole.log('Double SHA-256 hash:', Utils.toHex(doubleHash))\n\n// Manual double hashing\nconst firstHash = Hash.sha256(Utils.toArray(message, 'utf8'))\nconst secondHash = Hash.sha256(firstHash)\nconsole.log('Manual double hash:', Utils.toHex(secondHash))\n\n// Both methods produce the same result\nconsole.log('Results match:', Utils.toHex(doubleHash) === Utils.toHex(secondHash))\n</code></pre>"},{"location":"tutorials/hashes-and-hmacs/#hash160-sha-256-ripemd-160","title":"Hash160 (SHA-256 + RIPEMD-160)","text":"<p>Used for Bitcoin address generation:</p> <pre><code>// Hash160: SHA-256 followed by RIPEMD-160\nconst publicKeyData = 'compressed_public_key_hex_data'\nconst hash160Result = Hash.hash160(Utils.toArray(publicKeyData, 'hex'))\nconsole.log('Hash160 result:', Utils.toHex(hash160Result))\n\n// Manual implementation\nconst sha256First = Hash.sha256(Utils.toArray(publicKeyData, 'hex'))\nconst ripemd160Second = new Hash.RIPEMD160().update(sha256First).digest()\nconsole.log('Manual Hash160:', Utils.toHex(ripemd160Second))\n\n// Results should match\nconsole.log('Hash160 results match:', \n  Utils.toHex(hash160Result) === Utils.toHex(ripemd160Second))\n</code></pre>"},{"location":"tutorials/hashes-and-hmacs/#hmac-implementation","title":"HMAC Implementation","text":"<p>HMACs (Hash-based Message Authentication Codes) provide both data integrity and authentication by incorporating a secret key into the hashing process.</p>"},{"location":"tutorials/hashes-and-hmacs/#basic-hmac-usage","title":"Basic HMAC Usage","text":"<pre><code>// SHA-256 HMAC\nconst key = 'secret_key'\nconst message = 'Message to authenticate'\n\n// Method 1: Using HMAC class\nconst hmacHasher = new Hash.SHA256HMAC(key)\nhmacHasher.update(message)\nconst hmacResult = hmacHasher.digestHex()\nconsole.log('HMAC-SHA256:', hmacResult)\n// Output: b4d897472c73a052733d0796a5f71cf8253bab7d3969811b64f41ff6aa89d86f\n\n// Method 2: Using helper function\nconst hmacHelper = Hash.sha256hmac(key, message)\nconsole.log('HMAC helper result:', Utils.toHex(hmacHelper))\n\n// Both methods produce the same result\nconsole.log('HMAC results match:', hmacResult === Utils.toHex(hmacHelper))\n</code></pre>"},{"location":"tutorials/hashes-and-hmacs/#hmac-with-different-algorithms","title":"HMAC with Different Algorithms","text":"<pre><code>// SHA-512 HMAC\nconst sha512Hmac = new Hash.SHA512HMAC('my_secret_key')\nsha512Hmac.update('Data to authenticate')\nconst sha512HmacResult = sha512Hmac.digestHex()\nconsole.log('HMAC-SHA512:', sha512HmacResult)\n\n// SHA-1 HMAC (legacy)\nconst sha1Hmac = new Hash.SHA1HMAC('legacy_key')\nsha1Hmac.update('Legacy data')\nconst sha1HmacResult = sha1Hmac.digestHex()\nconsole.log('HMAC-SHA1:', sha1HmacResult)\n</code></pre>"},{"location":"tutorials/hashes-and-hmacs/#hmac-key-management","title":"HMAC Key Management","text":"<pre><code>// Strong key generation\nfunction generateHmacKey(): string {\n  const randomBytes = new Array(32)\n  for (let i = 0; i &lt; 32; i++) {\n    randomBytes[i] = Math.floor(Math.random() * 256)\n  }\n  return Utils.toHex(randomBytes)\n}\n\n// Key derivation from password\nfunction deriveKeyFromPassword(password: string, salt: string): number[] {\n  const combined = password + salt\n  return Hash.sha256(Utils.toArray(combined, 'utf8'))\n}\n\n// Example usage\nconst strongKey = generateHmacKey()\nconst derivedKey = deriveKeyFromPassword('user_password', 'random_salt')\n\nconsole.log('Strong key:', strongKey)\nconsole.log('Derived key:', Utils.toHex(derivedKey))\n\n// Use derived key for HMAC\nconst secureHmac = Hash.sha256hmac(derivedKey, 'sensitive_data')\nconsole.log('Secure HMAC:', Utils.toHex(secureHmac))\n</code></pre>"},{"location":"tutorials/hashes-and-hmacs/#practical-applications","title":"Practical Applications","text":""},{"location":"tutorials/hashes-and-hmacs/#data-integrity-verification","title":"Data Integrity Verification","text":"<pre><code>class DataIntegrityChecker {\n  private data: string\n  private hash: string\n\n  constructor(data: string) {\n    this.data = data\n    this.hash = this.calculateHash(data)\n  }\n\n  private calculateHash(data: string): string {\n    const hashResult = Hash.sha256(Utils.toArray(data, 'utf8'))\n    return Utils.toHex(hashResult)\n  }\n\n  verify(): boolean {\n    const currentHash = this.calculateHash(this.data)\n    return currentHash === this.hash\n  }\n\n  getData(): string {\n    return this.data\n  }\n\n  getHash(): string {\n    return this.hash\n  }\n\n  // Simulate data corruption\n  corruptData(): void {\n    this.data += '_corrupted'\n  }\n}\n\n// Example usage\nconst checker = new DataIntegrityChecker('Important document content')\nconsole.log('Original hash:', checker.getHash())\nconsole.log('Data is valid:', checker.verify()) // true\n\nchecker.corruptData()\nconsole.log('After corruption, data is valid:', checker.verify()) // false\n</code></pre>"},{"location":"tutorials/hashes-and-hmacs/#message-authentication-system","title":"Message Authentication System","text":"<pre><code>class MessageAuthenticator {\n  private secretKey: string\n\n  constructor(secretKey: string) {\n    this.secretKey = secretKey\n  }\n\n  createAuthenticatedMessage(message: string): {\n    message: string\n    hmac: string\n    timestamp: number\n  } {\n    const timestamp = Date.now()\n    const messageWithTimestamp = `${message}:${timestamp}`\n    const hmac = Hash.sha256hmac(this.secretKey, messageWithTimestamp)\n\n    return {\n      message,\n      hmac: Utils.toHex(hmac),\n      timestamp\n    }\n  }\n\n  verifyMessage(authenticatedMessage: {\n    message: string\n    hmac: string\n    timestamp: number\n  }): boolean {\n    try {\n      const messageWithTimestamp = `${authenticatedMessage.message}:${authenticatedMessage.timestamp}`\n      const expectedHmac = Hash.sha256hmac(this.secretKey, messageWithTimestamp)\n      const expectedHmacHex = Utils.toHex(expectedHmac)\n\n      // Constant-time comparison to prevent timing attacks\n      return this.constantTimeCompare(authenticatedMessage.hmac, expectedHmacHex)\n    } catch (error) {\n      console.error('Verification error:', error)\n      return false\n    }\n  }\n\n  private constantTimeCompare(a: string, b: string): boolean {\n    if (a.length !== b.length) {\n      return false\n    }\n\n    let result = 0\n    for (let i = 0; i &lt; a.length; i++) {\n      result |= a.charCodeAt(i) ^ b.charCodeAt(i)\n    }\n\n    return result === 0\n  }\n}\n\n// Example usage\nconst authenticator = new MessageAuthenticator('super_secret_key_123')\n\nconst authMessage = authenticator.createAuthenticatedMessage('Transfer 100 satoshis to Alice')\nconsole.log('Authenticated message:', authMessage)\n\nconst isValid = authenticator.verifyMessage(authMessage)\nconsole.log('Message is authentic:', isValid) // true\n\n// Tamper with the message\nauthMessage.message = 'Transfer 1000 satoshis to Alice'\nconst isTamperedValid = authenticator.verifyMessage(authMessage)\nconsole.log('Tampered message is authentic:', isTamperedValid) // false\n</code></pre>"},{"location":"tutorials/hashes-and-hmacs/#transaction-metadata-protection","title":"Transaction Metadata Protection","text":"<pre><code>interface TransactionMetadata {\n  description: string\n  category: string\n  tags: string[]\n  amount: number\n}\n\nclass SecureTransactionMetadata {\n  private key: number[]\n\n  constructor(password: string) {\n    // Derive key from password\n    this.key = Hash.sha256(Utils.toArray(password, 'utf8'))\n  }\n\n  protectMetadata(metadata: TransactionMetadata): {\n    data: string\n    integrity: string\n  } {\n    const jsonData = JSON.stringify(metadata)\n    const dataBytes = Utils.toArray(jsonData, 'utf8')\n\n    // Create integrity hash\n    const integrity = Hash.sha256hmac(this.key, dataBytes)\n\n    return {\n      data: Utils.toBase64(dataBytes),\n      integrity: Utils.toHex(integrity)\n    }\n  }\n\n  verifyAndExtract(protectedData: {\n    data: string\n    integrity: string\n  }): TransactionMetadata | null {\n    try {\n      const dataBytes = Array.from(Buffer.from(protectedData.data, 'base64'))\n      const expectedIntegrity = Hash.sha256hmac(this.key, dataBytes)\n      const expectedIntegrityHex = Utils.toHex(expectedIntegrity)\n\n      if (protectedData.integrity !== expectedIntegrityHex) {\n        console.error('Integrity check failed')\n        return null\n      }\n\n      const jsonString = Utils.toUTF8(dataBytes)\n      return JSON.parse(jsonString) as TransactionMetadata\n    } catch (error) {\n      console.error('Extraction error:', error)\n      return null\n    }\n  }\n}\n\n// Example usage\nconst metadataProtector = new SecureTransactionMetadata('user_password_123')\n\nconst originalMetadata: TransactionMetadata = {\n  description: 'Payment for services',\n  category: 'business',\n  tags: ['consulting', 'development'],\n  amount: 100\n}\n\nconst protectedData = metadataProtector.protectMetadata(originalMetadata)\nconsole.log('Protected metadata:', protectedData)\n\nconst extracted = metadataProtector.verifyAndExtract(protectedData)\nconsole.log('Extracted metadata:', extracted)\nconsole.log('Metadata matches:', JSON.stringify(originalMetadata) === JSON.stringify(extracted))\n</code></pre>"},{"location":"tutorials/hashes-and-hmacs/#performance-optimization","title":"Performance Optimization","text":""},{"location":"tutorials/hashes-and-hmacs/#batch-hashing","title":"Batch Hashing","text":"<pre><code>class BatchHashProcessor {\n  private hasher: Hash.SHA256\n\n  constructor() {\n    this.hasher = new Hash.SHA256()\n  }\n\n  hashMultipleMessages(messages: string[]): string[] {\n    const results: string[] = []\n\n    for (const message of messages) {\n      // Reset hasher for each message\n      this.hasher = new Hash.SHA256()\n      this.hasher.update(message)\n      results.push(this.hasher.digestHex())\n    }\n\n    return results\n  }\n\n  createMerkleRoot(hashes: string[]): string {\n    if (hashes.length === 0) {\n      throw new Error('Cannot create merkle root from empty array')\n    }\n\n    if (hashes.length === 1) {\n      return hashes[0]\n    }\n\n    const nextLevel: string[] = []\n\n    for (let i = 0; i &lt; hashes.length; i += 2) {\n      const left = hashes[i]\n      const right = i + 1 &lt; hashes.length ? hashes[i + 1] : left\n\n      const combined = left + right\n      const combinedBytes = Utils.toArray(combined, 'hex')\n      const hash = Hash.sha256(combinedBytes)\n      nextLevel.push(Utils.toHex(hash))\n    }\n\n    return this.createMerkleRoot(nextLevel)\n  }\n}\n\n// Performance testing\nfunction performanceTest() {\n  const processor = new BatchHashProcessor()\n  const testMessages = Array.from({ length: 1000 }, (_, i) =&gt; `Message ${i}`)\n\n  console.time('Batch hashing 1000 messages')\n  const hashes = processor.hashMultipleMessages(testMessages)\n  console.timeEnd('Batch hashing 1000 messages')\n\n  console.time('Creating merkle root')\n  const merkleRoot = processor.createMerkleRoot(hashes)\n  console.timeEnd('Creating merkle root')\n\n  console.log('Merkle root:', merkleRoot)\n  console.log('Processed', hashes.length, 'messages')\n}\n\nperformanceTest()\n</code></pre>"},{"location":"tutorials/hashes-and-hmacs/#memory-efficient-streaming","title":"Memory-Efficient Streaming","text":"<pre><code>class StreamingHasher {\n  private hasher: Hash.SHA256\n\n  constructor() {\n    this.hasher = new Hash.SHA256()\n  }\n\n  processLargeData(data: string, chunkSize: number = 1024): string {\n    for (let i = 0; i &lt; data.length; i += chunkSize) {\n      const chunk = data.slice(i, i + chunkSize)\n      this.hasher.update(chunk)\n    }\n\n    return this.hasher.digestHex()\n  }\n\n  reset(): void {\n    this.hasher = new Hash.SHA256()\n  }\n}\n\n// Example with large data\nconst streamingHasher = new StreamingHasher()\nconst largeData = 'A'.repeat(1000000) // 1MB of data\nconst streamHash = streamingHasher.processLargeData(largeData)\nconsole.log('Streaming hash result:', streamHash)\n</code></pre>"},{"location":"tutorials/hashes-and-hmacs/#security-best-practices","title":"Security Best Practices","text":""},{"location":"tutorials/hashes-and-hmacs/#secure-key-generation-and-storage","title":"Secure Key Generation and Storage","text":"<pre><code>class SecureKeyManager {\n  static generateSecureKey(length: number = 32): number[] {\n    // In production, use a cryptographically secure random number generator\n    const key = new Array(length)\n    for (let i = 0; i &lt; length; i++) {\n      key[i] = Math.floor(Math.random() * 256)\n    }\n    return key\n  }\n\n  static deriveKeyFromPassword(\n    password: string, \n    salt: number[], \n    iterations: number = 10000\n  ): number[] {\n    let derived = Hash.sha256(Utils.toArray(password + Utils.toHex(salt), 'utf8'))\n\n    for (let i = 1; i &lt; iterations; i++) {\n      derived = Hash.sha256(derived)\n    }\n\n    return derived\n  }\n\n  static secureCompare(a: number[], b: number[]): boolean {\n    if (a.length !== b.length) {\n      return false\n    }\n\n    let result = 0\n    for (let i = 0; i &lt; a.length; i++) {\n      result |= a[i] ^ b[i]\n    }\n\n    return result === 0\n  }\n\n  static clearSensitiveData(data: number[]): void {\n    for (let i = 0; i &lt; data.length; i++) {\n      data[i] = 0\n    }\n  }\n}\n\n// Example secure usage\nconst salt = SecureKeyManager.generateSecureKey(16)\nconst derivedKey = SecureKeyManager.deriveKeyFromPassword('user_password', salt)\n\nconsole.log('Salt:', Utils.toHex(salt))\nconsole.log('Derived key:', Utils.toHex(derivedKey))\n\n// Clear sensitive data when done\nSecureKeyManager.clearSensitiveData(derivedKey)\nSecureKeyManager.clearSensitiveData(salt)\n</code></pre>"},{"location":"tutorials/hashes-and-hmacs/#input-validation-and-error-handling","title":"Input Validation and Error Handling","text":"<pre><code>class SafeHasher {\n  static validateInput(input: any): void {\n    if (input === null || input === undefined) {\n      throw new Error('Input cannot be null or undefined')\n    }\n\n    if (typeof input === 'string' &amp;&amp; input.length === 0) {\n      throw new Error('Input string cannot be empty')\n    }\n\n    if (Array.isArray(input) &amp;&amp; input.length === 0) {\n      throw new Error('Input array cannot be empty')\n    }\n  }\n\n  static safeHash(input: string | number[], algorithm: 'sha256' | 'sha512' = 'sha256'): string {\n    try {\n      this.validateInput(input)\n\n      let data: number[]\n      if (typeof input === 'string') {\n        data = Utils.toArray(input, 'utf8')\n      } else {\n        data = input\n      }\n\n      let result: number[]\n      switch (algorithm) {\n        case 'sha256':\n          result = Hash.sha256(data)\n          break\n        case 'sha512':\n          result = Hash.sha512(data)\n          break\n        default:\n          throw new Error(`Unsupported algorithm: ${algorithm}`)\n      }\n\n      return Utils.toHex(result)\n    } catch (error) {\n      console.error('Hashing error:', error)\n      throw new Error(`Failed to hash input: ${error instanceof Error ? error.message : 'Unknown error'}`)\n    }\n  }\n\n  static safeHmac(key: string | number[], message: string | number[]): string {\n    try {\n      this.validateInput(key)\n      this.validateInput(message)\n\n      const result = Hash.sha256hmac(key, message)\n      return Utils.toHex(result)\n    } catch (error) {\n      console.error('HMAC error:', error)\n      throw new Error(`Failed to create HMAC: ${error instanceof Error ? error.message : 'Unknown error'}`)\n    }\n  }\n}\n\n// Example safe usage\ntry {\n  const hash = SafeHasher.safeHash('Valid input')\n  console.log('Safe hash:', hash)\n\n  const hmac = SafeHasher.safeHmac('secret_key', 'message')\n  console.log('Safe HMAC:', hmac)\n} catch (error) {\n  console.error('Operation failed:', error)\n}\n</code></pre>"},{"location":"tutorials/hashes-and-hmacs/#testing-your-implementation","title":"Testing Your Implementation","text":"<pre><code>// Comprehensive test suite\nfunction runHashTests(): void {\n  console.log('Running hash function tests...')\n\n  // Test SHA-256 consistency\n  const testMessage = 'Hello, Bitcoin!'\n  const hash1 = Hash.sha256(Utils.toArray(testMessage, 'utf8'))\n  const hash2 = new Hash.SHA256().update(testMessage).digest()\n\n  console.assert(\n    Utils.toHex(hash1) === Utils.toHex(hash2),\n    'SHA-256 methods should produce same result'\n  )\n\n  // Test HMAC consistency\n  const key = 'test_key'\n  const message = 'test_message'\n  const hmac1 = Hash.sha256hmac(key, message)\n  const hmac2 = new Hash.SHA256HMAC(key).update(message).digest()\n\n  console.assert(\n    Utils.toHex(hmac1) === Utils.toHex(hmac2),\n    'HMAC methods should produce same result'\n  )\n\n  // Test Bitcoin-specific functions\n  const data = 'bitcoin_data'\n  const hash256Result = Hash.hash256(Utils.toArray(data, 'utf8'))\n  const manualDouble = Hash.sha256(Hash.sha256(Utils.toArray(data, 'utf8')))\n\n  console.assert(\n    Utils.toHex(hash256Result) === Utils.toHex(manualDouble),\n    'hash256 should equal double SHA-256'\n  )\n\n  console.log('All tests passed!')\n}\n\nrunHashTests()\n</code></pre>"},{"location":"tutorials/hashes-and-hmacs/#troubleshooting-common-issues","title":"Troubleshooting Common Issues","text":""},{"location":"tutorials/hashes-and-hmacs/#issue-1-encoding-problems","title":"Issue 1: Encoding Problems","text":"<pre><code>// Problem: Incorrect encoding leads to different hashes\n// Note: Hash.sha256() requires number[] input, not strings directly\nconst correctHash = Hash.sha256(Utils.toArray('hello', 'utf8')) // Correct approach\n\nconsole.log('Correct hash with proper encoding:', Utils.toHex(correctHash))\nconsole.log('Always use Utils.toArray() for proper encoding')\n</code></pre>"},{"location":"tutorials/hashes-and-hmacs/#issue-2-key-management","title":"Issue 2: Key Management","text":"<pre><code>// Problem: Weak keys or improper key derivation\nconst weakKey = 'password123' // Weak\nconst strongKey = SecureKeyManager.generateSecureKey() // Strong\n\n// Problem: Reusing keys across different purposes\nconst hmacKey = strongKey\nconst encryptionKey = strongKey // Wrong: same key for different purposes\n\n// Solution: Derive different keys for different purposes\nconst hmacKeyDerived = Hash.sha256(Utils.toArray('hmac:' + Utils.toHex(strongKey), 'utf8'))\nconst encryptionKeyDerived = Hash.sha256(Utils.toArray('encrypt:' + Utils.toHex(strongKey), 'utf8'))\n</code></pre>"},{"location":"tutorials/hashes-and-hmacs/#issue-3-performance-problems","title":"Issue 3: Performance Problems","text":"<pre><code>// Problem: Creating new hasher instances unnecessarily\nfunction inefficientHashing(messages: string[]): string[] {\n  return messages.map(msg =&gt; {\n    const hasher = new Hash.SHA256() // Inefficient: new instance each time\n    return hasher.update(msg).digestHex()\n  })\n}\n\n// Solution: Reuse hasher or use helper functions\nfunction efficientHashing(messages: string[]): string[] {\n  return messages.map(msg =&gt; {\n    return Utils.toHex(Hash.sha256(Utils.toArray(msg, 'utf8'))) // Efficient\n  })\n}\n</code></pre>"},{"location":"tutorials/hashes-and-hmacs/#summary","title":"Summary","text":"<p>This tutorial covered comprehensive usage of cryptographic hashing and HMACs in the BSV TypeScript SDK:</p> <p>Key Concepts Learned:</p> <ul> <li>Hash function fundamentals and Bitcoin-specific applications</li> <li>SHA-256, SHA-512, SHA-1, and RIPEMD-160 implementation</li> <li>HMAC creation and verification for message authentication</li> <li>Bitcoin-specific functions: hash256 (double SHA-256) and hash160</li> <li>Performance optimization techniques for batch processing</li> <li>Security best practices for key management and validation</li> </ul> <p>Practical Applications:</p> <ul> <li>Data integrity verification systems</li> <li>Message authentication protocols</li> <li>Transaction metadata protection</li> <li>Merkle tree construction</li> <li>Secure key derivation patterns</li> </ul> <p>Security Considerations:</p> <ul> <li>Proper input validation and error handling</li> <li>Constant-time comparison to prevent timing attacks</li> <li>Secure key generation and storage practices</li> <li>Memory management for sensitive data</li> </ul> <p>The Hash module in the BSV TypeScript SDK provides both low-level control through classes and high-level convenience through helper functions, enabling developers to implement robust cryptographic solutions for Bitcoin applications.</p> <p>Continue exploring advanced cryptographic topics with the ECDH Key Exchange and AES Symmetric Encryption tutorials to build complete cryptographic systems.</p>"},{"location":"tutorials/identity-management/","title":"Identity Management and Certificates","text":"<p>Duration: 90 minutes Prerequisites: Node.js, basic TypeScript knowledge, understanding of digital certificates Learning Goals:</p> <ul> <li>Understand decentralized identity concepts</li> <li>Use IdentityClient for certificate management</li> <li>Implement identity verification systems</li> <li>Build identity-based applications</li> </ul>"},{"location":"tutorials/identity-management/#introduction","title":"Introduction","text":"<p>The BSV ecosystem uses a decentralized identity system based on cryptographic certificates. The <code>IdentityClient</code> provides tools for managing identity certificates, verifying identities, and building identity-aware applications.</p>"},{"location":"tutorials/identity-management/#key-concepts","title":"Key Concepts","text":"<ul> <li>Identity Certificates: Cryptographically signed identity claims</li> <li>Certificate Revelation: Publicly revealing identity attributes</li> <li>Identity Resolution: Finding identities by key or attributes</li> <li>Certificate Verification: Validating identity claims</li> </ul>"},{"location":"tutorials/identity-management/#what-youll-build","title":"What You'll Build","text":"<ul> <li>Identity certificate management system</li> <li>Identity verification service</li> <li>Public identity revelation</li> <li>Identity-based authentication</li> </ul>"},{"location":"tutorials/identity-management/#setting-up-identity-management-with-walletclient","title":"Setting Up Identity Management with <code>WalletClient</code>","text":""},{"location":"tutorials/identity-management/#basic-identity-operations","title":"Basic Identity Operations","text":"<pre><code>import { IdentityClient, WalletClient } from '@bsv/sdk'\n\nasync function basicIdentityOperations() {\n  const wallet = new WalletClient()\n  const identityClient = new IdentityClient(wallet)\n\n  console.log('Identity client initialized')\n\n  // Get our identity key\n  const { publicKey: identityKey } = await wallet.getPublicKey({\n    identityKey: true\n  })\n\n  console.log('Our identity key:', identityKey.substring(0, 20) + '...')\n\n  return { identityClient, identityKey }\n}\n\nbasicIdentityOperations().catch(console.error)\n</code></pre>"},{"location":"tutorials/identity-management/#resolving-identities-by-key","title":"Resolving Identities by Key","text":"<pre><code>import { IdentityClient, WalletClient } from '@bsv/sdk'\n\nasync function resolveIdentityByKey(identityKey: string) {\n  const identityClient = new IdentityClient()\n\n  try {\n    console.log('Resolving identity for key:', identityKey.substring(0, 20) + '...')\n\n    const identities = await identityClient.resolveByIdentityKey({\n      identityKey\n    })\n\n    console.log('Found identities:', identities.length)\n\n    identities.forEach((identity, index) =&gt; {\n      console.log(`Identity ${index + 1}:`)\n      console.log('  Name:', identity.name)\n      console.log('  Badge:', identity.badgeLabel)\n      console.log('  Avatar:', identity.avatarURL)\n      console.log('  Key:', identity.abbreviatedKey)\n    })\n\n    return identities\n  } catch (error) {\n    console.error('Failed to resolve identity:', error)\n    return []\n  }\n}\n\n// Example usage (replace with actual identity key)\n// resolveIdentityByKey('actual-identity-key-here').catch(console.error)\n</code></pre>"},{"location":"tutorials/identity-management/#resolving-identities-by-attributes","title":"Resolving Identities by Attributes","text":"<pre><code>import { IdentityClient } from '@bsv/sdk'\n\nasync function resolveIdentityByAttributes() {\n  const identityClient = new IdentityClient()\n\n  try {\n    console.log('Searching for identities by attributes...')\n\n    const identities = await identityClient.resolveByAttributes({\n      attributes: {\n        email: 'user@example.com'\n      }\n    })\n\n    console.log('Found identities with matching attributes:', identities.length)\n\n    identities.forEach((identity, index) =&gt; {\n      console.log(`Match ${index + 1}:`)\n      console.log('  Name:', identity.name)\n      console.log('  Badge:', identity.badgeLabel)\n      console.log('  Identity Key:', identity.identityKey.substring(0, 20) + '...')\n    })\n\n    return identities\n  } catch (error) {\n    console.error('Failed to resolve by attributes:', error)\n    return []\n  }\n}\n\nresolveIdentityByAttributes().catch(console.error)\n</code></pre>"},{"location":"tutorials/identity-management/#certificate-management-system","title":"Certificate Management System","text":""},{"location":"tutorials/identity-management/#identity-manager-class","title":"Identity Manager Class","text":"<pre><code>import { IdentityClient, WalletClient } from '@bsv/sdk'\n\ninterface IdentityRecord {\n  identityKey: string\n  name: string\n  badgeLabel: string\n  avatarURL: string\n  verificationStatus: 'verified' | 'unverified' | 'pending'\n  certificates: any[]\n  lastUpdated: Date\n}\n\nclass IdentityManager {\n  private identityClient: IdentityClient\n  private wallet: WalletClient\n  private identityCache: Map&lt;string, IdentityRecord&gt; = new Map()\n\n  constructor(wallet?: WalletClient) {\n    this.wallet = wallet || new WalletClient()\n    this.identityClient = new IdentityClient(this.wallet)\n  }\n\n  async getOurIdentity(): Promise&lt;string&gt; {\n    const { publicKey } = await this.wallet.getPublicKey({\n      identityKey: true\n    })\n    return publicKey\n  }\n\n  async verifyIdentity(identityKey: string): Promise&lt;IdentityRecord | null&gt; {\n    try {\n      console.log('Verifying identity:', identityKey.substring(0, 20) + '...')\n\n      // Check cache first\n      const cached = this.identityCache.get(identityKey)\n      if (cached &amp;&amp; this.isCacheValid(cached)) {\n        console.log('Using cached identity data')\n        return cached\n      }\n\n      // Resolve identity from network\n      const identities = await this.identityClient.resolveByIdentityKey({\n        identityKey\n      })\n\n      if (identities.length === 0) {\n        console.log('No identity found for key')\n        return null\n      }\n\n      // Use the first identity found\n      const identity = identities[0]\n\n      const record: IdentityRecord = {\n        identityKey,\n        name: identity.name,\n        badgeLabel: identity.badgeLabel,\n        avatarURL: identity.avatarURL,\n        verificationStatus: 'verified',\n        certificates: [], // Would contain actual certificates\n        lastUpdated: new Date()\n      }\n\n      // Cache the result\n      this.identityCache.set(identityKey, record)\n\n      console.log('Identity verified:', record.name)\n      return record\n    } catch (error) {\n      console.error('Identity verification failed:', error)\n      return null\n    }\n  }\n\n  async searchIdentities(query: {\n    name?: string\n    email?: string\n    attributes?: Record&lt;string, string&gt;\n  }): Promise&lt;IdentityRecord[]&gt; {\n    try {\n      console.log('Searching identities with query:', query)\n\n      const searchAttributes = {\n        ...query.attributes,\n        ...(query.name &amp;&amp; { name: query.name }),\n        ...(query.email &amp;&amp; { email: query.email })\n      }\n\n      const identities = await this.identityClient.resolveByAttributes({\n        attributes: searchAttributes\n      })\n\n      const records: IdentityRecord[] = identities.map(identity =&gt; ({\n        identityKey: identity.identityKey,\n        name: identity.name,\n        badgeLabel: identity.badgeLabel,\n        avatarURL: identity.avatarURL,\n        verificationStatus: 'verified' as const,\n        certificates: [],\n        lastUpdated: new Date()\n      }))\n\n      console.log('Found', records.length, 'matching identities')\n      return records\n    } catch (error) {\n      console.error('Identity search failed:', error)\n      return []\n    }\n  }\n\n  async revealPublicAttributes(\n    certificate: any,\n    fieldsToReveal: string[]\n  ): Promise&lt;boolean&gt; {\n    try {\n      console.log('Revealing public attributes:', fieldsToReveal)\n\n      const result = await this.identityClient.publiclyRevealAttributes(\n        certificate,\n        fieldsToReveal\n      )\n\n      console.log('Attributes revealed successfully')\n      return true\n    } catch (error) {\n      console.error('Failed to reveal attributes:', error)\n      return false\n    }\n  }\n\n  private isCacheValid(record: IdentityRecord): boolean {\n    const cacheAge = Date.now() - record.lastUpdated.getTime()\n    const maxAge = 60 * 60 * 1000 // 1 hour\n    return cacheAge &lt; maxAge\n  }\n\n  getCachedIdentities(): IdentityRecord[] {\n    return Array.from(this.identityCache.values())\n  }\n\n  clearCache(): void {\n    this.identityCache.clear()\n    console.log('Identity cache cleared')\n  }\n}\n\nasync function demonstrateIdentityManager() {\n  const identityManager = new IdentityManager()\n\n  console.log('=== Identity Manager Demo ===')\n\n  // Get our own identity\n  const ourIdentity = await identityManager.getOurIdentity()\n  console.log('Our identity key:', ourIdentity.substring(0, 20) + '...')\n\n  // Search for identities\n  const searchResults = await identityManager.searchIdentities({\n    name: 'John'\n  })\n\n  console.log('Search results:', searchResults.length)\n\n  // Verify specific identities\n  for (const result of searchResults.slice(0, 2)) { // Limit to first 2\n    const verified = await identityManager.verifyIdentity(result.identityKey)\n    if (verified) {\n      console.log('Verified identity:', verified.name)\n    }\n  }\n\n  // Show cached identities\n  const cached = identityManager.getCachedIdentities()\n  console.log('Cached identities:', cached.length)\n\n  return { ourIdentity, searchResults, cached }\n}\n\ndemonstrateIdentityManager().catch(console.error)\n</code></pre>"},{"location":"tutorials/identity-management/#identity-based-authentication","title":"Identity-Based Authentication","text":""},{"location":"tutorials/identity-management/#authentication-service","title":"Authentication Service","text":"<pre><code>import { IdentityClient, WalletClient } from '@bsv/sdk'\n\ninterface AuthenticationResult {\n  success: boolean\n  identityKey?: string\n  identity?: any\n  error?: string\n}\n\nclass IdentityAuthService {\n  private identityClient: IdentityClient\n  private authenticatedUsers: Map&lt;string, {\n    identity: any\n    sessionStart: Date\n    lastActivity: Date\n  }&gt; = new Map()\n\n  constructor(wallet?: WalletClient) {\n    this.identityClient = new IdentityClient(wallet)\n  }\n\n  async authenticateUser(identityKey: string): Promise&lt;AuthenticationResult&gt; {\n    try {\n      console.log('Authenticating user:', identityKey.substring(0, 20) + '...')\n\n      // Resolve identity\n      const identities = await this.identityClient.resolveByIdentityKey({\n        identityKey\n      })\n\n      if (identities.length === 0) {\n        return {\n          success: false,\n          error: 'Identity not found'\n        }\n      }\n\n      const identity = identities[0]\n\n      // Create session\n      this.authenticatedUsers.set(identityKey, {\n        identity,\n        sessionStart: new Date(),\n        lastActivity: new Date()\n      })\n\n      console.log('User authenticated:', identity.name)\n\n      return {\n        success: true,\n        identityKey,\n        identity\n      }\n    } catch (error) {\n      console.error('Authentication failed:', error)\n      return {\n        success: false,\n        error: error.message\n      }\n    }\n  }\n\n  async verifySession(identityKey: string): Promise&lt;boolean&gt; {\n    const session = this.authenticatedUsers.get(identityKey)\n\n    if (!session) {\n      return false\n    }\n\n    // Check session timeout (24 hours)\n    const sessionAge = Date.now() - session.sessionStart.getTime()\n    const maxAge = 24 * 60 * 60 * 1000\n\n    if (sessionAge &gt; maxAge) {\n      this.authenticatedUsers.delete(identityKey)\n      return false\n    }\n\n    // Update last activity\n    session.lastActivity = new Date()\n    return true\n  }\n\n  async requireAuthentication(identityKey: string): Promise&lt;{\n    authorized: boolean\n    identity?: any\n    error?: string\n  }&gt; {\n    const isValid = await this.verifySession(identityKey)\n\n    if (!isValid) {\n      return {\n        authorized: false,\n        error: 'Authentication required'\n      }\n    }\n\n    const session = this.authenticatedUsers.get(identityKey)\n    return {\n      authorized: true,\n      identity: session?.identity\n    }\n  }\n\n  logout(identityKey: string): void {\n    this.authenticatedUsers.delete(identityKey)\n    console.log('User logged out:', identityKey.substring(0, 20) + '...')\n  }\n\n  getActiveSessions(): Array&lt;{\n    identityKey: string\n    name: string\n    sessionStart: Date\n    lastActivity: Date\n  }&gt; {\n    return Array.from(this.authenticatedUsers.entries()).map(([key, session]) =&gt; ({\n      identityKey: key,\n      name: session.identity.name,\n      sessionStart: session.sessionStart,\n      lastActivity: session.lastActivity\n    }))\n  }\n}\n\nasync function demonstrateAuthentication() {\n  const authService = new IdentityAuthService()\n\n  console.log('=== Identity Authentication Demo ===')\n\n  // Simulate user authentication\n  const wallet = new WalletClient()\n  const { publicKey: userIdentity } = await wallet.getPublicKey({\n    identityKey: true\n  })\n\n  // Authenticate user\n  const authResult = await authService.authenticateUser(userIdentity)\n\n  if (authResult.success) {\n    console.log('\u2705 Authentication successful')\n    console.log('User:', authResult.identity?.name || 'Unknown')\n\n    // Verify session\n    const sessionValid = await authService.verifySession(userIdentity)\n    console.log('Session valid:', sessionValid)\n\n    // Test authorization\n    const authCheck = await authService.requireAuthentication(userIdentity)\n    console.log('Authorization check:', authCheck.authorized ? 'PASSED' : 'FAILED')\n\n    // Show active sessions\n    const sessions = authService.getActiveSessions()\n    console.log('Active sessions:', sessions.length)\n\n    // Logout\n    authService.logout(userIdentity)\n    console.log('User logged out')\n\n  } else {\n    console.log('\u274c Authentication failed:', authResult.error)\n  }\n\n  return authResult\n}\n\ndemonstrateAuthentication().catch(console.error)\n</code></pre>"},{"location":"tutorials/identity-management/#identity-verification-service","title":"Identity Verification Service","text":""},{"location":"tutorials/identity-management/#complete-verification-system","title":"Complete Verification System","text":"<pre><code>import { IdentityClient, WalletClient } from '@bsv/sdk'\n\ninterface VerificationRequest {\n  identityKey: string\n  requiredCertificates: string[]\n  purpose: string\n  timestamp: Date\n}\n\ninterface VerificationResult {\n  verified: boolean\n  identityKey: string\n  certificates: any[]\n  trustScore: number\n  issues: string[]\n}\n\nclass IdentityVerificationService {\n  private identityClient: IdentityClient\n  private verificationHistory: Map&lt;string, VerificationResult[]&gt; = new Map()\n\n  constructor(wallet?: WalletClient) {\n    this.identityClient = new IdentityClient(wallet)\n  }\n\n  async verifyIdentity(request: VerificationRequest): Promise&lt;VerificationResult&gt; {\n    console.log('Starting identity verification for:', request.identityKey.substring(0, 20) + '...')\n    console.log('Purpose:', request.purpose)\n\n    const result: VerificationResult = {\n      verified: false,\n      identityKey: request.identityKey,\n      certificates: [],\n      trustScore: 0,\n      issues: []\n    }\n\n    try {\n      // Resolve identity\n      const identities = await this.identityClient.resolveByIdentityKey({\n        identityKey: request.identityKey\n      })\n\n      if (identities.length === 0) {\n        result.issues.push('Identity not found')\n        return result\n      }\n\n      const identity = identities[0]\n\n      // Calculate trust score based on available information\n      result.trustScore = this.calculateTrustScore(identity)\n\n      // Check if verification meets requirements\n      if (result.trustScore &gt;= 70) { // Minimum trust score\n        result.verified = true\n        console.log('\u2705 Identity verified:', identity.name)\n      } else {\n        result.issues.push('Insufficient trust score')\n        console.log('\u274c Identity verification failed: low trust score')\n      }\n\n      // Store verification history\n      const history = this.verificationHistory.get(request.identityKey) || []\n      history.push(result)\n      this.verificationHistory.set(request.identityKey, history)\n\n    } catch (error) {\n      result.issues.push(`Verification error: ${error.message}`)\n      console.error('Verification error:', error)\n    }\n\n    return result\n  }\n\n  private calculateTrustScore(identity: any): number {\n    let score = 0\n\n    // Base score for having an identity\n    score += 30\n\n    // Score for having a name\n    if (identity.name &amp;&amp; identity.name !== 'Unknown') {\n      score += 20\n    }\n\n    // Score for having an avatar\n    if (identity.avatarURL) {\n      score += 10\n    }\n\n    // Score for having a badge\n    if (identity.badgeLabel) {\n      score += 20\n    }\n\n    // Additional score for verified badge\n    if (identity.badgeLabel?.includes('Verified')) {\n      score += 20\n    }\n\n    return Math.min(score, 100) // Cap at 100\n  }\n\n  async batchVerify(identityKeys: string[], purpose: string): Promise&lt;{\n    verified: VerificationResult[]\n    failed: VerificationResult[]\n  }&gt; {\n    console.log(`Starting batch verification of ${identityKeys.length} identities`)\n\n    const requests = identityKeys.map(key =&gt; ({\n      identityKey: key,\n      requiredCertificates: [],\n      purpose,\n      timestamp: new Date()\n    }))\n\n    const results = await Promise.all(\n      requests.map(request =&gt; this.verifyIdentity(request))\n    )\n\n    const verified = results.filter(r =&gt; r.verified)\n    const failed = results.filter(r =&gt; !r.verified)\n\n    console.log(`Batch verification complete: ${verified.length} verified, ${failed.length} failed`)\n\n    return { verified, failed }\n  }\n\n  getVerificationHistory(identityKey: string): VerificationResult[] {\n    return this.verificationHistory.get(identityKey) || []\n  }\n\n  getTrustStatistics(): {\n    totalVerifications: number\n    successRate: number\n    averageTrustScore: number\n  } {\n    let totalVerifications = 0\n    let successfulVerifications = 0\n    let totalTrustScore = 0\n\n    for (const history of this.verificationHistory.values()) {\n      for (const result of history) {\n        totalVerifications++\n        totalTrustScore += result.trustScore\n\n        if (result.verified) {\n          successfulVerifications++\n        }\n      }\n    }\n\n    return {\n      totalVerifications,\n      successRate: totalVerifications &gt; 0 ? successfulVerifications / totalVerifications : 0,\n      averageTrustScore: totalVerifications &gt; 0 ? totalTrustScore / totalVerifications : 0\n    }\n  }\n}\n\nasync function demonstrateVerificationService() {\n  const verificationService = new IdentityVerificationService()\n\n  console.log('=== Identity Verification Service Demo ===')\n\n  // Create test identities\n  const wallet1 = new WalletClient()\n  const wallet2 = new WalletClient()\n\n  const { publicKey: identity1 } = await wallet1.getPublicKey({ identityKey: true })\n  const { publicKey: identity2 } = await wallet2.getPublicKey({ identityKey: true })\n\n  const testIdentities = [identity1, identity2]\n\n  // Batch verification\n  const batchResult = await verificationService.batchVerify(\n    testIdentities,\n    'User registration verification'\n  )\n\n  console.log('Batch verification results:')\n  console.log('  Verified:', batchResult.verified.length)\n  console.log('  Failed:', batchResult.failed.length)\n\n  // Individual verification with details\n  for (const identity of testIdentities.slice(0, 1)) { // Just first one\n    const request: VerificationRequest = {\n      identityKey: identity,\n      requiredCertificates: ['identity'],\n      purpose: 'Account access verification',\n      timestamp: new Date()\n    }\n\n    const result = await verificationService.verifyIdentity(request)\n\n    console.log(`\\nVerification for ${identity.substring(0, 20)}...`)\n    console.log('  Verified:', result.verified)\n    console.log('  Trust Score:', result.trustScore)\n    console.log('  Issues:', result.issues)\n  }\n\n  // Get statistics\n  const stats = verificationService.getTrustStatistics()\n  console.log('\\nVerification Statistics:')\n  console.log('  Total Verifications:', stats.totalVerifications)\n  console.log('  Success Rate:', (stats.successRate * 100).toFixed(1) + '%')\n  console.log('  Average Trust Score:', stats.averageTrustScore.toFixed(1))\n\n  return { batchResult, stats }\n}\n\ndemonstrateVerificationService().catch(console.error)\n</code></pre>"},{"location":"tutorials/identity-management/#conclusion","title":"Conclusion","text":"<p>Congratulations! You've successfully built a comprehensive identity management system using the BSV TypeScript SDK. In this tutorial, you've learned how to create, manage, and verify digital identities on the BSV blockchain.</p>"},{"location":"tutorials/identity-management/#core-concepts-mastered","title":"Core Concepts Mastered","text":"<ol> <li>Identity Creation: Generated unique BSV identities using cryptographic key pairs</li> <li>Certificate Management: Created and managed identity certificates for enhanced trust</li> <li>Identity Resolution: Implemented identity lookup and verification services</li> <li>Trust Scoring: Built systems to calculate and evaluate identity trustworthiness</li> <li>Batch Processing: Optimized identity operations for handling multiple identities efficiently</li> </ol>"},{"location":"tutorials/identity-management/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about AuthFetch Integration to use identities for API authentication</li> <li>Explore Identity Verification Systems for advanced verification patterns</li> <li>Understand Security Best Practices for production identity systems</li> </ul>"},{"location":"tutorials/identity-management/#additional-resources","title":"Additional Resources","text":"<ul> <li>Identity Client API Reference</li> <li>Certificate Management Guide</li> <li>Decentralized Identity Concepts</li> <li>BSV Identity Standards</li> </ul>"},{"location":"tutorials/key-management/","title":"Key Management and Cryptography","text":"<p>Duration: 45 minutes Prerequisites: Completed \"Your First BSV Transaction\" tutorial, Node.js, basic TypeScript knowledge  </p>"},{"location":"tutorials/key-management/#learning-goals","title":"Learning Goals","text":"<ul> <li>Generate and manage private/public keys</li> <li>Understand ECDSA signatures</li> <li>Create and verify digital signatures</li> <li>Apply secure key management practices</li> <li>Use <code>WalletClient</code> for advanced key operations</li> </ul> <p>\ud83d\udcda Related Concepts: Review Key Management, Digital Signatures, and Trust Model for essential background.</p>"},{"location":"tutorials/key-management/#introduction","title":"Introduction","text":"<p>Bitcoin is built on cryptographic principles, with keys and signatures forming the foundation of its security model. In this tutorial, you'll learn how to generate, manage, and use cryptographic keys with the BSV TypeScript SDK. You'll also learn how to create and verify digital signatures, which are essential for authorizing transactions and proving ownership.</p> <p>\ud83d\udca1 Try It Interactive: Experiment with key generation and cryptographic operations in our Interactive BSV Coding Environment - perfect for testing the concepts covered in this tutorial!</p>"},{"location":"tutorials/key-management/#step-1-setting-up-your-environment","title":"Step 1: Setting Up Your Environment","text":"<p>First, let's create a project for our key management exercises:</p> <pre><code># Create a new directory for the project\nmkdir bsv-key-management\ncd bsv-key-management\n\n# Initialize a new Node.js project\nnpm init -y\n\n# Install TypeScript and ts-node\nnpm install typescript ts-node @types/node --save-dev\n\n# Install the BSV SDK\nnpm install @bsv/sdk\n</code></pre> <p>Create a basic TypeScript configuration file (<code>tsconfig.json</code>):</p> <pre><code>{\n  \"compilerOptions\": {\n    \"target\": \"es2022\",\n    \"module\": \"commonjs\",\n    \"esModuleInterop\": true,\n    \"strict\": true,\n    \"outDir\": \"./dist\"\n  }\n}\n</code></pre>"},{"location":"tutorials/key-management/#step-2-understanding-bitcoin-keys","title":"Step 2: Understanding Bitcoin Keys","text":"<p>Before diving into code, let's understand the key concepts:</p>"},{"location":"tutorials/key-management/#key-hierarchy","title":"Key Hierarchy","text":"<p>Bitcoin uses a hierarchical key system:</p> <ul> <li>Private Key: A randomly generated number that must be kept secret</li> <li>Public Key: Derived from the private key, can be shared safely</li> <li>Bitcoin Address: Derived from the public key, used to receive funds</li> </ul>"},{"location":"tutorials/key-management/#key-formats","title":"Key Formats","text":"<p>Private keys can be represented in several formats:</p> <ul> <li>Raw: A 32-byte number</li> <li>WIF (Wallet Import Format): A Base58Check encoded string, making keys easier to handle</li> <li>Extended Keys: Used in HD wallets (covered in advanced tutorials)</li> </ul> <p>Public keys can be represented as:</p> <ul> <li>Compressed: 33 bytes (more efficient, preferred format)</li> <li>Uncompressed: 65 bytes (legacy format)</li> </ul> <p>Addresses can be in various formats:</p> <ul> <li>P2PKH: Standard \"Pay to Public Key Hash\" addresses</li> <li>P2SH: \"Pay to Script Hash\" addresses for more complex scripts</li> <li>Others: Various formats exist for specific use cases</li> </ul>"},{"location":"tutorials/key-management/#step-3-generating-and-managing-keys","title":"Step 3: Generating and Managing Keys","text":"<p>Let's create a file called <code>key-management.ts</code> to experiment with key generation and management:</p> <pre><code>import { PrivateKey, PublicKey } from '@bsv/sdk'\n\n// Generate a new random private key\nfunction generateNewKey() {\n  const privateKey = PrivateKey.fromRandom()\n  const publicKey = privateKey.toPublicKey()\n  const address = privateKey.toAddress()\n\n  console.log('\\n=== Newly Generated Key ===')  \n  console.log(`Private Key (WIF): ${privateKey.toWif()}`)\n  console.log(`Public Key (DER Hex): ${publicKey.toDER('hex')}`)\n  console.log(`Bitcoin Address: ${address.toString()}`)\n\n  return privateKey\n}\n\n// Import an existing private key from WIF format\nfunction importFromWIF(wifString: string) {\n  try {\n    const privateKey = PrivateKey.fromWif(wifString)\n    const publicKey = privateKey.toPublicKey()\n    const address = privateKey.toAddress()\n\n    console.log('\\n=== Imported Key ===')  \n    console.log(`Private Key (WIF): ${privateKey.toWif()}`)\n    console.log(`Public Key (DER Hex): ${publicKey.toDER('hex')}`)\n    console.log(`Bitcoin Address: ${address.toString()}`)\n\n    return privateKey\n  } catch (error) {\n    console.error('Error importing key:', error)\n    return null\n  }\n}\n\n// Derive different address types from a private key\nfunction deriveAddressTypes(privateKey: PrivateKey) {\n  // Standard P2PKH mainnet address (prefix 0x00)\n  const mainnetAddress = privateKey.toAddress()\n\n  console.log('\\n=== Bitcoin Address Types ===')  \n  console.log(`Mainnet Address: ${mainnetAddress.toString()}`)\n\n  // Get the public key and hash it to show the process\n  const publicKey = privateKey.toPublicKey()\n  // For P2PKH addresses, we use HASH160 (RIPEMD160(SHA256(pubKey)))\n  const pubKeyHash = publicKey.toHash()\n  console.log(`Public Key Hash: ${Buffer.from(pubKeyHash).toString('hex')}`)\n\n  return mainnetAddress\n}\n\n// Advanced: Check if a public key corresponds to a private key\nfunction verifyKeyPair(privateKey: PrivateKey, publicKeyHex: string) {\n  // Convert the provided public key hex to a PublicKey object\n  // The toDER('hex') method provides a hex string that can be parsed by fromString\n  const providedPubKey = PublicKey.fromString(publicKeyHex)\n\n  // Derive the public key from the private key\n  const derivedPubKey = privateKey.toPublicKey()\n\n  // Compare the hex representations\n  // Make sure we cast to string to ensure proper comparison\n  const isMatch = (providedPubKey.toDER('hex') as string) === (derivedPubKey.toDER('hex') as string)\n\n  console.log('\\n=== Key Pair Verification ===')  \n  console.log(`Public keys match: ${isMatch}`)\n\n  return isMatch\n}\n\n// Execute our key management examples\nasync function runKeyManagementExamples() {\n  // Generate a new key\n  const newKey = generateNewKey()\n\n  // Derive different address types from the key\n  deriveAddressTypes(newKey)\n\n  // Import a key from WIF (using the one we just generated as an example)\n  const wif = newKey.toWif()\n  const importedKey = importFromWIF(wif)\n\n  if (importedKey) {\n    // Verify the key pair\n    // Make sure we're using a string type for the public key hex\n    const pubKeyHex = newKey.toPublicKey().toDER('hex') as string\n    verifyKeyPair(importedKey, pubKeyHex)\n  }\n\n  console.log('\\n=== Key Management Demo Complete ===')  \n}\n\n// Run our examples\nrunKeyManagementExamples().catch(console.error)\n</code></pre> <p>Run the script with:</p> <pre><code>npx ts-node key-management.ts\n</code></pre> <p>You should see output showing the generated keys, addresses, and verification results.</p>"},{"location":"tutorials/key-management/#step-4-creating-and-verifying-digital-signatures","title":"Step 4: Creating and Verifying Digital Signatures","text":"<p>Digital signatures are fundamental to Bitcoin. They prove that the owner of a private key has authorized a specific action, like spending coins in a transaction.</p>"},{"location":"tutorials/key-management/#approach-1-using-walletclient","title":"Approach 1: Using <code>WalletClient</code>","text":"<p><code>WalletClient</code> is the recommended interface for these actions, providing enhanced security as private keys remain isolated within the wallet environment. Let's create a file called <code>signatures-wallet.ts</code>:</p> <pre><code>import { WalletClient } from '@bsv/sdk'\n\nasync function signatureWalletExamples() {\n  // Initialize a WalletClient with default settings\n  const wallet = new WalletClient('auto', 'localhost')\n\n  console.log('\\n=== WalletClient Signature Example ===')\n\n  try {\n    // Connect to the wallet substrate\n    await wallet.connectToSubstrate()\n\n    // 1. Define protocol and key identifiers for wallet operations\n    // In a real app, these would be specific to your application\n    // Using 1 to represent medium security level\n    // Using 'any' type to bypass type checking since we don't have access to the SecurityLevel enum values\n    const protocolID = [1, 'bsv tutorial'] as any\n    const keyID = 'tutorial signing key'\n\n    // 2. Get a public key from the wallet for verification (for demo purposes)\n    const keyResult = await wallet.getPublicKey({\n      protocolID,\n      keyID,\n      counterparty: 'self' // Get our own public key\n    })\n\n    console.log(`Public Key from Wallet: ${keyResult.publicKey}`)\n\n    // 3. Create a message to sign\n    const message = 'Hello, Bitcoin SV!'\n    console.log(`\\nMessage to sign: \"${message}\"`)\n    const messageBytes = new TextEncoder().encode(message)\n\n    // 4. Create a signature using WalletClient\n    console.log('\\nCreating signature with parameters:')\n    console.log('- Protocol ID:', JSON.stringify(protocolID))\n    console.log('- Key ID:', keyID)\n    console.log('- Message bytes:', JSON.stringify(Array.from(messageBytes)))\n\n    // When creating signatures with counterparty='self', we must explicitly set it\n    // This ensures we can verify the signature with the default parameters\n    const sigResult = await wallet.createSignature({\n      data: Array.from(messageBytes),\n      protocolID,\n      keyID,\n      counterparty: 'self' // Explicitly use 'self' as counterparty, as the default counterparty is 'anyone' (implicit)\n    })\n\n    console.log(`\\nSignature created with WalletClient: ${Buffer.from(sigResult.signature).toString('hex').substring(0, 64)}...`)\n\n    // 5. Verify the signature using WalletClient\n    // Note: WalletClient throws an error when verification fails\n    try {\n      console.log('\\nVerifying signature with parameters:')\n      console.log('- Protocol ID:', JSON.stringify(protocolID))\n      console.log('- Key ID:', keyID)\n      console.log('- Message bytes:', JSON.stringify(Array.from(messageBytes)))\n\n      // When verifying signatures, the default counterparty is 'self'\n      // Since we created the signature with counterparty='self', we can use the default\n      const verifyResult = await wallet.verifySignature({\n        data: Array.from(messageBytes),\n        signature: sigResult.signature,\n        protocolID,\n        keyID\n        // Using default counterparty: 'self' (implicit)\n        // counterparty: ourPublicKey \n      })\n\n      console.log(`\\nSignature verification result: ${verifyResult.valid ? 'Valid \u2713' : 'Invalid \u2717'}`)\n    } catch (error) {\n      // The wallet throws an error when verification fails instead of returning { valid: false }\n      console.log('\\nSignature verification result: Invalid \u2717')\n      console.log(`Verification error: ${error instanceof Error ? error.message : 'Unknown error'}`)\n    }\n\n    // 6. Try verifying with tampered data\n    const tamperedMessage = 'Hello, Bitcoin SV! [tampered]'\n    const tamperedBytes = new TextEncoder().encode(tamperedMessage)\n\n    try {\n      // For tampered message verification, we use the same parameters\n      const tamperedVerifyResult = await wallet.verifySignature({\n        data: Array.from(tamperedBytes),\n        signature: sigResult.signature,\n        protocolID,\n        keyID\n        // Using default counterparty: 'self' (implicit)\n        // counterparty: ourPublicKey \n      })\n\n      console.log(`\\nTampered message verification: ${tamperedVerifyResult.valid ? 'Valid \u2713' : 'Invalid \u2717'}`)\n    } catch (error) {\n      // Expected behavior: verification should fail with tampered data\n      console.log('\\nTampered message verification: Invalid \u2717')\n      console.log('This is the expected behavior - tampered data should fail verification')\n    }\n\n  } catch (error) {\n    console.error('\\nError during WalletClient operations:', error)\n    console.log('Note: To use WalletClient, you need a compatible wallet connection.')\n  }\n}\n\n// Run our wallet signature examples\nsignatureWalletExamples().catch(console.error)\n</code></pre> <p>Run the example:</p> <pre><code>npx ts-node signatures-wallet.ts\n</code></pre>"},{"location":"tutorials/key-management/#approach-2-using-low-level-cryptography-apis","title":"Approach 2: Using Low-level Cryptography APIs","text":"<p>Alternatively, you could perform the same using direct cryptography APIs. Let's create a file called <code>signatures-low-level.ts</code>:</p> <pre><code>import { PrivateKey, PublicKey, Signature } from '@bsv/sdk'\n\nasync function signatureLowLevelExamples() {\n  // Generate a key to use for signing\n  const privateKey = PrivateKey.fromRandom()\n  const publicKey = privateKey.toPublicKey()\n\n  console.log('\\n=== Key for Signing (Low-level API) ===')  \n  console.log(`Private Key (WIF): ${privateKey.toWif()}`)\n  console.log(`Public Key (DER Hex): ${publicKey.toDER('hex')}`)\n\n  // 1. Create a message to sign\n  const message = 'Hello, Bitcoin SV!'\n  console.log(`\\nMessage to sign: \"${message}\"`)\n\n  // 2. Sign the message - using the message string directly\n  const signature = await privateKey.sign(message)\n\n  // Get the signature in DER format (hex string)\n  const derSignatureHex = signature.toDER('hex') as string\n  console.log(`\\nSignature (DER format): ${derSignatureHex}`)\n\n  // 3. Verify the signature using the public key\n  const isValid = await publicKey.verify(message, signature)\n  console.log(`\\nSignature verification result: ${isValid ? 'Valid \u2713' : 'Invalid \u2717'}`)\n\n  // 4. Try verifying with a modified message (should fail)\n  const tamperedMessage = message + ' [tampered]'\n  const isTamperedValid = await publicKey.verify(tamperedMessage, signature)\n  console.log(`\\nTampered message verification: ${isTamperedValid ? 'Valid \u2713' : 'Invalid \u2717'}`)\n\n  // 5. Try verifying with a different public key (should fail)\n  const differentKey = PrivateKey.fromRandom().toPublicKey()\n  const isDifferentKeyValid = await differentKey.verify(message, signature)\n  console.log(`\\nWrong key verification: ${isDifferentKeyValid ? 'Valid \u2713' : 'Invalid \u2717'}`)\n\n  // 6. Importing a signature from DER format (as number array)\n  const derSignature = signature.toDER() as number[]\n  const importedSignature = Signature.fromDER(derSignature)\n  const isImportedValid = await publicKey.verify(message, importedSignature)\n  console.log(`\\nImported signature verification: ${isImportedValid ? 'Valid \u2713' : 'Invalid \u2717'}`)\n}\n\n// Run our signature examples\nsignatureLowLevelExamples().catch(console.error)\n</code></pre> <p>Run the script:</p> <pre><code>npx ts-node signatures-low-level.ts\n</code></pre>"},{"location":"tutorials/key-management/#key-benefits-of-walletclient-for-signatures","title":"Key Benefits of <code>WalletClient</code> for Signatures","text":"<ol> <li>Enhanced Security: Private keys never leave the wallet environment</li> <li>Key Management: No need to handle raw private keys in your code</li> <li>Standardized API: Consistent interface for all cryptographic operations</li> <li>Protocol-based: Keys are managed within specific protocol contexts</li> </ol>"},{"location":"tutorials/key-management/#step-5-practical-application-signing-transactions-with-walletclient","title":"Step 5: Practical Application: Signing Transactions with <code>WalletClient</code>","text":"<p>Let's put our knowledge to practical use by creating and signing a Bitcoin transaction using the <code>WalletClient</code>.</p> <p>Create a file called <code>wallet-transaction-signing.ts</code>:</p> <pre><code>import { WalletClient, Transaction } from '@bsv/sdk'\n\nasync function walletTransactionDemo() {\n  console.log('\\n=== Transaction Signing with WalletClient ===')\n\n  try {\n    // 1. WalletClient Key Management\n    // Note: This tutorial requires a BSV wallet to be installed and available\n    // If you get connection errors, you may need to install a compatible BSV wallet\n    const wallet = new WalletClient('auto', 'localhost')\n\n    console.log('\\n1. WalletClient Key Management')\n\n    // Define protocol and key identifiers for wallet operations\n    // Use 1 to represent medium security level\n    // Cast it to any to bypass strict type checking since we don't have the SecurityLevel enum\n    const protocolID = [1, 'example'] as any\n    const keyID = 'transaction-signing-key'\n\n    console.log(`Protocol ID: ${protocolID[0]}-${protocolID[1]}`)\n    console.log(`Key ID: ${keyID}`)\n\n    // Get a public key from the wallet\n    // In a real application, this would be a key securely managed by the wallet\n    const publicKeyResult = await wallet.getPublicKey({ protocolID, keyID })\n    const publicKeyHex = publicKeyResult.publicKey\n    console.log(`Public Key: ${publicKeyHex}`)\n\n    // 2. Creating a transaction with WalletClient\n    console.log('\\n2. Creating a transaction with WalletClient')\n\n    // Set up payment details\n    const recipientAddress = '1DBz6V6CmvjZTvfjvJpfnrBk9Lf8fJ8dW8' // Example recipient\n    const amountSatoshis = 100\n\n    // Create a payment action using WalletClient\n    // This builds a complete transaction structure internally\n    const actionResult = await wallet.createAction({\n      description: `Payment to ${recipientAddress}`,\n      // Define outputs for the transaction\n      outputs: [\n        {\n          // In a real application, you would create a proper P2PKH script for the recipient\n          lockingScript: '76a914eb0bd5edba389198e73f8efabddfc61666969ff788ac', // Example P2PKH script\n          satoshis: amountSatoshis,\n          outputDescription: `Payment to ${recipientAddress}`\n        }\n      ],\n      // Set options to ensure we get a signable transaction\n      options: {\n        signAndProcess: false // This ensures we get a signable transaction back\n      }\n    })\n\n    console.log('Payment action created:')\n    if (actionResult.signableTransaction) {\n      console.log(`- Action Reference: ${actionResult.signableTransaction.reference}`)\n      console.log(`- Transaction available: ${!!actionResult.signableTransaction.tx}`)\n    } else {\n      console.log('No signable transaction returned - check wallet configuration')\n      return\n    }\n    console.log(`- Description: Payment to ${recipientAddress}`)\n    console.log(`- Amount: ${amountSatoshis} satoshis`)\n\n    // 3. Sign the transaction with WalletClient\n    console.log('\\n3. Signing transaction with WalletClient')\n\n    // Request wallet to sign the action/transaction\n    const signResult = await wallet.signAction({\n      // Use the reference from the createAction result\n      reference: actionResult.signableTransaction.reference,\n      // For wallet-managed transactions, we can let the wallet handle unlocking scripts\n      spends: {},\n      // Add options to ensure proper handling\n      options: {\n        acceptDelayedBroadcast: true,\n        returnTXIDOnly: false,\n        noSend: true // Don't broadcast automatically for this tutorial\n      }\n    })\n\n    console.log('Transaction signed successfully!')\n    if (signResult.txid) {\n      console.log(`Transaction ID: ${signResult.txid}`)\n    }\n\n    // 4. Examine the transaction\n    console.log('\\n4. Examining the transaction')\n\n    // Check if we have a transaction ID from the sign result\n    if (signResult.txid) {\n      console.log(`Transaction ID: ${signResult.txid}`)\n      console.log('Transaction was successfully signed!')\n    } else {\n      console.log('No transaction ID available - transaction may not have been completed')\n    }\n\n  } catch (error) {\n    console.error('Error during wallet transaction operations:', error)\n  }\n}\n\n// Run the demo\nwalletTransactionDemo().catch(console.error)\n</code></pre> <p>Run the script:</p> <pre><code>npx ts-node wallet-transaction-signing.ts\n</code></pre> <p>This example demonstrates:</p> <ol> <li>Creating a transaction with inputs and outputs</li> <li>Getting the transaction hash that needs to be signed</li> <li>How the <code>WalletClient</code> would sign this hash securely</li> <li>Verifying the transaction signature</li> <li>The complete <code>WalletClient</code> workflow for real applications</li> </ol> <p>For a detailed comparison between <code>WalletClient</code> transaction signing and low-level transaction signing approaches, see the Transaction Signing Methods guide.</p>"},{"location":"tutorials/key-management/#advanced-transaction-signing","title":"Advanced Transaction Signing","text":"<p>For more advanced transaction signing techniques like using different SIGHASH flags, manual signature creation, and multi-signature transactions, please refer to the Advanced Transaction Signing guide.</p>"},{"location":"tutorials/key-management/#conclusion","title":"Conclusion","text":"<p>Congratulations! You've learned the fundamentals of key management and cryptography with the BSV TypeScript SDK. In this tutorial, you've:</p> <ul> <li>Generated and managed private/public keys</li> <li>Created and verified digital signatures using both direct cryptography APIs and <code>WalletClient</code></li> <li>Applied signatures in a Bitcoin transaction context using <code>WalletClient</code></li> <li>Learned best practices for secure key management</li> </ul> <p>These cryptographic concepts form the foundation of Bitcoin and blockchain technology. By understanding how keys and signatures work, you're well-equipped to build secure and robust applications using the BSV TypeScript SDK.</p> <p>For more advanced techniques like different signature hash types (SIGHASH flags), manual signature creation, and multi-signature transactions, refer to the following documents:</p> <ul> <li>Advanced Transaction Signing (How-To Guide)</li> <li>Transaction Signatures Reference (Technical Reference)</li> </ul>"},{"location":"tutorials/key-management/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about Transaction Broadcasting and ARC</li> <li>Explore Advanced Transaction Construction</li> <li>Dive deeper into Script Construction and Custom Logic</li> </ul>"},{"location":"tutorials/protowallet-development/","title":"Working with ProtoWallet for Development","text":"<p>Duration: 45 minutes Prerequisites: Node.js, basic TypeScript knowledge, completed \"Your First BSV Transaction\" tutorial Learning Goals:</p> <ul> <li>Understand ProtoWallet's role in development and testing</li> <li>Implement cryptographic operations without blockchain interaction</li> <li>Use ProtoWallet for key derivation and signing</li> <li>Build development tools and testing frameworks</li> </ul>"},{"location":"tutorials/protowallet-development/#introduction","title":"Introduction","text":"<p>ProtoWallet is a lightweight wallet implementation designed for development and testing scenarios. Unlike full wallets, ProtoWallet focuses purely on cryptographic operations without blockchain interaction, making it perfect for:</p> <ul> <li>Development and testing environments</li> <li>Cryptographic operation prototyping</li> <li>Key derivation and signing operations</li> <li>Building wallet-like functionality without full wallet complexity</li> </ul>"},{"location":"tutorials/protowallet-development/#what-youll-build","title":"What You'll Build","text":"<p>In this tutorial, you'll create a development toolkit using ProtoWallet that includes:</p> <ul> <li>Key generation and management</li> <li>Message signing and verification</li> <li>Symmetric encryption/decryption</li> <li>HMAC creation and verification</li> </ul>"},{"location":"tutorials/protowallet-development/#setting-up-protowallet","title":"Setting Up ProtoWallet","text":""},{"location":"tutorials/protowallet-development/#basic-protowallet-creation","title":"Basic ProtoWallet Creation","text":"<pre><code>import { ProtoWallet, PrivateKey } from '@bsv/sdk'\n\nasync function createProtoWallet() {\n  // Create with a random private key\n  const randomWallet = new ProtoWallet(PrivateKey.fromRandom())\n\n  // Create with a specific private key\n  const privateKey = PrivateKey.fromRandom()\n  const specificWallet = new ProtoWallet(privateKey)\n\n  // Create with 'anyone' key (for testing)\n  const anyoneWallet = new ProtoWallet('anyone')\n\n  console.log('ProtoWallet instances created successfully')\n  return { randomWallet, specificWallet, anyoneWallet }\n}\n\ncreateProtoWallet().catch(console.error)\n</code></pre>"},{"location":"tutorials/protowallet-development/#getting-public-keys","title":"Getting Public Keys","text":"<pre><code>import { ProtoWallet } from '@bsv/sdk'\n\nasync function demonstratePublicKeys() {\n  const wallet = new ProtoWallet(PrivateKey.fromRandom())\n\n  // Get identity public key\n  const { publicKey: identityKey } = await wallet.getPublicKey({\n    identityKey: true\n  })\n  console.log('Identity Key:', identityKey)\n\n  // Get derived public key for a protocol\n  const { publicKey: protocolKey } = await wallet.getPublicKey({\n    protocolID: [1, 'my-app'],\n    keyID: 'user-signing-key'\n  })\n  console.log('Protocol Key:', protocolKey)\n\n  // Get public key for counterparty communication\n  const { publicKey: counterpartyKey } = await wallet.getPublicKey({\n    protocolID: [1, 'messaging'],\n    keyID: 'chat-key',\n    counterparty: identityKey\n  })\n  console.log('Counterparty Key:', counterpartyKey)\n}\n\ndemonstratePublicKeys().catch(console.error)\n</code></pre>"},{"location":"tutorials/protowallet-development/#digital-signatures-with-protowallet","title":"Digital Signatures with ProtoWallet","text":""},{"location":"tutorials/protowallet-development/#creating-and-verifying-signatures","title":"Creating and Verifying Signatures","text":"<pre><code>import { ProtoWallet, Utils } from '@bsv/sdk'\n\nasync function demonstrateSignatures() {\n  const wallet = new ProtoWallet(PrivateKey.fromRandom())\n\n  // Message to sign\n  const message = 'Hello, BSV development!'\n  const messageBytes = Utils.toArray(message, 'utf8')\n\n  // Create signature\n  const { signature } = await wallet.createSignature({\n    data: messageBytes,\n    protocolID: [1, 'document signing'],\n    keyID: 'doc-key',\n    counterparty: 'self'\n  })\n\n  console.log('Message:', message)\n  console.log('Signature:', Utils.toBase64(signature))\n\n  // Verify signature\n  const { valid } = await wallet.verifySignature({\n    data: messageBytes,\n    signature,\n    protocolID: [1, 'document signing'],\n    keyID: 'doc-key',\n    counterparty: 'self'\n  })\n\n  console.log('Signature valid:', valid)\n\n  return { message, signature, valid }\n}\n\ndemonstrateSignatures().catch(console.error)\n</code></pre>"},{"location":"tutorials/protowallet-development/#advanced-signature-scenarios","title":"Advanced Signature Scenarios","text":"<pre><code>import { ProtoWallet, Utils } from '@bsv/sdk'\n\nclass DocumentSigner {\n  private wallet: ProtoWallet\n\n  constructor() {\n    this.wallet = new ProtoWallet(PrivateKey.fromRandom())\n  }\n\n  async signDocument(content: string, documentId: string): Promise&lt;{\n    signature: number[]\n    publicKey: string\n    timestamp: number\n  }&gt; {\n    const timestamp = Date.now()\n    const documentData = {\n      content,\n      documentId,\n      timestamp\n    }\n\n    const dataToSign = Utils.toArray(JSON.stringify(documentData), 'utf8')\n\n    const { signature } = await this.wallet.createSignature({\n      data: dataToSign,\n      protocolID: [1, 'document system'],\n      keyID: `doc-${documentId}`,\n      counterparty: 'self'\n    })\n\n    const { publicKey } = await this.wallet.getPublicKey({\n      protocolID: [1, 'document system'],\n      keyID: `doc-${documentId}`\n    })\n\n    return { signature, publicKey, timestamp }\n  }\n\n  async verifyDocument(\n    content: string,\n    documentId: string,\n    signature: number[],\n    timestamp: number\n  ): Promise&lt;boolean&gt; {\n    const documentData = {\n      content,\n      documentId,\n      timestamp\n    }\n\n    const dataToVerify = Utils.toArray(JSON.stringify(documentData), 'utf8')\n\n    const { valid } = await this.wallet.verifySignature({\n      data: dataToVerify,\n      signature,\n      protocolID: [1, 'document system'],\n      keyID: `doc-${documentId}`,\n      counterparty: 'self'\n    })\n\n    return valid\n  }\n}\n\nasync function demonstrateDocumentSigning() {\n  const signer = new DocumentSigner()\n\n  const document = {\n    content: 'This is a confidential document requiring digital signature.',\n    id: 'contract-2024-001'\n  }\n\n  // Sign document\n  const signatureData = await signer.signDocument(document.content, document.id)\n  console.log('Document signed:', {\n    documentId: document.id,\n    publicKey: signatureData.publicKey,\n    timestamp: new Date(signatureData.timestamp).toISOString()\n  })\n\n  // Verify document\n  const isValid = await signer.verifyDocument(\n    document.content,\n    document.id,\n    signatureData.signature,\n    signatureData.timestamp\n  )\n\n  console.log('Document verification:', isValid ? 'VALID' : 'INVALID')\n\n  return { signatureData, isValid }\n}\n\ndemonstrateDocumentSigning().catch(console.error)\n</code></pre>"},{"location":"tutorials/protowallet-development/#encryption-and-decryption","title":"Encryption and Decryption","text":""},{"location":"tutorials/protowallet-development/#symmetric-encryption","title":"Symmetric Encryption","text":"<pre><code>import { ProtoWallet, Utils } from '@bsv/sdk'\n\nasync function demonstrateEncryption() {\n  const wallet = new ProtoWallet(PrivateKey.fromRandom())\n\n  // Data to encrypt\n  const secretMessage = 'This is confidential development data'\n  const plaintext = Utils.toArray(secretMessage, 'utf8')\n\n  // Encrypt data\n  const { ciphertext } = await wallet.encrypt({\n    plaintext,\n    protocolID: [1, 'secure storage'],\n    keyID: 'data-encryption-key'\n  })\n\n  console.log('Original message:', secretMessage)\n  console.log('Encrypted (base64):', Utils.toBase64(ciphertext))\n\n  // Decrypt data\n  const { plaintext: decrypted } = await wallet.decrypt({\n    ciphertext,\n    protocolID: [1, 'secure storage'],\n    keyID: 'data-encryption-key'\n  })\n\n  const decryptedMessage = Utils.toUTF8(decrypted)\n  console.log('Decrypted message:', decryptedMessage)\n\n  return { original: secretMessage, decrypted: decryptedMessage }\n}\n\ndemonstrateEncryption().catch(console.error)\n</code></pre>"},{"location":"tutorials/protowallet-development/#counterparty-encryption","title":"Counterparty Encryption","text":"<pre><code>import { ProtoWallet, Utils } from '@bsv/sdk'\n\nclass SecureMessaging {\n  private aliceWallet: ProtoWallet\n  private bobWallet: ProtoWallet\n  private aliceIdentity: string\n  private bobIdentity: string\n\n  constructor() {\n    this.aliceWallet = new ProtoWallet(PrivateKey.fromRandom())\n    this.bobWallet = new ProtoWallet(PrivateKey.fromRandom())\n  }\n\n  async initialize() {\n    // Get identity keys for both parties\n    const aliceKey = await this.aliceWallet.getPublicKey({ identityKey: true })\n    const bobKey = await this.bobWallet.getPublicKey({ identityKey: true })\n\n    this.aliceIdentity = aliceKey.publicKey\n    this.bobIdentity = bobKey.publicKey\n\n    console.log('Alice Identity:', this.aliceIdentity.substring(0, 20) + '...')\n    console.log('Bob Identity:', this.bobIdentity.substring(0, 20) + '...')\n  }\n\n  async aliceSendsToBob(message: string): Promise&lt;string&gt; {\n    const plaintext = Utils.toArray(message, 'utf8')\n\n    const { ciphertext } = await this.aliceWallet.encrypt({\n      plaintext,\n      protocolID: [1, 'secure chat'],\n      keyID: 'message-key',\n      counterparty: this.bobIdentity\n    })\n\n    console.log('Alice encrypts message for Bob')\n    return Utils.toBase64(ciphertext)\n  }\n\n  async bobReceivesFromAlice(ciphertext: string): Promise&lt;string&gt; {\n    const ciphertextBytes = Utils.toArray(ciphertext, 'base64')\n\n    const { plaintext } = await this.bobWallet.decrypt({\n      ciphertext: ciphertextBytes,\n      protocolID: [1, 'secure chat'],\n      keyID: 'message-key',\n      counterparty: this.aliceIdentity\n    })\n\n    const message = Utils.toUTF8(plaintext)\n    console.log('Bob decrypts message from Alice')\n    return message\n  }\n}\n\nasync function demonstrateSecureMessaging() {\n  const messaging = new SecureMessaging()\n  await messaging.initialize()\n\n  const originalMessage = 'Hello Bob, this is a secure message from Alice!'\n\n  // Alice encrypts and sends\n  const encryptedMessage = await messaging.aliceSendsToBob(originalMessage)\n  console.log('Encrypted message length:', encryptedMessage.length, 'bytes')\n\n  // Bob receives and decrypts\n  const decryptedMessage = await messaging.bobReceivesFromAlice(encryptedMessage)\n\n  console.log('Original:', originalMessage)\n  console.log('Decrypted:', decryptedMessage)\n  console.log('Messages match:', originalMessage === decryptedMessage)\n\n  return { originalMessage, decryptedMessage }\n}\n\ndemonstrateSecureMessaging().catch(console.error)\n</code></pre>"},{"location":"tutorials/protowallet-development/#hmac-operations","title":"HMAC Operations","text":""},{"location":"tutorials/protowallet-development/#creating-and-verifying-hmacs","title":"Creating and Verifying HMACs","text":"<pre><code>import { ProtoWallet, Utils } from '@bsv/sdk'\n\nasync function demonstrateHMAC() {\n  const wallet = new ProtoWallet(PrivateKey.fromRandom())\n\n  // Data to authenticate\n  const data = Utils.toArray('Important data requiring integrity verification', 'utf8')\n\n  // Create HMAC\n  const { hmac } = await wallet.createHmac({\n    data,\n    protocolID: [1, 'data integrity'],\n    keyID: 'hmac-key'\n  })\n\n  console.log('Data:', Utils.toUTF8(data))\n  console.log('HMAC:', Utils.toHex(hmac))\n\n  // Verify HMAC\n  const { valid } = await wallet.verifyHmac({\n    data,\n    hmac,\n    protocolID: [1, 'data integrity'],\n    keyID: 'hmac-key'\n  })\n\n  console.log('HMAC valid:', valid)\n\n  // Test with tampered data\n  const tamperedData = Utils.toArray('Tampered data requiring integrity verification', 'utf8')\n  const { valid: tamperedValid } = await wallet.verifyHmac({\n    data: tamperedData,\n    hmac,\n    protocolID: [1, 'data integrity'],\n    keyID: 'hmac-key'\n  })\n\n  console.log('Tampered data HMAC valid:', tamperedValid)\n\n  return { valid, tamperedValid }\n}\n\ndemonstrateHMAC().catch(console.error)\n</code></pre>"},{"location":"tutorials/protowallet-development/#building-a-development-toolkit","title":"Building a Development Toolkit","text":""},{"location":"tutorials/protowallet-development/#complete-protowallet-utility-class","title":"Complete ProtoWallet Utility Class","text":"<pre><code>import { ProtoWallet, PrivateKey, Utils } from '@bsv/sdk'\n\nexport class DevelopmentWallet {\n  private wallet: ProtoWallet\n  private identityKey: string | null = null\n\n  constructor(privateKey?: PrivateKey) {\n    this.wallet = new ProtoWallet(privateKey)\n  }\n\n  async getIdentity(): Promise&lt;string&gt; {\n    if (!this.identityKey) {\n      const { publicKey } = await this.wallet.getPublicKey({ identityKey: true })\n      this.identityKey = publicKey\n    }\n    return this.identityKey\n  }\n\n  async signData(data: string, protocolId: string, keyId: string): Promise&lt;{\n    signature: string\n    publicKey: string\n    data: string\n  }&gt; {\n    const dataBytes = Utils.toArray(data, 'utf8')\n\n    const { signature } = await this.wallet.createSignature({\n      data: dataBytes,\n      protocolID: [1, protocolId],\n      keyID: keyId,\n      counterparty: 'self'\n    })\n\n    const { publicKey } = await this.wallet.getPublicKey({\n      protocolID: [1, protocolId],\n      keyID: keyId\n    })\n\n    return {\n      signature: Utils.toBase64(signature),\n      publicKey,\n      data\n    }\n  }\n\n  async verifyData(\n    data: string,\n    signature: string,\n    protocolId: string,\n    keyId: string\n  ): Promise&lt;boolean&gt; {\n    const dataBytes = Utils.toArray(data, 'utf8')\n    const signatureBytes = Utils.toArray(signature, 'base64')\n\n    const { valid } = await this.wallet.verifySignature({\n      data: dataBytes,\n      signature: signatureBytes,\n      protocolID: [1, protocolId],\n      keyID: keyId,\n      counterparty: 'self'\n    })\n\n    return valid\n  }\n\n  async encryptForSelf(data: string, protocolId: string, keyId: string): Promise&lt;string&gt; {\n    const plaintext = Utils.toArray(data, 'utf8')\n\n    const { ciphertext } = await this.wallet.encrypt({\n      plaintext,\n      protocolID: [1, protocolId],\n      keyID: keyId\n    })\n\n    return Utils.toBase64(ciphertext)\n  }\n\n  async decryptFromSelf(\n    encryptedData: string,\n    protocolId: string,\n    keyId: string\n  ): Promise&lt;string&gt; {\n    const ciphertext = Utils.toArray(encryptedData, 'base64')\n\n    const { plaintext } = await this.wallet.decrypt({\n      ciphertext,\n      protocolID: [1, protocolId],\n      keyID: keyId\n    })\n\n    return Utils.toUTF8(plaintext)\n  }\n\n  async createDataIntegrityTag(data: string, protocolId: string, keyId: string): Promise&lt;string&gt; {\n    const dataBytes = Utils.toArray(data, 'utf8')\n\n    const { hmac } = await this.wallet.createHmac({\n      data: dataBytes,\n      protocolID: [1, protocolId],\n      keyID: keyId\n    })\n\n    return Utils.toHex(hmac)\n  }\n\n  async verifyDataIntegrity(\n    data: string,\n    integrityTag: string,\n    protocolId: string,\n    keyId: string\n  ): Promise&lt;boolean&gt; {\n    const dataBytes = Utils.toArray(data, 'utf8')\n    const hmac = Utils.toArray(integrityTag, 'hex')\n\n    const { valid } = await this.wallet.verifyHmac({\n      data: dataBytes,\n      hmac,\n      protocolID: [1, protocolId],\n      keyID: keyId\n    })\n\n    return valid\n  }\n}\n\nasync function demonstrateDevelopmentToolkit() {\n  const devWallet = new DevelopmentWallet()\n\n  console.log('=== Development Wallet Toolkit Demo ===')\n\n  // Get identity\n  const identity = await devWallet.getIdentity()\n  console.log('Wallet Identity:', identity.substring(0, 20) + '...')\n\n  // Sign and verify data\n  const testData = 'Development test data for signing'\n  const signatureResult = await devWallet.signData(testData, 'dev-tools', 'test-key')\n  console.log('Data signed successfully')\n\n  const isValid = await devWallet.verifyData(\n    testData,\n    signatureResult.signature,\n    'dev-tools',\n    'test-key'\n  )\n  console.log('Signature verification:', isValid ? 'PASSED' : 'FAILED')\n\n  // Encrypt and decrypt data\n  const secretData = 'Confidential development information'\n  const encrypted = await devWallet.encryptForSelf(secretData, 'dev-storage', 'secret-key')\n  console.log('Data encrypted successfully')\n\n  const decrypted = await devWallet.decryptFromSelf(encrypted, 'dev-storage', 'secret-key')\n  console.log('Decryption result:', secretData === decrypted ? 'PASSED' : 'FAILED')\n\n  // Create and verify integrity tag\n  const importantData = 'Critical development configuration'\n  const integrityTag = await devWallet.createDataIntegrityTag(\n    importantData,\n    'dev-integrity',\n    'config-key'\n  )\n  console.log('Integrity tag created')\n\n  const integrityValid = await devWallet.verifyDataIntegrity(\n    importantData,\n    integrityTag,\n    'dev-integrity',\n    'config-key'\n  )\n  console.log('Integrity verification:', integrityValid ? 'PASSED' : 'FAILED')\n\n  return {\n    identity,\n    signatureValid: isValid,\n    decryptionValid: secretData === decrypted,\n    integrityValid\n  }\n}\n\ndemonstrateDevelopmentToolkit().catch(console.error)\n</code></pre>"},{"location":"tutorials/protowallet-development/#testing-framework-integration","title":"Testing Framework Integration","text":""},{"location":"tutorials/protowallet-development/#protowallet-test-utilities","title":"ProtoWallet Test Utilities","text":"<pre><code>import { ProtoWallet, PrivateKey, Utils } from '@bsv/sdk'\n\nexport class ProtoWalletTestUtils {\n  static createTestWallet(seed?: string): ProtoWallet {\n    if (seed) {\n      // Create deterministic wallet for testing\n      const hash = Utils.toArray(seed, 'utf8')\n      const privateKey = PrivateKey.fromString(Utils.toHex(hash).padEnd(64, '0'))\n      return new ProtoWallet(privateKey)\n    }\n    return new ProtoWallet(PrivateKey.fromRandom())\n  }\n\n  static async createTestIdentities(count: number): Promise&lt;{\n    wallets: ProtoWallet[]\n    identities: string[]\n  }&gt; {\n    const wallets: ProtoWallet[] = []\n    const identities: string[] = []\n\n    for (let i = 0; i &lt; count; i++) {\n      const wallet = this.createTestWallet(`test-identity-${i}`)\n      const { publicKey } = await wallet.getPublicKey({ identityKey: true })\n\n      wallets.push(wallet)\n      identities.push(publicKey)\n    }\n\n    return { wallets, identities }\n  }\n\n  static async testCryptographicRoundTrip(\n    wallet: ProtoWallet,\n    data: string,\n    protocolId: string,\n    keyId: string\n  ): Promise&lt;{\n    signatureValid: boolean\n    encryptionValid: boolean\n    hmacValid: boolean\n  }&gt; {\n    const dataBytes = Utils.toArray(data, 'utf8')\n\n    // Test signature round trip\n    const { signature } = await wallet.createSignature({\n      data: dataBytes,\n      protocolID: [1, protocolId],\n      keyID: keyId,\n      counterparty: 'self'\n    })\n\n    const { valid: signatureValid } = await wallet.verifySignature({\n      data: dataBytes,\n      signature,\n      protocolID: [1, protocolId],\n      keyID: keyId,\n      counterparty: 'self'\n    })\n\n    // Test encryption round trip\n    const { ciphertext } = await wallet.encrypt({\n      plaintext: dataBytes,\n      protocolID: [1, protocolId],\n      keyID: keyId\n    })\n\n    const { plaintext } = await wallet.decrypt({\n      ciphertext,\n      protocolID: [1, protocolId],\n      keyID: keyId\n    })\n\n    const encryptionValid = Utils.toUTF8(plaintext) === data\n\n    // Test HMAC round trip\n    const { hmac } = await wallet.createHmac({\n      data: dataBytes,\n      protocolID: [1, protocolId],\n      keyID: keyId\n    })\n\n    const { valid: hmacValid } = await wallet.verifyHmac({\n      data: dataBytes,\n      hmac,\n      protocolID: [1, protocolId],\n      keyID: keyId\n    })\n\n    return { signatureValid, encryptionValid, hmacValid }\n  }\n}\n\nasync function runTestSuite() {\n  console.log('=== ProtoWallet Test Suite ===')\n\n  // Test deterministic wallet creation\n  const wallet1 = ProtoWalletTestUtils.createTestWallet('test-seed-123')\n  const wallet2 = ProtoWalletTestUtils.createTestWallet('test-seed-123')\n\n  const identity1 = await wallet1.getPublicKey({ identityKey: true })\n  const identity2 = await wallet2.getPublicKey({ identityKey: true })\n\n  console.log('Deterministic wallet test:', \n    identity1.publicKey === identity2.publicKey ? 'PASSED' : 'FAILED')\n\n  // Test multiple identities\n  const { wallets, identities } = await ProtoWalletTestUtils.createTestIdentities(3)\n  console.log('Created test identities:', identities.length)\n\n  // Test cryptographic operations\n  const testData = 'Test data for cryptographic operations'\n  const results = await ProtoWalletTestUtils.testCryptographicRoundTrip(\n    wallets[0],\n    testData,\n    'test-protocol',\n    'test-key'\n  )\n\n  console.log('Cryptographic tests:')\n  console.log('  Signature:', results.signatureValid ? 'PASSED' : 'FAILED')\n  console.log('  Encryption:', results.encryptionValid ? 'PASSED' : 'FAILED')\n  console.log('  HMAC:', results.hmacValid ? 'PASSED' : 'FAILED')\n\n  return results\n}\n\nrunTestSuite().catch(console.error)\n</code></pre>"},{"location":"tutorials/protowallet-development/#conclusion","title":"Conclusion","text":"<p>Congratulations! You've successfully built a comprehensive ProtoWallet development framework using the BSV TypeScript SDK. In this tutorial, you've learned how to create, test, and manage prototype wallet implementations for rapid development and testing.</p>"},{"location":"tutorials/protowallet-development/#core-concepts-mastered","title":"Core Concepts Mastered","text":"<ol> <li>ProtoWallet Architecture: Implemented lightweight wallet prototypes for development and testing</li> <li>Key Management: Created deterministic key generation and management systems</li> <li>Cryptographic Operations: Implemented signing, encryption, and HMAC operations</li> <li>Protocol Integration: Built protocol-specific wallet functionality with proper key derivation</li> <li>Testing Framework: Developed comprehensive testing utilities for wallet validation</li> </ol>"},{"location":"tutorials/protowallet-development/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about Development Wallet Setup for production-ready wallet implementation</li> <li>Explore Key Management for advanced cryptographic key handling</li> <li>Understand Security Best Practices for secure wallet development</li> </ul>"},{"location":"tutorials/protowallet-development/#additional-resources","title":"Additional Resources","text":"<ul> <li>Wallet API Reference</li> <li>Key Management Concepts</li> <li>BSV Wallet Standards</li> </ul>"},{"location":"tutorials/script-construction/","title":"Script Construction and Custom Logic","text":"<p>Learn how to create, manipulate, and implement custom Bitcoin scripts using the BSV TypeScript SDK. This tutorial covers both basic script operations and advanced script template creation.</p>"},{"location":"tutorials/script-construction/#prerequisites","title":"Prerequisites","text":"<ul> <li>Completed \"Your First BSV Transaction\" tutorial</li> <li>Basic understanding of Bitcoin script operations</li> <li>Node.js and TypeScript knowledge</li> </ul> <p>\ud83d\udcda Related Concepts: Review Script Templates and Transaction Structure for foundational understanding. See OP Codes Reference for complete opcode documentation.</p>"},{"location":"tutorials/script-construction/#learning-goals","title":"Learning Goals","text":"<ul> <li>Understand Bitcoin script fundamentals</li> <li>Create and serialize scripts in different formats</li> <li>Build custom script templates</li> <li>Implement locking and unlocking logic</li> <li>Work with opcodes and script chunks</li> </ul> <p>\ud83d\udca1 Try It Interactive: Test script construction and custom templates in our Interactive BSV Coding Environment - experiment with opcodes and script logic in real-time!</p>"},{"location":"tutorials/script-construction/#duration","title":"Duration","text":"<p>60 minutes</p>"},{"location":"tutorials/script-construction/#part-1-script-fundamentals","title":"Part 1: Script Fundamentals","text":""},{"location":"tutorials/script-construction/#understanding-bitcoin-scripts","title":"Understanding Bitcoin Scripts","text":"<p>Bitcoin scripts are small programs that define the conditions under which bitcoins can be spent. They consist of:</p> <ul> <li>Locking Scripts: Define spending conditions (found in transaction outputs)</li> <li>Unlocking Scripts: Provide evidence to satisfy conditions (found in transaction inputs)</li> </ul>"},{"location":"tutorials/script-construction/#setting-up","title":"Setting Up","text":"<p>First, install the SDK and import the necessary modules:</p> <pre><code>npm install @bsv/sdk\n</code></pre> <pre><code>import { \n  Script, \n  LockingScript, \n  UnlockingScript, \n  OP, \n  PrivateKey, \n  P2PKH,\n  ScriptTemplate,\n  Transaction,\n  Hash\n} from '@bsv/sdk'\n</code></pre>"},{"location":"tutorials/script-construction/#creating-scripts-from-different-formats","title":"Creating Scripts from Different Formats","text":"<p>The SDK supports creating scripts from various formats:</p>"},{"location":"tutorials/script-construction/#from-asm-assembly","title":"From ASM (Assembly)","text":"<pre><code>// Create a P2PKH script from ASM\nconst scriptFromASM = Script.fromASM(\n  'OP_DUP OP_HASH160 1451baa3aad777144a0759998a03538018dd7b4b OP_EQUALVERIFY OP_CHECKSIG'\n)\n\nconsole.log('Script from ASM:', scriptFromASM.toHex())\n</code></pre>"},{"location":"tutorials/script-construction/#from-hexadecimal","title":"From Hexadecimal","text":"<pre><code>// Create script from hex\nconst scriptFromHex = Script.fromHex('76a9141451baa3aad777144a0759998a03538018dd7b4b88ac')\n\nconsole.log('Script from hex:', scriptFromHex.toASM())\n</code></pre>"},{"location":"tutorials/script-construction/#from-binary-array","title":"From Binary Array","text":"<pre><code>// Create script from binary data\nconst binaryData = [OP.OP_TRUE, OP.OP_RETURN, 4, 0x74, 0x65, 0x73, 0x74]\nconst scriptFromBinary = Script.fromBinary(binaryData)\n\nconsole.log('Script from binary:', scriptFromBinary.toASM())\n</code></pre>"},{"location":"tutorials/script-construction/#script-serialization","title":"Script Serialization","text":"<p>Convert scripts between different formats for storage or transmission:</p> <pre><code>const script = Script.fromASM('OP_DUP OP_HASH160 1451baa3aad777144a0759998a03538018dd7b4b OP_EQUALVERIFY OP_CHECKSIG')\n\n// Serialize to different formats\nconst scriptAsHex = script.toHex()\nconst scriptAsASM = script.toASM()\nconst scriptAsBinary = script.toBinary()\n\nconsole.log('Hex:', scriptAsHex)\nconsole.log('ASM:', scriptAsASM)\nconsole.log('Binary length:', scriptAsBinary.length)\n</code></pre>"},{"location":"tutorials/script-construction/#part-2-working-with-script-chunks","title":"Part 2: Working with Script Chunks","text":""},{"location":"tutorials/script-construction/#understanding-script-chunks","title":"Understanding Script Chunks","text":"<p>Scripts are composed of chunks, each containing either an opcode or data:</p> <pre><code>// Create a script with mixed opcodes and data\nconst script = new Script([\n  { op: OP.OP_DUP },\n  { op: OP.OP_HASH160 },\n  { op: 20, data: [0x14, 0x51, 0xba, 0xa3, 0xaa, 0xd7, 0x77, 0x14, 0x4a, 0x07, 0x59, 0x99, 0x8a, 0x03, 0x53, 0x80, 0x18, 0xdd, 0x7b, 0x4b] },\n  { op: OP.OP_EQUALVERIFY },\n  { op: OP.OP_CHECKSIG }\n])\n\nconsole.log('Script chunks:', script.chunks.length)\nconsole.log('Script ASM:', script.toASM())\n</code></pre>"},{"location":"tutorials/script-construction/#building-scripts-programmatically","title":"Building Scripts Programmatically","text":"<pre><code>// Build a script step by step\nconst script = new Script()\n\n// Add opcodes\nscript.writeOpCode(OP.OP_DUP)\nscript.writeOpCode(OP.OP_HASH160)\n\n// Add data\nconst pubkeyHash = [0x14, 0x51, 0xba, 0xa3, 0xaa, 0xd7, 0x77, 0x14, 0x4a, 0x07, 0x59, 0x99, 0x8a, 0x03, 0x53, 0x80, 0x18, 0xdd, 0x7b, 0x4b]\nscript.writeBin(pubkeyHash)\n\n// Add more opcodes\nscript.writeOpCode(OP.OP_EQUALVERIFY)\nscript.writeOpCode(OP.OP_CHECKSIG)\n\nconsole.log('Built script:', script.toASM())\n</code></pre>"},{"location":"tutorials/script-construction/#adding-numbers-and-data","title":"Adding Numbers and Data","text":"<pre><code>const script = new Script()\n\n// Add numbers (automatically encoded)\nscript.writeNumber(42)\nscript.writeNumber(1000)\n\n// Add binary data\nscript.writeBin([0x48, 0x65, 0x6c, 0x6c, 0x6f]) // \"Hello\"\n\n// Add another script\nconst dataScript = Script.fromASM('OP_TRUE OP_FALSE')\nscript.writeScript(dataScript)\n\nconsole.log('Data script:', script.toASM())\n</code></pre>"},{"location":"tutorials/script-construction/#part-3-standard-script-templates","title":"Part 3: Standard Script Templates","text":""},{"location":"tutorials/script-construction/#using-p2pkh-template","title":"Using P2PKH Template","text":"<p>The P2PKH (Pay to Public Key Hash) template is the most common script type:</p> <pre><code>async function runP2PKHExample() {\n  // Generate a key pair\n  const privateKey = PrivateKey.fromRandom()\n  const publicKey = privateKey.toPublicKey()\n  const pubkeyHash = publicKey.toHash()\n\n  // Create P2PKH template\n  const p2pkh = new P2PKH()\n\n  // Create locking script\n  const lockingScript = p2pkh.lock(pubkeyHash)\n  console.log('P2PKH locking script:', lockingScript.toASM())\n\n  // Create unlocking script\n  const unlockingTemplate = p2pkh.unlock(privateKey)\n  console.log('Unlocking script estimate:', await unlockingTemplate.estimateLength())\n}\n\n// Run the example\nrunP2PKHExample().catch(console.error)\n</code></pre>"},{"location":"tutorials/script-construction/#data-storage-scripts","title":"Data Storage Scripts","text":"<p>Create scripts that store arbitrary data:</p> <pre><code>// Create a simple data storage script\nconst dataScript = new Script()\ndataScript.writeOpCode(OP.OP_FALSE)\ndataScript.writeOpCode(OP.OP_RETURN)\ndataScript.writeBin([0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x20, 0x57, 0x6f, 0x72, 0x6c, 0x64]) // \"Hello World\"\n\nconsole.log('Data script:', dataScript.toASM())\nconsole.log('Data script hex:', dataScript.toHex())\n</code></pre>"},{"location":"tutorials/script-construction/#part-4-custom-script-templates","title":"Part 4: Custom Script Templates","text":""},{"location":"tutorials/script-construction/#creating-a-simple-custom-template","title":"Creating a Simple Custom Template","text":"<p>Let's create a custom script template for a simple puzzle:</p> <pre><code>import { ScriptTemplate, LockingScript, UnlockingScript, OP, Transaction } from '@bsv/sdk'\n\nclass SimplePuzzle implements ScriptTemplate {\n  /**\n   * Creates a locking script that requires a specific number to unlock\n   */\n  lock(secretNumber: number): LockingScript {\n    const script = new LockingScript()\n    script.writeNumber(secretNumber)\n    script.writeOpCode(OP.OP_EQUAL)\n    return script\n  }\n\n  /**\n   * Creates an unlocking script with the secret number\n   */\n  unlock(secretNumber: number) {\n    return {\n      sign: async (tx: Transaction, inputIndex: number): Promise&lt;UnlockingScript&gt; =&gt; {\n        const script = new UnlockingScript()\n        script.writeNumber(secretNumber)\n        return script\n      },\n      estimateLength: async (): Promise&lt;number&gt; =&gt; {\n        // Estimate: number encoding (1-5 bytes) + push opcode (1 byte)\n        return 6\n      }\n    }\n  }\n}\n\nasync function runSimplePuzzleExample() {\n  // Usage example\n  const puzzle = new SimplePuzzle()\n  const secretNumber = 42\n\n  const lockingScript = puzzle.lock(secretNumber)\n  console.log('Puzzle locking script:', lockingScript.toASM())\n\n  const unlockingTemplate = puzzle.unlock(secretNumber)\n  console.log('Estimated unlock length:', await unlockingTemplate.estimateLength())\n}\n\n// Run the example\nrunSimplePuzzleExample().catch(console.error)\n</code></pre>"},{"location":"tutorials/script-construction/#advanced-custom-template-hash-puzzle","title":"Advanced Custom Template: Hash Puzzle","text":"<p>Create a more sophisticated template that uses hash functions:</p> <pre><code>class HashPuzzle implements ScriptTemplate {\n  /**\n   * Creates a locking script that requires the preimage of a hash\n   */\n  lock(hash: number[]): LockingScript {\n    const script = new LockingScript()\n    script.writeOpCode(OP.OP_SHA256)\n    script.writeBin(hash)\n    script.writeOpCode(OP.OP_EQUAL)\n    return script\n  }\n\n  /**\n   * Creates an unlocking script with the preimage\n   */\n  unlock(preimage: number[]) {\n    return {\n      sign: async (tx: Transaction, inputIndex: number): Promise&lt;UnlockingScript&gt; =&gt; {\n        const script = new UnlockingScript()\n        script.writeBin(preimage)\n        return script\n      },\n      estimateLength: async (): Promise&lt;number&gt; =&gt; {\n        // Estimate: preimage length + push opcodes\n        return preimage.length + 5\n      }\n    }\n  }\n}\n\nasync function runHashPuzzleExample() {\n  // Usage example\n  const hashPuzzle = new HashPuzzle()\n  const preimage = [0x48, 0x65, 0x6c, 0x6c, 0x6f] // \"Hello\"\n  const hash = Hash.sha256(preimage)\n\n  const lockingScript = hashPuzzle.lock(hash)\n  console.log('Hash puzzle locking script:', lockingScript.toASM())\n\n  const unlockingTemplate = hashPuzzle.unlock(preimage)\n  console.log('Hash puzzle unlock estimate:', await unlockingTemplate.estimateLength())\n}\n\n// Run the example\nrunHashPuzzleExample().catch(console.error)\n</code></pre>"},{"location":"tutorials/script-construction/#part-5-multi-signature-scripts","title":"Part 5: Multi-Signature Scripts","text":""},{"location":"tutorials/script-construction/#creating-multi-sig-templates","title":"Creating Multi-Sig Templates","text":"<pre><code>class MultiSig implements ScriptTemplate {\n  /**\n   * Creates a multi-signature locking script\n   */\n  lock(requiredSigs: number, publicKeys: number[][]): LockingScript {\n    const script = new LockingScript()\n\n    // Required signatures count\n    script.writeNumber(requiredSigs)\n\n    // Add public keys\n    for (const pubkey of publicKeys) {\n      script.writeBin(pubkey)\n    }\n\n    // Total public keys count\n    script.writeNumber(publicKeys.length)\n    script.writeOpCode(OP.OP_CHECKMULTISIG)\n\n    return script\n  }\n\n  /**\n   * Creates an unlocking script for multi-sig\n   */\n  unlock(signatures: number[][]) {\n    return {\n      sign: async (tx: Transaction, inputIndex: number): Promise&lt;UnlockingScript&gt; =&gt; {\n        const script = new UnlockingScript()\n\n        // OP_0 due to CHECKMULTISIG bug\n        script.writeOpCode(OP.OP_0)\n\n        // Add signatures\n        for (const sig of signatures) {\n          script.writeBin(sig)\n        }\n\n        return script\n      },\n      estimateLength: async (): Promise&lt;number&gt; =&gt; {\n        // Estimate: OP_0 + signatures with push opcodes\n        return 1 + signatures.reduce((total, sig) =&gt; total + sig.length + 1, 0)\n      }\n    }\n  }\n}\n\nasync function runMultiSigExample() {\n  // Usage example\n  const multiSig = new MultiSig()\n  const requiredSigs = 2\n  const publicKeys = [\n    [0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x30, 0x31, 0x32, 0x33],\n    [0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x60, 0x61, 0x62, 0x63, 0x64, 0x65]\n  ]\n\n  const lockingScript = multiSig.lock(requiredSigs, publicKeys)\n  console.log('Multi-sig locking script:', lockingScript.toASM())\n\n  const unlockingTemplate = multiSig.unlock([\n    [0x66, 0x67, 0x68, 0x69, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97],\n    [0x98, 0x99, 0x100, 0x101, 0x102, 0x103, 0x104, 0x105, 0x106, 0x107, 0x108, 0x109, 0x110, 0x111, 0x112, 0x113, 0x114, 0x115, 0x116, 0x117, 0x118, 0x119, 0x120, 0x121, 0x122, 0x123, 0x124, 0x125, 0x126, 0x127, 0x128, 0x129]\n  ])\n  console.log('Multi-sig unlock estimate:', await unlockingTemplate.estimateLength())\n}\n\n// Run the example\nrunMultiSigExample().catch(console.error)\n</code></pre>"},{"location":"tutorials/script-construction/#part-6-script-validation-and-testing","title":"Part 6: Script Validation and Testing","text":""},{"location":"tutorials/script-construction/#testing-script-templates","title":"Testing Script Templates","text":"<pre><code>// Test the simple puzzle template\nasync function testSimplePuzzle() {\n  const puzzle = new SimplePuzzle()\n  const secretNumber = 123\n\n  // Create locking script\n  const lockingScript = puzzle.lock(secretNumber)\n\n  // Create unlocking script\n  const unlockingTemplate = puzzle.unlock(secretNumber)\n\n  // In a real scenario, you would use this with a transaction\n  console.log('Puzzle test:')\n  console.log('Locking script:', lockingScript.toASM())\n  console.log('Estimated unlock length:', await unlockingTemplate.estimateLength())\n\n  // Test with wrong number\n  const wrongUnlock = puzzle.unlock(456)\n  console.log('Wrong unlock estimate:', await wrongUnlock.estimateLength())\n}\n\ntestSimplePuzzle()\n</code></pre>"},{"location":"tutorials/script-construction/#script-analysis","title":"Script Analysis","text":"<pre><code>// Analyze script properties\nfunction analyzeScript(script: Script) {\n  console.log('Script Analysis:')\n  console.log('- Chunks:', script.chunks.length)\n  console.log('- ASM:', script.toASM())\n  console.log('- Hex:', script.toHex())\n  console.log('- Binary length:', script.toBinary().length)\n  console.log('- Is push-only:', script.isPushOnly())\n}\n\nconst testScript = Script.fromASM('OP_DUP OP_HASH160 1451baa3aad777144a0759998a03538018dd7b4b OP_EQUALVERIFY OP_CHECKSIG')\nanalyzeScript(testScript)\n</code></pre>"},{"location":"tutorials/script-construction/#part-7-advanced-script-operations","title":"Part 7: Advanced Script Operations","text":""},{"location":"tutorials/script-construction/#script-manipulation","title":"Script Manipulation","text":"<pre><code>// Modify existing scripts\nconst script = Script.fromASM('OP_DUP OP_HASH160 1451baa3aad777144a0759998a03538018dd7b4b OP_EQUALVERIFY OP_CHECKSIG')\n\n// Remove code separators (if any)\nscript.removeCodeseparators()\n\n// Modify specific chunks\nscript.setChunkOpCode(0, OP.OP_2DUP) // Change first OP_DUP to OP_2DUP\n\nconsole.log('Modified script:', script.toASM())\n</code></pre>"},{"location":"tutorials/script-construction/#combining-scripts","title":"Combining Scripts","text":"<pre><code>// Combine multiple scripts\nconst script1 = Script.fromASM('OP_TRUE')\nconst script2 = Script.fromASM('OP_FALSE')\nconst script3 = Script.fromASM('OP_ADD')\n\nconst combinedScript = new Script()\ncombinedScript.writeScript(script1)\ncombinedScript.writeScript(script2)\ncombinedScript.writeScript(script3)\n\nconsole.log('Combined script:', combinedScript.toASM())\n</code></pre>"},{"location":"tutorials/script-construction/#part-8-real-world-example","title":"Part 8: Real-World Example","text":""},{"location":"tutorials/script-construction/#creating-a-time-locked-script-template","title":"Creating a Time-Locked Script Template","text":"<pre><code>class TimeLock implements ScriptTemplate {\n  /**\n   * Creates a time-locked script that can only be spent after a certain time\n   */\n  lock(lockTime: number, pubkeyHash: number[]): LockingScript {\n    const script = new LockingScript()\n\n    // Push the lock time\n    script.writeNumber(lockTime)\n    script.writeOpCode(OP.OP_CHECKLOCKTIMEVERIFY)\n    script.writeOpCode(OP.OP_DROP)\n\n    // Standard P2PKH after time check\n    script.writeOpCode(OP.OP_DUP)\n    script.writeOpCode(OP.OP_HASH160)\n    script.writeBin(pubkeyHash)\n    script.writeOpCode(OP.OP_EQUALVERIFY)\n    script.writeOpCode(OP.OP_CHECKSIG)\n\n    return script\n  }\n\n  /**\n   * Creates an unlocking script for time-locked output\n   */\n  unlock(privateKey: PrivateKey) {\n    return {\n      sign: async (tx: Transaction, inputIndex: number): Promise&lt;UnlockingScript&gt; =&gt; {\n        // This would need proper signature creation in a real implementation\n        const script = new UnlockingScript()\n\n        // Add signature (simplified - would need proper SIGHASH implementation)\n        const dummySig = [0x30, 0x44, 0x02, 0x20] // Placeholder signature\n        script.writeBin(dummySig)\n\n        // Add public key\n        const pubkey = privateKey.toPublicKey().encode(true) as number[]\n        script.writeBin(pubkey)\n\n        return script\n      },\n      estimateLength: async (): Promise&lt;number&gt; =&gt; {\n        // Signature (~71 bytes) + public key (33 bytes) + push opcodes\n        return 106\n      }\n    }\n  }\n}\n\n// Usage\nconst timeLock = new TimeLock()\nconst lockTime = Math.floor(Date.now() / 1000) + 3600 // 1 hour from now\nconst privateKey = PrivateKey.fromRandom()\nconst pubkeyHash = privateKey.toPublicKey().toHash()\n\nconst lockingScript = timeLock.lock(lockTime, pubkeyHash)\nconsole.log('Time-locked script:', lockingScript.toASM())\n</code></pre>"},{"location":"tutorials/script-construction/#best-practices","title":"Best Practices","text":""},{"location":"tutorials/script-construction/#1-script-efficiency","title":"1. Script Efficiency","text":"<ul> <li>Keep scripts as small as possible to minimize fees</li> <li>Use standard templates when possible</li> <li>Avoid unnecessary operations</li> </ul>"},{"location":"tutorials/script-construction/#2-security-considerations","title":"2. Security Considerations","text":"<ul> <li>Validate all inputs in custom templates</li> <li>Test scripts thoroughly before mainnet use</li> </ul>"},{"location":"tutorials/script-construction/#3-testing","title":"3. Testing","text":"<pre><code>// Always test your custom templates\nasync function testTemplate(template: ScriptTemplate, ...lockParams: any[]) {\n  try {\n    const lockingScript = template.lock(...lockParams)\n    console.log('\u2713 Locking script created:', lockingScript.toASM())\n\n    // Test unlocking if parameters are available\n    // const unlockingTemplate = template.unlock(...unlockParams)\n    // const estimate = await unlockingTemplate.estimateLength()\n    // console.log('\u2713 Unlock estimate:', estimate)\n\n  } catch (error) {\n    console.error('\u2717 Template test failed:', error.message)\n  }\n}\n</code></pre>"},{"location":"tutorials/script-construction/#common-patterns","title":"Common Patterns","text":""},{"location":"tutorials/script-construction/#1-data-storage-pattern","title":"1. Data Storage Pattern","text":"<pre><code>// Store data with OP_RETURN\nconst dataScript = new Script()\ndataScript.writeOpCode(OP.OP_FALSE)\ndataScript.writeOpCode(OP.OP_RETURN)\ndataScript.writeBin([/* your data */])\n</code></pre>"},{"location":"tutorials/script-construction/#2-conditional-spending-pattern","title":"2. Conditional Spending Pattern","text":"<pre><code>// IF-ELSE conditional spending\nconst conditionalScript = new Script()\nconditionalScript.writeOpCode(OP.OP_IF)\n// ... condition true path\nconditionalScript.writeOpCode(OP.OP_ELSE)\n// ... condition false path\nconditionalScript.writeOpCode(OP.OP_ENDIF)\n</code></pre>"},{"location":"tutorials/script-construction/#3-hash-verification-pattern","title":"3. Hash Verification Pattern","text":"<pre><code>// Verify hash preimage\nconst hashScript = new Script()\nhashScript.writeOpCode(OP.OP_SHA256)\nhashScript.writeBin([/* expected hash */])\nhashScript.writeOpCode(OP.OP_EQUAL)\n</code></pre>"},{"location":"tutorials/script-construction/#integration-with-walletclient","title":"Integration with <code>WalletClient</code>","text":"<p>Your custom script templates can be used with the <code>WalletClient</code> for production applications:</p> <pre><code>// Create a wallet client instance\nconst walletClient = new WalletClient({\n  // ... wallet client options\n})\n\n// Create a custom script template\nconst customTemplate = new SimplePuzzle()\n\n// Create a locking script\nconst lockingScript = customTemplate.lock(42)\n\n// Create a transaction with the custom script\nconst tx = walletClient.createTransaction({\n  // ... transaction options\n  lockingScript,\n})\n\n// Send the transaction\nwalletClient.sendTransaction(tx)\n</code></pre>"},{"location":"tutorials/script-construction/#summary","title":"Summary","text":"<p>In this tutorial, you learned:</p> <ul> <li>\u2705 Bitcoin script fundamentals and structure</li> <li>\u2705 Creating scripts from different formats (ASM, hex, binary)</li> <li>\u2705 Working with script chunks and opcodes</li> <li>\u2705 Using standard script templates like P2PKH</li> <li>\u2705 Building custom script templates</li> <li>\u2705 Implementing locking and unlocking logic</li> <li>\u2705 Advanced script operations and combinations</li> <li>\u2705 Best practices for script development</li> </ul> <p>You now have the knowledge to create sophisticated Bitcoin scripts and custom templates for your applications. Remember to test thoroughly and consider security implications when deploying custom scripts.</p>"},{"location":"tutorials/script-construction/#next-steps","title":"Next Steps","text":"<ul> <li>Explore the Advanced Transaction Construction tutorial</li> <li>Learn about Transaction Broadcasting</li> <li>Study the SDK's built-in script templates for more examples</li> <li>Practice with testnet before deploying to mainnet</li> </ul>"},{"location":"tutorials/script-construction/#troubleshooting","title":"Troubleshooting","text":""},{"location":"tutorials/script-construction/#common-issues","title":"Common Issues","text":"<ol> <li>Script too large: Minimize operations and data size</li> <li>Invalid opcodes: Check opcode values against the OP enum</li> <li>Serialization errors: Ensure proper data encoding</li> <li>Template errors: Verify unlock function returns correct structure</li> </ol>"},{"location":"tutorials/script-construction/#getting-help","title":"Getting Help","text":"<ul> <li>Check the BSV TypeScript SDK documentation</li> <li>Review existing script templates in the SDK source</li> <li>Test scripts on testnet before mainnet deployment</li> </ul>"},{"location":"tutorials/spv-merkle-proofs/","title":"SPV and Merkle Proof Verification","text":""},{"location":"tutorials/spv-merkle-proofs/#introduction","title":"Introduction","text":"<p>Simplified Payment Verification (SPV) is a method for verifying Bitcoin transactions without downloading the entire blockchain. Instead of storing all transaction data, SPV clients only need block headers and merkle proofs to verify that specific transactions are included in the blockchain.</p> <p>This tutorial covers:</p> <ul> <li>Understanding SPV principles and merkle trees</li> <li>Working with merkle proofs using the <code>MerklePath</code> class</li> <li>Verifying transactions with the <code>Transaction.verify()</code> method</li> <li>Implementing custom chain trackers for block header verification</li> <li>Working with BEEF (BRC-62) structures for efficient SPV</li> </ul> <p>\ud83d\udcda Related Concepts: Review SPV Verification, Transaction Verification, and BEEF Format for foundational understanding.</p>"},{"location":"tutorials/spv-merkle-proofs/#prerequisites","title":"Prerequisites","text":"<ul> <li>Completed \"Your First BSV Transaction\" tutorial</li> <li>Basic understanding of Bitcoin transaction structure</li> <li>Familiarity with cryptographic hash functions</li> </ul>"},{"location":"tutorials/spv-merkle-proofs/#understanding-spv-and-merkle-trees","title":"Understanding SPV and Merkle Trees","text":""},{"location":"tutorials/spv-merkle-proofs/#what-is-spv","title":"What is SPV?","text":"<p>SPV allows lightweight clients to verify transactions without storing the full blockchain by:</p> <ol> <li>Block Headers Only: Store only block headers (80 bytes each) instead of full blocks</li> <li>Merkle Proofs: Use cryptographic proofs to verify transaction inclusion</li> <li>Chain Validation: Verify the proof-of-work chain of block headers</li> <li>Script Validation: Validate that transaction scripts are properly formed</li> </ol>"},{"location":"tutorials/spv-merkle-proofs/#merkle-trees-in-bitcoin","title":"Merkle Trees in Bitcoin","text":"<p>Bitcoin blocks organize transactions in a binary merkle tree structure:</p> <pre><code>        Merkle Root\n       /           \\\n    Hash AB       Hash CD\n   /      \\      /      \\\nHash A  Hash B Hash C  Hash D\n  |       |      |       |\n Tx A    Tx B   Tx C    Tx D\n</code></pre> <p>A merkle proof provides the minimum hashes needed to compute the merkle root from a specific transaction.</p>"},{"location":"tutorials/spv-merkle-proofs/#working-with-merklepath","title":"Working with MerklePath","text":"<p>The <code>MerklePath</code> class represents a merkle proof for a specific transaction:</p> <pre><code>import { MerklePath, WhatsOnChain } from '@bsv/sdk'\n\nasync function runMerkleExample() {\n  // Create the merkle path first (our demonstration example)\n  const blockHeight = 850000\n  const merklePath = new MerklePath(blockHeight, [\n    [\n      { offset: 0, hash: 'ffeff11c25cde7c06d407490d81ef4d0db64aad6ab3d14393530701561a465ef', txid: true },\n      { offset: 1, hash: 'b9ef07a62553ef8b0898a79c291b92c60f7932260888bde0dab2dd2610d8668e' }\n    ]\n  ])\n\n  // Example tx\n  const txid = 'ffeff11c25cde7c06d407490d81ef4d0db64aad6ab3d14393530701561a465ef'\n\n  // Create a chain tracker for mainnet\n  const chainTracker = new WhatsOnChain('main')\n\n  // Verify the merkle proof\n  const isValid = await merklePath.verify(txid, chainTracker)\n  console.log('Merkle proof valid:', isValid)\n\n  // Note: This will return false because our example merkle path\n  // doesn't correspond to a real block on the BSV mainnet\n}\n\nrunMerkleExample().catch(console.error)\n</code></pre>"},{"location":"tutorials/spv-merkle-proofs/#working-with-real-blockchain-data","title":"Working with Real Blockchain Data","text":"<p>The example above demonstrates the fundamental concepts using a simplified 2-transaction block. In real BSV blockchain scenarios, blocks contain hundreds or thousands of transactions, creating much deeper merkle trees.</p> <p>Our Working Example:</p> <ul> <li>Block Height: 850000 (arbitrary example height)</li> <li>Transaction ID: <code>ffeff11c25cde7c06d407490d81ef4d0db64aad6ab3d14393530701561a465ef</code> (from BSV Technical Standards)</li> <li>Sibling Hash: <code>b9ef07a62553ef8b0898a79c291b92c60f7932260888bde0dab2dd2610d8668e</code> (from BSV Technical Standards)</li> <li>Computed Merkle Root: <code>6f0a2a566d54512576b3b32eb3a8ca5273d8f35d8bfba02123bb7aad59be1e61</code></li> </ul> <p>Real-World Complexity: In actual BSV blocks, a transaction at index 12 (like in the BSV Technical Standards example) would require a merkle path with multiple levels:</p> <ul> <li>5 proof levels for a block with ~32 transactions</li> <li>10 proof levels for a block with ~1024 transactions  </li> <li>20 proof levels for a block with ~1 million transactions</li> </ul> <p>The logarithmic nature of merkle trees means even massive blocks require relatively few proof hashes for verification.</p>"},{"location":"tutorials/spv-merkle-proofs/#real-blockchain-merkle-paths","title":"Real Blockchain Merkle Paths","text":"<p>In practice, merkle paths from real BSV blocks are more complex, with multiple levels representing the tree structure. The example above shows the simplest case - a block with only 2 transactions.</p> <p>Real BSV Blockchain Example: Based on data from the BSV Technical Standards, a transaction at index 12 in a larger block would have a merkle path with these hash values:</p> <ul> <li>Transaction: <code>ffeff11c25cde7c06d407490d81ef4d0db64aad6ab3d14393530701561a465ef</code></li> <li>Proof nodes: 5 hash values that form the path to the merkle root</li> <li>Merkle root: <code>75edb0a69eb195cdd81e310553aa4d25e18450e08f168532a2c2e9cf447bf169</code></li> </ul> <p>The SDK handles the complex offset calculations automatically when parsing from binary formats or BEEF structures.</p>"},{"location":"tutorials/spv-merkle-proofs/#serialization-formats","title":"Serialization Formats","text":"<p>The BSV TypeScript SDK uses an internal object format for MerklePath construction, while the BSV Technical Standards define a binary serialization format. The SDK handles the conversion between these formats internally.</p> <p>Internal Format (used above):</p> <ul> <li>Array of levels, each containing leaf objects with <code>offset</code>, <code>hash</code>, <code>txid</code>, and <code>duplicate</code> properties</li> <li>Direct construction allows for clear understanding of the merkle tree structure</li> </ul> <p>Binary Format (from standards):</p> <ul> <li>Compact binary representation for network transmission and storage</li> <li>Can be parsed using <code>MerklePath.fromHex()</code> when properly formatted</li> </ul>"},{"location":"tutorials/spv-merkle-proofs/#computing-merkle-roots","title":"Computing Merkle Roots","text":"<p>You can compute the merkle root for a given transaction ID:</p> <pre><code>// Compute merkle root for a specific transaction\nconst txid = 'ffeff11c25cde7c06d407490d81ef4d0db64aad6ab3d14393530701561a465ef'\nconst merkleRoot = merklePath.computeRoot(txid)\n\nconsole.log('Computed merkle root:', merkleRoot)\n\n// How the merkle root is computed for our 2-transaction block:\n// 1. Take our transaction: ffeff11c25cde7c06d407490d81ef4d0db64aad6ab3d14393530701561a465ef\n// 2. Take sibling transaction: b9ef07a62553ef8b0898a79c291b92c60f7932260888bde0dab2dd2610d8668e\n// 3. Hash them together: SHA256(SHA256(txid + sibling))\n// 4. Result is the merkle root: 6f0a2a566d54512576b3b32eb3a8ca5273d8f35d8bfba02123bb7aad59be1e61\n\nconsole.log('Expected result: 6f0a2a566d54512576b3b32eb3a8ca5273d8f35d8bfba02123bb7aad59be1e61')\nconsole.log('Merkle root matches expected:', merkleRoot === '6f0a2a566d54512576b3b32eb3a8ca5273d8f35d8bfba02123bb7aad59be1e61')\n</code></pre>"},{"location":"tutorials/spv-merkle-proofs/#understanding-merkle-tree-computation","title":"Understanding Merkle Tree Computation","text":"<p>The merkle root computation follows a specific mathematical process:</p> <p>For a 2-transaction block (our example):</p> <pre><code>Level 0 (Leaves):    [Transaction A]  [Transaction B]\n                           |              |\nLevel 1 (Root):           [Hash(A + B)]\n</code></pre> <p>Step-by-step process:</p> <ol> <li>Start with transaction IDs (already hashed)</li> <li>Concatenate them: <code>ffeff11c...465ef</code> + <code>b9ef07a6...8668e</code></li> <li>Double SHA256: <code>SHA256(SHA256(concatenated_data))</code></li> <li>Result: The merkle root that represents the entire block</li> </ol> <p>For larger blocks (e.g., 4 transactions):</p> <pre><code>Level 0:    [Tx A]  [Tx B]  [Tx C]  [Tx D]\n              |       |       |       |\nLevel 1:    [Hash(A+B)]     [Hash(C+D)]\n                 |               |\nLevel 2:         [Hash(AB + CD)]\n</code></pre> <p>This tree structure allows you to prove any transaction's inclusion with only <code>log\u2082(n)</code> hashes, making verification extremely efficient even for blocks with millions of transactions.</p>"},{"location":"tutorials/spv-merkle-proofs/#verifying-merkle-proofs","title":"Verifying Merkle Proofs","text":"<p>Verify that a transaction is included in a block using a chain tracker:</p> <pre><code>import { MerklePath, WhatsOnChain } from '@bsv/sdk'\n\nasync function runMerkleVerificationExample() {\n  // Create a simple merkle path for demonstration\n  // This is a 2-transaction block example from BSV Technical Standards\n  const blockHeight = 850000\n  const merklePath = new MerklePath(blockHeight, [\n    [\n      { offset: 0, hash: 'ffeff11c25cde7c06d407490d81ef4d0db64aad6ab3d14393530701561a465ef', txid: true },\n      { offset: 1, hash: 'b9ef07a62553ef8b0898a79c291b92c60f7932260888bde0dab2dd2610d8668e' }\n    ]\n  ])\n\n  // Example transaction ID\n  const txid = 'ffeff11c25cde7c06d407490d81ef4d0db64aad6ab3d14393530701561a465ef'\n\n  // Create a chain tracker for mainnet\n  const chainTracker = new WhatsOnChain('main')\n\n  try {\n    // Compute the merkle root (this works with our demonstration data)\n    const merkleRoot = merklePath.computeRoot(txid)\n    console.log('Computed merkle root:', merkleRoot)\n\n    // Verify the merkle proof (this will return false for our demo data)\n    const isValid = await merklePath.verify(txid, chainTracker)\n    console.log('Merkle proof valid:', isValid)\n\n    // Note: This returns false because our example uses demonstration data\n    // rather than real blockchain merkle proof data\n    if (!isValid) {\n      console.log('\u2139\ufe0f  This is expected - our example uses synthetic data for learning purposes')\n      console.log('   Real applications receive merkle paths from BEEF structures or blockchain services')\n    }\n  } catch (error) {\n    console.error('Error verifying merkle proof:', error)\n  }\n}\n\n// Run the example\nrunMerkleVerificationExample().catch(console.error)\n</code></pre>"},{"location":"tutorials/spv-merkle-proofs/#chain-trackers","title":"Chain Trackers","text":"<p>Chain trackers verify that merkle roots are valid for specific block heights. The SDK provides the <code>WhatsOnChain</code> implementation:</p>"},{"location":"tutorials/spv-merkle-proofs/#using-whatsonchain-chain-tracker","title":"Using WhatsOnChain Chain Tracker","text":"<pre><code>import { WhatsOnChain } from '@bsv/sdk'\n\nasync function runChainTrackerExample() {\n  // Mainnet chain tracker\n  const mainnetTracker = new WhatsOnChain('main')\n\n  // Testnet chain tracker  \n  const testnetTracker = new WhatsOnChain('test', {\n    apiKey: 'your-api-key' // Optional for higher rate limits\n  })\n\n  try {\n    // Check current blockchain height\n    const currentHeight = await mainnetTracker.currentHeight()\n    console.log('Current block height:', currentHeight)\n\n    // Verify a merkle root for a specific height\n    const isValidRoot = await mainnetTracker.isValidRootForHeight(\n      'merkle-root-hex',\n      850000\n    )\n    console.log('Valid merkle root:', isValidRoot)\n    console.log('NOTE - this is expected to be false, as our example uses demonstration data')\n  } catch (error) {\n    console.error('Chain tracker error:', error)\n  }\n}\n\n// Run the example\nrunChainTrackerExample().catch(console.error)\n</code></pre>"},{"location":"tutorials/spv-merkle-proofs/#transaction-verification-with-spv","title":"Transaction Verification with SPV","text":"<p>The <code>Transaction.verify()</code> method performs complete SPV verification:</p>"},{"location":"tutorials/spv-merkle-proofs/#basic-transaction-verification","title":"Basic Transaction Verification","text":"<pre><code>import { Transaction, WhatsOnChain, SatoshisPerKilobyte } from '@bsv/sdk'\n\nasync function runTransactionVerificationExample() {\n  // Create transaction from BEEF data\n  const beefHex = 'your-beef-hex-data'\n  const transaction = Transaction.fromHexBEEF(beefHex)\n\n  // Set up chain tracker and fee model\n  const chainTracker = new WhatsOnChain('main')\n  const feeModel = new SatoshisPerKilobyte(1)\n\n  // Verify the transaction\n  try {\n    const isValid = await transaction.verify(chainTracker, feeModel)\n    console.log('Transaction valid:', isValid)\n    console.log('NOTE - this is expected to be false, as our example uses demonstration data')\n  } catch (error) {\n    console.error('Verification failed:', error.message)\n  }\n}\n\n// Run the example\nrunTransactionVerificationExample().catch(console.error)\n</code></pre>"},{"location":"tutorials/spv-merkle-proofs/#scripts-only-verification","title":"Scripts-Only Verification","text":"<pre><code>async function runScriptsOnlyVerificationExample() {\n  // Assuming you have a transaction from previous example\n  const beefHex = 'your-beef-hex-data'\n  const transaction = Transaction.fromHexBEEF(beefHex)\n\n  try {\n    // Verify only scripts without checking block headers\n    const isScriptValid = await transaction.verify('scripts only')\n    console.log('Scripts valid:', isScriptValid)\n  } catch (error) {\n    console.error('Script verification failed:', error.message)\n  }\n}\n\n// Run the example\nrunScriptsOnlyVerificationExample().catch(console.error)\n</code></pre>"},{"location":"tutorials/spv-merkle-proofs/#working-with-beef-structures","title":"Working with BEEF Structures","text":"<p>BEEF (BRC-62) provides an efficient format for SPV data:</p>"},{"location":"tutorials/spv-merkle-proofs/#creating-beef-from-transaction","title":"Creating BEEF from Transaction","text":"<pre><code>// Create a transaction with inputs and merkle proofs\nconst tx = new Transaction()\n// ... add inputs and outputs ...\n\n// Convert to BEEF format\nconst beefData = tx.toBEEF()\nconst beefHex = Buffer.from(beefData).toString('hex')\n\nconsole.log('BEEF hex:', beefHex)\n</code></pre>"},{"location":"tutorials/spv-merkle-proofs/#parsing-beef-data","title":"Parsing BEEF Data","text":"<pre><code>// Parse BEEF structure\nconst transaction = Transaction.fromHexBEEF(beefHex)\n\nconsole.log('Transaction ID:', Buffer.from(transaction.id()).toString('hex'))\nconsole.log('Input count:', transaction.inputs.length)\nconsole.log('Output count:', transaction.outputs.length)\n\n// Check if merkle paths are included\ntransaction.inputs.forEach((input, index) =&gt; {\n  if (input.sourceTransaction?.merklePath) {\n    console.log(`Input ${index} has merkle proof at height:`, \n      input.sourceTransaction.merklePath.blockHeight)\n  }\n})\n</code></pre>"},{"location":"tutorials/spv-merkle-proofs/#practical-example-payment-verification","title":"Practical Example: Payment Verification","text":"<p>Let's create a complete example that verifies a payment transaction:</p> <pre><code>import { \n  Transaction, \n  WhatsOnChain, \n  SatoshisPerKilobyte,\n  PrivateKey,\n  P2PKH \n} from '@bsv/sdk'\n\nasync function verifyPayment(beefHex: string): Promise&lt;boolean&gt; {\n  try {\n    // Parse the BEEF transaction\n    const transaction = Transaction.fromHexBEEF(beefHex)\n\n    // Set up verification components\n    const chainTracker = new WhatsOnChain('main')\n\n    // Perform SPV verification\n    const isValid = await transaction.verify(chainTracker)\n\n    if (isValid) {\n      console.log('\u2705 Payment verified successfully!')\n\n      // Extract payment details\n      const txid = Buffer.from(transaction.id()).toString('hex')\n      console.log('Transaction ID:', txid)\n\n      // Check outputs for payment amounts\n      transaction.outputs.forEach((output, index) =&gt; {\n        console.log(`Output ${index}: ${output.satoshis} satoshis`)\n\n        // Check if it's a P2PKH output (OP_DUP OP_HASH160 &lt;20-byte-hash&gt; OP_EQUALVERIFY OP_CHECKSIG)\n        try {\n          const script = output.lockingScript\n          const chunks = script.chunks\n          if (chunks.length === 5 &amp;&amp; \n              chunks[0].op === 118 &amp;&amp; // OP_DUP\n              chunks[1].op === 169 &amp;&amp; // OP_HASH160\n              chunks[2].data &amp;&amp; chunks[2].data.length === 20 &amp;&amp;\n              chunks[3].op === 136 &amp;&amp; // OP_EQUALVERIFY\n              chunks[4].op === 172) { // OP_CHECKSIG\n            const pubKeyHash = Buffer.from(chunks[2].data).toString('hex')\n            console.log(`  \u2192 P2PKH address hash: ${pubKeyHash}`)\n          } else {\n            console.log(`  \u2192 Custom script output`)\n          }\n        } catch {\n          console.log(`  \u2192 Custom script output`)\n        }\n      })\n\n      return true\n    } else {\n      console.log('\u274c Payment verification failed')\n      return false\n    }\n  } catch (error) {\n    console.error('Verification error:', (error as Error).message)\n    return false\n  }\n}\n\n// Example usage\nconst exampleBEEF = '0100beef01fe636d0c0007021400fe507c0c7aa754cef1f7889d5fd395cf1f785dd7de98eed895dbedfe4e5bc70d1502ac4e164f5bc16746bb0868404292ac8318bbac3800e4aad13a014da427adce3e010b00bc4ff395efd11719b277694cface5aa50d085a0bb81f613f70313acd28cf4557010400574b2d9142b8d28b61d88e3b2c3f44d858411356b49a28a4643b6d1a6a092a5201030051a05fc84d531b5d250c23f4f886f6812f9fe3f402d61607f977b4ecd2701c19010000fd781529d58fc2523cf396a7f25440b409857e7e221766c57214b1d38c7b481f01010062f542f45ea3660f86c013ced80534cb5fd4c19d66c56e7e8c5d4bf2d40acc5e010100b121e91836fd7cd5102b654e9f72f3cf6fdbfd0b161c53a9c54b12c841126331020100000001cd4e4cac3c7b56920d1e7655e7e260d31f29d9a388d04910f1bbd72304a79029010000006b483045022100e75279a205a547c445719420aa3138bf14743e3f42618e5f86a19bde14bb95f7022064777d34776b05d816daf1699493fcdf2ef5a5ab1ad710d9c97bfb5b8f7cef3641210263e2dee22b1ddc5e11f6fab8bcd2378bdd19580d640501ea956ec0e786f93e76ffffffff013e660000000000001976a9146bfd5c7fbe21529d45803dbcf0c87dd3c71efbc288ac0000000001000100000001ac4e164f5bc16746bb0868404292ac8318bbac3800e4aad13a014da427adce3e000000006a47304402203a61a2e931612b4bda08d541cfb980885173b8dcf64a3471238ae7abcd368d6402204cbf24f04b9aa2256d8901f0ed97866603d2be8324c2bfb7a37bf8fc90edd5b441210263e2dee22b1ddc5e11f6fab8bcd2378bdd19580d640501ea956ec0e786f93e76ffffffff013c660000000000001976a9146bfd5c7fbe21529d45803dbcf0c87dd3c71efbc288ac0000000000'\n\nasync function runPaymentVerificationExample() {\n  console.log('=== Payment Verification Example ===\\n')\n\n  // Verify the payment\n  const isValid = await verifyPayment(exampleBEEF)\n\n  if (isValid) {\n    console.log('\\n\u2705 Payment successfully verified using SPV!')\n    console.log('This transaction can be trusted without downloading the full blockchain.')\n  } else {\n    console.log('\\n\u274c Payment verification failed!')\n    console.log('This transaction should not be trusted.')\n  }\n\n  console.log('\\n=== Payment Processing Workflow ===')\n  console.log('1. Customer sends BEEF-encoded transaction')\n  console.log('2. Merchant verifies transaction using SPV')\n  console.log('3. If valid, merchant can safely accept payment')\n  console.log('4. No need to wait for confirmations or run full node')\n}\n\nrunPaymentVerificationExample().catch(console.error)\n</code></pre>"},{"location":"tutorials/spv-merkle-proofs/#advanced-spv-patterns","title":"Advanced SPV Patterns","text":""},{"location":"tutorials/spv-merkle-proofs/#batch-verification","title":"Batch Verification","text":"<p>Verify multiple transactions efficiently:</p> <pre><code>async function verifyMultipleTransactions(beefHexArray: string[]): Promise&lt;boolean[]&gt; {\n  const chainTracker = new WhatsOnChain('main')\n  const feeModel = new SatoshisPerKilobyte(1)\n\n  const results = await Promise.all(\n    beefHexArray.map(async (beefHex) =&gt; {\n      try {\n        const tx = Transaction.fromHexBEEF(beefHex)\n        return await tx.verify(chainTracker, feeModel)\n      } catch (error) {\n        console.error('Verification failed:', error.message)\n        return false\n      }\n    })\n  )\n\n  return results\n}\n</code></pre>"},{"location":"tutorials/spv-merkle-proofs/#merkle-proof-validation","title":"Merkle Proof Validation","text":"<p>Manually validate merkle proofs:</p> <pre><code>function validateMerkleProof(\n  txid: string, \n  merklePath: MerklePath, \n  expectedRoot: string\n): boolean {\n  try {\n    const computedRoot = merklePath.computeRoot(txid)\n    return computedRoot === expectedRoot\n  } catch (error) {\n    console.error('Error computing merkle root:', error.message)\n    return false\n  }\n}\n\n// Example usage\nconst isValidProof = validateMerkleProof(\n  'transaction-id',\n  merklePath,\n  'expected-merkle-root'\n)\nconsole.log('Merkle proof valid:', isValidProof)\n</code></pre>"},{"location":"tutorials/spv-merkle-proofs/#custom-memory-limits","title":"Custom Memory Limits","text":"<p>Control script execution memory usage:</p> <pre><code>// Verify with custom memory limit (in bytes)\nconst isValid = await transaction.verify(\n  chainTracker,\n  feeModel,\n  1024 * 1024 // 1MB memory limit\n)\n</code></pre>"},{"location":"tutorials/spv-merkle-proofs/#error-handling-and-debugging","title":"Error Handling and Debugging","text":""},{"location":"tutorials/spv-merkle-proofs/#common-verification-errors","title":"Common Verification Errors","text":"<pre><code>async function robustVerification(beefHex: string): Promise&lt;void&gt; {\n  try {\n    const transaction = Transaction.fromHexBEEF(beefHex)\n\n    // Set up verification components\n    const chainTracker = new WhatsOnChain('main')\n\n    console.log('\ud83d\udd0d Starting transaction verification...')\n    console.log('Transaction ID:', Buffer.from(transaction.id()).toString('hex'))\n\n    // Perform SPV verification\n    const isValid = await transaction.verify(chainTracker)\n\n    if (!isValid) {\n      console.log('\u274c Transaction verification failed. Checking components...')\n\n      // Check individual merkle proofs\n      for (let i = 0; i &lt; transaction.inputs.length; i++) {\n        const input = transaction.inputs[i]\n        if (input.sourceTransaction?.merklePath) {\n          try {\n            const sourceTxid = Buffer.from(input.sourceTransaction.id()).toString('hex')\n            const proofValid = await input.sourceTransaction.merklePath.verify(\n              sourceTxid, \n              chainTracker\n            )\n            console.log(`  Input ${i} merkle proof: ${proofValid ? '\u2705' : '\u274c'}`)\n          } catch (err) {\n            console.log(`  Input ${i} merkle proof: \u274c (${(err as Error).message})`)\n          }\n        } else {\n          console.log(`  Input ${i}: No merkle path provided`)\n        }\n      }\n\n      // Try scripts-only verification\n      try {\n        const scriptsValid = await transaction.verify('scripts only')\n        console.log('  Scripts validation:', scriptsValid ? '\u2705' : '\u274c')\n      } catch (err) {\n        console.log('  Scripts validation: \u274c (', (err as Error).message, ')')\n      }\n    } else {\n      console.log('\u2705 Transaction verification successful!')\n    }\n\n  } catch (error) {\n    const errorMessage = (error as Error).message\n\n    console.log('\u274c Verification failed with error:')\n\n    if (errorMessage.includes('Missing source transaction')) {\n      console.error('  \u2192 BEEF structure incomplete - missing input transactions')\n      console.error('  \u2192 Solution: Ensure all input transactions are included in BEEF')\n    } else if (errorMessage.includes('Merkle root')) {\n      console.error('  \u2192 Merkle proof verification failed')\n      console.error('  \u2192 Solution: Check merkle path data and chain tracker connectivity')\n    } else if (errorMessage.includes('script')) {\n      console.error('  \u2192 Script validation failed')\n      console.error('  \u2192 Solution: Check unlocking scripts and signature validity')\n    } else if (errorMessage.includes('BEEF')) {\n      console.error('  \u2192 BEEF parsing error')\n      console.error('  \u2192 Solution: Verify BEEF format and encoding')\n    } else {\n      console.error('  \u2192 Unexpected error:', errorMessage)\n    }\n  }\n}\n</code></pre>"},{"location":"tutorials/spv-merkle-proofs/#network-specific-verification","title":"Network-Specific Verification","text":"<pre><code>async function verifyOnNetwork(beefHex: string, network: 'main' | 'test'): Promise&lt;boolean&gt; {\n  const chainTracker = new WhatsOnChain(network)\n  const transaction = Transaction.fromHexBEEF(beefHex)\n\n  console.log(`Verifying on ${network}net...`)\n  return await transaction.verify(chainTracker)\n}\n</code></pre>"},{"location":"tutorials/spv-merkle-proofs/#best-practices","title":"Best Practices","text":""},{"location":"tutorials/spv-merkle-proofs/#1-chain-tracker-selection","title":"1. Chain Tracker Selection","text":"<pre><code>// Production: Use WhatsOnChain with API key\nconst productionTracker = new WhatsOnChain('main', {\n  apiKey: process.env.WHATSONCHAIN_API_KEY\n})\n\n// Development: Use testnet\nconst devTracker = new WhatsOnChain('test')\n\n// Testing: Use mock tracker\nconst testTracker: ChainTracker = {\n  async isValidRootForHeight() { return true },\n  async currentHeight() { return 850000 }\n}\n</code></pre>"},{"location":"tutorials/spv-merkle-proofs/#2-error-recovery","title":"2. Error Recovery","text":"<pre><code>async function verifyWithRetry(beefHex: string, maxRetries = 3): Promise&lt;boolean&gt; {\n  for (let attempt = 1; attempt &lt;= maxRetries; attempt++) {\n    try {\n      const transaction = Transaction.fromHexBEEF(beefHex)\n      const chainTracker = new WhatsOnChain('main')\n\n      return await transaction.verify(chainTracker)\n    } catch (error) {\n      console.log(`Attempt ${attempt} failed:`, (error as Error).message)\n\n      if (attempt === maxRetries) {\n        throw error\n      }\n\n      // Wait before retry\n      await new Promise(resolve =&gt; setTimeout(resolve, 1000 * attempt))\n    }\n  }\n\n  return false\n}\n</code></pre>"},{"location":"tutorials/spv-merkle-proofs/#summary","title":"Summary","text":"<p>SPV and merkle proof verification enable lightweight Bitcoin clients to verify transactions without storing the full blockchain. The BSV TypeScript SDK provides comprehensive tools for:</p> <ul> <li>MerklePath: Computing and verifying merkle proofs</li> <li>ChainTracker: Validating merkle roots against block headers  </li> <li>Transaction.verify(): Complete SPV verification</li> <li>BEEF: Efficient SPV data structures</li> </ul> <p>Key takeaways:</p> <ul> <li>SPV trades storage for bandwidth and computation</li> <li>Merkle proofs provide cryptographic inclusion proofs</li> <li>Chain trackers ensure merkle roots are valid</li> <li>BEEF structures optimize SPV data transmission</li> <li>Always use trusted chain trackers in production</li> <li>Implement proper error handling and retry logic</li> </ul> <p>This foundation enables building lightweight Bitcoin applications that can verify payments and transactions without running a full node.</p> <p>Understanding of <code>WalletClient</code> usage is also important for building robust applications. <code>WalletClient</code> provides high-level transaction verification, but understanding SPV verification gives you the ability to build lightweight applications that can verify transactions without downloading the entire blockchain.</p>"},{"location":"tutorials/spv-merkle-proofs/#spv-vs-full-node-vs-walletclient-verification","title":"SPV vs Full Node vs <code>WalletClient</code> Verification","text":"Method <code>WalletClient</code> SPV Full Node Storage High Low High Bandwidth Low High Low Verification High-level Low-level High-level Security High High High <p>The <code>WalletClient</code> approach is recommended for most applications, while SPV verification is valuable for specialized lightweight applications.</p>"},{"location":"tutorials/testnet-transactions-low-level/","title":"Working with Testnet Transactions","text":"<p>Duration: 30 minutes Prerequisites: Completed \"Your First BSV Transaction\" tutorial, Node.js, basic TypeScript knowledge  </p>"},{"location":"tutorials/testnet-transactions-low-level/#learning-goals","title":"Learning Goals","text":"<ul> <li>Set up a BSV testnet environment</li> <li>Obtain and manage testnet coins</li> <li>Create and broadcast real transactions on the testnet</li> <li>Track and verify transaction confirmations</li> <li>Configure <code>WalletClient</code> for different environments</li> </ul>"},{"location":"tutorials/testnet-transactions-low-level/#introduction","title":"Introduction","text":"<p>While the previous tutorial taught you the basics of creating transaction structures, this tutorial takes you to the next level: creating and broadcasting actual transactions on the Bitcoin SV testnet. The testnet is a separate blockchain that functions almost identically to the main BSV network (mainnet), but with coins that have no real-world value, making it perfect for experimentation and learning.</p>"},{"location":"tutorials/testnet-transactions-low-level/#step-1-understanding-testnet-vs-mainnet","title":"Step 1: Understanding Testnet vs Mainnet","text":"<p>Before we start, it's important to understand the difference between testnet and mainnet:</p> Feature Testnet Mainnet Purpose Testing and development Real-world transactions Coin value None (free from faucets) Real monetary value Network prefix Different from mainnet Production network Block difficulty Lower than mainnet Higher mining difficulty Explorer URLs Testnet-specific Mainnet-specific <p>The code you write for testnet can usually work on mainnet with minimal changes (primarily network configuration), making testnet ideal for development and testing.</p>"},{"location":"tutorials/testnet-transactions-low-level/#step-2-setting-up-a-testnet-wallet","title":"Step 2: Setting Up a Testnet Wallet","text":"<p>First, let's create a new project for our testnet experiments:</p> <pre><code># Create a new directory for your testnet project\nmkdir bsv-testnet-transactions\ncd bsv-testnet-transactions\n\n# Initialize a new Node.js project\nnpm init -y\n\n# Install TypeScript and ts-node\nnpm install typescript ts-node @types/node --save-dev\n\n# Install the BSV SDK\nnpm install @bsv/sdk\n</code></pre> <p>Now, create a basic TypeScript configuration file (<code>tsconfig.json</code>):</p> <pre><code>{\n  \"compilerOptions\": {\n    \"target\": \"es2022\",\n    \"module\": \"commonjs\",\n    \"esModuleInterop\": true,\n    \"strict\": true,\n    \"outDir\": \"./dist\"\n  }\n}\n</code></pre> <p>Let's create a file to generate a testnet wallet. Create a new file called <code>create-wallet.ts</code>:</p> <pre><code>import { \n  PrivateKey,\n  P2PKH\n} from '@bsv/sdk'\n\n// Create a new private key\nconst privateKey = PrivateKey.fromRandom()\n\n// Derive the public key and create a testnet address\n// Use the testnet prefix (0x6f) for the address\nconst address = privateKey.toAddress([0x6f])\n\n// Display the information\nconsole.log('===== TESTNET WALLET =====')\nconsole.log(`Address: ${address.toString()}`)\nconsole.log(`Private Key (WIF): ${privateKey.toWif()}`)\nconsole.log('\\nIMPORTANT: Save this information securely. You will need the private key to spend any received coins.')\nconsole.log('=============================')\n</code></pre> <p>Run this script to generate your testnet wallet:</p> <pre><code>npx ts-node create-wallet.ts\n</code></pre> <p>You should see output similar to this:</p> <pre><code>===== TESTNET WALLET =====\nAddress: mzJR1zKcZCZvMJj87PUeQPPXRi3DEpyEDp\nPrivate Key (WIF): cQcTnoUm6hQCSoGDQQiGfRxLEbsB6Sm3DnQPDrJdHZrP6ufuuJyp\n\nIMPORTANT: Save this information securely. You will need the private key to spend any received coins.\n=============================\n</code></pre> <p>Important: Save the displayed address and private key somewhere secure. You'll need them for the rest of this tutorial.</p>"},{"location":"tutorials/testnet-transactions-low-level/#step-3-getting-testnet-coins","title":"Step 3: Getting Testnet Coins","text":"<p>Now that you have a testnet address, you need to get some testnet coins. Unlike mainnet, testnet coins are free and can be obtained from \"faucets\" - services that distribute testnet coins for development purposes.</p> <p>Here are some BSV testnet faucets you can use:</p> <ul> <li>Scrypt.io Testnet Faucet</li> <li>BSV Testnet Faucet</li> </ul> <p>Visit one of these faucets, enter your testnet address, and request some coins. The faucet will send a small amount of testnet BSV to your address.</p>"},{"location":"tutorials/testnet-transactions-low-level/#step-4-verifying-your-balance-and-finding-utxo-information","title":"Step 4: Verifying Your Balance and Finding UTXO Information","text":"<p>After requesting coins from a faucet, you'll need to verify that you received them and gather information about the UTXO (Unspent Transaction Output) you're going to spend. You can use a testnet block explorer for this purpose:</p> <ul> <li>WhatsOnChain Testnet</li> <li>BitcoinSV Testnet Explorer</li> </ul>"},{"location":"tutorials/testnet-transactions-low-level/#using-whatsonchain-testnet-explorer","title":"Using WhatsOnChain Testnet Explorer","text":"<ol> <li> <p>Go to WhatsOnChain Testnet Explorer</p> </li> <li> <p>Enter your testnet address in the search bar at the top and click the search icon</p> </li> <li> <p>You'll see your address details page with any transactions listed. Verify that you have received coins from the faucet. It may take a few minutes for the transaction to be confirmed.</p> </li> <li> <p>Once you confirm that you've received coins with at least one confirmed transaction (unspent output/UTXO), you can proceed to gather the information needed for your transaction.</p> </li> <li> <p>Look for the incoming transaction from the faucet</p> </li> <li> <p>Click on the transaction ID (txid) to view the full transaction details</p> </li> <li> <p>On the transaction details page, find the following information:</p> <ul> <li>Transaction ID (txid): This is the long hexadecimal string at the top of the page (e.g., <code>7f4e6ea49a847f557fccd9bf99d4a07ac103e5e8cb3464abb852af552516317e</code>)</li> <li>Output Index: In the \"Outputs\" section, find your address and note its index number (0-based). If your address is the first output, the index is 0.</li> <li> <p>Output Amount: Note the amount sent to your address in this specific output. WhatsOnChain displays amounts in BSV (e.g., 0.00010000 BSV), but our code needs satoshis. To convert:</p> <ul> <li>1 BSV = 100,000,000 satoshis</li> <li>Example: 0.00010000 BSV = 10,000 satoshis (multiply by 100,000,000)</li> <li>You can use a calculator or simply move the decimal point 8 places to the right</li> </ul> </li> </ul> </li> <li> <p>Write down or copy these three pieces of information:</p> </li> </ol> <pre><code>Transaction ID (txid): [your transaction id]\nOutput Index: [your output index, usually 0]\nOutput Amount: [amount in BSV shown on WhatsOnChain] = [converted amount in satoshis]\n              Example: 0.00010000 BSV = 10000 satoshis\n</code></pre> <p>Important: Make sure you're looking at an unspent output. If the coins have already been spent, you won't be able to use them in your transaction. WhatsOnChain typically shows if an output has been spent.</p> <p>Write down this information as you'll need it for the next step.</p>"},{"location":"tutorials/testnet-transactions-low-level/#step-5-creating-a-transaction-with-utxos","title":"Step 5: Creating a Transaction with UTXOs","text":""},{"location":"tutorials/testnet-transactions-low-level/#understanding-utxo-consumption","title":"Understanding UTXO Consumption","text":"<p>When you spend a UTXO in Bitcoin, the entire UTXO must be consumed. You can think of a UTXO like a bill in your wallet - if you want to spend a $20 bill, you must use the entire bill, not just part of it. If you only want to spend $5, you'll spend the entire $20 bill and get $15 back as change.</p> <p>In the same way, when creating a Bitcoin transaction:</p> <ol> <li>You spend the entire UTXO (even if you only want to send a portion of it)</li> <li> <p>You specify how to distribute those funds:</p> <ul> <li>Some goes to the recipient (the payment)</li> <li>Some goes to the miners (the transaction fee)</li> <li>The remainder comes back to you (the change)</li> </ul> </li> </ol>"},{"location":"tutorials/testnet-transactions-low-level/#prerequisites","title":"Prerequisites","text":""},{"location":"tutorials/testnet-transactions-low-level/#taal-api-key-for-broadcasting","title":"Taal API Key for Broadcasting","text":"<p>To broadcast transactions via the ARC API, you'll need a Taal API key:</p> <ol> <li>Sign up for an account at https://console.taal.com</li> <li>Once logged in, navigate to the API keys section</li> <li>Create a new API key for your application</li> <li>Copy the generated API key - you'll need it for the transaction broadcasting step</li> </ol>"},{"location":"tutorials/testnet-transactions-low-level/#implementation","title":"Implementation","text":"<p>Create a file <code>send-transaction.ts</code>:</p> <pre><code>import { Transaction, PrivateKey, P2PKH, ARC, NodejsHttpClient } from '@bsv/sdk'\nimport https from 'https'\n\nasync function main() {\n  try {\n    // Step 1: Set up your wallet\n    const privateKey = PrivateKey.fromWif('your_testnet_private_key_here')\n    const myAddress = privateKey.toAddress([0x6f]) // 0x6f is the testnet prefix\n    const recipientAddress = 'testnet_address_to_send_coins_to'\n\n    // Step 2: Fetch the full transaction hex\n    const txid = 'source_transaction_id_here'\n    const response = await fetch(`https://api.whatsonchain.com/v1/bsv/test/tx/${txid}/hex`)\n    const sourceTxHex = await response.text()\n    console.log(`Retrieved transaction hex (first 50 chars): ${sourceTxHex.substring(0, 50)}...`)\n\n    // Step 3: Create a transaction\n    const tx = new Transaction()\n\n    // Step 4: Add the input\n    // For testnet, we need the hex of the transaction that contains our UTXO\n    tx.addInput({\n      sourceTransaction: Transaction.fromHex(sourceTxHex),\n      sourceOutputIndex: 0, // The output index from Step 4 (typically 0)\n      unlockingScriptTemplate: new P2PKH().unlock(privateKey)\n    })\n\n    // Step 5: Add the recipient output\n    tx.addOutput({\n      lockingScript: new P2PKH().lock(recipientAddress),\n      satoshis: 100 // Amount to send (must be less than input amount)\n    })\n\n    // Step 6: Add the change output back to our address\n      tx.addOutput({\n        lockingScript: new P2PKH().lock(myAddress),\n      change: true // SDK will automatically calculate the change amount\n      })\n\n    // Step 7: Calculate fee and sign the transaction\n    await tx.fee()\n    await tx.sign()\n\n    // Step 8: Broadcast the transaction to the testnet using ARC\n    // You need to provide your Taal API key here\n    // Get it by signing up at https://console.taal.com\n    const apiKey = 'your_taal_api_key_here' // Replace with your actual API key\n\n    // Create an HTTP client to ensure the transaction can be broadcast\n    const httpClient = new NodejsHttpClient(https)\n\n    // The SDK automatically appends '/v1/tx' to the base URL when broadcasting\n    // so we need to use the base URL without the '/arc' suffix\n    const arc = new ARC('https://arc-test.taal.com', {\n      apiKey,\n      httpClient, // Provide an HTTP client to avoid connectivity issues\n      deploymentId: 'testnet-tutorial-deployment' // Provide a fixed deployment ID to avoid random generation\n    })\n    const result = await tx.broadcast(arc)\n    console.log('ARC Response:', JSON.stringify(result, null, 2)) // Log the full response for debugging\n\n    // Step 9: Display the transaction ID\n    console.log(`Transaction ID: ${Buffer.from(tx.id()).toString('hex')}`)\n    console.log(`View on explorer: https://test.whatsonchain.com/tx/${Buffer.from(tx.id()).toString('hex')}`)\n    console.log('Transaction broadcast successfully!')\n  } catch (error) {\n    console.error('Error:', error)\n  }\n}\n\n// Run the main function\nmain()\n</code></pre> <p>Before running this script, make sure to replace these values in the code:</p> <ol> <li><code>your_testnet_private_key_here</code>: Your testnet private key (WIF format) from Step 2</li> <li><code>testnet_address_to_send_coins_to</code>: The recipient's testnet address - for the purpose of this tutorial, use your own address</li> <li><code>source_transaction_id_here</code>: The ID of the transaction containing your UTXO</li> <li>Update the <code>sourceOutputIndex</code> value if your output index is not 0</li> <li>Adjust the recipient output <code>satoshis</code> value (currently 100) to be less than your input amount</li> </ol> <p>Once you've made these changes, run the script:</p> <pre><code>npx ts-node send-transaction.ts\n</code></pre>"},{"location":"tutorials/testnet-transactions-low-level/#step-6-tracking-your-transaction","title":"Step 6: Tracking Your Transaction","text":"<p>After broadcasting your transaction, you can track its progress using a testnet explorer (note - it can take a few seconds for the transaction to show up). Our code already outputs the transaction ID and a direct link to view it on WhatsOnChain:</p> <pre><code>console.log(`Transaction ID: ${Buffer.from(tx.id()).toString('hex')}`)\nconsole.log(`View on explorer: https://test.whatsonchain.com/tx/${Buffer.from(tx.id()).toString('hex')}`)\n</code></pre> <p>Simply click the link or copy the transaction ID to search for it on WhatsOnChain Testnet or another testnet explorer.</p> <p>Initially, your transaction will be unconfirmed. Once it's included in a block, it will show as confirmed. On testnet, confirmations typically happen faster than on mainnet due to lower mining difficulty.</p>"},{"location":"tutorials/testnet-transactions-low-level/#step-7-understanding-transaction-fees","title":"Step 7: Understanding Transaction Fees","text":"<p>Transaction fees are paid to miners to include your transaction in a block. In our simplified code example, we're using the BSV SDK's automatic fee calculation with:</p> <pre><code>await tx.fee()\n</code></pre> <p>This method automatically calculates the appropriate fee based on:</p> <ul> <li>The size of your transaction (in bytes)</li> <li>Current network fee rates</li> <li>Number of inputs and outputs</li> </ul> <p>The <code>change: true</code> parameter in our change output works with the fee calculation to:</p> <ol> <li>Calculate the appropriate fee amount</li> <li>Subtract that fee from the total input amount</li> <li>Allocate the remaining balance to the change address</li> </ol> <p>This approach ensures your transaction pays an appropriate fee based on its size and current network conditions, without needing to manually calculate fees and change amounts.</p>"},{"location":"tutorials/testnet-transactions-low-level/#conclusion","title":"Conclusion","text":"<p>Congratulations! You've successfully created, signed, and broadcast a real transaction on the Bitcoin SV testnet. In this tutorial, you've learned:</p> <ul> <li>How to set up a testnet wallet</li> <li>How to obtain testnet coins from a faucet</li> <li>How to find and use UTXO information</li> <li>How to create, sign, and broadcast a real transaction</li> <li>How to track transaction confirmations</li> <li>How to work with transaction fees</li> </ul> <p>This practical experience with testnet transactions provides a solid foundation for working with real BSV transactions on the mainnet. With these skills, you're ready to move on to more advanced topics in the BSV TypeScript SDK.</p>"},{"location":"tutorials/testnet-transactions-low-level/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about Key Management and Cryptography</li> <li>Explore Advanced Transaction Construction</li> <li>Discover how to implement Multi-signature Transactions</li> </ul>"},{"location":"tutorials/testnet-transactions-low-level/#additional-resources","title":"Additional Resources","text":"<ul> <li>BSV Testnet Faucet List</li> <li>WhatsOnChain Testnet API Documentation</li> <li>BSV Transaction Reference</li> </ul>"},{"location":"tutorials/testnet-transactions-low-level/#low-level-vs-walletclient-approach","title":"Low-Level vs <code>WalletClient</code> Approach","text":"Feature Low-Level <code>WalletClient</code> Control Full control over transaction structure Simplified, high-level interface Complexity Requires manual UTXO management and fee calculation Handles UTXO management and fee calculation automatically Use Cases Advanced applications, custom transaction logic Most production applications, simple transaction workflows <p>The <code>WalletClient</code> approach is generally recommended for production applications, while the low-level approach is valuable for:</p> <ul> <li>Advanced applications requiring custom transaction logic</li> <li>Educational purposes, to understand the underlying mechanics of Bitcoin transactions</li> <li>Specialized use cases where fine-grained control is necessary</li> </ul> <p>Understanding both approaches will help you choose the best method for your specific use case and provide a deeper understanding of the Bitcoin SV ecosystem.</p> <p>This tutorial focuses on low-level transaction construction, which gives you complete control over every aspect of the transaction. For simpler applications, consider using the <code>WalletClient</code> approach covered in other tutorials.</p> <p>Alternative Approach: For most applications, the <code>WalletClient</code> interface provides a simpler way to create transactions. This tutorial focuses on the low-level approach for educational purposes and specialized use cases.</p>"},{"location":"tutorials/transaction-broadcasting/","title":"Transaction Broadcasting","text":"<p>Duration: 25 minutes Prerequisites: Completed \"Your First BSV Transaction\" tutorial, Node.js, basic TypeScript knowledge  </p>"},{"location":"tutorials/transaction-broadcasting/#learning-goals","title":"Learning Goals","text":"<ul> <li>Understand how transaction broadcasting works in BSV</li> <li>Learn the difference between <code>WalletClient</code> and direct broadcasting approaches</li> <li>Configure broadcasting for testnet vs mainnet</li> <li>Implement custom broadcasters for different services (ARC, WhatsOnChain)</li> <li>Handle broadcasting errors and responses</li> </ul> <p>\ud83d\udcda Related Concepts: Review Chain Tracking, Transaction Fees, and Wallet Integration for background on network interaction.</p>"},{"location":"tutorials/transaction-broadcasting/#introduction","title":"Introduction","text":"<p>Transaction broadcasting is the process of submitting your signed transaction to the Bitcoin SV network so it can be included in a block. The BSV TypeScript SDK provides multiple approaches for broadcasting transactions, each suited for different use cases and deployment scenarios.</p> <p>In this tutorial, you'll learn about the two main broadcasting approaches:</p> <ol> <li>WalletClient Broadcasting: Uses a BRC-100 compliant wallet as a proxy (such as the MetaNet Desktop Wallet)</li> <li>Direct Broadcasting: Connects directly to mining services and APIs</li> </ol>"},{"location":"tutorials/transaction-broadcasting/#understanding-broadcasting-architecture","title":"Understanding Broadcasting Architecture","text":""},{"location":"tutorials/transaction-broadcasting/#walletclient-broadcasting-flow","title":"WalletClient Broadcasting Flow","text":"<p>When you use <code>WalletClient</code>, the broadcasting flow looks like this:</p> <pre><code>Your App \u2192 WalletClient \u2192 Wallet \u2192 Mining Services \u2192 BSV Network\n</code></pre> <p>The Wallet acts as a proxy that:</p> <ul> <li>Manages your broadcasting preferences</li> <li>Handles fallback logic between different services</li> <li>Provides a consistent API regardless of the underlying service</li> </ul> <p>Due to its simplicity, this is the recommended approach.</p>"},{"location":"tutorials/transaction-broadcasting/#direct-broadcasting-flow","title":"Direct Broadcasting Flow","text":"<p>With direct broadcasting, your application connects directly to mining services:</p> <pre><code>Your App \u2192 Custom Broadcaster \u2192 Mining Service API \u2192 BSV Network\n</code></pre> <p>This approach gives you:</p> <ul> <li>Full control over which service to use</li> <li>Direct error handling and response processing</li> <li>Ability to implement custom retry logic</li> <li>No dependency on external wallet software</li> </ul> <p>Due to its complexity and need to handle the low-level details of the broadcasting process, this is the less recommended approach.</p>"},{"location":"tutorials/transaction-broadcasting/#step-1-walletclient-broadcasting","title":"Step 1: WalletClient Broadcasting","text":"<p>Let's start with the <code>WalletClient</code> approach, which is the simplest for most applications. This is the same approach we have seen in the previous tutorials, where we used the <code>WalletClient</code> to create and broadcast transactions.</p>"},{"location":"tutorials/transaction-broadcasting/#basic-walletclient-setup","title":"Basic WalletClient Setup","text":"<p>First, create a new project for our broadcasting examples:</p> <pre><code># Create a new directory\nmkdir bsv-broadcasting-tutorial\ncd bsv-broadcasting-tutorial\n\n# Initialize project\nnpm init -y\n\n# Install dependencies\nnpm install typescript ts-node @types/node --save-dev\nnpm install @bsv/sdk\n</code></pre> <p>Create a basic TypeScript configuration (<code>tsconfig.json</code>):</p> <pre><code>{\n  \"compilerOptions\": {\n    \"target\": \"es2020\",\n    \"module\": \"commonjs\",\n    \"esModuleInterop\": true,\n    \"strict\": true,\n    \"outDir\": \"./dist\"\n  }\n}\n</code></pre>"},{"location":"tutorials/transaction-broadcasting/#walletclient-broadcasting-example","title":"WalletClient Broadcasting Example","text":"<p>Create <code>wallet-broadcasting.ts</code>:</p> <pre><code>import { WalletClient } from '@bsv/sdk'\n\nasync function walletClientBroadcasting() {\n  try {\n    // Initialize the `WalletClient`, using localhost as wallet substrate\n    const wallet = new WalletClient('auto', 'localhost')\n\n    // Check if we're authenticated with the wallet\n    const { authenticated } = await wallet.isAuthenticated()\n    if (!authenticated) {\n      console.log('Please authenticate with your wallet')\n      await wallet.waitForAuthentication()\n      console.log('Successfully authenticated!')\n    }\n\n    // Get wallet version\n    const { version } = await wallet.getVersion()\n    console.log(`Wallet version: ${version}`)\n\n    // For this tutorial, we'll create a transaction with a simple OP_RETURN data output\n    // The wallet will handle input selection, change outputs and fees\n    console.log('\\n\ud83d\ude80 Creating transaction...')\n    const actionResult = await wallet.createAction({\n      description: 'Broadcasting tutorial transaction',\n      outputs: [\n        {\n          satoshis: 100, // Amount in satoshis (very small amount)\n          // For this basic example, we'll use a standard OP_RETURN script\n          // Here we use a pre-defined script for simplicity (OP_RETURN with simple data)\n          lockingScript: '006a0461626364', // OP_RETURN with data 'abcd'\n          outputDescription: 'Broadcasting tutorial data'\n        }\n      ]\n    })\n\n    console.log('Transaction created:')\n\n    if (actionResult.txid) {\n      // If the wallet auto-signed and broadcast the transaction\n      console.log('Full action result:', JSON.stringify(actionResult, null, 2))\n      console.log(`Transaction ID: ${actionResult.txid}`)\n      console.log(`View on explorer: https://whatsonchain.com/tx/${actionResult.txid}`)\n      console.log('Transaction was automatically signed and broadcast!')\n    } \n    else if (actionResult.signableTransaction) {\n      console.log('Created transaction that needs signing')\n      // Get the reference needed for signing\n      const txReference = actionResult.signableTransaction.reference\n\n      // Now sign the transaction\n      // Note: In a real application, you might prompt the user to sign\n      const signResult = await wallet.signAction({\n        // The wallet knows which inputs need to be spent based on the reference\n        spends: {},\n        // Use the reference from the createAction result\n        reference: txReference,\n        options: {\n          acceptDelayedBroadcast: true\n        }\n      })\n\n      console.log(`Transaction signed and broadcast!`)\n      console.log(`Transaction ID: ${signResult.txid}`)\n      console.log(`View on explorer: https://whatsonchain.com/tx/${signResult.txid}`)\n    }\n    else {\n      console.log('Transaction created but no actionable result returned')\n    }\n\n  } catch (error) {\n    console.error('\u274c Broadcasting failed:', error)\n    console.log('Note: Make sure you have a compatible wallet running and are authenticated.')\n  }\n}\n\n// Run the example\nwalletClientBroadcasting()\n</code></pre>"},{"location":"tutorials/transaction-broadcasting/#how-walletclient-broadcasting-works","title":"How <code>WalletClient</code> Broadcasting Works","text":"<p>When you use <code>WalletClient</code>:</p> <ol> <li>Connection: Your app connects to the BRC-100 wallet's local HTTP API (usually <code>http://localhost:3321</code> for MetaNet Desktop Wallet)</li> <li>Transaction Creation: The wallet helps construct the transaction using your available UTXOs</li> <li>Signing: The wallet signs the transaction with your private keys</li> <li>Broadcasting: The wallet submits the transaction to whatever broadcast service is configured in its settings</li> <li>Response: You receive either a transaction ID (success) or an error message</li> </ol> <p>The key advantage is that you don't control the broadcasting directly - the BRC-100 wallet handles it based on its configuration. This means:</p> <ul> <li>\u2705 Easy to use - no need to manage API keys or endpoints</li> <li>\u2705 Fallback logic built-in</li> <li>\u2705 User can configure preferred services through the wallet UI</li> </ul>"},{"location":"tutorials/transaction-broadcasting/#step-2-direct-broadcasting-with-custom-broadcasters","title":"Step 2: Direct Broadcasting with Custom Broadcasters","text":"<p>The <code>WalletClient</code> approach in step 1 is the recommended approach. However, if you need more control, you can broadcast transactions directly using custom broadcaster implementations. We will demonstrate the main broadcaster implementations in the SDK: ARC and WhatsOnChain.</p>"},{"location":"tutorials/transaction-broadcasting/#automatic-vs-manual-broadcasting","title":"Automatic vs Manual Broadcasting","text":"<p>Important: By default, <code>wallet.createAction()</code> automatically broadcasts transactions through the wallet's configured broadcaster. To demonstrate manual broadcasting with specific services, you need to:</p> <ol> <li>Prevent automatic broadcast: Use <code>options: { noSend: true }</code> in <code>createAction()</code></li> <li>Convert to Transaction: Convert the returned <code>AtomicBEEF</code> to a <code>Transaction</code> object</li> <li>Manual broadcast: Use your chosen broadcaster to submit the transaction</li> </ol> <p>This approach is useful when you need to:</p> <ul> <li>Use a specific broadcasting service (ARC, WhatsOnChain, etc.)</li> <li>Implement custom retry logic or error handling</li> <li>Broadcast to multiple services for redundancy</li> <li>Control exactly when and how transactions are broadcast</li> </ul>"},{"location":"tutorials/transaction-broadcasting/#understanding-broadcaster-interface","title":"Understanding Broadcaster Interface","text":"<p>All broadcasters in the SDK implement the <code>Broadcaster</code> interface:</p> <pre><code>interface Broadcaster {\n  broadcast(tx: Transaction): Promise&lt;BroadcastResponse | BroadcastFailure&gt;\n}\n</code></pre> <p>The response types are:</p> <pre><code>interface BroadcastResponse {\n  status: 'success'\n  txid: string\n  message?: string\n}\n\ninterface BroadcastFailure {\n  status: 'error'\n  code: string\n  description: string\n}\n</code></pre>"},{"location":"tutorials/transaction-broadcasting/#arc-broadcasting","title":"ARC Broadcasting","text":"<p>ARC (Application Resource Component) is TAAL's enterprise-grade transaction processing service. Create <code>arc-broadcasting.ts</code>:</p> <pre><code>import { WalletClient, ARC, NodejsHttpClient, Transaction } from '@bsv/sdk'\nimport https from 'https'\n\nasync function arcBroadcasting() {\n  try {\n    // 1. Set up wallet connection\n    const wallet = new WalletClient('auto', 'localhost')\n\n    // Check if wallet is connected\n    const isAuthenticated = await wallet.isAuthenticated()\n    if (!isAuthenticated) {\n      console.log('Please authenticate with your BRC-100 wallet first')\n      return\n    }\n\n    // 2. Create a transaction action WITHOUT automatic broadcasting\n    const actionResult = await wallet.createAction({\n      description: 'ARC broadcasting tutorial transaction',\n      outputs: [\n        {\n          satoshis: 100, // Small payment amount\n          lockingScript: '76a914f1c075a01882ae0972f95d3a4177c86c852b7d9188ac', // P2PKH script to a test address\n          outputDescription: 'ARC broadcasting tutorial payment'\n        }\n      ],\n      options: {\n        noSend: true // Prevent automatic broadcasting - we'll broadcast manually with ARC\n      }\n    })\n\n    console.log('Transaction created successfully (not broadcast yet)')\n    console.log(`Transaction ID: ${actionResult.txid}`)\n\n    // 3. Convert AtomicBEEF to Transaction for manual broadcasting\n    if (!actionResult.tx) {\n      throw new Error('Transaction creation failed - no transaction returned')\n    }\n    const tx = Transaction.fromAtomicBEEF(actionResult.tx)\n\n    // 4. Set up ARC broadcaster for testnet\n    // You need to provide your Taal API key here\n    // Get it by signing up at https://console.taal.com\n    const apiKey = process.env.TAAL_API_KEY || 'your_taal_api_key_here'\n    const httpClient = new NodejsHttpClient(https)\n\n    const arc = new ARC('https://arc.taal.com', {\n      apiKey,\n      httpClient,\n      deploymentId: 'broadcasting-tutorial'\n    })\n\n    // 5. Manually broadcast the transaction using ARC\n    console.log('Broadcasting transaction with ARC...')\n    const result = await tx.broadcast(arc)\n\n    if (result.status === 'success') {\n      console.log('\u2705 Transaction broadcast successful!')\n      console.log(`Transaction ID: ${result.txid}`)\n      console.log(`View on explorer: https://www.whatsonchain.com/tx/${result.txid}`)\n    } else {\n      console.log('\u274c Broadcasting failed:', result)\n    }\n\n  } catch (error: any) {\n    console.error('\u274c Error during ARC broadcasting:', error)\n\n    // Common troubleshooting\n    if (error.message?.includes('Insufficient funds')) {\n      console.log('\ud83d\udca1 Make sure your wallet has sufficient testnet coins')\n    } else if (error.message?.includes('no header should have returned false')) {\n      console.log('\ud83d\udca1 Try restarting your wallet application and ensure it is fully synced')\n    }\n  }\n}\n\n// Run the example\narcBroadcasting()\n</code></pre>"},{"location":"tutorials/transaction-broadcasting/#whatsonchain-broadcasting","title":"WhatsOnChain Broadcasting","text":"<p>WhatsOnChain provides a free broadcasting service. Create <code>whatsonchain-broadcasting.ts</code>:</p> <pre><code>import { WalletClient, WhatsOnChainBroadcaster, NodejsHttpClient, Transaction } from '@bsv/sdk'\nimport https from 'https'\n\nasync function whatsOnChainBroadcasting() {\n  try {\n    // 1. Set up wallet connection\n    const wallet = new WalletClient('auto', 'localhost')\n\n    // Check if wallet is connected\n    const isAuthenticated = await wallet.isAuthenticated()\n    if (!isAuthenticated) {\n      console.log('Please authenticate with your BRC-100 wallet first')\n      return\n    }\n\n    // 2. Create a transaction action WITHOUT automatic broadcasting\n    const actionResult = await wallet.createAction({\n      description: 'WhatsOnChain broadcasting tutorial transaction',\n      outputs: [\n        {\n          satoshis: 100, // Small payment amount\n          lockingScript: '76a914f1c075a01882ae0972f95d3a4177c86c852b7d9188ac', // P2PKH script to a test address\n          outputDescription: 'WhatsOnChain broadcasting tutorial payment'\n        }\n      ],\n      options: {\n        noSend: true // Prevent automatic broadcasting - we'll broadcast manually with WhatsOnChain\n      }\n    })\n\n    console.log('Transaction created successfully (not broadcast yet)')\n    console.log(`Transaction ID: ${actionResult.txid}`)\n\n    // 3. Convert AtomicBEEF to Transaction for manual broadcasting\n    if (!actionResult.tx) {\n      throw new Error('Transaction creation failed - no transaction returned')\n    }\n    const tx = Transaction.fromAtomicBEEF(actionResult.tx)\n\n    // 4. Set up WhatsOnChain broadcaster for mainnet\n    const httpClient = new NodejsHttpClient(https)\n    const broadcaster = new WhatsOnChainBroadcaster('main', httpClient)\n\n    // 5. Manually broadcast the transaction using WhatsOnChain\n    console.log('Broadcasting transaction with WhatsOnChain...')\n    const result = await tx.broadcast(broadcaster)\n\n    if (result.status === 'success') {\n      console.log('\u2705 Transaction broadcast successful!')\n      console.log(`Transaction ID: ${result.txid}`)\n      console.log(`View on explorer: https://www.whatsonchain.com/tx/${result.txid}`)\n    } else {\n      console.log('\u274c Broadcasting failed:', result)\n    }\n\n  } catch (error: any) {\n    console.error('\u274c Error during WhatsOnChain broadcasting:', error)\n\n    // Common troubleshooting\n    if (error.message?.includes('Insufficient funds')) {\n      console.log('\ud83d\udca1 Make sure your wallet has sufficient mainnet coins')\n    } else if (error.message?.includes('no header should have returned false')) {\n      console.log('\ud83d\udca1 Try restarting your wallet application and ensure it is fully synced')\n    }\n  }\n}\n\n// Run the example\nwhatsOnChainBroadcasting()\n</code></pre>"},{"location":"tutorials/transaction-broadcasting/#step-3-network-configuration-testnet-vs-mainnet","title":"Step 3: Network Configuration (Testnet vs Mainnet)","text":"<p>For advanced broadcasting scenarios like custom broadcaster implementations, see the Custom Broadcasters Guide.</p> <p>Important: When using manual broadcasting, ensure your wallet and broadcasters are configured for the same network. If your BRC-100 wallet is connected to testnet, use testnet broadcasters. If it's on mainnet, use mainnet broadcasters. Mismatched networks will cause broadcasting failures.</p> <p>Different networks require different broadcaster configurations:</p> <pre><code>import { ARC, WhatsOnChainBroadcaster, Broadcaster } from '@bsv/sdk'\n\ninterface NetworkConfig {\n  name: string\n  arc: Broadcaster\n  whatsOnChain: Broadcaster\n}\n\n// Network configurations\nconst networks: Record&lt;string, NetworkConfig&gt; = {\n  testnet: {\n    name: 'BSV Testnet',\n    arc: new ARC('https://arc-test.taal.com'),\n    whatsOnChain: new WhatsOnChainBroadcaster('test')\n  },\n\n  mainnet: {\n    name: 'BSV Mainnet',\n    arc: new ARC('https://arc.taal.com', {\n      apiKey: process.env.TAAL_API_KEY // Use environment variable for production\n    }),\n    whatsOnChain: new WhatsOnChainBroadcaster('main')\n  }\n}\n</code></pre>"},{"location":"tutorials/transaction-broadcasting/#step-4-monitoring-and-verification","title":"Step 4: Monitoring and Verification","text":"<p>After broadcasting, you should verify that your transaction was accepted:</p> <pre><code>import { Transaction } from '@bsv/sdk'\n\nasync function verifyTransaction(txid: string, network: 'test' | 'main' = 'test') {\n  const baseUrl = network === 'test' \n    ? 'https://api.whatsonchain.com/v1/bsv/test'\n    : 'https://api.whatsonchain.com/v1/bsv/main'\n\n  try {\n    // Check if transaction exists\n    const response = await fetch(`${baseUrl}/tx/${txid}`)\n\n    if (response.ok) {\n      const txData = await response.json()\n\n      console.log('\u2705 Transaction found on network')\n      console.log('Transaction ID:', txData.txid)\n      console.log('Block height:', txData.blockheight || 'Unconfirmed')\n      console.log('Confirmations:', txData.confirmations || 0)\n\n      return txData\n    } else if (response.status === 404) {\n      console.log('\u23f3 Transaction not yet visible on network')\n      return null\n    } else {\n      throw new Error(`API error: ${response.status}`)\n    }\n\n  } catch (error) {\n    console.error('\u274c Error verifying transaction:', error)\n    throw error\n  }\n}\n\nasync function waitForTransaction(\n  txid: string, \n  network: 'test' | 'main' = 'test',\n  timeoutMs: number = 30000\n): Promise&lt;any&gt; {\n  const startTime = Date.now()\n\n  while (Date.now() - startTime &lt; timeoutMs) {\n    const txData = await verifyTransaction(txid, network)\n\n    if (txData) {\n      return txData\n    }\n\n    // Transactions can take a few seconds to show up in WhatsOnChain\n    // Wait 2 seconds before checking again\n    await new Promise(resolve =&gt; setTimeout(resolve, 2000))\n  }\n\n  throw new Error(`Transaction ${txid} not found within ${timeoutMs}ms`)\n}\n\n// Example usage\nasync function monitoringExample(txid: string) {\n  try {\n    console.log('Waiting for transaction to appear on network...')\n    const txData = await waitForTransaction(txid, 'main')\n\n    console.log('\u2705 Transaction confirmed:', txData)\n\n  } catch (error) {\n    console.error('\u274c Transaction monitoring failed:', error)\n  }\n}\n\n// Run the example\nmonitoringExample('your-transaction-id-here')\n</code></pre>"},{"location":"tutorials/transaction-broadcasting/#summary","title":"Summary","text":"<p>In this tutorial, you learned about the two main approaches to transaction broadcasting in BSV:</p>"},{"location":"tutorials/transaction-broadcasting/#walletclient-approach","title":"<code>WalletClient</code> Approach","text":"<ul> <li>\u2705 Simple: Easy to use with BRC-100 wallets</li> <li>\u2705 Managed: Wallet handles service selection and fallbacks</li> <li>\u2705 User Control: Users can configure preferred services</li> </ul>"},{"location":"tutorials/transaction-broadcasting/#direct-broadcasting-approach","title":"Direct Broadcasting Approach","text":"<ul> <li>\u2705 Full Control: Choose exactly which service to use</li> <li>\u2705 No Dependencies: Works without external wallet software</li> <li>\u2705 Custom Logic: Implement your own retry and fallback logic</li> <li>\u2705 Error Handling: Direct access to service responses</li> <li>\u274c More Complex: Requires more setup and configuration</li> </ul>"},{"location":"tutorials/transaction-broadcasting/#next-steps","title":"Next Steps","text":"<ul> <li>Experiment with different broadcaster configurations</li> <li>Implement custom broadcasters for other services  </li> <li>Build monitoring dashboards for your applications</li> <li>Explore advanced features like batch broadcasting</li> <li>Implement robust error handling: See the Error Handling and Edge Cases Tutorial for comprehensive patterns and the Custom Broadcasters Guide for advanced retry logic and failover strategies</li> </ul> <p>The broadcasting approach you choose depends on your application's requirements, deployment environment, and control needs. Both approaches are valid and can be used effectively in different scenarios.</p>"},{"location":"tutorials/transaction-types/","title":"Transaction Types and Data","text":"<p>Duration: 30 minutes Prerequisites: Completed \"Your First BSV Transaction\" tutorial, Node.js, basic TypeScript knowledge  </p>"},{"location":"tutorials/transaction-types/#learning-goals","title":"Learning Goals","text":"<ul> <li>Create transactions with multiple outputs</li> <li>Add data to transactions</li> <li>Work with different output types</li> <li>Use advanced <code>WalletClient</code> features</li> </ul>"},{"location":"tutorials/transaction-types/#introduction","title":"Introduction","text":"<p>In the previous tutorial, you created a simple transaction that sent BSV to a single address. In this tutorial, you'll expand your knowledge by learning how to create more complex transactions using the <code>WalletClient</code> interface. You'll learn how to send to multiple recipients, include data in transactions, and explore more advanced <code>WalletClient</code> features.</p>"},{"location":"tutorials/transaction-types/#prerequisites","title":"Prerequisites","text":"<ul> <li>Complete the Your First BSV Transaction tutorial</li> <li>Have a BRC-100 compliant wallet (such as MetaNet Desktop Wallet) installed and configured</li> <li>Some BSV in your wallet</li> </ul>"},{"location":"tutorials/transaction-types/#transaction-with-multiple-outputs","title":"Transaction with Multiple Outputs","text":"<p>One powerful feature of Bitcoin transactions is the ability to send to multiple recipients in a single transaction. Let's create a transaction that sends to two different recipients:</p> <pre><code>import { WalletClient } from '@bsv/sdk'\n\nasync function createMultiOutputTransaction() {\n  try {\n    // Initialize the WalletClient (use localhost as wallet originator)\n    const wallet = new WalletClient('auto', 'localhost')\n\n    // Authenticate with the wallet if needed\n    const { authenticated } = await wallet.isAuthenticated()\n    if (!authenticated) {\n      console.log('Please authenticate with your wallet')\n      await wallet.waitForAuthentication()\n    }\n\n    // Get network information\n    const { network } = await wallet.getNetwork()\n    console.log(`Connected to ${network} network`)\n\n    // Get our own public key for sending back to ourselves\n    const { publicKey } = await wallet.getPublicKey({ identityKey: true })\n\n    // Create a transaction with multiple outputs\n    const actionResult = await wallet.createAction({\n      description: 'Multi-output transaction example',\n      outputs: [\n        {\n          // First output - uses simple OP_RETURN with data\n          satoshis: 100,\n          lockingScript: '006a0461626364', // OP_RETURN with data 'abcd'\n          outputDescription: 'First data output'\n        },\n        {\n          // Second output - also uses OP_RETURN with different data\n          satoshis: 100,\n          lockingScript: '006a04656667', // OP_RETURN with data 'efgh'\n          outputDescription: 'Second data output'\n        }\n      ]\n    })\n\n    console.log('Transaction created:')\n\n    let txReference\n    let txid\n\n    // If the wallet auto-signed and broadcast the transaction (otherwise, refer to the examples in our first tutorial to see how to explicitly sign it and broadcast it)\n    if (actionResult.txid) {\n\n      console.log(`Transaction ID: ${actionResult.txid}`)\n      console.log(`View on explorer: https://whatsonchain.com/tx/${actionResult.txid}`)\n      console.log('Transaction was automatically signed and broadcast!')\n      txid = actionResult.txid\n    } \n    else {\n      console.log('Transaction created but no actionable result returned')\n    }\n\n    console.log(`Transaction ID: ${txid}`)\n    console.log(`View on explorer: https://whatsonchain.com/tx/${txid}`)\n\n  } catch (error) {\n    console.error('Error:', error)\n  }\n}\n\ncreateMultiOutputTransaction().catch(console.error)\n</code></pre> <p>This transaction creates two outputs, both sending funds back to your own wallet but with different amounts and descriptions. In a real-world scenario, you could send to different recipients by specifying different addresses or public keys.</p>"},{"location":"tutorials/transaction-types/#adding-data-to-transactions","title":"Adding Data to Transactions","text":"<p>Another powerful capability of Bitcoin SV is the ability to store data on-chain. Let's create a transaction that includes some data:</p> <pre><code>import { WalletClient } from '@bsv/sdk'\n\nasync function createDataTransaction() {\n  try {\n    // Initialize the WalletClient\n    const wallet = new WalletClient('auto', 'localhost')\n\n    // Authenticate with the wallet if needed\n    const { authenticated } = await wallet.isAuthenticated()\n    if (!authenticated) {\n      await wallet.waitForAuthentication()\n    }\n\n    // Data to store on-chain (in this case, a simple text message)\n    const message = 'Hello, Bitcoin SV!'\n\n    // Convert the message to a hex string\n    const messageHex = Buffer.from(message).toString('hex')\n    console.log(`Message as hex: ${messageHex}`)\n\n    // Create the OP_RETURN script - start with OP_FALSE (00) + OP_RETURN (6a)\n    // Then add the length of the data as a single byte (hex encoded)\n    // Our message length is 16 bytes (0x10 in hex)\n    const dataLength = Buffer.from(message).length\n    const dataLengthHex = dataLength.toString(16).padStart(2, '0')\n\n    // Complete lockingScript: OP_FALSE + OP_RETURN + data length + data\n    const lockingScript = `006a${dataLengthHex}${messageHex}`\n    console.log(`Complete lockingScript: ${lockingScript}`)\n\n    // Create a transaction with an OP_RETURN output containing our data\n    const actionResult = await wallet.createAction({\n      description: 'Store data on-chain',\n      outputs: [\n        {\n          satoshis: 100, // Small amount of satoshis\n          lockingScript: lockingScript, // Dynamic OP_RETURN with our message data\n          outputDescription: 'Data storage'\n        }\n      ]\n    })\n\n    console.log('Transaction created:')\n\n    let txReference\n    let txid\n\n    if (actionResult.txid) {\n      // If the wallet auto-signed and broadcast the transaction\n      console.log(`Transaction ID: ${actionResult.txid}`)\n      console.log(`View on explorer: https://whatsonchain.com/tx/${actionResult.txid}`)\n      console.log('Transaction was automatically signed and broadcast!')\n      txid = actionResult.txid\n    } \n    else {\n      console.log('Transaction created but no actionable result returned')\n    }\n\n    console.log(`Transaction ID: ${txid}`)\n    console.log(`View on explorer: https://whatsonchain.com/tx/${txid}`)\n    console.log(`Data stored on-chain: \"${message}\"`)\n\n  } catch (error) {\n    console.error('Error:', error)\n  }\n}\n\ncreateDataTransaction().catch(console.error)\n</code></pre> <p>This transaction includes an OP_RETURN output, which is a special type of output that can contain arbitrary data but cannot be spent. This is a common way to store data on the Bitcoin SV blockchain.</p>"},{"location":"tutorials/transaction-types/#combining-payment-and-data","title":"Combining Payment and Data","text":"<p>You can also combine regular payment outputs with data outputs in the same transaction:</p> <pre><code>import { WalletClient } from '@bsv/sdk'\n\nasync function createCombinedTransaction() {\n  try {\n    // Initialize the WalletClient\n    const wallet = new WalletClient('auto', 'localhost')\n\n    // Authenticate with the wallet if needed\n    const { authenticated } = await wallet.isAuthenticated()\n    if (!authenticated) {\n      await wallet.waitForAuthentication()\n    }\n\n    // Get our own public key for sending back to ourselves\n    const { publicKey } = await wallet.getPublicKey({ identityKey: true })\n\n    // Message data for our OP_RETURN outputs\n    const receipt = 'Payment receipt'\n    const orderRef = 'Order #12345'\n\n    // Convert messages to hex\n    const receiptHex = Buffer.from(receipt).toString('hex')\n    const orderHex = Buffer.from(orderRef).toString('hex')\n\n    // Build the OP_RETURN scripts with correct lengths\n    // Format: OP_FALSE (00) + OP_RETURN (6a) + length byte + data in hex\n    const receiptLength = Buffer.from(receipt).length\n    const receiptLengthHex = receiptLength.toString(16).padStart(2, '0') // Ensure even length\n    const receiptScript = `006a${receiptLengthHex}${receiptHex}`\n\n    const orderLength = Buffer.from(orderRef).length\n    const orderLengthHex = orderLength.toString(16).padStart(2, '0') // Ensure even length\n    const orderScript = `006a${orderLengthHex}${orderHex}`\n\n    console.log(`Receipt script: ${receiptScript}`)\n    console.log(`Order script: ${orderScript}`)\n\n    // Create a transaction with both outputs containing different data\n    const actionResult = await wallet.createAction({\n      description: 'Multi-data transaction',\n      outputs: [\n        {\n          // First data output\n          satoshis: 100,\n          lockingScript: receiptScript, // OP_RETURN with payment receipt data\n          outputDescription: 'Payment receipt data'\n        },\n        {\n          // Second data output with different content\n          satoshis: 100,\n          lockingScript: orderScript, // OP_RETURN with order reference data\n          outputDescription: 'Order reference data'\n        }\n      ]\n    })\n\n    console.log('Transaction created:')\n\n    let txReference\n    let txid\n\n    if (actionResult.txid) {\n      // If the wallet auto-signed and broadcast the transaction\n      console.log(`Transaction ID: ${actionResult.txid}`)\n      console.log(`View on explorer: https://whatsonchain.com/tx/${actionResult.txid}`)\n      console.log('Transaction was automatically signed and broadcast!')\n      txid = actionResult.txid\n    } \n    else {\n      console.log('Transaction created but no actionable result returned')\n    }\n\n    console.log(`Transaction ID: ${txid}`)\n    console.log(`View on explorer: https://whatsonchain.com/tx/${txid}`)\n\n  } catch (error) {\n    console.error('Error:', error)\n  }\n}\n\ncreateCombinedTransaction().catch(console.error)\n</code></pre> <p>This pattern of combining payments with data is very powerful for business applications, allowing you to create an immutable record of a payment that includes metadata about the purpose of the payment.</p>"},{"location":"tutorials/transaction-types/#working-with-transaction-history","title":"Working with Transaction History","text":"<p>The <code>WalletClient</code> also allows you to retrieve your transaction history:</p> <pre><code>import { WalletClient } from '@bsv/sdk'\n\nasync function viewTransactionHistory() {\n  try {\n    // Initialize the WalletClient\n    const wallet = new WalletClient('auto', 'localhost')\n\n    // Authenticate with the wallet if needed\n    const { authenticated } = await wallet.isAuthenticated()\n    if (!authenticated) {\n      await wallet.waitForAuthentication()\n    }\n\n    // Get transaction history\n    const { totalActions, actions } = await wallet.listActions({\n      limit: 10, // Limit to the 10 first transactions\n      offset: 0  // Start from the beginning\n    })\n\n    console.log(`Found ${totalActions} total transactions`)\n    console.log('Recent transactions:')\n\n    // Display transaction details\n    actions.forEach((action, index) =&gt; {\n      console.log(`\\nTransaction #${index + 1}:`)\n      console.log(`  TXID: ${action.txid}`)\n      console.log(`  Description: ${action.description}`)\n      console.log(`  Amount: ${action.satoshis} satoshis`)\n      console.log(`  Status: ${action.status}`)\n      console.log(`  Is Outgoing: ${action.isOutgoing ? 'Yes' : 'No'}`)\n    })\n\n  } catch (error) {\n    console.error('Error:', error)\n  }\n}\n\nviewTransactionHistory().catch(console.error)\n</code></pre> <p>This code retrieves and displays your recent transaction history, showing transaction IDs, descriptions, amounts, statuses, and whether each transaction was outgoing or incoming.</p>"},{"location":"tutorials/transaction-types/#advanced-features-working-with-baskets","title":"Advanced Features: Working with Baskets","text":"<p>In the BSV SDK, \"baskets\" are a powerful UTXO management concept that allows you to organize and categorize your unspent transaction outputs (UTXOs) for better control over how they're used in transactions. Think of baskets as labeled containers for your UTXOs. Each basket can have its own purpose - for example, you might have a \"savings\" basket for long-term storage, a \"spending\" basket for daily transactions, or special baskets for specific applications or smart contracts.</p> <p>Baskets help with:</p> <ul> <li>UTXO organization: Group outputs for different purposes or applications</li> <li>Transaction optimization: Control which UTXOs are used for specific transaction types</li> <li>Privacy enhancement: Segregate UTXOs from different sources or uses</li> <li>Application-specific management: Maintain dedicated UTXOs for particular applications</li> </ul> <p>The <code>WalletClient</code> provides methods for working with baskets to give you fine-grained control over your UTXO management:</p> <pre><code>import { WalletClient } from '@bsv/sdk'\n\nasync function workWithBaskets() {\n  try {\n    // Initialize the WalletClient\n    const wallet = new WalletClient('auto', 'localhost')\n\n    // Authenticate with the wallet if needed\n    const { authenticated } = await wallet.isAuthenticated()\n    if (!authenticated) {\n      await wallet.waitForAuthentication()\n    }\n\n    // Basket name for our example\n    const basketName = 'bsv-tutorial'\n\n    // Let's create a transaction that explicitly uses this basket\n\n    console.log('\\nCreating a transaction with outputs assigned to our basket...')\n\n    // Get our own public key for the transaction\n    const { publicKey } = await wallet.getPublicKey({ identityKey: true })\n\n    // Create a transaction with outputs assigned to a specific basket\n    const actionResult = await wallet.createAction({\n      description: 'Transaction with basket assignment',\n      outputs: [\n        {\n          satoshis: 100,\n          lockingScript: '006a0c426173746b657420746573742e', // Simple OP_RETURN\n          outputDescription: 'Basket demonstration',\n          basket: basketName // Assign this output to our basket\n        }\n      ]\n    })\n\n    if (actionResult.txid) {\n      console.log(`Created transaction with ID: ${actionResult.txid}`)\n      console.log(`Output has been assigned to the \"${basketName}\" basket`)\n    }\n\n    // List outputs in the specified basket\n    const { outputs } = await wallet.listOutputs({\n      basket: basketName,\n      include: 'all' // use 'spendable' if you only want to see UTXOs that can be spent\n    })\n\n    console.log(`Found ${outputs.length} outputs in the \"${basketName}\" basket`)\n\n    // Display output details\n    outputs.forEach((output, index) =&gt; {\n      console.log(`\\nOutput #${index + 1}:`)\n      console.log(`  Outpoint: ${output.outpoint}`)\n      console.log(`  Value: ${output.satoshis} satoshis`)\n      console.log(`  Spendable: ${output.spendable ? 'Yes' : 'No'}`)\n    })\n\n  } catch (error) {\n    console.error('Error:', error)\n  }\n}\n\nworkWithBaskets().catch(console.error)\n</code></pre> <p>Important::</p> <ul> <li>The <code>basket</code> parameter is set at the individual output level, not at the transaction level</li> <li>Each output can be assigned to a different basket if needed</li> <li>The <code>include</code> parameter in <code>listOutputs()</code> can filter for 'all', 'spendable', or 'unspendable' outputs</li> <li>For a UTXO to appear in a basket, the output must explicitly have a <code>basket</code> property when it's created</li> </ul>"},{"location":"tutorials/transaction-types/#conclusion","title":"Conclusion","text":"<p>Congratulations! You've now learned how to create more complex transactions using the <code>WalletClient</code> interface. You can:</p> <ul> <li>Send to multiple recipients in a single transaction</li> <li>Store data on the blockchain using OP_RETURN outputs</li> <li>Combine payments with data in the same transaction</li> <li>Retrieve and view your transaction history</li> <li>Work with baskets to organize your UTXOs</li> </ul> <p>These capabilities form the foundation for building sophisticated applications on Bitcoin SV. With the <code>WalletClient</code> interface, you can focus on your application logic rather than the low-level details of transaction construction.</p>"},{"location":"tutorials/transaction-types/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about Key Management and Cryptography</li> <li>Explore Advanced Transaction Signing</li> <li>If you need more control over transaction construction, check out the Direct Transaction Creation Guide</li> </ul>"},{"location":"tutorials/transaction-types/#additional-resources","title":"Additional Resources","text":"<ul> <li>WalletClient API Reference</li> <li>BSV Transaction Types</li> <li>Data Storage on BSV</li> </ul>"},{"location":"tutorials/type-42/","title":"Type-42 Key Derivation","text":"<p>Duration: 75 minutes Prerequisites: Basic TypeScript knowledge, Elliptic Curve Fundamentals tutorial completed, ECDH Key Exchange tutorial completed</p>"},{"location":"tutorials/type-42/#learning-goals","title":"Learning Goals","text":"<ul> <li>Understand Type-42 key derivation protocol and its use cases</li> <li>Implement Type-42 operations with the BSV TypeScript SDK</li> <li>Create shared key universes between two parties</li> <li>Apply Type-42 in practical Bitcoin applications like message signing and encryption</li> <li>Understand the \"anyone key\" concept and its applications</li> </ul>"},{"location":"tutorials/type-42/#introduction-to-type-42","title":"Introduction to Type-42","text":"<p>Type-42 is a key derivation protocol that enables two parties with master keys to derive child keys from one another using a specific string called an \"invoice number.\" This creates a shared key universe that only these two parties can access, enabling secure communication and transactions without revealing their master keys.</p> <p>The protocol gets its name from its historical use in Bitcoin payment systems, where invoice numbers were used to generate unique keys for each transaction. However, Type-42 has broader applications in secure messaging, authentication, and any scenario requiring shared key derivation.</p>"},{"location":"tutorials/type-42/#setting-up-your-environment","title":"Setting Up Your Environment","text":"<pre><code>import { PrivateKey, PublicKey, Utils } from '@bsv/sdk'\n</code></pre>"},{"location":"tutorials/type-42/#understanding-type-42-process","title":"Understanding Type-42 Process","text":""},{"location":"tutorials/type-42/#the-mathematical-foundation","title":"The Mathematical Foundation","text":"<p>Type-42 key derivation follows these steps:</p> <ol> <li>Master Key Generation: Each party generates a master private key</li> <li>Public Key Exchange: Parties share their master public keys</li> <li>Shared Secret Creation: Using ECDH, parties compute a shared secret</li> <li>Invoice Number Agreement: Parties agree on a unique identifier (invoice number)</li> <li>HMAC Computation: The shared secret is used as an HMAC key to hash the invoice number</li> <li>Key Derivation: The HMAC output is used to derive child keys</li> </ol>"},{"location":"tutorials/type-42/#security-properties","title":"Security Properties","text":"<ul> <li>Only the two parties can compute the shared secret</li> <li>Only they can use the HMAC function with their shared secret</li> <li>No one else can link master keys to derived keys</li> <li>Each invoice number creates a unique key pair in their shared universe</li> </ul>"},{"location":"tutorials/type-42/#basic-type-42-implementation","title":"Basic Type-42 Implementation","text":""},{"location":"tutorials/type-42/#step-1-master-key-setup","title":"Step 1: Master Key Setup","text":"<pre><code>// Alice generates her master key pair\nconst alice = PrivateKey.fromRandom()\nconst alicePub = alice.toPublicKey()\n\n// Bob generates his master key pair\nconst bob = PrivateKey.fromRandom()\nconst bobPub = bob.toPublicKey()\n\nconsole.log('Alice master public key:', alicePub.toString())\nconsole.log('Bob master public key:', bobPub.toString())\n</code></pre>"},{"location":"tutorials/type-42/#step-2-invoice-number-agreement","title":"Step 2: Invoice Number Agreement","text":"<pre><code>// Both parties agree on an invoice number to use\n// This could be a payment ID, message ID, or any unique identifier\nconst invoiceNumber = '2-simple signing protocol-1'\n\nconsole.log('Using invoice number:', invoiceNumber)\n</code></pre>"},{"location":"tutorials/type-42/#step-3-child-key-derivation","title":"Step 3: Child Key Derivation","text":"<pre><code>// Alice derives a child private key for signing\nconst aliceSigningChild = alice.deriveChild(bobPub, invoiceNumber)\n\n// Bob derives Alice's corresponding public key\nconst aliceSigningPub = alicePub.deriveChild(bob, invoiceNumber)\n\n// Verify the keys match\nconst derivedPubFromPriv = aliceSigningChild.toPublicKey()\nconst keysMatch = derivedPubFromPriv.toString() === aliceSigningPub.toString()\nconsole.log('Keys match:', keysMatch)\n// true\n</code></pre>"},{"location":"tutorials/type-42/#practical-example-message-signing","title":"Practical Example: Message Signing","text":"<p>Let's implement a complete example where Alice signs a message for Bob using Type-42 derived keys:</p> <pre><code>import { PrivateKey, Utils } from '@bsv/sdk'\n\nasync function demonstrateType42Signing() {\n  // Step 1: Generate master keys\n  const alice = PrivateKey.fromRandom()\n  const alicePub = alice.toPublicKey()\n\n  const bob = PrivateKey.fromRandom()\n  const bobPub = bob.toPublicKey()\n\n  // Step 2: Agree on invoice number\n  const invoiceNumber = '2-secure-message-001'\n\n  // Step 3: Alice derives her signing key\n  const aliceSigningChild = alice.deriveChild(bobPub, invoiceNumber)\n\n  // Step 4: Alice signs a message\n  const message = Utils.toArray('Hello Bob, this is a secure message!', 'utf8')\n  const signature = aliceSigningChild.sign(message)\n\n  console.log('Message signed by Alice')\n  console.log('Signature:', signature.toDER('hex'))\n\n  // Step 5: Bob derives Alice's public key and verifies\n  const aliceSigningPub = alicePub.deriveChild(bob, invoiceNumber)\n  const verified = aliceSigningPub.verify(message, signature)\n\n  console.log('Signature verified by Bob:', verified)\n  // true\n\n  return {\n    alice,\n    bob,\n    aliceSigningChild,\n    aliceSigningPub,\n    message,\n    signature,\n    verified\n  }\n}\n\n// Run the demonstration\ndemonstrateType42Signing()\n</code></pre>"},{"location":"tutorials/type-42/#bidirectional-communication","title":"Bidirectional Communication","text":"<p>Type-42 enables both parties to derive keys for each other. Here's how Bob can also sign messages for Alice:</p> <pre><code>async function bidirectionalType42() {\n  const alice = PrivateKey.fromRandom()\n  const alicePub = alice.toPublicKey()\n\n  const bob = PrivateKey.fromRandom()\n  const bobPub = bob.toPublicKey()\n\n  const invoiceNumber = '2-bidirectional-chat-001'\n\n  // Alice signs a message for Bob\n  const aliceMessage = Utils.toArray('Hi Bob!', 'utf8')\n  const aliceSigningKey = alice.deriveChild(bobPub, invoiceNumber)\n  const aliceSignature = aliceSigningKey.sign(aliceMessage)\n\n  // Bob signs a reply for Alice\n  const bobMessage = Utils.toArray('Hi Alice!', 'utf8')\n  const bobSigningKey = bob.deriveChild(alicePub, invoiceNumber)\n  const bobSignature = bobSigningKey.sign(bobMessage)\n\n  // Cross-verification\n  const aliceVerifyKey = alicePub.deriveChild(bob, invoiceNumber)\n  const bobVerifyKey = bobPub.deriveChild(alice, invoiceNumber)\n\n  const aliceVerified = aliceVerifyKey.verify(aliceMessage, aliceSignature)\n  const bobVerified = bobVerifyKey.verify(bobMessage, bobSignature)\n\n  console.log('Alice message verified:', aliceVerified)\n  console.log('Bob message verified:', bobVerified)\n\n  return { aliceVerified, bobVerified }\n}\n</code></pre>"},{"location":"tutorials/type-42/#the-anyone-key-concept","title":"The \"Anyone Key\" Concept","text":"<p>The SDK supports a special \"anyone\" key concept for scenarios where one party wants to create publicly verifiable signatures. The \"anyone\" key is simply the private key with value 1:</p> <pre><code>// The \"anyone\" private key\nconst anyonePrivateKey = new PrivateKey(1)\nconst anyonePublicKey = anyonePrivateKey.toPublicKey()\n\nconsole.log('Anyone public key:', anyonePublicKey.toString())\n\n// Using \"anyone\" key for public verification\nfunction createPubliclyVerifiableSignature() {\n  const signer = PrivateKey.fromRandom()\n  const invoiceNumber = '2-public-announcement-001'\n\n  // Derive key using \"anyone\" as counterparty\n  const signingKey = signer.deriveChild(anyonePublicKey, invoiceNumber)\n\n  // Sign message\n  const message = Utils.toArray('This is a public announcement', 'utf8')\n  const signature = signingKey.sign(message)\n\n  // Anyone can verify using the signer's public key\n  const signerPub = signer.toPublicKey()\n  const verifyKey = signerPub.deriveChild(anyonePrivateKey, invoiceNumber)\n  const verified = verifyKey.verify(message, signature)\n\n  console.log('Public signature verified:', verified)\n\n  return {\n    signerPublicKey: signerPub.toString(),\n    signature: signature.toDER('hex'),\n    verified\n  }\n}\n\ncreatePubliclyVerifiableSignature()\n</code></pre>"},{"location":"tutorials/type-42/#advanced-type-42-applications","title":"Advanced Type-42 Applications","text":""},{"location":"tutorials/type-42/#multi-purpose-key-derivation","title":"Multi-Purpose Key Derivation","text":"<p>Use different invoice numbers for different purposes:</p> <pre><code>function multiPurposeKeyDerivation() {\n  const alice = PrivateKey.fromRandom()\n  const bob = PrivateKey.fromRandom()\n  const bobPub = bob.toPublicKey()\n\n  // Different keys for different purposes\n  const signingKey = alice.deriveChild(bobPub, '2-signing-001')\n  const encryptionKey = alice.deriveChild(bobPub, '2-encryption-001')\n  const authKey = alice.deriveChild(bobPub, '2-auth-001')\n\n  console.log('Signing key:', signingKey.toHex().substring(0, 16) + '...')\n  console.log('Encryption key:', encryptionKey.toHex().substring(0, 16) + '...')\n  console.log('Auth key:', authKey.toHex().substring(0, 16) + '...')\n\n  // Each key is unique and serves a different purpose\n  return { signingKey, encryptionKey, authKey }\n}\n</code></pre>"},{"location":"tutorials/type-42/#session-based-key-derivation","title":"Session-Based Key Derivation","text":"<p>Create time-based or session-based keys:</p> <pre><code>function sessionBasedKeys() {\n  const alice = PrivateKey.fromRandom()\n  const bob = PrivateKey.fromRandom()\n  const bobPub = bob.toPublicKey()\n\n  // Create session-specific keys\n  const sessionId = Date.now().toString()\n  const sessionInvoice = `2-session-${sessionId}`\n\n  const sessionKey = alice.deriveChild(bobPub, sessionInvoice)\n\n  console.log('Session ID:', sessionId)\n  console.log('Session key created:', sessionKey.toHex().substring(0, 16) + '...')\n\n  return { sessionId, sessionKey }\n}\n</code></pre>"},{"location":"tutorials/type-42/#integration-with-transactions","title":"Integration with Transactions","text":"<p>Type-42 derived keys can be used in Bitcoin transactions:</p> <pre><code>import { Transaction, P2PKH } from '@bsv/sdk'\n\nasync function type42Transaction() {\n  const alice = PrivateKey.fromRandom()\n  const bob = PrivateKey.fromRandom()\n  const bobPub = bob.toPublicKey()\n\n  const invoiceNumber = '2-payment-001'\n\n  // Alice derives a key for this specific payment\n  const paymentKey = alice.deriveChild(bobPub, invoiceNumber)\n  const paymentAddress = paymentKey.toAddress()\n\n  console.log('Payment address:', paymentAddress)\n\n  // Bob can derive the same public key to verify ownership\n  const alicePub = alice.toPublicKey()\n  const verifyKey = alicePub.deriveChild(bob, invoiceNumber)\n  const verifyAddress = verifyKey.toAddress()\n\n  console.log('Addresses match:', paymentAddress === verifyAddress)\n\n  return { paymentKey, paymentAddress, verifyAddress }\n}\n</code></pre>"},{"location":"tutorials/type-42/#error-handling-and-validation","title":"Error Handling and Validation","text":"<p>Implement robust error handling for Type-42 operations:</p> <pre><code>function safeType42Derivation(\n  privateKey: PrivateKey,\n  counterpartyPublicKey: PublicKey,\n  invoiceNumber: string\n): PrivateKey | null {\n  try {\n    // Validate inputs\n    if (!privateKey || !counterpartyPublicKey || !invoiceNumber) {\n      throw new Error('Missing required parameters')\n    }\n\n    if (invoiceNumber.length === 0) {\n      throw new Error('Invoice number cannot be empty')\n    }\n\n    // Perform derivation\n    const derivedKey = privateKey.deriveChild(counterpartyPublicKey, invoiceNumber)\n\n    // Validate result\n    if (!derivedKey) {\n      throw new Error('Key derivation failed')\n    }\n\n    return derivedKey\n  } catch (error: any) {\n    console.error('Type-42 derivation error:', error.message)\n    return null\n  }\n}\n\n// Usage example\nconst alice = PrivateKey.fromRandom()\nconst bob = PrivateKey.fromRandom()\nconst bobPub = bob.toPublicKey()\n\nconst derivedKey = safeType42Derivation(alice, bobPub, '2-safe-derivation-001')\nif (derivedKey) {\n  console.log('Derivation successful')\n} else {\n  console.log('Derivation failed')\n}\n</code></pre>"},{"location":"tutorials/type-42/#performance-considerations","title":"Performance Considerations","text":""},{"location":"tutorials/type-42/#caching-derived-keys","title":"Caching Derived Keys","text":"<p>For applications that frequently use the same invoice numbers:</p> <pre><code>class Type42KeyCache {\n  private cache = new Map&lt;string, PrivateKey&gt;()\n\n  constructor(private masterKey: PrivateKey) {}\n\n  deriveKey(counterpartyPub: PublicKey, invoiceNumber: string): PrivateKey {\n    const cacheKey = `${counterpartyPub.toString()}-${invoiceNumber}`\n\n    if (this.cache.has(cacheKey)) {\n      return this.cache.get(cacheKey)!\n    }\n\n    const derivedKey = this.masterKey.deriveChild(counterpartyPub, invoiceNumber)\n    this.cache.set(cacheKey, derivedKey)\n\n    return derivedKey\n  }\n\n  clearCache(): void {\n    this.cache.clear()\n  }\n\n  getCacheSize(): number {\n    return this.cache.size\n  }\n}\n\n// Usage\nconst alice = PrivateKey.fromRandom()\nconst keyCache = new Type42KeyCache(alice)\n\nconst bob = PrivateKey.fromRandom()\nconst bobPub = bob.toPublicKey()\n\n// First call performs derivation\nconst key1 = keyCache.deriveKey(bobPub, '2-cached-001')\n\n// Second call uses cache\nconst key2 = keyCache.deriveKey(bobPub, '2-cached-001')\n\nconsole.log('Keys are identical:', key1.toHex() === key2.toHex())\nconsole.log('Cache size:', keyCache.getCacheSize())\n</code></pre>"},{"location":"tutorials/type-42/#security-best-practices","title":"Security Best Practices","text":""},{"location":"tutorials/type-42/#1-invoice-number-guidelines","title":"1. Invoice Number Guidelines","text":"<pre><code>// Good: Structured, unique invoice numbers\nconst goodInvoiceNumbers = [\n  '2-payment-20241210-001',\n  '2-message-session-abc123',\n  '2-auth-token-xyz789'\n]\n\n// Avoid: Predictable or reused invoice numbers\nconst badInvoiceNumbers = [\n  '1', // Too simple\n  'payment', // Not unique\n  '2-payment-001' // Reused across different contexts\n]\n</code></pre>"},{"location":"tutorials/type-42/#2-master-key-protection","title":"2. Master Key Protection","text":"<pre><code>function secureMasterKeyUsage() {\n  // Generate master key securely\n  const masterKey = PrivateKey.fromRandom()\n\n  // Never log or expose master keys\n  // console.log('Master key:', masterKey.toHex()) // DON'T DO THIS\n\n  // Use derived keys for operations\n  const counterparty = PrivateKey.fromRandom().toPublicKey()\n  const derivedKey = masterKey.deriveChild(counterparty, '2-secure-operation-001')\n\n  // Log derived keys if needed (they don't reveal master key)\n  console.log('Derived key (safe to log):', derivedKey.toHex().substring(0, 16) + '...')\n\n  return derivedKey\n}\n</code></pre>"},{"location":"tutorials/type-42/#3-counterparty-validation","title":"3. Counterparty Validation","text":"<pre><code>function validateCounterparty(publicKey: PublicKey): boolean {\n  try {\n    // Ensure the public key is valid by checking its coordinates\n    const x = publicKey.x\n    const y = publicKey.y\n    if (!x || !y) {\n      return false\n    }\n\n    // Additional validation can be added here\n    return true\n  } catch (error: any) {\n    return false\n  }\n}\n</code></pre>"},{"location":"tutorials/type-42/#testing-type-42-implementation","title":"Testing Type-42 Implementation","text":"<pre><code>function testType42Implementation() {\n  console.log('Testing Type-42 key derivation...')\n\n  // Test 1: Basic derivation\n  const alice = PrivateKey.fromRandom()\n  const bob = PrivateKey.fromRandom()\n  const bobPub = bob.toPublicKey()\n  const alicePub = alice.toPublicKey()\n\n  const invoiceNumber = '2-test-001'\n\n  const aliceChild = alice.deriveChild(bobPub, invoiceNumber)\n  const aliceChildPub = alicePub.deriveChild(bob, invoiceNumber)\n\n  const test1 = aliceChild.toPublicKey().toString() === aliceChildPub.toString()\n  console.log('Test 1 - Key consistency:', test1 ? 'PASS' : 'FAIL')\n\n  // Test 2: Message signing and verification\n  const message = Utils.toArray('Test message', 'utf8')\n  const signature = aliceChild.sign(message)\n  const verified = aliceChildPub.verify(message, signature)\n\n  console.log('Test 2 - Sign/verify:', verified ? 'PASS' : 'FAIL')\n\n  // Test 3: Different invoice numbers produce different keys\n  const key1 = alice.deriveChild(bobPub, '2-test-001')\n  const key2 = alice.deriveChild(bobPub, '2-test-002')\n\n  const test3 = key1.toHex() !== key2.toHex()\n  console.log('Test 3 - Unique keys:', test3 ? 'PASS' : 'FAIL')\n\n  // Test 4: Bidirectional derivation\n  const bobChild = bob.deriveChild(alicePub, invoiceNumber)\n  const bobChildPub = bobPub.deriveChild(alice, invoiceNumber)\n\n  const test4 = bobChild.toPublicKey().toString() === bobChildPub.toString()\n  console.log('Test 4 - Bidirectional:', test4 ? 'PASS' : 'FAIL')\n\n  return test1 &amp;&amp; verified &amp;&amp; test3 &amp;&amp; test4\n}\n\n// Run tests\nconst allTestsPassed = testType42Implementation()\nconsole.log('All tests passed:', allTestsPassed)\n</code></pre>"},{"location":"tutorials/type-42/#troubleshooting-common-issues","title":"Troubleshooting Common Issues","text":""},{"location":"tutorials/type-42/#issue-1-key-mismatch","title":"Issue 1: Key Mismatch","text":"<pre><code>// Problem: Derived keys don't match\n// Solution: Ensure consistent invoice numbers and key order\n\nfunction debugKeyMismatch() {\n  const alice = PrivateKey.fromRandom()\n  const bob = PrivateKey.fromRandom()\n\n  // Wrong: Different invoice numbers\n  const key1 = alice.deriveChild(bob.toPublicKey(), '2-test-001')\n  const key2 = alice.toPublicKey().deriveChild(bob, '2-test-002') // Different number\n\n  // Correct: Same invoice number\n  const key3 = alice.deriveChild(bob.toPublicKey(), '2-test-001')\n  const key4 = alice.toPublicKey().deriveChild(bob, '2-test-001') // Same number\n\n  console.log('Wrong approach - keys match:', \n    key1.toPublicKey().toString() === key2.toString())\n  console.log('Correct approach - keys match:', \n    key3.toPublicKey().toString() === key4.toString())\n}\n</code></pre>"},{"location":"tutorials/type-42/#issue-2-invalid-public-key","title":"Issue 2: Invalid Public Key","text":"<pre><code>function handleInvalidPublicKey() {\n  try {\n    const alice = PrivateKey.fromRandom()\n    // This would cause an error if publicKey is invalid\n    const invalidPub = null as any\n\n    const derivedKey = alice.deriveChild(invalidPub, '2-test-001')\n  } catch (error: any) {\n    console.log('Caught invalid public key error:', error.message)\n    // Handle the error appropriately\n  }\n}\n</code></pre>"},{"location":"tutorials/type-42/#conclusion","title":"Conclusion","text":"<p>Type-42 key derivation provides a powerful mechanism for creating shared key universes between two parties. You've learned how to:</p> <ul> <li>Generate master keys and derive child keys using invoice numbers</li> <li>Implement secure message signing and verification</li> <li>Use the \"anyone key\" for publicly verifiable signatures</li> <li>Apply Type-42 in various Bitcoin applications</li> <li>Handle errors and optimize performance</li> <li>Follow security best practices</li> </ul> <p>Type-42 enables sophisticated cryptographic protocols while maintaining the security properties of elliptic curve cryptography. The derived keys are unlinkable to master keys by outside parties, providing privacy and security for Bitcoin applications.</p>"},{"location":"tutorials/type-42/#further-reading","title":"Further Reading","text":"<ul> <li>ECDH Key Exchange Tutorial</li> <li>Elliptic Curve Fundamentals Tutorial</li> <li>BSV Type-42 Documentation</li> <li>Messages Reference</li> </ul>"},{"location":"tutorials/uhrp-storage/","title":"Decentralized File Storage with UHRP","text":"<p>Duration: 75 minutes Prerequisites: Node.js, basic TypeScript knowledge, understanding of decentralized storage and <code>WalletClient</code> usage Learning Goals:</p> <ul> <li>Understand UHRP (Universal Hash Resource Protocol)</li> <li>Upload and download files using StorageUploader/StorageDownloader</li> <li>Implement decentralized file management systems</li> <li>Handle file integrity verification and expiration</li> </ul>"},{"location":"tutorials/uhrp-storage/#introduction","title":"Introduction","text":"<p>UHRP (Universal Hash Resource Protocol) is a decentralized file storage system that uses content hashing for addressing and retrieval. The BSV SDK provides <code>StorageUploader</code> and <code>StorageDownloader</code> classes for seamless integration with UHRP storage networks.</p>"},{"location":"tutorials/uhrp-storage/#prerequisites","title":"Prerequisites","text":""},{"location":"tutorials/uhrp-storage/#for-upload-operations","title":"For Upload Operations","text":"<ul> <li>BRC-100 compliant wallet (such as MetaNet Desktop Wallet) must be installed and running</li> <li>Wallet connection accessible via JSON API (typically http://localhost:3321)</li> <li>Sufficient wallet balance for transaction fees and storage costs</li> <li>UHRP storage service - This tutorial uses <code>https://nanostore.babbage.systems</code></li> </ul>"},{"location":"tutorials/uhrp-storage/#for-download-operations-only","title":"For Download Operations Only","text":"<ul> <li>No wallet connection required - downloads work independently</li> <li>Network access to resolve UHRP URLs via lookup services</li> </ul>"},{"location":"tutorials/uhrp-storage/#service-availability","title":"Service Availability","text":"<p>Important Note: This tutorial uses <code>https://nanostore.babbage.systems</code>, which is a working UHRP storage service. The examples demonstrate correct SDK usage patterns and will work with:</p> <ul> <li>A running BRC-100 compliant wallet (such as MetaNet Desktop Wallet)</li> <li>Sufficient wallet balance for storage fees</li> </ul> <p>Performance Note: UHRP storage operations may take time to complete as they involve blockchain transactions and network propagation. Upload operations can take 10-30 seconds or more depending on network conditions.</p> <p>Network Propagation: After uploading, files typically take 30-60 seconds to propagate across the UHRP network before they become available for download. This is normal behavior for decentralized storage systems and ensures content integrity verification.</p>"},{"location":"tutorials/uhrp-storage/#key-features","title":"Key Features","text":"<ul> <li>Content-Addressed Storage: Files identified by their hash</li> <li>Decentralized Retrieval: Multiple storage providers</li> <li>Integrity Verification: Automatic hash validation</li> <li>Expiration Management: Time-based file retention</li> <li>Authenticated Upload: Wallet-based authentication</li> </ul>"},{"location":"tutorials/uhrp-storage/#what-youll-build","title":"What You'll Build","text":"<ul> <li>File upload system with UHRP</li> <li>Decentralized file retrieval</li> <li>File management dashboard</li> <li>Integrity verification system</li> </ul>"},{"location":"tutorials/uhrp-storage/#setting-up-uhrp-storage","title":"Setting Up UHRP Storage","text":""},{"location":"tutorials/uhrp-storage/#basic-file-upload","title":"Basic File Upload","text":"<pre><code>import { StorageUploader, WalletClient } from '@bsv/sdk'\n\nasync function basicFileUpload() {\n  const wallet = new WalletClient('auto', 'localhost')\n\n  const uploader = new StorageUploader({\n    storageURL: 'https://nanostore.babbage.systems',\n    wallet\n  })\n\n  // Create sample file\n  const fileData = new TextEncoder().encode('Hello, UHRP storage!')\n  const file = {\n    data: fileData,\n    type: 'text/plain'\n  }\n\n  try {\n    const result = await uploader.publishFile({\n      file,\n      retentionPeriod: 60 * 24 * 7 // 7 days in minutes\n    })\n\n    console.log('File uploaded successfully!')\n    console.log('UHRP URL:', result.uhrpURL)\n    console.log('Published:', result.published)\n\n    return result\n  } catch (error) {\n    console.error('Upload failed:', error)\n    throw error\n  }\n}\n\nbasicFileUpload().catch(console.error)\n</code></pre>"},{"location":"tutorials/uhrp-storage/#file-download-and-verification","title":"File Download and Verification","text":"<pre><code>import { StorageDownloader } from '@bsv/sdk'\n\nasync function basicFileDownload(uhrpUrl: string) {\n  const downloader = new StorageDownloader({\n    networkPreset: 'mainnet'\n  })\n\n  try {\n    console.log('Downloading file:', uhrpUrl)\n\n    const result = await downloader.download(uhrpUrl)\n\n    console.log('File downloaded successfully!')\n    console.log('MIME Type:', result.mimeType)\n    console.log('Content length:', result.data.length, 'bytes')\n\n    // Convert to string if text file\n    if (result.mimeType?.startsWith('text/')) {\n      const content = new TextDecoder().decode(result.data)\n      console.log('Content:', content)\n    }\n\n    return result\n  } catch (error) {\n    console.error('Download failed:', error)\n    throw error\n  }\n}\n\n// Example usage (replace with actual UHRP URL)\n// basicFileDownload('uhrp://abc123...').catch(console.error)\n</code></pre>"},{"location":"tutorials/uhrp-storage/#complete-file-management-system","title":"Complete File Management System","text":""},{"location":"tutorials/uhrp-storage/#file-manager-class","title":"File Manager Class","text":"<pre><code>import { StorageUploader, StorageDownloader, WalletClient } from '@bsv/sdk'\n\ninterface FileMetadata {\n  uhrpUrl: string\n  originalName: string\n  mimeType: string\n  size: number\n  uploadDate: Date\n  expiryDate: Date\n  tags: string[]\n}\n\nclass UHRPFileManager {\n  private uploader: StorageUploader\n  private downloader: StorageDownloader\n  private fileRegistry: Map&lt;string, FileMetadata&gt; = new Map()\n\n  constructor(storageURL: string, wallet?: WalletClient) {\n    this.uploader = new StorageUploader({\n      storageURL,\n      wallet: wallet || new WalletClient('auto', 'localhost')\n    })\n\n    this.downloader = new StorageDownloader({\n      networkPreset: 'mainnet'\n    })\n  }\n\n  async uploadFile(\n    fileData: Uint8Array,\n    fileName: string,\n    mimeType: string,\n    retentionDays: number = 30,\n    tags: string[] = []\n  ): Promise&lt;FileMetadata&gt; {\n    const file = {\n      data: fileData,\n      type: mimeType\n    }\n\n    const retentionMinutes = retentionDays * 24 * 60\n\n    try {\n      const result = await this.uploader.publishFile({\n        file,\n        retentionPeriod: retentionMinutes\n      })\n\n      const metadata: FileMetadata = {\n        uhrpUrl: result.uhrpURL,\n        originalName: fileName,\n        mimeType,\n        size: fileData.length,\n        uploadDate: new Date(),\n        expiryDate: new Date(Date.now() + retentionDays * 24 * 60 * 60 * 1000),\n        tags\n      }\n\n      this.fileRegistry.set(result.uhrpURL, metadata)\n\n      console.log(`File \"${fileName}\" uploaded successfully`)\n      console.log('UHRP URL:', result.uhrpURL)\n\n      return metadata\n    } catch (error) {\n      console.error(`Failed to upload \"${fileName}\":`, error)\n      throw error\n    }\n  }\n\n  async downloadFile(uhrpUrl: string): Promise&lt;{\n    data: Uint8Array\n    metadata: FileMetadata | null\n  }&gt; {\n    try {\n      const result = await this.downloader.download(uhrpUrl)\n      const metadata = this.fileRegistry.get(uhrpUrl) || null\n\n      console.log('File downloaded:', uhrpUrl)\n\n      return {\n        data: result.data,\n        metadata\n      }\n    } catch (error) {\n      console.error('Download failed:', error)\n      throw error\n    }\n  }\n\n  async getFileInfo(uhrpUrl: string): Promise&lt;any&gt; {\n    try {\n      return await this.uploader.findFile(uhrpUrl)\n    } catch (error) {\n      console.error('Failed to get file info:', error)\n      throw error\n    }\n  }\n\n  async renewFile(uhrpUrl: string, additionalDays: number): Promise&lt;any&gt; {\n    const additionalMinutes = additionalDays * 24 * 60\n\n    try {\n      const result = await this.uploader.renewFile(uhrpUrl, additionalMinutes)\n\n      // Update local metadata if exists\n      const metadata = this.fileRegistry.get(uhrpUrl)\n      if (metadata) {\n        metadata.expiryDate = new Date(Date.now() + additionalDays * 24 * 60 * 60 * 1000)\n        this.fileRegistry.set(uhrpUrl, metadata)\n      }\n\n      console.log(`File renewed for ${additionalDays} days`)\n      return result\n    } catch (error) {\n      console.error('Failed to renew file:', error)\n      throw error\n    }\n  }\n\n  listFiles(tag?: string): FileMetadata[] {\n    const files = Array.from(this.fileRegistry.values())\n\n    if (tag) {\n      return files.filter(file =&gt; file.tags.includes(tag))\n    }\n\n    return files\n  }\n\n  getExpiringFiles(daysAhead: number = 7): FileMetadata[] {\n    const cutoffDate = new Date(Date.now() + daysAhead * 24 * 60 * 60 * 1000)\n\n    return Array.from(this.fileRegistry.values())\n      .filter(file =&gt; file.expiryDate &lt;= cutoffDate)\n      .sort((a, b) =&gt; a.expiryDate.getTime() - b.expiryDate.getTime())\n  }\n}\n\nasync function demonstrateFileManager() {\n  const fileManager = new UHRPFileManager('https://nanostore.babbage.systems')\n\n  console.log('=== UHRP File Manager Demo ===')\n\n  // Upload different types of files\n  const textData = new TextEncoder().encode('This is a text document for UHRP storage.')\n  const jsonData = new TextEncoder().encode(JSON.stringify({\n    message: 'Hello from UHRP',\n    timestamp: new Date().toISOString(),\n    data: [1, 2, 3, 4, 5]\n  }))\n\n  try {\n    // Upload text file\n    const textFile = await fileManager.uploadFile(\n      textData,\n      'document.txt',\n      'text/plain',\n      30,\n      ['document', 'text']\n    )\n\n    // Upload JSON file\n    const jsonFile = await fileManager.uploadFile(\n      jsonData,\n      'data.json',\n      'application/json',\n      60,\n      ['data', 'json']\n    )\n\n    console.log('\\n=== File Registry ===')\n    const allFiles = fileManager.listFiles()\n    allFiles.forEach(file =&gt; {\n      console.log(`${file.originalName}: ${file.uhrpUrl}`)\n    })\n\n    // Test download\n    console.log('\\n=== Testing Download ===')\n    const downloadResult = await fileManager.downloadFile(textFile.uhrpUrl)\n    const content = new TextDecoder().decode(downloadResult.data)\n    console.log('Downloaded content:', content)\n\n    // Check expiring files\n    console.log('\\n=== Expiring Files ===')\n    const expiringFiles = fileManager.getExpiringFiles(365) // Next year\n    expiringFiles.forEach(file =&gt; {\n      console.log(`${file.originalName} expires: ${file.expiryDate.toISOString()}`)\n    })\n\n    return { textFile, jsonFile, allFiles }\n  } catch (error) {\n    console.error('Demo failed:', error)\n  }\n}\n\ndemonstrateFileManager().catch(console.error)\n</code></pre>"},{"location":"tutorials/uhrp-storage/#advanced-features","title":"Advanced Features","text":""},{"location":"tutorials/uhrp-storage/#batch-operations","title":"Batch Operations","text":"<pre><code>import { StorageUploader, StorageDownloader, WalletClient } from '@bsv/sdk'\n\nclass BatchFileOperations {\n  private uploader: StorageUploader\n  private downloader: StorageDownloader\n\n  constructor(storageURL: string, wallet?: WalletClient) {\n    this.uploader = new StorageUploader({\n      storageURL,\n      wallet: wallet || new WalletClient('auto', 'localhost')\n    })\n\n    this.downloader = new StorageDownloader()\n  }\n\n  async batchUpload(files: Array&lt;{\n    data: Uint8Array\n    name: string\n    type: string\n    retention?: number\n  }&gt;): Promise&lt;Array&lt;{\n    success: boolean\n    file: string\n    uhrpUrl?: string\n    error?: string\n  }&gt;&gt; {\n    console.log(`Starting batch upload of ${files.length} files...`)\n\n    const results = await Promise.allSettled(\n      files.map(async (file) =&gt; {\n        const fileObj = {\n          data: file.data,\n          type: file.type\n        }\n\n        const result = await this.uploader.publishFile({\n          file: fileObj,\n          retentionPeriod: (file.retention || 30) * 24 * 60\n        })\n\n        return { file: file.name, result }\n      })\n    )\n\n    return results.map((result, index) =&gt; {\n      const fileName = files[index].name\n\n      if (result.status === 'fulfilled') {\n        return {\n          success: true,\n          file: fileName,\n          uhrpUrl: result.value.result.uhrpURL\n        }\n      } else {\n        return {\n          success: false,\n          file: fileName,\n          error: result.reason.message\n        }\n      }\n    })\n  }\n\n  async batchDownload(uhrpUrls: string[]): Promise&lt;Array&lt;{\n    success: boolean\n    url: string\n    data?: Uint8Array\n    error?: string\n  }&gt;&gt; {\n    console.log(`Starting batch download of ${uhrpUrls.length} files...`)\n\n    const results = await Promise.allSettled(\n      uhrpUrls.map(url =&gt; this.downloader.download(url))\n    )\n\n    return results.map((result, index) =&gt; {\n      const url = uhrpUrls[index]\n\n      if (result.status === 'fulfilled') {\n        return {\n          success: true,\n          url,\n          data: result.value.data\n        }\n      } else {\n        return {\n          success: false,\n          url,\n          error: result.reason.message\n        }\n      }\n    })\n  }\n}\n\nasync function demonstrateBatchOperations() {\n  const batchOps = new BatchFileOperations('https://nanostore.babbage.systems')\n\n  // Prepare test files\n  const testFiles = [\n    {\n      data: new TextEncoder().encode('File 1 content'),\n      name: 'file1.txt',\n      type: 'text/plain'\n    },\n    {\n      data: new TextEncoder().encode('File 2 content'),\n      name: 'file2.txt',\n      type: 'text/plain'\n    },\n    {\n      data: new TextEncoder().encode(JSON.stringify({ test: 'data' })),\n      name: 'data.json',\n      type: 'application/json'\n    }\n  ]\n\n  console.log('=== Batch Upload Demo ===')\n  const uploadResults = await batchOps.batchUpload(testFiles)\n\n  uploadResults.forEach(result =&gt; {\n    if (result.success) {\n      console.log(`\u2705 ${result.file}: ${result.uhrpUrl}`)\n    } else {\n      console.log(`\u274c ${result.file}: ${result.error}`)\n    }\n  })\n\n  // Extract successful URLs for download test\n  const successfulUrls = uploadResults\n    .filter(r =&gt; r.success &amp;&amp; r.uhrpUrl)\n    .map(r =&gt; r.uhrpUrl!)\n\n  if (successfulUrls.length &gt; 0) {\n    console.log('\\n=== Batch Download Demo ===')\n    const downloadResults = await batchOps.batchDownload(successfulUrls)\n\n    downloadResults.forEach(result =&gt; {\n      if (result.success) {\n        console.log(`\u2705 Downloaded: ${result.url} (${result.data?.length} bytes)`)\n      } else {\n        console.log(`\u274c Failed: ${result.url} - ${result.error}`)\n      }\n    })\n  }\n\n  return { uploadResults, downloadResults: [] }\n}\n\ndemonstrateBatchOperations().catch(console.error)\n</code></pre>"},{"location":"tutorials/uhrp-storage/#troubleshooting","title":"Troubleshooting","text":""},{"location":"tutorials/uhrp-storage/#common-issues-and-solutions","title":"Common Issues and Solutions","text":""},{"location":"tutorials/uhrp-storage/#no-wallet-available-error","title":"\"No wallet available\" Error","text":"<p>Problem: StorageUploader fails with \"No wallet available over any communication substrate\" Solution:</p> <ul> <li>Install and run a BRC-100 compliant wallet (e.g., MetaNet Desktop Wallet)</li> <li>Ensure wallet is accessible at http://localhost:3321</li> <li>Verify wallet is fully synced and has sufficient balance</li> </ul>"},{"location":"tutorials/uhrp-storage/#401-unauthorized-error","title":"\"401 Unauthorized\" Error","text":"<p>Problem: Upload operations fail with HTTP 401 errors Solution:</p> <ul> <li>Verify your wallet is properly authenticated</li> <li>Check that the UHRP storage service is available</li> <li>Ensure your wallet has sufficient balance for storage fees</li> </ul>"},{"location":"tutorials/uhrp-storage/#invalid-parameter-uhrp-url-error","title":"\"Invalid parameter UHRP url\" Error","text":"<p>Problem: Download operations fail with invalid URL error Solution:</p> <ul> <li>Verify the UHRP URL format (should start with <code>uhrp://</code>)</li> <li>Check that the file hasn\u2019t expired</li> <li>Ensure network connectivity for UHRP lookup services</li> </ul>"},{"location":"tutorials/uhrp-storage/#download-works-but-upload-fails","title":"Download Works but Upload Fails","text":"<p>Problem: StorageDownloader works but StorageUploader fails Solution: This is expected behavior without a wallet connection. StorageDownloader works independently, while StorageUploader requires wallet authentication.</p>"},{"location":"tutorials/uhrp-storage/#service-unavailable","title":"Service Unavailable","text":"<p>Problem: UHRP storage service returns errors or is unreachable Solution:</p> <ul> <li>Try alternative UHRP storage services</li> <li>Check service status and availability</li> <li>Consider setting up your own UHRP storage infrastructure</li> </ul>"},{"location":"tutorials/uhrp-storage/#best-practices","title":"Best Practices","text":""},{"location":"tutorials/uhrp-storage/#1-file-management","title":"1. File Management","text":"<ul> <li>Use meaningful file names and metadata</li> <li>Implement proper retention policies</li> <li>Tag files for easy organization and retrieval</li> </ul>"},{"location":"tutorials/uhrp-storage/#2-error-handling","title":"2. Error Handling","text":"<ul> <li>Always validate file integrity after download</li> <li>Implement retry logic for network failures</li> <li>Handle storage quota and payment requirements</li> </ul>"},{"location":"tutorials/uhrp-storage/#3-performance","title":"3. Performance","text":"<ul> <li>Use batch operations for multiple files</li> <li>Implement caching for frequently accessed files</li> <li>Monitor file expiration and renewal needs</li> </ul>"},{"location":"tutorials/uhrp-storage/#4-security","title":"4. Security","text":"<ul> <li>Encrypt sensitive files before upload</li> <li>Use authenticated storage endpoints</li> <li>Validate file types and sizes</li> </ul>"},{"location":"tutorials/uhrp-storage/#summary","title":"Summary","text":"<p>In this tutorial, you learned how to:</p> <p>\u2705 Upload files to UHRP storage with StorageUploader \u2705 Download and verify files with StorageDownloader \u2705 Build file management systems with metadata tracking \u2705 Implement batch operations for multiple files \u2705 Handle file expiration and renewal  </p> <p>UHRP provides a robust foundation for decentralized file storage with content addressing and integrity verification.</p>"},{"location":"tutorials/uhrp-storage/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about Identity Management and Certificates</li> <li>Explore AuthFetch for Authenticated HTTP Requests</li> <li>Review Security Best Practices</li> </ul> <p>UHRP provides a robust foundation for decentralized file storage with content addressing and integrity verification.</p> <p>The <code>WalletClient</code> provides the authentication and payment capabilities needed for UHRP operations.</p>"},{"location":"tutorials/uhrp-storage/#setting-up-uhrp-with-walletclient","title":"Setting Up UHRP with <code>WalletClient</code>","text":"<p>The <code>WalletClient</code> handles authentication automatically when you create <code>StorageUploader</code> and <code>StorageDownloader</code> instances.</p>"},{"location":"tutorials/uhrp-storage/#how-walletclient-enables-uhrp","title":"How <code>WalletClient</code> Enables UHRP","text":"<p>When you use UHRP with <code>WalletClient</code>:</p> <ul> <li>You can upload files to decentralized storage networks.</li> <li>You can download files from decentralized storage networks.</li> <li>You can manage file metadata and track file expiration.</li> <li>You can implement batch operations for multiple files.</li> </ul>"}]}