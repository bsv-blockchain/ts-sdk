{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"BSV TypeScript SDK Documentation","text":""},{"location":"#sdk-overview","title":"SDK Overview","text":"<p>The BSV TypeScript SDK is designed to provide an updated and unified layer for developing scalable applications on the BSV Blockchain. It addresses the limitations of previous tools by offering a Direct Instant Payments (DIP) approach, ensuring privacy and scalability.</p>"},{"location":"#installation","title":"Installation","text":"<p>To install the SDK, run:</p> <pre><code>npm install @bsv/sdk\n</code></pre> <p>You can then import modules from the SDK as follows:</p> <pre><code>import { WalletClient, PrivateKey, Transaction } from \"@bsv/sdk\";\n</code></pre> <p>Or using require syntax:</p> <pre><code>const { WalletClient, PrivateKey, Transaction } = require(\"@bsv/sdk\");\n</code></pre>"},{"location":"#brc-100-application-to-wallet-interface","title":"BRC-100 Application to Wallet Interface","text":"<p>This interface is what most application developers will use to interact with the BSV blockchain.</p> <p>\ud83d\ude80 WalletClient Quickstart</p> <ul> <li>Run SDK code examples without any setup</li> <li>Experiment with transactions, keys, and scripts in real-time  </li> <li>Learn by doing with immediate feedback</li> <li>Test concepts from our tutorials interactively</li> </ul> <p></p> <p>Perfect for getting started quickly or experimenting with new ideas.</p> <p>Another way to familiarize yourself with the Application to Wallet Interface is to checkout this Swagger UI.</p> <p></p> <p>Finally, you can deep dive into the details of the interface and types in the reference material below.</p>"},{"location":"#reference-material","title":"Reference Material","text":"<ul> <li>Wallet</li> <li>Primitives</li> <li>Script</li> <li>Transaction</li> <li>Mutual Authenitcation</li> <li>Identity</li> <li>Overlay Tools</li> <li>Registry</li> <li>Storage</li> <li>KV Store</li> <li>Messages</li> <li>TOTP</li> <li>Compatibility</li> </ul>"},{"location":"#coming-soontm","title":"Coming Soon\u2122","text":"<ul> <li>Manual Transaction Creation</li> <li>Broadcasting Transactions</li> <li>Deriving Keys</li> <li>Overlays</li> <li>MessageBox</li> </ul>"},{"location":"#performance-reports","title":"Performance Reports","text":"<ul> <li>Benchmarks</li> </ul>"},{"location":"performance/","title":"BigNumber Benchmarks","text":"<p>The benchmark scripts measure extremely large number operations and script number serialization performance.</p> <p>All results below were gathered on Node.js v22.16.0 using the <code>dist</code> build of the SDK. Each benchmark was executed with 200,000-digit inputs to stress the implementation.</p>"},{"location":"performance/#addition-and-multiplication","title":"Addition and Multiplication","text":"<p>Command:</p> <pre><code>node benchmarks/bignumber-bench.js 200000 1 1\n</code></pre> Branch mul large numbers add large numbers master (pre-May-2025) 6364.11ms 13.04ms fix-mem (May-2025) 13.60ms 2.64ms"},{"location":"performance/#serialization","title":"Serialization","text":"<p>Command:</p> <pre><code>node benchmarks/serialization-bench.js 200000 1\n</code></pre> Branch toSm big toSm little fromSm big fromSm little fromScriptNum master (pre-May-2025) 6.12ms 10.11ms 6.35ms 12.56ms 3.39ms fix-mem (May-2025) 8.46ms 8.12ms 27.77ms 11.16ms 10.31ms"},{"location":"performance/#transaction-verification","title":"Transaction Verification","text":"<p>Command:</p> <pre><code>node benchmarks/transaction-bench.js\n</code></pre> Branch deep chain verify wide transaction verify large tx verify nested inputs verify fix-mem (May-2025) 3335.76ms 2930.86ms 1534.36ms 1198.08ms"},{"location":"performance/#symmetrickey-encryptiondecryption","title":"SymmetricKey Encryption/Decryption","text":"<p>Command:</p> <pre><code>node benchmarks/symmetric-key-bench.js\n</code></pre> Branch encrypt large 2MB decrypt large 2MB encrypt 50 small decrypt 50 small encrypt 200 medium decrypt 200 medium fix-mem baseline 8609.78ms 8372.23ms 34.02ms 48.58ms 859.38ms 960.16ms optimized AESGCM (round 1) 7678.65ms 7619.82ms 60.23ms 35.21ms 871.89ms 763.13ms optimized AESGCM (round 2) 2026.89ms 1793.35ms 15.01ms 7.88ms 213.35ms 169.37ms"},{"location":"performance/#readerwriter-operations","title":"Reader/Writer Operations","text":"<p>Command:</p> <pre><code>node benchmarks/reader-writer-bench.js\n</code></pre> Branch mixed ops large payloads 3000 small payloads 400 medium payloads fix-mem baseline 9.93ms 127.49ms 27.86ms 41.71ms optimized utils.ts 5.02ms 91.93ms 19.04ms 53.80ms"},{"location":"reference/auth/","title":"API","text":"<p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/auth/#interfaces","title":"Interfaces","text":"AuthMessage PeerSession RequestedCertificateSet RequestedCertificateTypeIDAndFieldList Transport <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/auth/#interface-authmessage","title":"Interface: AuthMessage","text":"<pre><code>export interface AuthMessage {\n    version: string;\n    messageType: \"initialRequest\" | \"initialResponse\" | \"certificateRequest\" | \"certificateResponse\" | \"general\";\n    identityKey: string;\n    nonce?: string;\n    initialNonce?: string;\n    yourNonce?: string;\n    certificates?: VerifiableCertificate[];\n    requestedCertificates?: RequestedCertificateSet;\n    payload?: number[];\n    signature?: number[];\n}\n</code></pre> <p>See also: RequestedCertificateSet, VerifiableCertificate</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/auth/#interface-peersession","title":"Interface: PeerSession","text":"<pre><code>export interface PeerSession {\n    isAuthenticated: boolean;\n    sessionNonce?: string;\n    peerNonce?: string;\n    peerIdentityKey?: string;\n    lastUpdate: number;\n}\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/auth/#interface-requestedcertificateset","title":"Interface: RequestedCertificateSet","text":"<pre><code>export interface RequestedCertificateSet {\n    certifiers: string[];\n    types: RequestedCertificateTypeIDAndFieldList;\n}\n</code></pre> <p>See also: RequestedCertificateTypeIDAndFieldList</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/auth/#interface-requestedcertificatetypeidandfieldlist","title":"Interface: RequestedCertificateTypeIDAndFieldList","text":"<pre><code>export interface RequestedCertificateTypeIDAndFieldList {\n    [certificateTypeID: string]: string[];\n}\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/auth/#interface-transport","title":"Interface: Transport","text":"<pre><code>export interface Transport {\n    send: (message: AuthMessage) =&gt; Promise&lt;void&gt;;\n    onData: (callback: (message: AuthMessage) =&gt; Promise&lt;void&gt;) =&gt; Promise&lt;void&gt;;\n}\n</code></pre> <p>See also: AuthMessage</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/auth/#classes","title":"Classes","text":"AuthFetch Certificate CompletedProtoWallet MasterCertificate Peer SessionManager SimplifiedFetchTransport VerifiableCertificate <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/auth/#class-authfetch","title":"Class: AuthFetch","text":"<p>AuthFetch provides a lightweight fetch client for interacting with servers over a simplified HTTP transport mechanism. It integrates session management, peer communication, and certificate handling to enable secure and mutually-authenticated requests.</p> <p>Additionally, it automatically handles 402 Payment Required responses by creating and sending BSV payment transactions when necessary.</p> <pre><code>export class AuthFetch {\n    peers: Record&lt;string, AuthPeer&gt; = {};\n    constructor(wallet: WalletInterface, requestedCertificates?: RequestedCertificateSet, sessionManager?: SessionManager, originator?: OriginatorDomainNameStringUnder250Bytes) \n    async fetch(url: string, config: SimplifiedFetchRequestOptions = {}): Promise&lt;Response&gt; \n    async sendCertificateRequest(baseUrl: string, certificatesToRequest: RequestedCertificateSet): Promise&lt;VerifiableCertificate[]&gt; \n    public consumeReceivedCertificates(): VerifiableCertificate[] \n}\n</code></pre> <p>See also: OriginatorDomainNameStringUnder250Bytes, RequestedCertificateSet, SessionManager, VerifiableCertificate, WalletInterface</p>"},{"location":"reference/auth/#constructor","title":"Constructor","text":"<p>Constructs a new AuthFetch instance.</p> <p><pre><code>constructor(wallet: WalletInterface, requestedCertificates?: RequestedCertificateSet, sessionManager?: SessionManager, originator?: OriginatorDomainNameStringUnder250Bytes) \n</code></pre> See also: OriginatorDomainNameStringUnder250Bytes, RequestedCertificateSet, SessionManager, WalletInterface</p> <p>Argument Details</p> <ul> <li>wallet</li> <li>The wallet instance for signing and authentication.</li> <li>requestedCertificates</li> <li>Optional set of certificates to request from peers.</li> </ul>"},{"location":"reference/auth/#method-consumereceivedcertificates","title":"Method consumeReceivedCertificates","text":"<p>Return any certificates we've collected thus far, then clear them out.</p> <p><pre><code>public consumeReceivedCertificates(): VerifiableCertificate[] \n</code></pre> See also: VerifiableCertificate</p>"},{"location":"reference/auth/#method-fetch","title":"Method fetch","text":"<p>Mutually authenticates and sends a HTTP request to a server.</p> <p>1) Attempt the request. 2) If 402 Payment Required, automatically create and send payment. 3) Return the final response.</p> <pre><code>async fetch(url: string, config: SimplifiedFetchRequestOptions = {}): Promise&lt;Response&gt; \n</code></pre> <p>Returns</p> <p>A promise that resolves with the server's response, structured as a Response-like object.</p> <p>Argument Details</p> <ul> <li>url</li> <li>The URL to send the request to.</li> <li>config</li> <li>Configuration options for the request, including method, headers, and body.</li> </ul> <p>Throws</p> <p>Will throw an error if unsupported headers are used or other validation fails.</p>"},{"location":"reference/auth/#method-sendcertificaterequest","title":"Method sendCertificateRequest","text":"<p>Request Certificates from a Peer</p> <p><pre><code>async sendCertificateRequest(baseUrl: string, certificatesToRequest: RequestedCertificateSet): Promise&lt;VerifiableCertificate[]&gt; \n</code></pre> See also: RequestedCertificateSet, VerifiableCertificate</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/auth/#class-certificate","title":"Class: Certificate","text":"<p>Represents an Identity Certificate as per the Wallet interface specifications.</p> <p>This class provides methods to serialize and deserialize certificates, as well as signing and verifying the certificate's signature.</p> <pre><code>export default class Certificate {\n    type: Base64String;\n    serialNumber: Base64String;\n    subject: PubKeyHex;\n    certifier: PubKeyHex;\n    revocationOutpoint: OutpointString;\n    fields: Record&lt;CertificateFieldNameUnder50Bytes, Base64String&gt;;\n    signature?: HexString;\n    constructor(type: Base64String, serialNumber: Base64String, subject: PubKeyHex, certifier: PubKeyHex, revocationOutpoint: OutpointString, fields: Record&lt;CertificateFieldNameUnder50Bytes, string&gt;, signature?: HexString) \n    toBinary(includeSignature: boolean = true): number[] \n    static fromBinary(bin: number[]): Certificate \n    async verify(): Promise&lt;boolean&gt; \n    async sign(certifierWallet: ProtoWallet): Promise&lt;void&gt; \n    static getCertificateFieldEncryptionDetails(fieldName: string, serialNumber?: string): {\n        protocolID: WalletProtocol;\n        keyID: string;\n    } \n    static fromObject(obj: {\n        type: Base64String;\n        serialNumber: Base64String;\n        subject: PubKeyHex;\n        certifier: PubKeyHex;\n        revocationOutpoint: OutpointString;\n        fields: Record&lt;CertificateFieldNameUnder50Bytes, Base64String&gt;;\n        signature?: HexString;\n    }): Certificate \n}\n</code></pre> <p>See also: Base64String, CertificateFieldNameUnder50Bytes, HexString, OutpointString, ProtoWallet, PubKeyHex, WalletProtocol, sign, verify</p>"},{"location":"reference/auth/#constructor_1","title":"Constructor","text":"<p>Constructs a new Certificate.</p> <p><pre><code>constructor(type: Base64String, serialNumber: Base64String, subject: PubKeyHex, certifier: PubKeyHex, revocationOutpoint: OutpointString, fields: Record&lt;CertificateFieldNameUnder50Bytes, string&gt;, signature?: HexString) \n</code></pre> See also: Base64String, CertificateFieldNameUnder50Bytes, HexString, OutpointString, PubKeyHex</p> <p>Argument Details</p> <ul> <li>type</li> <li>Type identifier for the certificate, base64 encoded string, 32 bytes.</li> <li>serialNumber</li> <li>Unique serial number of the certificate, base64 encoded string, 32 bytes.</li> <li>subject</li> <li>The public key belonging to the certificate's subject, compressed public key hex string.</li> <li>certifier</li> <li>Public key of the certifier who issued the certificate, compressed public key hex string.</li> <li>revocationOutpoint</li> <li>The outpoint used to confirm that the certificate has not been revoked (TXID.OutputIndex), as a string.</li> <li>fields</li> <li>All the fields present in the certificate.</li> <li>signature</li> <li>Certificate signature by the certifier's private key, DER encoded hex string.</li> </ul>"},{"location":"reference/auth/#property-certifier","title":"Property certifier","text":"<p>Public key of the certifier who issued the certificate, compressed public key hex string.</p> <p><pre><code>certifier: PubKeyHex\n</code></pre> See also: PubKeyHex</p>"},{"location":"reference/auth/#property-fields","title":"Property fields","text":"<p>All the fields present in the certificate, with field names as keys and encrypted field values as Base64 strings.</p> <p><pre><code>fields: Record&lt;CertificateFieldNameUnder50Bytes, Base64String&gt;\n</code></pre> See also: Base64String, CertificateFieldNameUnder50Bytes</p>"},{"location":"reference/auth/#property-revocationoutpoint","title":"Property revocationOutpoint","text":"<p>The outpoint used to confirm that the certificate has not been revoked (TXID.OutputIndex), as a string.</p> <p><pre><code>revocationOutpoint: OutpointString\n</code></pre> See also: OutpointString</p>"},{"location":"reference/auth/#property-serialnumber","title":"Property serialNumber","text":"<p>Unique serial number of the certificate, base64 encoded string, 32 bytes.</p> <p><pre><code>serialNumber: Base64String\n</code></pre> See also: Base64String</p>"},{"location":"reference/auth/#property-signature","title":"Property signature","text":"<p>Certificate signature by the certifier's private key, DER encoded hex string.</p> <p><pre><code>signature?: HexString\n</code></pre> See also: HexString</p>"},{"location":"reference/auth/#property-subject","title":"Property subject","text":"<p>The public key belonging to the certificate's subject, compressed public key hex string.</p> <p><pre><code>subject: PubKeyHex\n</code></pre> See also: PubKeyHex</p>"},{"location":"reference/auth/#property-type","title":"Property type","text":"<p>Type identifier for the certificate, base64 encoded string, 32 bytes.</p> <p><pre><code>type: Base64String\n</code></pre> See also: Base64String</p>"},{"location":"reference/auth/#method-frombinary","title":"Method fromBinary","text":"<p>Deserializes a certificate from binary format.</p> <p><pre><code>static fromBinary(bin: number[]): Certificate \n</code></pre> See also: Certificate</p> <p>Returns</p> <ul> <li>The deserialized Certificate object.</li> </ul> <p>Argument Details</p> <ul> <li>bin</li> <li>The binary data representing the certificate.</li> </ul>"},{"location":"reference/auth/#method-fromobject","title":"Method fromObject","text":"<p>Creates a Certificate instance from a plain object representation.</p> <p><pre><code>static fromObject(obj: {\n    type: Base64String;\n    serialNumber: Base64String;\n    subject: PubKeyHex;\n    certifier: PubKeyHex;\n    revocationOutpoint: OutpointString;\n    fields: Record&lt;CertificateFieldNameUnder50Bytes, Base64String&gt;;\n    signature?: HexString;\n}): Certificate \n</code></pre> See also: Base64String, Certificate, CertificateFieldNameUnder50Bytes, HexString, OutpointString, PubKeyHex</p> <p>Returns</p> <p>A new Certificate instance.</p> <p>Argument Details</p> <ul> <li>obj</li> <li>The object containing certificate data.</li> </ul>"},{"location":"reference/auth/#method-getcertificatefieldencryptiondetails","title":"Method getCertificateFieldEncryptionDetails","text":"<p>Helper function which retrieves the protocol ID and key ID for certificate field encryption.</p> <p>For master certificate creation, no serial number is provided because entropy is required from both the client and the certifier. In this case, the <code>keyID</code> is simply the <code>fieldName</code>.</p> <p>For VerifiableCertificates verifier keyring creation, both the serial number and field name are available, so the <code>keyID</code> is formed by concatenating the <code>serialNumber</code> and <code>fieldName</code>.</p> <p><pre><code>static getCertificateFieldEncryptionDetails(fieldName: string, serialNumber?: string): {\n    protocolID: WalletProtocol;\n    keyID: string;\n} \n</code></pre> See also: WalletProtocol</p> <p>Returns</p> <p>An object containing: - <code>protocolID</code> (WalletProtocol): The protocol ID for certificate field encryption. - <code>keyID</code> (string): A unique key identifier. It is the <code>fieldName</code> if <code>serialNumber</code> is undefined, otherwise it is a combination of <code>serialNumber</code> and <code>fieldName</code>.</p> <p>Argument Details</p> <ul> <li>fieldName</li> <li>The name of the field within the certificate to be encrypted.</li> <li>serialNumber</li> <li>(Optional) The serial number of the certificate.</li> </ul>"},{"location":"reference/auth/#method-sign","title":"Method sign","text":"<p>Signs the certificate using the provided certifier wallet.</p> <p><pre><code>async sign(certifierWallet: ProtoWallet): Promise&lt;void&gt; \n</code></pre> See also: ProtoWallet</p> <p>Argument Details</p> <ul> <li>certifierWallet</li> <li>The wallet representing the certifier.</li> </ul>"},{"location":"reference/auth/#method-tobinary","title":"Method toBinary","text":"<p>Serializes the certificate into binary format, with or without a signature.</p> <pre><code>toBinary(includeSignature: boolean = true): number[] \n</code></pre> <p>Returns</p> <ul> <li>The serialized certificate in binary format.</li> </ul> <p>Argument Details</p> <ul> <li>includeSignature</li> <li>Whether to include the signature in the serialization.</li> </ul>"},{"location":"reference/auth/#method-verify","title":"Method verify","text":"<p>Verifies the certificate's signature.</p> <pre><code>async verify(): Promise&lt;boolean&gt; \n</code></pre> <p>Returns</p> <ul> <li>A promise that resolves to true if the signature is valid.</li> </ul> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/auth/#class-completedprotowallet","title":"Class: CompletedProtoWallet","text":"<pre><code>export class CompletedProtoWallet extends ProtoWallet implements WalletInterface {\n    keyDeriver: KeyDeriver;\n    constructor(rootKeyOrKeyDeriver: PrivateKey | \"anyone\" | KeyDeriverApi) \n    async isAuthenticated(): Promise&lt;AuthenticatedResult&gt; \n    async waitForAuthentication(): Promise&lt;AuthenticatedResult&gt; \n    async getNetwork(): Promise&lt;GetNetworkResult&gt; \n    async getVersion(): Promise&lt;GetVersionResult&gt; \n    async getPublicKey(args: GetPublicKeyArgs): Promise&lt;{\n        publicKey: PubKeyHex;\n    }&gt; \n    async createAction(): Promise&lt;CreateActionResult&gt; \n    async signAction(): Promise&lt;SignActionResult&gt; \n    async abortAction(): Promise&lt;AbortActionResult&gt; \n    async listActions(): Promise&lt;ListActionsResult&gt; \n    async internalizeAction(): Promise&lt;InternalizeActionResult&gt; \n    async listOutputs(): Promise&lt;ListOutputsResult&gt; \n    async relinquishOutput(): Promise&lt;RelinquishOutputResult&gt; \n    async acquireCertificate(): Promise&lt;AcquireCertificateResult&gt; \n    async listCertificates(): Promise&lt;ListCertificatesResult&gt; \n    async proveCertificate(): Promise&lt;ProveCertificateResult&gt; \n    async relinquishCertificate(): Promise&lt;RelinquishCertificateResult&gt; \n    async discoverByIdentityKey(): Promise&lt;DiscoverCertificatesResult&gt; \n    async discoverByAttributes(): Promise&lt;DiscoverCertificatesResult&gt; \n    async getHeight(): Promise&lt;GetHeightResult&gt; \n    async getHeaderForHeight(): Promise&lt;GetHeaderResult&gt; \n}\n</code></pre> <p>See also: AbortActionResult, AcquireCertificateResult, AuthenticatedResult, CreateActionResult, DiscoverCertificatesResult, GetHeaderResult, GetHeightResult, GetNetworkResult, GetPublicKeyArgs, GetVersionResult, InternalizeActionResult, KeyDeriver, KeyDeriverApi, ListActionsResult, ListCertificatesResult, ListOutputsResult, PrivateKey, ProtoWallet, ProveCertificateResult, PubKeyHex, RelinquishCertificateResult, RelinquishOutputResult, SignActionResult, WalletInterface</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/auth/#class-mastercertificate","title":"Class: MasterCertificate","text":"<p>MasterCertificate extends the base Certificate class to manage a master keyring, enabling the creation of verifiable certificates.</p> <p>It allows for the selective disclosure of certificate fields by creating a <code>VerifiableCertificate</code> for a specific verifier. The <code>MasterCertificate</code> can securely decrypt each master key and re-encrypt it for a verifier, creating a customized keyring containing only the keys necessary for the verifier to access designated fields.</p> <pre><code>export class MasterCertificate extends Certificate {\n    declare type: Base64String;\n    declare serialNumber: Base64String;\n    declare subject: PubKeyHex;\n    declare certifier: PubKeyHex;\n    declare revocationOutpoint: OutpointString;\n    declare fields: Record&lt;CertificateFieldNameUnder50Bytes, Base64String&gt;;\n    declare signature?: HexString;\n    masterKeyring: Record&lt;CertificateFieldNameUnder50Bytes, Base64String&gt;;\n    constructor(type: Base64String, serialNumber: Base64String, subject: PubKeyHex, certifier: PubKeyHex, revocationOutpoint: OutpointString, fields: Record&lt;CertificateFieldNameUnder50Bytes, Base64String&gt;, masterKeyring: Record&lt;CertificateFieldNameUnder50Bytes, Base64String&gt;, signature?: HexString) \n    static async createCertificateFields(creatorWallet: ProtoWallet, certifierOrSubject: WalletCounterparty, fields: Record&lt;CertificateFieldNameUnder50Bytes, string&gt;, privileged?: boolean, privilegedReason?: string): Promise&lt;CreateCertificateFieldsResult&gt; \n    static async createKeyringForVerifier(subjectWallet: ProtoWallet, certifier: WalletCounterparty, verifier: WalletCounterparty, fields: Record&lt;CertificateFieldNameUnder50Bytes, Base64String&gt;, fieldsToReveal: string[], masterKeyring: Record&lt;CertificateFieldNameUnder50Bytes, Base64String&gt;, serialNumber: Base64String, privileged?: boolean, privilegedReason?: string): Promise&lt;Record&lt;CertificateFieldNameUnder50Bytes, string&gt;&gt; \n    static async issueCertificateForSubject(certifierWallet: ProtoWallet, subject: WalletCounterparty, fields: Record&lt;CertificateFieldNameUnder50Bytes, string&gt;, certificateType: string, getRevocationOutpoint = async (_serial: string): Promise&lt;string&gt; =&gt; {\n        void _serial;\n        return \"Certificate revocation not tracked.\";\n    }, serialNumber?: string): Promise&lt;MasterCertificate&gt; \n    static async decryptFields(subjectOrCertifierWallet: ProtoWallet, masterKeyring: Record&lt;CertificateFieldNameUnder50Bytes, Base64String&gt;, fields: Record&lt;CertificateFieldNameUnder50Bytes, Base64String&gt;, counterparty: WalletCounterparty, privileged?: boolean, privilegedReason?: string): Promise&lt;Record&lt;CertificateFieldNameUnder50Bytes, string&gt;&gt; \n    static async decryptField(subjectOrCertifierWallet: ProtoWallet, masterKeyring: Record&lt;CertificateFieldNameUnder50Bytes, Base64String&gt;, fieldName: Base64String, fieldValue: Base64String, counterparty: WalletCounterparty, privileged?: boolean, privilegedReason?: string): Promise&lt;{\n        fieldRevelationKey: number[];\n        decryptedFieldValue: string;\n    }&gt; \n}\n</code></pre> <p>See also: Base64String, Certificate, CertificateFieldNameUnder50Bytes, HexString, OutpointString, ProtoWallet, PubKeyHex, WalletCounterparty</p>"},{"location":"reference/auth/#method-createcertificatefields","title":"Method createCertificateFields","text":"<p>Encrypts certificate fields for a subject and generates a master keyring. This method returns a master keyring tied to a specific certifier or subject who will validate and sign off on the fields, along with the encrypted certificate fields.</p> <p><pre><code>static async createCertificateFields(creatorWallet: ProtoWallet, certifierOrSubject: WalletCounterparty, fields: Record&lt;CertificateFieldNameUnder50Bytes, string&gt;, privileged?: boolean, privilegedReason?: string): Promise&lt;CreateCertificateFieldsResult&gt; \n</code></pre> See also: CertificateFieldNameUnder50Bytes, ProtoWallet, WalletCounterparty</p> <p>Returns</p> <p>A promise resolving to an object containing: - <code>certificateFields</code> {Record}: The encrypted certificate fields. - <code>masterKeyring</code> {Record}: The master keyring containing encrypted revelation keys for each field. <p>Argument Details</p> <ul> <li>creatorWallet</li> <li>The wallet of the creator responsible for encrypting the fields.</li> <li>certifierOrSubject</li> <li>The certifier or subject who will validate the certificate fields.</li> <li>fields</li> <li>A record of certificate field names (under 50 bytes) mapped to their values.</li> <li>privileged</li> <li>Whether this is a privileged request.</li> <li>privilegedReason</li> <li>Reason provided for privileged access, required if this is a privileged operation.   *</li> </ul>"},{"location":"reference/auth/#method-createkeyringforverifier","title":"Method createKeyringForVerifier","text":"<p>Creates a keyring for a verifier, enabling them to decrypt specific certificate fields. This method decrypts the master field keys for the specified fields and re-encrypts them for the verifier's identity key. The result is a keyring containing the keys necessary for the verifier to access the designated fields.</p> <p><pre><code>static async createKeyringForVerifier(subjectWallet: ProtoWallet, certifier: WalletCounterparty, verifier: WalletCounterparty, fields: Record&lt;CertificateFieldNameUnder50Bytes, Base64String&gt;, fieldsToReveal: string[], masterKeyring: Record&lt;CertificateFieldNameUnder50Bytes, Base64String&gt;, serialNumber: Base64String, privileged?: boolean, privilegedReason?: string): Promise&lt;Record&lt;CertificateFieldNameUnder50Bytes, string&gt;&gt; \n</code></pre> See also: Base64String, CertificateFieldNameUnder50Bytes, ProtoWallet, WalletCounterparty</p> <p>Returns</p> <ul> <li>A keyring mapping field names to encrypted field revelation keys, allowing the verifier to decrypt specified fields.</li> </ul> <p>Argument Details</p> <ul> <li>subjectWallet</li> <li>The wallet instance of the subject, used to decrypt and re-encrypt field keys.</li> <li>verifier</li> <li>The verifier who will receive access to the selectively revealed fields. Can be an identity key as hex, 'anyone', or 'self'.</li> <li>fieldsToReveal</li> <li>An array of field names to be revealed to the verifier. Must be a subset of the certificate's fields.</li> <li>originator</li> <li>Optional originator identifier, used if additional context is needed for decryption and encryption operations.</li> <li>privileged</li> <li>Whether this is a privileged request.</li> <li>privilegedReason</li> <li>Reason provided for privileged access, required if this is a privileged operation.   *</li> </ul> <p>Throws</p> <p>Throws an error if: - fieldsToReveal is not an array of strings. - A field in <code>fieldsToReveal</code> does not exist in the certificate. - The decrypted master field key fails to decrypt the corresponding field (indicating an invalid key).</p>"},{"location":"reference/auth/#method-decryptfields","title":"Method decryptFields","text":"<p>Decrypts all fields in the MasterCertificate using the subject's or certifier's wallet.</p> <p>This method allows the subject or certifier to decrypt the <code>masterKeyring</code> and retrieve the encryption keys for each field, which are then used to decrypt the corresponding field values. The counterparty used for decryption depends on how the certificate fields were created: - If the certificate is self-signed, the counterparty should be set to 'self'. - Otherwise, the counterparty should always be the other party involved in the certificate issuance process (the subject or certifier).</p> <p><pre><code>static async decryptFields(subjectOrCertifierWallet: ProtoWallet, masterKeyring: Record&lt;CertificateFieldNameUnder50Bytes, Base64String&gt;, fields: Record&lt;CertificateFieldNameUnder50Bytes, Base64String&gt;, counterparty: WalletCounterparty, privileged?: boolean, privilegedReason?: string): Promise&lt;Record&lt;CertificateFieldNameUnder50Bytes, string&gt;&gt; \n</code></pre> See also: Base64String, CertificateFieldNameUnder50Bytes, ProtoWallet, WalletCounterparty</p> <p>Returns</p> <p>A promise resolving to a record of field names and their decrypted values in plaintext.</p> <p>Argument Details</p> <ul> <li>subjectOrCertifierWallet</li> <li>The wallet of the subject or certifier, used to decrypt the master keyring and field values.</li> <li>masterKeyring</li> <li>A record containing encrypted keys for each field.</li> <li>fields</li> <li>A record of encrypted field names and their values.</li> <li>counterparty</li> <li>The counterparty responsible for creating or signing the certificate. For self-signed certificates, use 'self'.</li> <li>privileged</li> <li>Whether this is a privileged request.</li> <li>privilegedReason</li> <li>Reason provided for privileged access, required if this is a privileged operation.</li> </ul> <p>Throws</p> <p>Throws an error if the <code>masterKeyring</code> is invalid or if decryption fails for any field.</p>"},{"location":"reference/auth/#method-issuecertificateforsubject","title":"Method issueCertificateForSubject","text":"<p>Issues a new MasterCertificate for a specified subject.</p> <p>This method generates a certificate containing encrypted fields and a keyring for the subject to decrypt all fields. Each field is encrypted with a randomly generated symmetric key, which is then encrypted for the subject. The certificate can also includes a revocation outpoint to manage potential revocation.</p> <p><pre><code>static async issueCertificateForSubject(certifierWallet: ProtoWallet, subject: WalletCounterparty, fields: Record&lt;CertificateFieldNameUnder50Bytes, string&gt;, certificateType: string, getRevocationOutpoint = async (_serial: string): Promise&lt;string&gt; =&gt; {\n    void _serial;\n    return \"Certificate revocation not tracked.\";\n}, serialNumber?: string): Promise&lt;MasterCertificate&gt; \n</code></pre> See also: CertificateFieldNameUnder50Bytes, MasterCertificate, ProtoWallet, WalletCounterparty</p> <p>Returns</p> <ul> <li>A signed MasterCertificate instance containing the encrypted fields and subject specific keyring.</li> </ul> <p>Argument Details</p> <ul> <li>certifierWallet</li> <li>The wallet of the certifier, used to sign the certificate and encrypt field keys.</li> <li>subject</li> <li>The subject for whom the certificate is issued.</li> <li>fields</li> <li>Unencrypted certificate fields to include, with their names and values.</li> <li>certificateType</li> <li>The type of certificate being issued.</li> <li>getRevocationOutpoint</li> <li>- Optional function to obtain a revocation outpoint for the certificate. Defaults to a placeholder.</li> <li>updateProgress</li> <li>Optional callback for reporting progress updates during the operation. Defaults to a no-op.</li> </ul> <p>Throws</p> <p>Throws an error if any operation (e.g., encryption, signing) fails during certificate issuance.</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/auth/#class-peer","title":"Class: Peer","text":"<p>Represents a peer capable of performing mutual authentication. Manages sessions, handles authentication handshakes, certificate requests and responses, and sending and receiving general messages over a transport layer.</p> <p>This version supports multiple concurrent sessions per peer identityKey.</p> <pre><code>export class Peer {\n    public sessionManager: SessionManager;\n    certificatesToRequest: RequestedCertificateSet;\n    constructor(wallet: WalletInterface, transport: Transport, certificatesToRequest?: RequestedCertificateSet, sessionManager?: SessionManager, autoPersistLastSession?: boolean, originator?: OriginatorDomainNameStringUnder250Bytes) \n    async toPeer(message: number[], identityKey?: string, maxWaitTime?: number): Promise&lt;void&gt; \n    async requestCertificates(certificatesToRequest: RequestedCertificateSet, identityKey?: string, maxWaitTime = 10000): Promise&lt;void&gt; \n    async getAuthenticatedSession(identityKey?: string, maxWaitTime?: number): Promise&lt;PeerSession&gt; \n    listenForGeneralMessages(callback: (senderPublicKey: string, payload: number[]) =&gt; void): number \n    stopListeningForGeneralMessages(callbackID: number): void \n    listenForCertificatesReceived(callback: (senderPublicKey: string, certs: VerifiableCertificate[]) =&gt; void): number \n    stopListeningForCertificatesReceived(callbackID: number): void \n    listenForCertificatesRequested(callback: (senderPublicKey: string, requestedCertificates: RequestedCertificateSet) =&gt; void): number \n    stopListeningForCertificatesRequested(callbackID: number): void \n    async sendCertificateResponse(verifierIdentityKey: string, certificates: VerifiableCertificate[]): Promise&lt;void&gt; \n}\n</code></pre> <p>See also: OriginatorDomainNameStringUnder250Bytes, PeerSession, RequestedCertificateSet, SessionManager, Transport, VerifiableCertificate, WalletInterface</p>"},{"location":"reference/auth/#constructor_2","title":"Constructor","text":"<p>Creates a new Peer instance</p> <p><pre><code>constructor(wallet: WalletInterface, transport: Transport, certificatesToRequest?: RequestedCertificateSet, sessionManager?: SessionManager, autoPersistLastSession?: boolean, originator?: OriginatorDomainNameStringUnder250Bytes) \n</code></pre> See also: OriginatorDomainNameStringUnder250Bytes, RequestedCertificateSet, SessionManager, Transport, WalletInterface</p> <p>Argument Details</p> <ul> <li>wallet</li> <li>The wallet instance used for cryptographic operations.</li> <li>transport</li> <li>The transport mechanism used for sending and receiving messages.</li> <li>certificatesToRequest</li> <li>Optional set of certificates to request from a peer during the initial handshake.</li> <li>sessionManager</li> <li>Optional SessionManager to be used for managing peer sessions.</li> <li>autoPersistLastSession</li> <li>Whether to auto-persist the session with the last-interacted-with peer. Defaults to true.</li> </ul>"},{"location":"reference/auth/#method-getauthenticatedsession","title":"Method getAuthenticatedSession","text":"<p>Retrieves an authenticated session for a given peer identity. If no session exists or the session is not authenticated, initiates a handshake to create or authenticate the session.</p> <ul> <li>If <code>identityKey</code> is provided, we look up any existing session for that identity key.</li> <li>If none is found or not authenticated, we do a new handshake.</li> <li>If <code>identityKey</code> is not provided, but we have a <code>lastInteractedWithPeer</code>, we try that key.</li> </ul> <p><pre><code>async getAuthenticatedSession(identityKey?: string, maxWaitTime?: number): Promise&lt;PeerSession&gt; \n</code></pre> See also: PeerSession</p> <p>Returns</p> <ul> <li>A promise that resolves with an authenticated <code>PeerSession</code>.</li> </ul> <p>Argument Details</p> <ul> <li>identityKey</li> <li>The identity public key of the peer.</li> <li>maxWaitTime</li> <li>The maximum time in milliseconds to wait for the handshake.</li> </ul>"},{"location":"reference/auth/#method-listenforcertificatesreceived","title":"Method listenForCertificatesReceived","text":"<p>Registers a callback to listen for certificates received from peers.</p> <p><pre><code>listenForCertificatesReceived(callback: (senderPublicKey: string, certs: VerifiableCertificate[]) =&gt; void): number \n</code></pre> See also: VerifiableCertificate</p> <p>Returns</p> <p>The ID of the callback listener.</p> <p>Argument Details</p> <ul> <li>callback</li> <li>The function to call when certificates are received.</li> </ul>"},{"location":"reference/auth/#method-listenforcertificatesrequested","title":"Method listenForCertificatesRequested","text":"<p>Registers a callback to listen for certificates requested from peers.</p> <p><pre><code>listenForCertificatesRequested(callback: (senderPublicKey: string, requestedCertificates: RequestedCertificateSet) =&gt; void): number \n</code></pre> See also: RequestedCertificateSet</p> <p>Returns</p> <p>The ID of the callback listener.</p> <p>Argument Details</p> <ul> <li>callback</li> <li>The function to call when a certificate request is received</li> </ul>"},{"location":"reference/auth/#method-listenforgeneralmessages","title":"Method listenForGeneralMessages","text":"<p>Registers a callback to listen for general messages from peers.</p> <pre><code>listenForGeneralMessages(callback: (senderPublicKey: string, payload: number[]) =&gt; void): number \n</code></pre> <p>Returns</p> <p>The ID of the callback listener.</p> <p>Argument Details</p> <ul> <li>callback</li> <li>The function to call when a general message is received.</li> </ul>"},{"location":"reference/auth/#method-requestcertificates","title":"Method requestCertificates","text":"<p>Sends a request for certificates to a peer. This method allows a peer to dynamically request specific certificates after an initial handshake or message has been exchanged.</p> <p><pre><code>async requestCertificates(certificatesToRequest: RequestedCertificateSet, identityKey?: string, maxWaitTime = 10000): Promise&lt;void&gt; \n</code></pre> See also: RequestedCertificateSet</p> <p>Returns</p> <p>Resolves if the certificate request message is successfully sent.</p> <p>Argument Details</p> <ul> <li>certificatesToRequest</li> <li>Specifies the certifiers and types of certificates required from the peer.</li> <li>identityKey</li> <li>The identity public key of the peer. If not provided, the current or last session identity is used.</li> <li>maxWaitTime</li> <li>Maximum time in milliseconds to wait for the peer session to be authenticated.</li> </ul> <p>Throws</p> <p>Will throw an error if the peer session is not authenticated or if sending the request fails.</p>"},{"location":"reference/auth/#method-sendcertificateresponse","title":"Method sendCertificateResponse","text":"<p>Sends a certificate response message containing the specified certificates to a peer.</p> <p><pre><code>async sendCertificateResponse(verifierIdentityKey: string, certificates: VerifiableCertificate[]): Promise&lt;void&gt; \n</code></pre> See also: VerifiableCertificate</p> <p>Argument Details</p> <ul> <li>verifierIdentityKey</li> <li>The identity key of the peer requesting the certificates.</li> <li>certificates</li> <li>The list of certificates to include in the response.</li> </ul> <p>Throws</p> <p>Will throw an error if the transport fails to send the message.</p>"},{"location":"reference/auth/#method-stoplisteningforcertificatesreceived","title":"Method stopListeningForCertificatesReceived","text":"<p>Cancels and unsubscribes a certificatesReceived listener.</p> <pre><code>stopListeningForCertificatesReceived(callbackID: number): void \n</code></pre> <p>Argument Details</p> <ul> <li>callbackID</li> <li>The ID of the certificates received callback to cancel.</li> </ul>"},{"location":"reference/auth/#method-stoplisteningforcertificatesrequested","title":"Method stopListeningForCertificatesRequested","text":"<p>Cancels and unsubscribes a certificatesRequested listener.</p> <pre><code>stopListeningForCertificatesRequested(callbackID: number): void \n</code></pre> <p>Argument Details</p> <ul> <li>callbackID</li> <li>The ID of the requested certificates callback to cancel.</li> </ul>"},{"location":"reference/auth/#method-stoplisteningforgeneralmessages","title":"Method stopListeningForGeneralMessages","text":"<p>Removes a general message listener.</p> <pre><code>stopListeningForGeneralMessages(callbackID: number): void \n</code></pre> <p>Argument Details</p> <ul> <li>callbackID</li> <li>The ID of the callback to remove.</li> </ul>"},{"location":"reference/auth/#method-topeer","title":"Method toPeer","text":"<p>Sends a general message to a peer, and initiates a handshake if necessary.</p> <pre><code>async toPeer(message: number[], identityKey?: string, maxWaitTime?: number): Promise&lt;void&gt; \n</code></pre> <p>Argument Details</p> <ul> <li>message</li> <li>The message payload to send.</li> <li>identityKey</li> <li>The identity public key of the peer. If not provided, uses lastInteractedWithPeer (if any).</li> <li>maxWaitTime</li> <li>optional max wait time in ms</li> </ul> <p>Throws</p> <p>Will throw an error if the message fails to send.</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/auth/#class-sessionmanager","title":"Class: SessionManager","text":"<p>Manages sessions for peers, allowing multiple concurrent sessions per identity key. Primary lookup is always by <code>sessionNonce</code>.</p> <pre><code>export class SessionManager {\n    constructor() \n    addSession(session: PeerSession): void \n    updateSession(session: PeerSession): void \n    getSession(identifier: string): PeerSession | undefined \n    removeSession(session: PeerSession): void \n    hasSession(identifier: string): boolean \n}\n</code></pre> <p>See also: PeerSession</p>"},{"location":"reference/auth/#method-addsession","title":"Method addSession","text":"<p>Adds a session to the manager, associating it with its sessionNonce, and also with its peerIdentityKey (if any).</p> <p>This does NOT overwrite existing sessions for the same peerIdentityKey, allowing multiple concurrent sessions for the same peer.</p> <p><pre><code>addSession(session: PeerSession): void \n</code></pre> See also: PeerSession</p> <p>Argument Details</p> <ul> <li>session</li> <li>The peer session to add.</li> </ul>"},{"location":"reference/auth/#method-getsession","title":"Method getSession","text":"<p>Retrieves a session based on a given identifier, which can be:  - A sessionNonce, or  - A peerIdentityKey.</p> <p>If it is a <code>sessionNonce</code>, returns that exact session. If it is a <code>peerIdentityKey</code>, returns the \"best\" (e.g. most recently updated, authenticated) session associated with that peer, if any.</p> <p><pre><code>getSession(identifier: string): PeerSession | undefined \n</code></pre> See also: PeerSession</p> <p>Returns</p> <ul> <li>The matching peer session, or undefined if not found.</li> </ul> <p>Argument Details</p> <ul> <li>identifier</li> <li>The identifier for the session (sessionNonce or peerIdentityKey).</li> </ul>"},{"location":"reference/auth/#method-hassession","title":"Method hasSession","text":"<p>Checks if a session exists for a given identifier (either sessionNonce or identityKey).</p> <pre><code>hasSession(identifier: string): boolean \n</code></pre> <p>Returns</p> <ul> <li>True if the session exists, false otherwise.</li> </ul> <p>Argument Details</p> <ul> <li>identifier</li> <li>The identifier to check.</li> </ul>"},{"location":"reference/auth/#method-removesession","title":"Method removeSession","text":"<p>Removes a session from the manager by clearing all associated identifiers.</p> <p><pre><code>removeSession(session: PeerSession): void \n</code></pre> See also: PeerSession</p> <p>Argument Details</p> <ul> <li>session</li> <li>The peer session to remove.</li> </ul>"},{"location":"reference/auth/#method-updatesession","title":"Method updateSession","text":"<p>Updates a session in the manager (primarily by re-adding it), ensuring we record the latest data (e.g., isAuthenticated, lastUpdate, etc.).</p> <p><pre><code>updateSession(session: PeerSession): void \n</code></pre> See also: PeerSession</p> <p>Argument Details</p> <ul> <li>session</li> <li>The peer session to update.</li> </ul> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/auth/#class-simplifiedfetchtransport","title":"Class: SimplifiedFetchTransport","text":"<p>Implements an HTTP-specific transport for handling Peer mutual authentication messages. This class integrates with fetch to send and receive authenticated messages between peers.</p> <pre><code>export class SimplifiedFetchTransport implements Transport {\n    fetchClient: typeof fetch;\n    baseUrl: string;\n    constructor(baseUrl: string, fetchClient = defaultFetch) \n    async send(message: AuthMessage): Promise&lt;void&gt; \n    async onData(callback: (message: AuthMessage) =&gt; Promise&lt;void&gt;): Promise&lt;void&gt; \n    deserializeRequestPayload(payload: number[]): {\n        method: string;\n        urlPostfix: string;\n        headers: Record&lt;string, string&gt;;\n        body: number[];\n        requestId: string;\n    } \n}\n</code></pre> <p>See also: AuthMessage, Transport</p>"},{"location":"reference/auth/#constructor_3","title":"Constructor","text":"<p>Constructs a new instance of SimplifiedFetchTransport.</p> <pre><code>constructor(baseUrl: string, fetchClient = defaultFetch) \n</code></pre> <p>Argument Details</p> <ul> <li>baseUrl</li> <li>The base URL for all HTTP requests made by this transport.</li> <li>fetchClient</li> <li>A fetch implementation to use for HTTP requests (default: global fetch).</li> </ul>"},{"location":"reference/auth/#method-deserializerequestpayload","title":"Method deserializeRequestPayload","text":"<p>Deserializes a request payload from a byte array into an HTTP request-like structure.</p> <pre><code>deserializeRequestPayload(payload: number[]): {\n    method: string;\n    urlPostfix: string;\n    headers: Record&lt;string, string&gt;;\n    body: number[];\n    requestId: string;\n} \n</code></pre> <p>Returns</p> <p>An object representing the deserialized request, including the method, URL postfix (path and query string), headers, body, and request ID.</p> <p>Argument Details</p> <ul> <li>payload</li> <li>The serialized payload to deserialize.</li> </ul>"},{"location":"reference/auth/#method-ondata","title":"Method onData","text":"<p>Registers a callback to handle incoming messages. This must be called before sending any messages to ensure responses can be processed.</p> <p><pre><code>async onData(callback: (message: AuthMessage) =&gt; Promise&lt;void&gt;): Promise&lt;void&gt; \n</code></pre> See also: AuthMessage</p> <p>Returns</p> <p>A promise that resolves once the callback is set.</p> <p>Argument Details</p> <ul> <li>callback</li> <li>A function to invoke when an incoming AuthMessage is received.</li> </ul>"},{"location":"reference/auth/#method-send","title":"Method send","text":"<p>Sends a message to an HTTP server using the transport mechanism. Handles both general and authenticated message types. For general messages, the payload is deserialized and sent as an HTTP request. For other message types, the message is sent as a POST request to the <code>/auth</code> endpoint.</p> <p><pre><code>async send(message: AuthMessage): Promise&lt;void&gt; \n</code></pre> See also: AuthMessage</p> <p>Returns</p> <p>A promise that resolves when the message is successfully sent.</p> <p>Argument Details</p> <ul> <li>message</li> <li>The AuthMessage to send.</li> </ul> <p>Throws</p> <p>Will throw an error if no listener has been registered via <code>onData</code>.</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/auth/#class-verifiablecertificate","title":"Class: VerifiableCertificate","text":"<p>VerifiableCertificate extends the Certificate class, adding functionality to manage a verifier-specific keyring. This keyring allows selective decryption of certificate fields for authorized verifiers.</p> <pre><code>export class VerifiableCertificate extends Certificate {\n    declare type: Base64String;\n    declare serialNumber: Base64String;\n    declare subject: PubKeyHex;\n    declare certifier: PubKeyHex;\n    declare revocationOutpoint: OutpointString;\n    declare fields: Record&lt;CertificateFieldNameUnder50Bytes, string&gt;;\n    declare signature?: HexString;\n    keyring: Record&lt;CertificateFieldNameUnder50Bytes, string&gt;;\n    decryptedFields?: Record&lt;CertificateFieldNameUnder50Bytes, Base64String&gt;;\n    constructor(type: Base64String, serialNumber: Base64String, subject: PubKeyHex, certifier: PubKeyHex, revocationOutpoint: OutpointString, fields: Record&lt;CertificateFieldNameUnder50Bytes, string&gt;, keyring: Record&lt;CertificateFieldNameUnder50Bytes, string&gt;, signature?: HexString, decryptedFields?: Record&lt;CertificateFieldNameUnder50Bytes, Base64String&gt;) \n    static fromCertificate(certificate: WalletCertificate, keyring: Record&lt;CertificateFieldNameUnder50Bytes, string&gt;): VerifiableCertificate \n    async decryptFields(verifierWallet: ProtoWallet, privileged?: boolean, privilegedReason?: string, originator?: OriginatorDomainNameStringUnder250Bytes): Promise&lt;Record&lt;CertificateFieldNameUnder50Bytes, string&gt;&gt; \n}\n</code></pre> <p>See also: Base64String, Certificate, CertificateFieldNameUnder50Bytes, HexString, OriginatorDomainNameStringUnder250Bytes, OutpointString, ProtoWallet, PubKeyHex, WalletCertificate</p>"},{"location":"reference/auth/#method-decryptfields_1","title":"Method decryptFields","text":"<p>Decrypts selectively revealed certificate fields using the provided keyring and verifier wallet</p> <p><pre><code>async decryptFields(verifierWallet: ProtoWallet, privileged?: boolean, privilegedReason?: string, originator?: OriginatorDomainNameStringUnder250Bytes): Promise&lt;Record&lt;CertificateFieldNameUnder50Bytes, string&gt;&gt; \n</code></pre> See also: CertificateFieldNameUnder50Bytes, OriginatorDomainNameStringUnder250Bytes, ProtoWallet</p> <p>Returns</p> <ul> <li>A promise that resolves to an object where each key is a field name and each value is the decrypted field value as a string.</li> </ul> <p>Argument Details</p> <ul> <li>verifierWallet</li> <li>The wallet instance of the certificate's verifier, used to decrypt field keys.</li> <li>privileged</li> <li>Whether this is a privileged request.</li> <li>privilegedReason</li> <li>Reason provided for privileged access, required if this is a privileged operation.</li> </ul> <p>Throws</p> <p>Throws an error if any of the decryption operations fail, with a message indicating the failure context.</p>"},{"location":"reference/auth/#method-fromcertificate","title":"Method fromCertificate","text":"<p><pre><code>static fromCertificate(certificate: WalletCertificate, keyring: Record&lt;CertificateFieldNameUnder50Bytes, string&gt;): VerifiableCertificate \n</code></pre> See also: CertificateFieldNameUnder50Bytes, VerifiableCertificate, WalletCertificate</p> <p>Returns</p> <p>\u2013 A fully-formed instance containing the original certificate data plus the supplied keyring.</p> <p>Argument Details</p> <ul> <li>certificate</li> <li>\u2013 The source certificate that was issued and signed by the certifier.</li> <li>keyring</li> <li>\u2013 A allows the verifier to decrypt selected certificate fields.</li> </ul> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/auth/#functions","title":"Functions","text":"createNonce verifyNonce <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/auth/#function-createnonce","title":"Function: createNonce","text":"<p>Creates a nonce derived from a wallet</p> <pre><code>export async function createNonce(wallet: WalletInterface, counterparty: WalletCounterparty = \"self\", originator?: OriginatorDomainNameStringUnder250Bytes): Promise&lt;Base64String&gt; \n</code></pre> <p>See also: Base64String, OriginatorDomainNameStringUnder250Bytes, WalletCounterparty, WalletInterface</p> <p>Returns</p> <p>A random nonce derived with a wallet</p> <p>Argument Details</p> <ul> <li>counterparty</li> <li>The counterparty to the nonce creation. Defaults to 'self'.</li> </ul> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/auth/#function-verifynonce","title":"Function: verifyNonce","text":"<p>Verifies a nonce derived from a wallet</p> <pre><code>export async function verifyNonce(nonce: Base64String, wallet: WalletInterface, counterparty: WalletCounterparty = \"self\", originator?: OriginatorDomainNameStringUnder250Bytes): Promise&lt;boolean&gt; \n</code></pre> <p>See also: Base64String, OriginatorDomainNameStringUnder250Bytes, WalletCounterparty, WalletInterface</p> <p>Returns</p> <p>The status of the validation</p> <p>Argument Details</p> <ul> <li>nonce</li> <li>A nonce to verify as a base64 string.</li> <li>counterparty</li> <li>The counterparty to the nonce creation. Defaults to 'self'.</li> </ul> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/auth/#types","title":"Types","text":""},{"location":"reference/auth/#enums","title":"Enums","text":""},{"location":"reference/auth/#variables","title":"Variables","text":"getVerifiableCertificates validateCertificates <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/auth/#variable-getverifiablecertificates","title":"Variable: getVerifiableCertificates","text":"<pre><code>getVerifiableCertificates = async (wallet: WalletInterface, requestedCertificates: RequestedCertificateSet, verifierIdentityKey: string, originator?: OriginatorDomainNameStringUnder250Bytes): Promise&lt;VerifiableCertificate[]&gt; =&gt; {\n    const matchingCertificates = await wallet.listCertificates({\n        certifiers: requestedCertificates.certifiers,\n        types: Object.keys(requestedCertificates.types)\n    }, originator);\n    return await Promise.all(matchingCertificates.certificates.map(async (certificate) =&gt; {\n        const { keyringForVerifier } = await wallet.proveCertificate({\n            certificate,\n            fieldsToReveal: requestedCertificates.types[certificate.type],\n            verifier: verifierIdentityKey\n        }, originator);\n        return new VerifiableCertificate(certificate.type, certificate.serialNumber, certificate.subject, certificate.certifier, certificate.revocationOutpoint, certificate.fields, keyringForVerifier, certificate.signature);\n    }));\n}\n</code></pre> <p>See also: OriginatorDomainNameStringUnder250Bytes, RequestedCertificateSet, VerifiableCertificate, WalletInterface</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/auth/#variable-validatecertificates","title":"Variable: validateCertificates","text":"<pre><code>validateCertificates = async (verifierWallet: WalletInterface, message: AuthMessage, certificatesRequested?: RequestedCertificateSet, originator?: OriginatorDomainNameStringUnder250Bytes): Promise&lt;void&gt; =&gt; {\n    if ((message.certificates == null) || message.certificates.length === 0) {\n        throw new Error(\"No certificates were provided in the AuthMessage.\");\n    }\n    await Promise.all(message.certificates.map(async (incomingCert: VerifiableCertificate) =&gt; {\n        if (incomingCert.subject !== message.identityKey) {\n            throw new Error(`The subject of one of your certificates (\"${incomingCert.subject}\") is not the same as the request sender (\"${message.identityKey}\").`);\n        }\n        const certToVerify = new VerifiableCertificate(incomingCert.type, incomingCert.serialNumber, incomingCert.subject, incomingCert.certifier, incomingCert.revocationOutpoint, incomingCert.fields, incomingCert.keyring, incomingCert.signature);\n        const isValidCert = await certToVerify.verify();\n        if (!isValidCert) {\n            throw new Error(`The signature for the certificate with serial number ${certToVerify.serialNumber} is invalid!`);\n        }\n        if (certificatesRequested != null) {\n            const { certifiers, types } = certificatesRequested;\n            if (!certifiers.includes(certToVerify.certifier)) {\n                throw new Error(`Certificate with serial number ${certToVerify.serialNumber} has an unrequested certifier: ${certToVerify.certifier}`);\n            }\n            const requestedFields = types[certToVerify.type];\n            if (requestedFields == null) {\n                throw new Error(`Certificate with type ${certToVerify.type} was not requested`);\n            }\n        }\n        await certToVerify.decryptFields(verifierWallet, undefined, undefined, originator);\n    }));\n}\n</code></pre> <p>See also: AuthMessage, Certificate, OriginatorDomainNameStringUnder250Bytes, RequestedCertificateSet, VerifiableCertificate, WalletInterface, verify</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/compat/","title":"API","text":"<p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/compat/#interfaces","title":"Interfaces","text":""},{"location":"reference/compat/#classes","title":"Classes","text":"ECIES HD Mnemonic <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/compat/#class-ecies","title":"Class: ECIES","text":"<pre><code>export default class ECIES {\n    public static ivkEkM(privKey: PrivateKey, pubKey: PublicKey): {\n        iv: number[];\n        kE: number[];\n        kM: number[];\n    } \n    public static electrumEncrypt(messageBuf: number[], toPublicKey: PublicKey, fromPrivateKey?: PrivateKey, noKey = false): number[] \n    public static electrumDecrypt(encBuf: number[], toPrivateKey: PrivateKey, fromPublicKey?: PublicKey): number[] \n    public static bitcoreEncrypt(messageBuf: number[], toPublicKey: PublicKey, fromPrivateKey?: PrivateKey, ivBuf?: number[]): number[] \n    public static bitcoreDecrypt(encBuf: number[], toPrivateKey: PrivateKey): number[] \n}\n</code></pre> <p>See also: PrivateKey, PublicKey</p>"},{"location":"reference/compat/#method-bitcoredecrypt","title":"Method bitcoreDecrypt","text":"<p>Decrypts a message encrypted using the Bitcore variant of ECIES.</p> <p><pre><code>public static bitcoreDecrypt(encBuf: number[], toPrivateKey: PrivateKey): number[] \n</code></pre> See also: PrivateKey</p> <p>Returns</p> <p>The decrypted message as a number array.</p> <p>Argument Details</p> <ul> <li>encBuf</li> <li>The encrypted message buffer.</li> <li>toPrivateKey</li> <li>The private key of the recipient.</li> </ul>"},{"location":"reference/compat/#method-bitcoreencrypt","title":"Method bitcoreEncrypt","text":"<p>Encrypts a given message using the Bitcore variant of ECIES.</p> <p><pre><code>public static bitcoreEncrypt(messageBuf: number[], toPublicKey: PublicKey, fromPrivateKey?: PrivateKey, ivBuf?: number[]): number[] \n</code></pre> See also: PrivateKey, PublicKey</p> <p>Returns</p> <p>The encrypted message as a number array.</p> <p>Argument Details</p> <ul> <li>messageBuf</li> <li>The message to be encrypted, in number array format.</li> <li>toPublicKey</li> <li>The public key of the recipient.</li> <li>fromPrivateKey</li> <li>The private key of the sender. If not provided, a random private key is used.</li> <li>ivBuf</li> <li>The initialization vector for encryption. If not provided, a random IV is used.</li> </ul>"},{"location":"reference/compat/#method-electrumdecrypt","title":"Method electrumDecrypt","text":"<p>Decrypts a message encrypted using the Electrum ECIES method.</p> <p><pre><code>public static electrumDecrypt(encBuf: number[], toPrivateKey: PrivateKey, fromPublicKey?: PublicKey): number[] \n</code></pre> See also: PrivateKey, PublicKey</p> <p>Returns</p> <p>The decrypted message as a number array.</p> <p>Argument Details</p> <ul> <li>encBuf</li> <li>The encrypted message buffer.</li> <li>toPrivateKey</li> <li>The private key of the recipient.</li> <li>fromPublicKey</li> <li>The public key of the sender. If not provided, it is extracted from the message.</li> </ul>"},{"location":"reference/compat/#method-electrumencrypt","title":"Method electrumEncrypt","text":"<p>Encrypts a given message using the Electrum ECIES method.</p> <p><pre><code>public static electrumEncrypt(messageBuf: number[], toPublicKey: PublicKey, fromPrivateKey?: PrivateKey, noKey = false): number[] \n</code></pre> See also: PrivateKey, PublicKey</p> <p>Returns</p> <p>The encrypted message as a number array.</p> <p>Argument Details</p> <ul> <li>messageBuf</li> <li>The message to be encrypted, in number array format.</li> <li>toPublicKey</li> <li>The public key of the recipient.</li> <li>fromPrivateKey</li> <li>The private key of the sender. If not provided, a random private key is used.</li> <li>noKey</li> <li>If true, does not include the sender's public key in the encrypted message.</li> </ul>"},{"location":"reference/compat/#method-ivkekm","title":"Method ivkEkM","text":"<p>Generates the initialization vector (iv), encryption key (kE), and MAC key (kM) using the sender's private key and receiver's public key.</p> <p><pre><code>public static ivkEkM(privKey: PrivateKey, pubKey: PublicKey): {\n    iv: number[];\n    kE: number[];\n    kM: number[];\n} \n</code></pre> See also: PrivateKey, PublicKey</p> <p>Returns</p> <p>An object containing the iv, kE, and kM as number arrays.</p> <p>Argument Details</p> <ul> <li>privKey</li> <li>The sender's private key.</li> <li>pubKey</li> <li>The receiver's public key.</li> </ul> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/compat/#class-hd","title":"Class: HD","text":"<pre><code>export default class HD {\n    versionBytesNum: number;\n    depth: number;\n    parentFingerPrint: number[];\n    childIndex: number;\n    chainCode: number[];\n    privKey: PrivateKey;\n    pubKey: PublicKey;\n    constants = {\n        pubKey: 76067358,\n        privKey: 76066276\n    };\n    constructor(versionBytesNum?: number, depth?: number, parentFingerPrint?: number[], childIndex?: number, chainCode?: number[], privKey?: PrivateKey, pubKey?: PublicKey) \n    public fromRandom(): this \n    public static fromRandom(): HD \n    public static fromString(str: string): HD \n    public fromString(str: string): this \n    public static fromSeed(bytes: number[]): HD \n    public fromSeed(bytes: number[]): this \n    public static fromBinary(buf: number[]): HD \n    public fromBinary(buf: number[]): this \n    public toString(): string \n    public derive(path: string): HD \n    public deriveChild(i: number): HD \n    public toPublic(): HD \n    public toBinary(): number[] \n    public isPrivate(): boolean \n}\n</code></pre> <p>See also: PrivateKey, PublicKey</p>"},{"location":"reference/compat/#constructor","title":"Constructor","text":"<p>Constructor for the BIP32 HD wallet. Initializes an HD wallet with optional parameters for version bytes, depth, parent fingerprint, child index, chain code, private key, and public key.</p> <p><pre><code>constructor(versionBytesNum?: number, depth?: number, parentFingerPrint?: number[], childIndex?: number, chainCode?: number[], privKey?: PrivateKey, pubKey?: PublicKey) \n</code></pre> See also: PrivateKey, PublicKey</p> <p>Argument Details</p> <ul> <li>versionBytesNum</li> <li>Version bytes number for the wallet.</li> <li>depth</li> <li>Depth of the key in the hierarchy.</li> <li>parentFingerPrint</li> <li>Fingerprint of the parent key.</li> <li>childIndex</li> <li>Index of the child key.</li> <li>chainCode</li> <li>Chain code for key derivation.</li> <li>privKey</li> <li>Private key of the wallet.</li> <li>pubKey</li> <li>Public key of the wallet.</li> </ul>"},{"location":"reference/compat/#method-derive","title":"Method derive","text":"<p>Derives a child HD wallet based on a given path. The path specifies the hierarchy of the child key to be derived.</p> <p><pre><code>public derive(path: string): HD \n</code></pre> See also: HD</p> <p>Returns</p> <p>A new HD instance representing the derived child wallet.</p> <p>Argument Details</p> <ul> <li>path</li> <li>A string representing the derivation path (e.g., 'm/0'/1).</li> </ul>"},{"location":"reference/compat/#method-derivechild","title":"Method deriveChild","text":"<p>Derives a child HD wallet from the current wallet based on an index. This method generates either a private or public child key depending on the current wallet's state.</p> <p><pre><code>public deriveChild(i: number): HD \n</code></pre> See also: HD</p> <p>Returns</p> <p>A new HD instance representing the derived child wallet.</p> <p>Argument Details</p> <ul> <li>i</li> <li>The index of the child key to derive.</li> </ul>"},{"location":"reference/compat/#method-frombinary","title":"Method fromBinary","text":"<p>Initializes the HD wallet from a binary buffer. Parses a binary buffer to set up the wallet's properties.</p> <p><pre><code>public static fromBinary(buf: number[]): HD \n</code></pre> See also: HD</p> <p>Returns</p> <p>The new instance with properties set from the buffer.</p> <p>Argument Details</p> <ul> <li>buf</li> <li>A buffer containing the wallet data.</li> </ul>"},{"location":"reference/compat/#method-frombinary_1","title":"Method fromBinary","text":"<p>Initializes the HD wallet from a binary buffer. Parses a binary buffer to set up the wallet's properties.</p> <pre><code>public fromBinary(buf: number[]): this \n</code></pre> <p>Returns</p> <p>The current instance with properties set from the buffer.</p> <p>Argument Details</p> <ul> <li>buf</li> <li>A buffer containing the wallet data.</li> </ul>"},{"location":"reference/compat/#method-fromrandom","title":"Method fromRandom","text":"<p>Generates a new HD wallet with random keys. This method creates a root HD wallet with randomly generated private and public keys.</p> <pre><code>public fromRandom(): this \n</code></pre> <p>Returns</p> <p>The current HD instance with generated keys.</p>"},{"location":"reference/compat/#method-fromrandom_1","title":"Method fromRandom","text":"<p>Generates a new HD wallet with random keys. This method creates a root HD wallet with randomly generated private and public keys.</p> <p><pre><code>public static fromRandom(): HD \n</code></pre> See also: HD</p> <p>Returns</p> <p>A new HD instance with generated keys.</p>"},{"location":"reference/compat/#method-fromseed","title":"Method fromSeed","text":"<p>Initializes the HD wallet from a seed. This method generates keys and other properties from a given seed, conforming to the BIP32 specification.</p> <p><pre><code>public static fromSeed(bytes: number[]): HD \n</code></pre> See also: HD</p> <p>Returns</p> <p>The current instance with properties set from the seed.</p> <p>Argument Details</p> <ul> <li>bytes</li> <li>An array of bytes representing the seed.</li> </ul>"},{"location":"reference/compat/#method-fromseed_1","title":"Method fromSeed","text":"<p>Initializes the HD wallet from a seed. This method generates keys and other properties from a given seed, conforming to the BIP32 specification.</p> <pre><code>public fromSeed(bytes: number[]): this \n</code></pre> <p>Returns</p> <p>The current instance with properties set from the seed.</p> <p>Argument Details</p> <ul> <li>bytes</li> <li>An array of bytes representing the seed.</li> </ul>"},{"location":"reference/compat/#method-fromstring","title":"Method fromString","text":"<p>Initializes the HD wallet from a given base58 encoded string. This method decodes a provided string to set up the HD wallet's properties.</p> <p><pre><code>public static fromString(str: string): HD \n</code></pre> See also: HD</p> <p>Returns</p> <p>The new instance with properties set from the string.</p> <p>Argument Details</p> <ul> <li>str</li> <li>A base58 encoded string representing the wallet.</li> </ul>"},{"location":"reference/compat/#method-fromstring_1","title":"Method fromString","text":"<p>Initializes the HD wallet from a given base58 encoded string. This method decodes a provided string to set up the HD wallet's properties.</p> <pre><code>public fromString(str: string): this \n</code></pre> <p>Returns</p> <p>The current instance with properties set from the string.</p> <p>Argument Details</p> <ul> <li>str</li> <li>A base58 encoded string representing the wallet.</li> </ul>"},{"location":"reference/compat/#method-isprivate","title":"Method isPrivate","text":"<p>Checks if the HD wallet contains a private key. This method determines whether the wallet is a private key wallet or a public key only wallet.</p> <pre><code>public isPrivate(): boolean \n</code></pre> <p>Returns</p> <p>A boolean value indicating whether the wallet has a private key (true) or not (false).</p>"},{"location":"reference/compat/#method-tobinary","title":"Method toBinary","text":"<p>Converts the HD wallet into a binary representation. This method serializes the wallet's properties into a binary format.</p> <pre><code>public toBinary(): number[] \n</code></pre> <p>Returns</p> <p>An array of numbers representing the binary data of the wallet.</p>"},{"location":"reference/compat/#method-topublic","title":"Method toPublic","text":"<p>Converts the current HD wallet to a public-only wallet. This method strips away the private key information, leaving only the public part.</p> <p><pre><code>public toPublic(): HD \n</code></pre> See also: HD</p> <p>Returns</p> <p>A new HD instance representing the public-only wallet.</p>"},{"location":"reference/compat/#method-tostring","title":"Method toString","text":"<p>function toString() { [native code] }</p> <p>Converts the HD wallet to a base58 encoded string. This method provides a string representation of the HD wallet's current state.</p> <pre><code>public toString(): string \n</code></pre> <p>Returns</p> <p>A base58 encoded string of the HD wallet.</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/compat/#class-mnemonic","title":"Class: Mnemonic","text":"<pre><code>export default class Mnemonic {\n    public mnemonic: string;\n    public seed: number[];\n    public Wordlist: {\n        value: string[];\n        space: string;\n    };\n    constructor(mnemonic?: string, seed?: number[], wordlist = wordList) \n    public toBinary(): number[] \n    public fromBinary(bin: number[]): this \n    public fromRandom(bits?: number): this \n    public static fromRandom(bits?: number): Mnemonic \n    public fromEntropy(buf: number[]): this \n    public static fromEntropy(buf: number[]): Mnemonic \n    public fromString(mnemonic: string): this \n    public static fromString(str: string): Mnemonic \n    public toString(): string \n    public toSeed(passphrase?: string): number[] \n    public entropy2Mnemonic(buf: number[]): this \n    public check(): boolean \n    public mnemonic2Seed(passphrase = \"\"): this \n    public isValid(passphrase = \"\"): boolean \n    public static isValid(mnemonic: string, passphrase = \"\"): boolean \n}\n</code></pre> <p>See also: wordList</p>"},{"location":"reference/compat/#constructor_1","title":"Constructor","text":"<p>Constructs a Mnemonic object.</p> <p><pre><code>constructor(mnemonic?: string, seed?: number[], wordlist = wordList) \n</code></pre> See also: wordList</p> <p>Argument Details</p> <ul> <li>mnemonic</li> <li>An optional mnemonic phrase.</li> <li>seed</li> <li>An optional seed derived from the mnemonic.</li> <li>wordlist</li> <li>An object containing a list of words and space character used in the mnemonic.</li> </ul>"},{"location":"reference/compat/#method-check","title":"Method check","text":"<p>Validates the mnemonic phrase. Checks for correct length, absence of invalid words, and proper checksum.</p> <pre><code>public check(): boolean \n</code></pre> <p>Returns</p> <p>True if the mnemonic is valid, false otherwise.</p> <p>Throws</p> <p>If the mnemonic is not an even multiple of 11 bits.</p>"},{"location":"reference/compat/#method-entropy2mnemonic","title":"Method entropy2Mnemonic","text":"<p>Converts entropy to a mnemonic phrase. This method takes a buffer of entropy and converts it into a corresponding mnemonic phrase based on the Mnemonic wordlist. The entropy should be at least 128 bits. The method applies a checksum and maps the entropy to words in the wordlist.</p> <pre><code>public entropy2Mnemonic(buf: number[]): this \n</code></pre> <p>Returns</p> <p>The Mnemonic instance with the mnemonic set from the entropy.</p> <p>Argument Details</p> <ul> <li>buf</li> <li>The entropy buffer to convert. Must be at least 128 bits.</li> </ul> <p>Throws</p> <p>If the entropy is less than 128 bits or if it's not an even multiple of 11 bits.</p>"},{"location":"reference/compat/#method-frombinary_2","title":"Method fromBinary","text":"<p>Loads a mnemonic and seed from a binary representation.</p> <pre><code>public fromBinary(bin: number[]): this \n</code></pre> <p>Returns</p> <p>The Mnemonic instance with loaded mnemonic and seed.</p> <p>Argument Details</p> <ul> <li>bin</li> <li>The binary representation of a mnemonic and seed.</li> </ul>"},{"location":"reference/compat/#method-fromentropy","title":"Method fromEntropy","text":"<p>Converts given entropy into a mnemonic phrase. This method is used to generate a mnemonic from a specific entropy source.</p> <pre><code>public fromEntropy(buf: number[]): this \n</code></pre> <p>Returns</p> <p>The Mnemonic instance with the mnemonic set from the given entropy.</p> <p>Argument Details</p> <ul> <li>buf</li> <li>The entropy buffer, must be at least 128 bits.</li> </ul> <p>Throws</p> <p>If the entropy is less than 128 bits.</p>"},{"location":"reference/compat/#method-fromentropy_1","title":"Method fromEntropy","text":"<p>Static method to create a Mnemonic instance from a given entropy.</p> <p><pre><code>public static fromEntropy(buf: number[]): Mnemonic \n</code></pre> See also: Mnemonic</p> <p>Returns</p> <p>A new Mnemonic instance.</p> <p>Argument Details</p> <ul> <li>buf</li> <li>The entropy buffer.</li> </ul>"},{"location":"reference/compat/#method-fromrandom_2","title":"Method fromRandom","text":"<p>Generates a random mnemonic from a given bit length.</p> <pre><code>public fromRandom(bits?: number): this \n</code></pre> <p>Returns</p> <p>The Mnemonic instance with the new random mnemonic.</p> <p>Argument Details</p> <ul> <li>bits</li> <li>The bit length for the random mnemonic (must be a multiple of 32 and at least 128).</li> </ul> <p>Throws</p> <p>If the bit length is not a multiple of 32 or is less than 128.</p>"},{"location":"reference/compat/#method-fromrandom_3","title":"Method fromRandom","text":"<p>Static method to generate a Mnemonic instance with a random mnemonic.</p> <p><pre><code>public static fromRandom(bits?: number): Mnemonic \n</code></pre> See also: Mnemonic</p> <p>Returns</p> <p>A new Mnemonic instance.</p> <p>Argument Details</p> <ul> <li>bits</li> <li>The bit length for the random mnemonic.</li> </ul>"},{"location":"reference/compat/#method-fromstring_2","title":"Method fromString","text":"<p>Sets the mnemonic for the instance from a string.</p> <pre><code>public fromString(mnemonic: string): this \n</code></pre> <p>Returns</p> <p>The Mnemonic instance with the set mnemonic.</p> <p>Argument Details</p> <ul> <li>mnemonic</li> <li>The mnemonic phrase as a string.</li> </ul>"},{"location":"reference/compat/#method-fromstring_3","title":"Method fromString","text":"<p>Static method to create a Mnemonic instance from a mnemonic string.</p> <p><pre><code>public static fromString(str: string): Mnemonic \n</code></pre> See also: Mnemonic</p> <p>Returns</p> <p>A new Mnemonic instance.</p> <p>Argument Details</p> <ul> <li>str</li> <li>The mnemonic phrase.</li> </ul>"},{"location":"reference/compat/#method-isvalid","title":"Method isValid","text":"<p>Determines the validity of a given passphrase with the mnemonic. This method is useful for checking if a passphrase matches with the mnemonic.</p> <pre><code>public isValid(passphrase = \"\"): boolean \n</code></pre> <p>Returns</p> <p>True if the mnemonic and passphrase combination is valid, false otherwise.</p> <p>Argument Details</p> <ul> <li>passphrase</li> <li>The passphrase to validate.</li> </ul>"},{"location":"reference/compat/#method-isvalid_1","title":"Method isValid","text":"<p>Static method to check the validity of a given mnemonic and passphrase combination.</p> <pre><code>public static isValid(mnemonic: string, passphrase = \"\"): boolean \n</code></pre> <p>Returns</p> <p>True if the combination is valid, false otherwise.</p> <p>Argument Details</p> <ul> <li>mnemonic</li> <li>The mnemonic phrase.</li> <li>passphrase</li> <li>The passphrase to validate.</li> </ul>"},{"location":"reference/compat/#method-mnemonic2seed","title":"Method mnemonic2Seed","text":"<p>Converts a mnemonic to a seed. This method takes the instance's mnemonic phrase, combines it with a passphrase (if provided), and uses PBKDF2 to generate a seed. It also validates the mnemonic before conversion. This seed can then be used for generating deterministic keys.</p> <pre><code>public mnemonic2Seed(passphrase = \"\"): this \n</code></pre> <p>Returns</p> <p>The Mnemonic instance with the seed generated from the mnemonic.</p> <p>Argument Details</p> <ul> <li>passphrase</li> <li>An optional passphrase for added security.</li> </ul> <p>Throws</p> <p>If the mnemonic does not pass validation or if the passphrase is not a string.</p>"},{"location":"reference/compat/#method-tobinary_1","title":"Method toBinary","text":"<p>Converts the mnemonic and seed into a binary representation.</p> <pre><code>public toBinary(): number[] \n</code></pre> <p>Returns</p> <p>The binary representation of the mnemonic and seed.</p>"},{"location":"reference/compat/#method-toseed","title":"Method toSeed","text":"<p>Converts the mnemonic to a seed. The mnemonic must pass the validity check before conversion.</p> <pre><code>public toSeed(passphrase?: string): number[] \n</code></pre> <p>Returns</p> <p>The generated seed.</p> <p>Argument Details</p> <ul> <li>passphrase</li> <li>An optional passphrase for additional security.</li> </ul> <p>Throws</p> <p>If the mnemonic is invalid.</p>"},{"location":"reference/compat/#method-tostring_1","title":"Method toString","text":"<p>function toString() { [native code] }</p> <p>Converts the instance's mnemonic to a string representation.</p> <pre><code>public toString(): string \n</code></pre> <p>Returns</p> <p>The mnemonic phrase as a string.</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/compat/#functions","title":"Functions","text":""},{"location":"reference/compat/#function-fromutxo","title":"Function: fromUtxo","text":"<p>Example</p> <pre><code>const i = fromUtxo({\n  txid: '434555433eaca96dff6e71a4d02febd0dd3832e5ca4e5734623ca914522e17d5',\n  vout: 0,\n  script: '51',\n  satoshis: 1234\n}, new P2PKH().unlock(p))\n\ntx.addInput(i)\n</code></pre> <pre><code>export default function fromUtxo(utxo: jsonUtxo, unlockingScriptTemplate: {\n    sign: (tx: Transaction, inputIndex: number) =&gt; Promise&lt;UnlockingScript&gt;;\n    estimateLength: (tx: Transaction, inputIndex: number) =&gt; Promise&lt;number&gt;;\n}): TransactionInput \n</code></pre> <p>See also: Transaction, TransactionInput, UnlockingScript, sign</p> <p>Argument Details</p> <ul> <li>utxo</li> <li>: jsonUtxo</li> <li>unlockingScriptTemplate</li> <li>: { sign: (tx: Transaction, inputIndex: number) =&gt; Promise, estimateLength: (tx: Transaction, inputIndex: number) =&gt; Promise } <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/compat/#types","title":"Types","text":""},{"location":"reference/compat/#enums","title":"Enums","text":""},{"location":"reference/compat/#variables","title":"Variables","text":"magicHash sign verify wordList <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/compat/#variable-magichash","title":"Variable: magicHash","text":"<pre><code>magicHash = (messageBuf: number[]): number[] =&gt; {\n    const bw = new Writer();\n    bw.writeVarIntNum(prefix.length);\n    bw.write(toArray(prefix, \"utf8\"));\n    bw.writeVarIntNum(messageBuf.length);\n    bw.write(messageBuf);\n    const buf = bw.toArray();\n    const hashBuf = Hash.hash256(buf);\n    return hashBuf;\n}\n</code></pre> <p>See also: Writer, hash256, toArray</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/compat/#variable-sign","title":"Variable: sign","text":"<pre><code>sign = (message: number[], privateKey: PrivateKey, mode: \"raw\" | \"base64\" = \"base64\"): Signature | string =&gt; {\n    const hashBuf = magicHash(message);\n    const sig = ECDSA.sign(new BigNumber(hashBuf), privateKey, true);\n    if (mode === \"raw\") {\n        return sig;\n    }\n    const h = new BigNumber(hashBuf);\n    const r = sig.CalculateRecoveryFactor(privateKey.toPublicKey(), h);\n    return sig.toCompact(r, true, \"base64\") as string;\n}\n</code></pre> <p>See also: BigNumber, PrivateKey, Signature, magicHash</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/compat/#variable-verify","title":"Variable: verify","text":"<pre><code>verify = (message: number[], sig: Signature, pubKey: PublicKey): boolean =&gt; {\n    const hashBuf = magicHash(message);\n    return ECDSA.verify(new BigNumber(hashBuf), sig, pubKey);\n}\n</code></pre> <p>See also: BigNumber, PublicKey, Signature, magicHash</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/compat/#variable-wordlist","title":"Variable: wordList","text":"<pre><code>wordList = {\n    value: [\n        \"abandon\",\n        \"ability\",\n        \"able\",\n        \"about\",\n        \"above\",\n        \"absent\",\n        \"absorb\",\n        \"abstract\",\n        \"absurd\",\n        \"abuse\",\n        \"access\",\n        \"accident\",\n        \"account\",\n        \"accuse\",\n        \"achieve\",\n        \"acid\",\n        \"acoustic\",\n        \"acquire\",\n        \"across\",\n        \"act\",\n        \"action\",\n        \"actor\",\n        \"actress\",\n        \"actual\",\n        \"adapt\",\n        \"add\",\n        \"addict\",\n        \"address\",\n        \"adjust\",\n        \"admit\",\n        \"adult\",\n        \"advance\",\n        \"advice\",\n        \"aerobic\",\n        \"affair\",\n        \"afford\",\n        \"afraid\",\n        \"again\",\n        \"age\",\n        \"agent\",\n        \"agree\",\n        \"ahead\",\n        \"aim\",\n        \"air\",\n        \"airport\",\n        \"aisle\",\n        \"alarm\",\n        \"album\",\n        \"alcohol\",\n        \"alert\",\n        \"alien\",\n        \"all\",\n        \"alley\",\n        \"allow\",\n        \"almost\",\n        \"alone\",\n        \"alpha\",\n        \"already\",\n        \"also\",\n        \"alter\",\n        \"always\",\n        \"amateur\",\n        \"amazing\",\n        \"among\",\n        \"amount\",\n        \"amused\",\n        \"analyst\",\n        \"anchor\",\n        \"ancient\",\n        \"anger\",\n        \"angle\",\n        \"angry\",\n        \"animal\",\n        \"ankle\",\n        \"announce\",\n        \"annual\",\n        \"another\",\n        \"answer\",\n        \"antenna\",\n        \"antique\",\n        \"anxiety\",\n        \"any\",\n        \"apart\",\n        \"apology\",\n        \"appear\",\n        \"apple\",\n        \"approve\",\n        \"april\",\n        \"arch\",\n        \"arctic\",\n        \"area\",\n        \"arena\",\n        \"argue\",\n        \"arm\",\n        \"armed\",\n        \"armor\",\n        \"army\",\n        \"around\",\n        \"arrange\",\n        \"arrest\",\n        \"arrive\",\n        \"arrow\",\n        \"art\",\n        \"artefact\",\n        \"artist\",\n        \"artwork\",\n        \"ask\",\n        \"aspect\",\n        \"assault\",\n        \"asset\",\n        \"assist\",\n        \"assume\",\n        \"asthma\",\n        \"athlete\",\n        \"atom\",\n        \"attack\",\n        \"attend\",\n        \"attitude\",\n        \"attract\",\n        \"auction\",\n        \"audit\",\n        \"august\",\n        \"aunt\",\n        \"author\",\n        \"auto\",\n        \"autumn\",\n        \"average\",\n        \"avocado\",\n        \"avoid\",\n        \"awake\",\n        \"aware\",\n        \"away\",\n        \"awesome\",\n        \"awful\",\n        \"awkward\",\n        \"axis\",\n        \"baby\",\n        \"bachelor\",\n        \"bacon\",\n        \"badge\",\n        \"bag\",\n        \"balance\",\n        \"balcony\",\n        \"ball\",\n        \"bamboo\",\n        \"banana\",\n        \"banner\",\n        \"bar\",\n        \"barely\",\n        \"bargain\",\n        \"barrel\",\n        \"base\",\n        \"basic\",\n        \"basket\",\n        \"battle\",\n        \"beach\",\n        \"bean\",\n        \"beauty\",\n        \"because\",\n        \"become\",\n        \"beef\",\n        \"before\",\n        \"begin\",\n        \"behave\",\n        \"behind\",\n        \"believe\",\n        \"below\",\n        \"belt\",\n        \"bench\",\n        \"benefit\",\n        \"best\",\n        \"betray\",\n        \"better\",\n        \"between\",\n        \"beyond\",\n        \"bicycle\",\n        \"bid\",\n        \"bike\",\n        \"bind\",\n        \"biology\",\n        \"bird\",\n        \"birth\",\n        \"bitter\",\n        \"black\",\n        \"blade\",\n        \"blame\",\n        \"blanket\",\n        \"blast\",\n        \"bleak\",\n        \"bless\",\n        \"blind\",\n        \"blood\",\n        \"blossom\",\n        \"blouse\",\n        \"blue\",\n        \"blur\",\n        \"blush\",\n        \"board\",\n        \"boat\",\n        \"body\",\n        \"boil\",\n        \"bomb\",\n        \"bone\",\n        \"bonus\",\n        \"book\",\n        \"boost\",\n        \"border\",\n        \"boring\",\n        \"borrow\",\n        \"boss\",\n        \"bottom\",\n        \"bounce\",\n        \"box\",\n        \"boy\",\n        \"bracket\",\n        \"brain\",\n        \"brand\",\n        \"brass\",\n        \"brave\",\n        \"bread\",\n        \"breeze\",\n        \"brick\",\n        \"bridge\",\n        \"brief\",\n        \"bright\",\n        \"bring\",\n        \"brisk\",\n        \"broccoli\",\n        \"broken\",\n        \"bronze\",\n        \"broom\",\n        \"brother\",\n        \"brown\",\n        \"brush\",\n        \"bubble\",\n        \"buddy\",\n        \"budget\",\n        \"buffalo\",\n        \"build\",\n        \"bulb\",\n        \"bulk\",\n        \"bullet\",\n        \"bundle\",\n        \"bunker\",\n        \"burden\",\n        \"burger\",\n        \"burst\",\n        \"bus\",\n        \"business\",\n        \"busy\",\n        \"butter\",\n        \"buyer\",\n        \"buzz\",\n        \"cabbage\",\n        \"cabin\",\n        \"cable\",\n        \"cactus\",\n        \"cage\",\n        \"cake\",\n        \"call\",\n        \"calm\",\n        \"camera\",\n        \"camp\",\n        \"can\",\n        \"canal\",\n        \"cancel\",\n        \"candy\",\n        \"cannon\",\n        \"canoe\",\n        \"canvas\",\n        \"canyon\",\n        \"capable\",\n        \"capital\",\n        \"captain\",\n        \"car\",\n        \"carbon\",\n        \"card\",\n        \"cargo\",\n        \"carpet\",\n        \"carry\",\n        \"cart\",\n        \"case\",\n        \"cash\",\n        \"casino\",\n        \"castle\",\n        \"casual\",\n        \"cat\",\n        \"catalog\",\n        \"catch\",\n        \"category\",\n        \"cattle\",\n        \"caught\",\n        \"cause\",\n        \"caution\",\n        \"cave\",\n        \"ceiling\",\n        \"celery\",\n        \"cement\",\n        \"census\",\n        \"century\",\n        \"cereal\",\n        \"certain\",\n        \"chair\",\n        \"chalk\",\n        \"champion\",\n        \"change\",\n        \"chaos\",\n        \"chapter\",\n        \"charge\",\n        \"chase\",\n        \"chat\",\n        \"cheap\",\n        \"check\",\n        \"cheese\",\n        \"chef\",\n        \"cherry\",\n        \"chest\",\n        \"chicken\",\n        \"chief\",\n        \"child\",\n        \"chimney\",\n        \"choice\",\n        \"choose\",\n        \"chronic\",\n        \"chuckle\",\n        \"chunk\",\n        \"churn\",\n        \"cigar\",\n        \"cinnamon\",\n        \"circle\",\n        \"citizen\",\n        \"city\",\n        \"civil\",\n        \"claim\",\n        \"clap\",\n        \"clarify\",\n        \"claw\",\n        \"clay\",\n        \"clean\",\n        \"clerk\",\n        \"clever\",\n        \"click\",\n        \"client\",\n        \"cliff\",\n        \"climb\",\n        \"clinic\",\n        \"clip\",\n        \"clock\",\n        \"clog\",\n        \"close\",\n        \"cloth\",\n        \"cloud\",\n        \"clown\",\n        \"club\",\n        \"clump\",\n        \"cluster\",\n        \"clutch\",\n        \"coach\",\n        \"coast\",\n        \"coconut\",\n        \"code\",\n        \"coffee\",\n        \"coil\",\n        \"coin\",\n        \"collect\",\n        \"color\",\n        \"column\",\n        \"combine\",\n        \"come\",\n        \"comfort\",\n        \"comic\",\n        \"common\",\n        \"company\",\n        \"concert\",\n        \"conduct\",\n        \"confirm\",\n        \"congress\",\n        \"connect\",\n        \"consider\",\n        \"control\",\n        \"convince\",\n        \"cook\",\n        \"cool\",\n        \"copper\",\n        \"copy\",\n        \"coral\",\n        \"core\",\n        \"corn\",\n        \"correct\",\n        \"cost\",\n        \"cotton\",\n        \"couch\",\n        \"country\",\n        \"couple\",\n        \"course\",\n        \"cousin\",\n        \"cover\",\n        \"coyote\",\n        \"crack\",\n        \"cradle\",\n        \"craft\",\n        \"cram\",\n        \"crane\",\n        \"crash\",\n        \"crater\",\n        \"crawl\",\n        \"crazy\",\n        \"cream\",\n        \"credit\",\n        \"creek\",\n        \"crew\",\n        \"cricket\",\n        \"crime\",\n        \"crisp\",\n        \"critic\",\n        \"crop\",\n        \"cross\",\n        \"crouch\",\n        \"crowd\",\n        \"crucial\",\n        \"cruel\",\n        \"cruise\",\n        \"crumble\",\n        \"crunch\",\n        \"crush\",\n        \"cry\",\n        \"crystal\",\n        \"cube\",\n        \"culture\",\n        \"cup\",\n        \"cupboard\",\n        \"curious\",\n        \"current\",\n        \"curtain\",\n        \"curve\",\n        \"cushion\",\n        \"custom\",\n        \"cute\",\n        \"cycle\",\n        \"dad\",\n        \"damage\",\n        \"damp\",\n        \"dance\",\n        \"danger\",\n        \"daring\",\n        \"dash\",\n        \"daughter\",\n        \"dawn\",\n        \"day\",\n        \"deal\",\n        \"debate\",\n        \"debris\",\n        \"decade\",\n        \"december\",\n        \"decide\",\n        \"decline\",\n        \"decorate\",\n        \"decrease\",\n        \"deer\",\n        \"defense\",\n        \"define\",\n        \"defy\",\n        \"degree\",\n        \"delay\",\n        \"deliver\",\n        \"demand\",\n        \"demise\",\n        \"denial\",\n        \"dentist\",\n        \"deny\",\n        \"depart\",\n        \"depend\",\n        \"deposit\",\n        \"depth\",\n        \"deputy\",\n        \"derive\",\n        \"describe\",\n        \"desert\",\n        \"design\",\n        \"desk\",\n        \"despair\",\n        \"destroy\",\n        \"detail\",\n        \"detect\",\n        \"develop\",\n        \"device\",\n        \"devote\",\n        \"diagram\",\n        \"dial\",\n        \"diamond\",\n        \"diary\",\n        \"dice\",\n        \"diesel\",\n        \"diet\",\n        \"differ\",\n        \"digital\",\n        \"dignity\",\n        \"dilemma\",\n        \"dinner\",\n        \"dinosaur\",\n        \"direct\",\n        \"dirt\",\n        \"disagree\",\n        \"discover\",\n        \"disease\",\n        \"dish\",\n        \"dismiss\",\n        \"disorder\",\n        \"display\",\n        \"distance\",\n        \"divert\",\n        \"divide\",\n        \"divorce\",\n        \"dizzy\",\n        \"doctor\",\n        \"document\",\n        \"dog\",\n        \"doll\",\n        \"dolphin\",\n        \"domain\",\n        \"donate\",\n        \"donkey\",\n        \"donor\",\n        \"door\",\n        \"dose\",\n        \"double\",\n        \"dove\",\n        \"draft\",\n        \"dragon\",\n        \"drama\",\n        \"drastic\",\n        \"draw\",\n        \"dream\",\n        \"dress\",\n        \"drift\",\n        \"drill\",\n        \"drink\",\n        \"drip\",\n        \"drive\",\n        \"drop\",\n        \"drum\",\n        \"dry\",\n        \"duck\",\n        \"dumb\",\n        \"dune\",\n        \"during\",\n        \"dust\",\n        \"dutch\",\n        \"duty\",\n        \"dwarf\",\n        \"dynamic\",\n        \"eager\",\n        \"eagle\",\n        \"early\",\n        \"earn\",\n        \"earth\",\n        \"easily\",\n        \"east\",\n        \"easy\",\n        \"echo\",\n        \"ecology\",\n        \"economy\",\n        \"edge\",\n        \"edit\",\n        \"educate\",\n        \"effort\",\n        \"egg\",\n        \"eight\",\n        \"either\",\n        \"elbow\",\n        \"elder\",\n        \"electric\",\n        \"elegant\",\n        \"element\",\n        \"elephant\",\n        \"elevator\",\n        \"elite\",\n        \"else\",\n        \"embark\",\n        \"embody\",\n        \"embrace\",\n        \"emerge\",\n        \"emotion\",\n        \"employ\",\n        \"empower\",\n        \"empty\",\n        \"enable\",\n        \"enact\",\n        \"end\",\n        \"endless\",\n        \"endorse\",\n        \"enemy\",\n        \"energy\",\n        \"enforce\",\n        \"engage\",\n        \"engine\",\n        \"enhance\",\n        \"enjoy\",\n        \"enlist\",\n        \"enough\",\n        \"enrich\",\n        \"enroll\",\n        \"ensure\",\n        \"enter\",\n        \"entire\",\n        \"entry\",\n        \"envelope\",\n        \"episode\",\n        \"equal\",\n        \"equip\",\n        \"era\",\n        \"erase\",\n        \"erode\",\n        \"erosion\",\n        \"error\",\n        \"erupt\",\n        \"escape\",\n        \"essay\",\n        \"essence\",\n        \"estate\",\n        \"eternal\",\n        \"ethics\",\n        \"evidence\",\n        \"evil\",\n        \"evoke\",\n        \"evolve\",\n        \"exact\",\n        \"example\",\n        \"excess\",\n        \"exchange\",\n        \"excite\",\n        \"exclude\",\n        \"excuse\",\n        \"execute\",\n        \"exercise\",\n        \"exhaust\",\n        \"exhibit\",\n        \"exile\",\n        \"exist\",\n        \"exit\",\n        \"exotic\",\n        \"expand\",\n        \"expect\",\n        \"expire\",\n        \"explain\",\n        \"expose\",\n        \"express\",\n        \"extend\",\n        \"extra\",\n        \"eye\",\n        \"eyebrow\",\n        \"fabric\",\n        \"face\",\n        \"faculty\",\n        \"fade\",\n        \"faint\",\n        \"faith\",\n        \"fall\",\n        \"false\",\n        \"fame\",\n        \"family\",\n        \"famous\",\n        \"fan\",\n        \"fancy\",\n        \"fantasy\",\n        \"farm\",\n        \"fashion\",\n        \"fat\",\n        \"fatal\",\n        \"father\",\n        \"fatigue\",\n        \"fault\",\n        \"favorite\",\n        \"feature\",\n        \"february\",\n        \"federal\",\n        \"fee\",\n        \"feed\",\n        \"feel\",\n        \"female\",\n        \"fence\",\n        \"festival\",\n        \"fetch\",\n        \"fever\",\n        \"few\",\n        \"fiber\",\n        \"fiction\",\n        \"field\",\n        \"figure\",\n        \"file\",\n        \"film\",\n        \"filter\",\n        \"final\",\n        \"find\",\n        \"fine\",\n        \"finger\",\n        \"finish\",\n        \"fire\",\n        \"firm\",\n        \"first\",\n        \"fiscal\",\n        \"fish\",\n        \"fit\",\n        \"fitness\",\n        \"fix\",\n        \"flag\",\n        \"flame\",\n        \"flash\",\n        \"flat\",\n        \"flavor\",\n        \"flee\",\n        \"flight\",\n        \"flip\",\n        \"float\",\n        \"flock\",\n        \"floor\",\n        \"flower\",\n        \"fluid\",\n        \"flush\",\n        \"fly\",\n        \"foam\",\n        \"focus\",\n        \"fog\",\n        \"foil\",\n        \"fold\",\n        \"follow\",\n        \"food\",\n        \"foot\",\n        \"force\",\n        \"forest\",\n        \"forget\",\n        \"fork\",\n        \"fortune\",\n        \"forum\",\n        \"forward\",\n        \"fossil\",\n        \"foster\",\n        \"found\",\n        \"fox\",\n        \"fragile\",\n        \"frame\",\n        \"frequent\",\n        \"fresh\",\n        \"friend\",\n        \"fringe\",\n        \"frog\",\n        \"front\",\n        \"frost\",\n        \"frown\",\n        \"frozen\",\n        \"fruit\",\n        \"fuel\",\n        \"fun\",\n        \"funny\",\n        \"furnace\",\n        \"fury\",\n        \"future\",\n        \"gadget\",\n        \"gain\",\n        \"galaxy\",\n        \"gallery\",\n        \"game\",\n        \"gap\",\n        \"garage\",\n        \"garbage\",\n        \"garden\",\n        \"garlic\",\n        \"garment\",\n        \"gas\",\n        \"gasp\",\n        \"gate\",\n        \"gather\",\n        \"gauge\",\n        \"gaze\",\n        \"general\",\n        \"genius\",\n        \"genre\",\n        \"gentle\",\n        \"genuine\",\n        \"gesture\",\n        \"ghost\",\n        \"giant\",\n        \"gift\",\n        \"giggle\",\n        \"ginger\",\n        \"giraffe\",\n        \"girl\",\n        \"give\",\n        \"glad\",\n        \"glance\",\n        \"glare\",\n        \"glass\",\n        \"glide\",\n        \"glimpse\",\n        \"globe\",\n        \"gloom\",\n        \"glory\",\n        \"glove\",\n        \"glow\",\n        \"glue\",\n        \"goat\",\n        \"goddess\",\n        \"gold\",\n        \"good\",\n        \"goose\",\n        \"gorilla\",\n        \"gospel\",\n        \"gossip\",\n        \"govern\",\n        \"gown\",\n        \"grab\",\n        \"grace\",\n        \"grain\",\n        \"grant\",\n        \"grape\",\n        \"grass\",\n        \"gravity\",\n        \"great\",\n        \"green\",\n        \"grid\",\n        \"grief\",\n        \"grit\",\n        \"grocery\",\n        \"group\",\n        \"grow\",\n        \"grunt\",\n        \"guard\",\n        \"guess\",\n        \"guide\",\n        \"guilt\",\n        \"guitar\",\n        \"gun\",\n        \"gym\",\n        \"habit\",\n        \"hair\",\n        \"half\",\n        \"hammer\",\n        \"hamster\",\n        \"hand\",\n        \"happy\",\n        \"harbor\",\n        \"hard\",\n        \"harsh\",\n        \"harvest\",\n        \"hat\",\n        \"have\",\n        \"hawk\",\n        \"hazard\",\n        \"head\",\n        \"health\",\n        \"heart\",\n        \"heavy\",\n        \"hedgehog\",\n        \"height\",\n        \"hello\",\n        \"helmet\",\n        \"help\",\n        \"hen\",\n        \"hero\",\n        \"hidden\",\n        \"high\",\n        \"hill\",\n        \"hint\",\n        \"hip\",\n        \"hire\",\n        \"history\",\n        \"hobby\",\n        \"hockey\",\n        \"hold\",\n        \"hole\",\n        \"holiday\",\n        \"hollow\",\n        \"home\",\n        \"honey\",\n        \"hood\",\n        \"hope\",\n        \"horn\",\n        \"horror\",\n        \"horse\",\n        \"hospital\",\n        \"host\",\n        \"hotel\",\n        \"hour\",\n        \"hover\",\n        \"hub\",\n        \"huge\",\n        \"human\",\n        \"humble\",\n        \"humor\",\n        \"hundred\",\n        \"hungry\",\n        \"hunt\",\n        \"hurdle\",\n        \"hurry\",\n        \"hurt\",\n        \"husband\",\n        \"hybrid\",\n        \"ice\",\n        \"icon\",\n        \"idea\",\n        \"identify\",\n        \"idle\",\n        \"ignore\",\n        \"ill\",\n        \"illegal\",\n        \"illness\",\n        \"image\",\n        \"imitate\",\n        \"immense\",\n        \"immune\",\n        \"impact\",\n        \"impose\",\n        \"improve\",\n        \"impulse\",\n        \"inch\",\n        \"include\",\n        \"income\",\n        \"increase\",\n        \"index\",\n        \"indicate\",\n        \"indoor\",\n        \"industry\",\n        \"infant\",\n        \"inflict\",\n        \"inform\",\n        \"inhale\",\n        \"inherit\",\n        \"initial\",\n        \"inject\",\n        \"injury\",\n        \"inmate\",\n        \"inner\",\n        \"innocent\",\n        \"input\",\n        \"inquiry\",\n        \"insane\",\n        \"insect\",\n        \"inside\",\n        \"inspire\",\n        \"install\",\n        \"intact\",\n        \"interest\",\n        \"into\",\n        \"invest\",\n        \"invite\",\n        \"involve\",\n        \"iron\",\n        \"island\",\n        \"isolate\",\n        \"issue\",\n        \"item\",\n        \"ivory\",\n        \"jacket\",\n        \"jaguar\",\n        \"jar\",\n        \"jazz\",\n        \"jealous\",\n        \"jeans\",\n        \"jelly\",\n        \"jewel\",\n        \"job\",\n        \"join\",\n        \"joke\",\n        \"journey\",\n        \"joy\",\n        \"judge\",\n        \"juice\",\n        \"jump\",\n        \"jungle\",\n        \"junior\",\n        \"junk\",\n        \"just\",\n        \"kangaroo\",\n        \"keen\",\n        \"keep\",\n        \"ketchup\",\n        \"key\",\n        \"kick\",\n        \"kid\",\n        \"kidney\",\n        \"kind\",\n        \"kingdom\",\n        \"kiss\",\n        \"kit\",\n        \"kitchen\",\n        \"kite\",\n        \"kitten\",\n        \"kiwi\",\n        \"knee\",\n        \"knife\",\n        \"knock\",\n        \"know\",\n        \"lab\",\n        \"label\",\n        \"labor\",\n        \"ladder\",\n        \"lady\",\n        \"lake\",\n        \"lamp\",\n        \"language\",\n        \"laptop\",\n        \"large\",\n        \"later\",\n        \"latin\",\n        \"laugh\",\n        \"laundry\",\n        \"lava\",\n        \"law\",\n        \"lawn\",\n        \"lawsuit\",\n        \"layer\",\n        \"lazy\",\n        \"leader\",\n        \"leaf\",\n        \"learn\",\n        \"leave\",\n        \"lecture\",\n        \"left\",\n        \"leg\",\n        \"legal\",\n        \"legend\",\n        \"leisure\",\n        \"lemon\",\n        \"lend\",\n        \"length\",\n        \"lens\",\n        \"leopard\",\n        \"lesson\",\n        \"letter\",\n        \"level\",\n        \"liar\",\n        \"liberty\",\n        \"library\",\n        \"license\",\n        \"life\",\n        \"lift\",\n        \"light\",\n        \"like\",\n        \"limb\",\n        \"limit\",\n        \"link\",\n        \"lion\",\n        \"liquid\",\n        \"list\",\n        \"little\",\n        \"live\",\n        \"lizard\",\n        \"load\",\n        \"loan\",\n        \"lobster\",\n        \"local\",\n        \"lock\",\n        \"logic\",\n        \"lonely\",\n        \"long\",\n        \"loop\",\n        \"lottery\",\n        \"loud\",\n        \"lounge\",\n        \"love\",\n        \"loyal\",\n        \"lucky\",\n        \"luggage\",\n        \"lumber\",\n        \"lunar\",\n        \"lunch\",\n        \"luxury\",\n        \"lyrics\",\n        \"machine\",\n        \"mad\",\n        \"magic\",\n        \"magnet\",\n        \"maid\",\n        \"mail\",\n        \"main\",\n        \"major\",\n        \"make\",\n        \"mammal\",\n        \"man\",\n        \"manage\",\n        \"mandate\",\n        \"mango\",\n        \"mansion\",\n        \"manual\",\n        \"maple\",\n        \"marble\",\n        \"march\",\n        \"margin\",\n        \"marine\",\n        \"market\",\n        \"marriage\",\n        \"mask\",\n        \"mass\",\n        \"master\",\n        \"match\",\n        \"material\",\n        \"math\",\n        \"matrix\",\n        \"matter\",\n        \"maximum\",\n        \"maze\",\n        \"meadow\",\n        \"mean\",\n        \"measure\",\n        \"meat\",\n        \"mechanic\",\n        \"medal\",\n        \"media\",\n        \"melody\",\n        \"melt\",\n        \"member\",\n        \"memory\",\n        \"mention\",\n        \"menu\",\n        \"mercy\",\n        \"merge\",\n        \"merit\",\n        \"merry\",\n        \"mesh\",\n        \"message\",\n        \"metal\",\n        \"method\",\n        \"middle\",\n        \"midnight\",\n        \"milk\",\n        \"million\",\n        \"mimic\",\n        \"mind\",\n        \"minimum\",\n        \"minor\",\n        \"minute\",\n        \"miracle\",\n        \"mirror\",\n        \"misery\",\n        \"miss\",\n        \"mistake\",\n        \"mix\",\n        \"mixed\",\n        \"mixture\",\n        \"mobile\",\n        \"model\",\n        \"modify\",\n        \"mom\",\n        \"moment\",\n        \"monitor\",\n        \"monkey\",\n        \"monster\",\n        \"month\",\n        \"moon\",\n        \"moral\",\n        \"more\",\n        \"morning\",\n        \"mosquito\",\n        \"mother\",\n        \"motion\",\n        \"motor\",\n        \"mountain\",\n        \"mouse\",\n        \"move\",\n        \"movie\",\n        \"much\",\n        \"muffin\",\n        \"mule\",\n        \"multiply\",\n        \"muscle\",\n        \"museum\",\n        \"mushroom\",\n        \"music\",\n        \"must\",\n        \"mutual\",\n        \"myself\",\n        \"mystery\",\n        \"myth\",\n        \"naive\",\n        \"name\",\n        \"napkin\",\n        \"narrow\",\n        \"nasty\",\n        \"nation\",\n        \"nature\",\n        \"near\",\n        \"neck\",\n        \"need\",\n        \"negative\",\n        \"neglect\",\n        \"neither\",\n        \"nephew\",\n        \"nerve\",\n        \"nest\",\n        \"net\",\n        \"network\",\n        \"neutral\",\n        \"never\",\n        \"news\",\n        \"next\",\n        \"nice\",\n        \"night\",\n        \"noble\",\n        \"noise\",\n        \"nominee\",\n        \"noodle\",\n        \"normal\",\n        \"north\",\n        \"nose\",\n        \"notable\",\n        \"note\",\n        \"nothing\",\n        \"notice\",\n        \"novel\",\n        \"now\",\n        \"nuclear\",\n        \"number\",\n        \"nurse\",\n        \"nut\",\n        \"oak\",\n        \"obey\",\n        \"object\",\n        \"oblige\",\n        \"obscure\",\n        \"observe\",\n        \"obtain\",\n        \"obvious\",\n        \"occur\",\n        \"ocean\",\n        \"october\",\n        \"odor\",\n        \"off\",\n        \"offer\",\n        \"office\",\n        \"often\",\n        \"oil\",\n        \"okay\",\n        \"old\",\n        \"olive\",\n        \"olympic\",\n        \"omit\",\n        \"once\",\n        \"one\",\n        \"onion\",\n        \"online\",\n        \"only\",\n        \"open\",\n        \"opera\",\n        \"opinion\",\n        \"oppose\",\n        \"option\",\n        \"orange\",\n        \"orbit\",\n        \"orchard\",\n        \"order\",\n        \"ordinary\",\n        \"organ\",\n        \"orient\",\n        \"original\",\n        \"orphan\",\n        \"ostrich\",\n        \"other\",\n        \"outdoor\",\n        \"outer\",\n        \"output\",\n        \"outside\",\n        \"oval\",\n        \"oven\",\n        \"over\",\n        \"own\",\n        \"owner\",\n        \"oxygen\",\n        \"oyster\",\n        \"ozone\",\n        \"pact\",\n        \"paddle\",\n        \"page\",\n        \"pair\",\n        \"palace\",\n        \"palm\",\n        \"panda\",\n        \"panel\",\n        \"panic\",\n        \"panther\",\n        \"paper\",\n        \"parade\",\n        \"parent\",\n        \"park\",\n        \"parrot\",\n        \"party\",\n        \"pass\",\n        \"patch\",\n        \"path\",\n        \"patient\",\n        \"patrol\",\n        \"pattern\",\n        \"pause\",\n        \"pave\",\n        \"payment\",\n        \"peace\",\n        \"peanut\",\n        \"pear\",\n        \"peasant\",\n        \"pelican\",\n        \"pen\",\n        \"penalty\",\n        \"pencil\",\n        \"people\",\n        \"pepper\",\n        \"perfect\",\n        \"permit\",\n        \"person\",\n        \"pet\",\n        \"phone\",\n        \"photo\",\n        \"phrase\",\n        \"physical\",\n        \"piano\",\n        \"picnic\",\n        \"picture\",\n        \"piece\",\n        \"pig\",\n        \"pigeon\",\n        \"pill\",\n        \"pilot\",\n        \"pink\",\n        \"pioneer\",\n        \"pipe\",\n        \"pistol\",\n        \"pitch\",\n        \"pizza\",\n        \"place\",\n        \"planet\",\n        \"plastic\",\n        \"plate\",\n        \"play\",\n        \"please\",\n        \"pledge\",\n        \"pluck\",\n        \"plug\",\n        \"plunge\",\n        \"poem\",\n        \"poet\",\n        \"point\",\n        \"polar\",\n        \"pole\",\n        \"police\",\n        \"pond\",\n        \"pony\",\n        \"pool\",\n        \"popular\",\n        \"portion\",\n        \"position\",\n        \"possible\",\n        \"post\",\n        \"potato\",\n        \"pottery\",\n        \"poverty\",\n        \"powder\",\n        \"power\",\n        \"practice\",\n        \"praise\",\n        \"predict\",\n        \"prefer\",\n        \"prepare\",\n        \"present\",\n        \"pretty\",\n        \"prevent\",\n        \"price\",\n        \"pride\",\n        \"primary\",\n        \"print\",\n        \"priority\",\n        \"prison\",\n        \"private\",\n        \"prize\",\n        \"problem\",\n        \"process\",\n        \"produce\",\n        \"profit\",\n        \"program\",\n        \"project\",\n        \"promote\",\n        \"proof\",\n        \"property\",\n        \"prosper\",\n        \"protect\",\n        \"proud\",\n        \"provide\",\n        \"public\",\n        \"pudding\",\n        \"pull\",\n        \"pulp\",\n        \"pulse\",\n        \"pumpkin\",\n        \"punch\",\n        \"pupil\",\n        \"puppy\",\n        \"purchase\",\n        \"purity\",\n        \"purpose\",\n        \"purse\",\n        \"push\",\n        \"put\",\n        \"puzzle\",\n        \"pyramid\",\n        \"quality\",\n        \"quantum\",\n        \"quarter\",\n        \"question\",\n        \"quick\",\n        \"quit\",\n        \"quiz\",\n        \"quote\",\n        \"rabbit\",\n        \"raccoon\",\n        \"race\",\n        \"rack\",\n        \"radar\",\n        \"radio\",\n        \"rail\",\n        \"rain\",\n        \"raise\",\n        \"rally\",\n        \"ramp\",\n        \"ranch\",\n        \"random\",\n        \"range\",\n        \"rapid\",\n        \"rare\",\n        \"rate\",\n        \"rather\",\n        \"raven\",\n        \"raw\",\n        \"razor\",\n        \"ready\",\n        \"real\",\n        \"reason\",\n        \"rebel\",\n        \"rebuild\",\n        \"recall\",\n        \"receive\",\n        \"recipe\",\n        \"record\",\n        \"recycle\",\n        \"reduce\",\n        \"reflect\",\n        \"reform\",\n        \"refuse\",\n        \"region\",\n        \"regret\",\n        \"regular\",\n        \"reject\",\n        \"relax\",\n        \"release\",\n        \"relief\",\n        \"rely\",\n        \"remain\",\n        \"remember\",\n        \"remind\",\n        \"remove\",\n        \"render\",\n        \"renew\",\n        \"rent\",\n        \"reopen\",\n        \"repair\",\n        \"repeat\",\n        \"replace\",\n        \"report\",\n        \"require\",\n        \"rescue\",\n        \"resemble\",\n        \"resist\",\n        \"resource\",\n        \"response\",\n        \"result\",\n        \"retire\",\n        \"retreat\",\n        \"return\",\n        \"reunion\",\n        \"reveal\",\n        \"review\",\n        \"reward\",\n        \"rhythm\",\n        \"rib\",\n        \"ribbon\",\n        \"rice\",\n        \"rich\",\n        \"ride\",\n        \"ridge\",\n        \"rifle\",\n        \"right\",\n        \"rigid\",\n        \"ring\",\n        \"riot\",\n        \"ripple\",\n        \"risk\",\n        \"ritual\",\n        \"rival\",\n        \"river\",\n        \"road\",\n        \"roast\",\n        \"robot\",\n        \"robust\",\n        \"rocket\",\n        \"romance\",\n        \"roof\",\n        \"rookie\",\n        \"room\",\n        \"rose\",\n        \"rotate\",\n        \"rough\",\n        \"round\",\n        \"route\",\n        \"royal\",\n        \"rubber\",\n        \"rude\",\n        \"rug\",\n        \"rule\",\n        \"run\",\n        \"runway\",\n        \"rural\",\n        \"sad\",\n        \"saddle\",\n        \"sadness\",\n        \"safe\",\n        \"sail\",\n        \"salad\",\n        \"salmon\",\n        \"salon\",\n        \"salt\",\n        \"salute\",\n        \"same\",\n        \"sample\",\n        \"sand\",\n        \"satisfy\",\n        \"satoshi\",\n        \"sauce\",\n        \"sausage\",\n        \"save\",\n        \"say\",\n        \"scale\",\n        \"scan\",\n        \"scare\",\n        \"scatter\",\n        \"scene\",\n        \"scheme\",\n        \"school\",\n        \"science\",\n        \"scissors\",\n        \"scorpion\",\n        \"scout\",\n        \"scrap\",\n        \"screen\",\n        \"script\",\n        \"scrub\",\n        \"sea\",\n        \"search\",\n        \"season\",\n        \"seat\",\n        \"second\",\n        \"secret\",\n        \"section\",\n        \"security\",\n        \"seed\",\n        \"seek\",\n        \"segment\",\n        \"select\",\n        \"sell\",\n        \"seminar\",\n        \"senior\",\n        \"sense\",\n        \"sentence\",\n        \"series\",\n        \"service\",\n        \"session\",\n        \"settle\",\n        \"setup\",\n        \"seven\",\n        \"shadow\",\n        \"shaft\",\n        \"shallow\",\n        \"share\",\n        \"shed\",\n        \"shell\",\n        \"sheriff\",\n        \"shield\",\n        \"shift\",\n        \"shine\",\n        \"ship\",\n        \"shiver\",\n        \"shock\",\n        \"shoe\",\n        \"shoot\",\n        \"shop\",\n        \"short\",\n        \"shoulder\",\n        \"shove\",\n        \"shrimp\",\n        \"shrug\",\n        \"shuffle\",\n        \"shy\",\n        \"sibling\",\n        \"sick\",\n        \"side\",\n        \"siege\",\n        \"sight\",\n        \"sign\",\n        \"silent\",\n        \"silk\",\n        \"silly\",\n        \"silver\",\n        \"similar\",\n        \"simple\",\n        \"since\",\n        \"sing\",\n        \"siren\",\n        \"sister\",\n        \"situate\",\n        \"six\",\n        \"size\",\n        \"skate\",\n        \"sketch\",\n        \"ski\",\n        \"skill\",\n        \"skin\",\n        \"skirt\",\n        \"skull\",\n        \"slab\",\n        \"slam\",\n        \"sleep\",\n        \"slender\",\n        \"slice\",\n        \"slide\",\n        \"slight\",\n        \"slim\",\n        \"slogan\",\n        \"slot\",\n        \"slow\",\n        \"slush\",\n        \"small\",\n        \"smart\",\n        \"smile\",\n        \"smoke\",\n        \"smooth\",\n        \"snack\",\n        \"snake\",\n        \"snap\",\n        \"sniff\",\n        \"snow\",\n        \"soap\",\n        \"soccer\",\n        \"social\",\n        \"sock\",\n        \"soda\",\n        \"soft\",\n        \"solar\",\n        \"soldier\",\n        \"solid\",\n        \"solution\",\n        \"solve\",\n        \"someone\",\n        \"song\",\n        \"soon\",\n        \"sorry\",\n        \"sort\",\n        \"soul\",\n        \"sound\",\n        \"soup\",\n        \"source\",\n        \"south\",\n        \"space\",\n        \"spare\",\n        \"spatial\",\n        \"spawn\",\n        \"speak\",\n        \"special\",\n        \"speed\",\n        \"spell\",\n        \"spend\",\n        \"sphere\",\n        \"spice\",\n        \"spider\",\n        \"spike\",\n        \"spin\",\n        \"spirit\",\n        \"split\",\n        \"spoil\",\n        \"sponsor\",\n        \"spoon\",\n        \"sport\",\n        \"spot\",\n        \"spray\",\n        \"spread\",\n        \"spring\",\n        \"spy\",\n        \"square\",\n        \"squeeze\",\n        \"squirrel\",\n        \"stable\",\n        \"stadium\",\n        \"staff\",\n        \"stage\",\n        \"stairs\",\n        \"stamp\",\n        \"stand\",\n        \"start\",\n        \"state\",\n        \"stay\",\n        \"steak\",\n        \"steel\",\n        \"stem\",\n        \"step\",\n        \"stereo\",\n        \"stick\",\n        \"still\",\n        \"sting\",\n        \"stock\",\n        \"stomach\",\n        \"stone\",\n        \"stool\",\n        \"story\",\n        \"stove\",\n        \"strategy\",\n        \"street\",\n        \"strike\",\n        \"strong\",\n        \"struggle\",\n        \"student\",\n        \"stuff\",\n        \"stumble\",\n        \"style\",\n        \"subject\",\n        \"submit\",\n        \"subway\",\n        \"success\",\n        \"such\",\n        \"sudden\",\n        \"suffer\",\n        \"sugar\",\n        \"suggest\",\n        \"suit\",\n        \"summer\",\n        \"sun\",\n        \"sunny\",\n        \"sunset\",\n        \"super\",\n        \"supply\",\n        \"supreme\",\n        \"sure\",\n        \"surface\",\n        \"surge\",\n        \"surprise\",\n        \"surround\",\n        \"survey\",\n        \"suspect\",\n        \"sustain\",\n        \"swallow\",\n        \"swamp\",\n        \"swap\",\n        \"swarm\",\n        \"swear\",\n        \"sweet\",\n        \"swift\",\n        \"swim\",\n        \"swing\",\n        \"switch\",\n        \"sword\",\n        \"symbol\",\n        \"symptom\",\n        \"syrup\",\n        \"system\",\n        \"table\",\n        \"tackle\",\n        \"tag\",\n        \"tail\",\n        \"talent\",\n        \"talk\",\n        \"tank\",\n        \"tape\",\n        \"target\",\n        \"task\",\n        \"taste\",\n        \"tattoo\",\n        \"taxi\",\n        \"teach\",\n        \"team\",\n        \"tell\",\n        \"ten\",\n        \"tenant\",\n        \"tennis\",\n        \"tent\",\n        \"term\",\n        \"test\",\n        \"text\",\n        \"thank\",\n        \"that\",\n        \"theme\",\n        \"then\",\n        \"theory\",\n        \"there\",\n        \"they\",\n        \"thing\",\n        \"this\",\n        \"thought\",\n        \"three\",\n        \"thrive\",\n        \"throw\",\n        \"thumb\",\n        \"thunder\",\n        \"ticket\",\n        \"tide\",\n        \"tiger\",\n        \"tilt\",\n        \"timber\",\n        \"time\",\n        \"tiny\",\n        \"tip\",\n        \"tired\",\n        \"tissue\",\n        \"title\",\n        \"toast\",\n        \"tobacco\",\n        \"today\",\n        \"toddler\",\n        \"toe\",\n        \"together\",\n        \"toilet\",\n        \"token\",\n        \"tomato\",\n        \"tomorrow\",\n        \"tone\",\n        \"tongue\",\n        \"tonight\",\n        \"tool\",\n        \"tooth\",\n        \"top\",\n        \"topic\",\n        \"topple\",\n        \"torch\",\n        \"tornado\",\n        \"tortoise\",\n        \"toss\",\n        \"total\",\n        \"tourist\",\n        \"toward\",\n        \"tower\",\n        \"town\",\n        \"toy\",\n        \"track\",\n        \"trade\",\n        \"traffic\",\n        \"tragic\",\n        \"train\",\n        \"transfer\",\n        \"trap\",\n        \"trash\",\n        \"travel\",\n        \"tray\",\n        \"treat\",\n        \"tree\",\n        \"trend\",\n        \"trial\",\n        \"tribe\",\n        \"trick\",\n        \"trigger\",\n        \"trim\",\n        \"trip\",\n        \"trophy\",\n        \"trouble\",\n        \"truck\",\n        \"true\",\n        \"truly\",\n        \"trumpet\",\n        \"trust\",\n        \"truth\",\n        \"try\",\n        \"tube\",\n        \"tuition\",\n        \"tumble\",\n        \"tuna\",\n        \"tunnel\",\n        \"turkey\",\n        \"turn\",\n        \"turtle\",\n        \"twelve\",\n        \"twenty\",\n        \"twice\",\n        \"twin\",\n        \"twist\",\n        \"two\",\n        \"type\",\n        \"typical\",\n        \"ugly\",\n        \"umbrella\",\n        \"unable\",\n        \"unaware\",\n        \"uncle\",\n        \"uncover\",\n        \"under\",\n        \"undo\",\n        \"unfair\",\n        \"unfold\",\n        \"unhappy\",\n        \"uniform\",\n        \"unique\",\n        \"unit\",\n        \"universe\",\n        \"unknown\",\n        \"unlock\",\n        \"until\",\n        \"unusual\",\n        \"unveil\",\n        \"update\",\n        \"upgrade\",\n        \"uphold\",\n        \"upon\",\n        \"upper\",\n        \"upset\",\n        \"urban\",\n        \"urge\",\n        \"usage\",\n        \"use\",\n        \"used\",\n        \"useful\",\n        \"useless\",\n        \"usual\",\n        \"utility\",\n        \"vacant\",\n        \"vacuum\",\n        \"vague\",\n        \"valid\",\n        \"valley\",\n        \"valve\",\n        \"van\",\n        \"vanish\",\n        \"vapor\",\n        \"various\",\n        \"vast\",\n        \"vault\",\n        \"vehicle\",\n        \"velvet\",\n        \"vendor\",\n        \"venture\",\n        \"venue\",\n        \"verb\",\n        \"verify\",\n        \"version\",\n        \"very\",\n        \"vessel\",\n        \"veteran\",\n        \"viable\",\n        \"vibrant\",\n        \"vicious\",\n        \"victory\",\n        \"video\",\n        \"view\",\n        \"village\",\n        \"vintage\",\n        \"violin\",\n        \"virtual\",\n        \"virus\",\n        \"visa\",\n        \"visit\",\n        \"visual\",\n        \"vital\",\n        \"vivid\",\n        \"vocal\",\n        \"voice\",\n        \"void\",\n        \"volcano\",\n        \"volume\",\n        \"vote\",\n        \"voyage\",\n        \"wage\",\n        \"wagon\",\n        \"wait\",\n        \"walk\",\n        \"wall\",\n        \"walnut\",\n        \"want\",\n        \"warfare\",\n        \"warm\",\n        \"warrior\",\n        \"wash\",\n        \"wasp\",\n        \"waste\",\n        \"water\",\n        \"wave\",\n        \"way\",\n        \"wealth\",\n        \"weapon\",\n        \"wear\",\n        \"weasel\",\n        \"weather\",\n        \"web\",\n        \"wedding\",\n        \"weekend\",\n        \"weird\",\n        \"welcome\",\n        \"west\",\n        \"wet\",\n        \"whale\",\n        \"what\",\n        \"wheat\",\n        \"wheel\",\n        \"when\",\n        \"where\",\n        \"whip\",\n        \"whisper\",\n        \"wide\",\n        \"width\",\n        \"wife\",\n        \"wild\",\n        \"will\",\n        \"win\",\n        \"window\",\n        \"wine\",\n        \"wing\",\n        \"wink\",\n        \"winner\",\n        \"winter\",\n        \"wire\",\n        \"wisdom\",\n        \"wise\",\n        \"wish\",\n        \"witness\",\n        \"wolf\",\n        \"woman\",\n        \"wonder\",\n        \"wood\",\n        \"wool\",\n        \"word\",\n        \"work\",\n        \"world\",\n        \"worry\",\n        \"worth\",\n        \"wrap\",\n        \"wreck\",\n        \"wrestle\",\n        \"wrist\",\n        \"write\",\n        \"wrong\",\n        \"yard\",\n        \"year\",\n        \"yellow\",\n        \"you\",\n        \"young\",\n        \"youth\",\n        \"zebra\",\n        \"zero\",\n        \"zone\",\n        \"zoo\"\n    ],\n    space: \" \"\n}\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/identity/","title":"API","text":"<p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/identity/#interfaces","title":"Interfaces","text":"DisplayableIdentity IdentityClientOptions <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/identity/#interface-displayableidentity","title":"Interface: DisplayableIdentity","text":"<pre><code>export interface DisplayableIdentity {\n    name: string;\n    avatarURL: string;\n    abbreviatedKey: string;\n    identityKey: string;\n    badgeIconURL: string;\n    badgeLabel: string;\n    badgeClickURL: string;\n}\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/identity/#interface-identityclientoptions","title":"Interface: IdentityClientOptions","text":"<pre><code>export interface IdentityClientOptions {\n    protocolID: WalletProtocol;\n    keyID: string;\n    tokenAmount: number;\n    outputIndex: number;\n}\n</code></pre> <p>See also: WalletProtocol</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/identity/#classes","title":"Classes","text":"ContactsManager IdentityClient <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/identity/#class-contactsmanager","title":"Class: ContactsManager","text":"<pre><code>export class ContactsManager {\n    constructor(wallet?: WalletInterface, originator?: string) \n    async getContacts(identityKey?: PubKeyHex, forceRefresh = false, limit = 1000): Promise&lt;Contact[]&gt; \n    async saveContact(contact: DisplayableIdentity, metadata?: Record&lt;string, any&gt;): Promise&lt;void&gt; \n    async removeContact(identityKey: string): Promise&lt;void&gt; \n}\n</code></pre> <p>See also: Contact, DisplayableIdentity, PubKeyHex, WalletInterface</p>"},{"location":"reference/identity/#method-getcontacts","title":"Method getContacts","text":"<p>Load all records from the contacts basket</p> <p><pre><code>async getContacts(identityKey?: PubKeyHex, forceRefresh = false, limit = 1000): Promise&lt;Contact[]&gt; \n</code></pre> See also: Contact, PubKeyHex</p> <p>Returns</p> <p>A promise that resolves with an array of contacts</p> <p>Argument Details</p> <ul> <li>identityKey</li> <li>Optional specific identity key to fetch</li> <li>forceRefresh</li> <li>Whether to force a check for new contact data</li> <li>limit</li> <li>Maximum number of contacts to return</li> </ul>"},{"location":"reference/identity/#method-removecontact","title":"Method removeContact","text":"<p>Remove a contact from the contacts basket</p> <pre><code>async removeContact(identityKey: string): Promise&lt;void&gt; \n</code></pre> <p>Argument Details</p> <ul> <li>identityKey</li> <li>The identity key of the contact to remove</li> </ul>"},{"location":"reference/identity/#method-savecontact","title":"Method saveContact","text":"<p>Save or update a Metanet contact</p> <p><pre><code>async saveContact(contact: DisplayableIdentity, metadata?: Record&lt;string, any&gt;): Promise&lt;void&gt; \n</code></pre> See also: DisplayableIdentity</p> <p>Argument Details</p> <ul> <li>contact</li> <li>The displayable identity information for the contact</li> <li>metadata</li> <li>Optional metadata to store with the contact (ex. notes, aliases, etc)</li> </ul> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/identity/#class-identityclient","title":"Class: IdentityClient","text":"<p>IdentityClient lets you discover who others are, and let the world know who you are.</p> <pre><code>export class IdentityClient {\n    constructor(wallet?: WalletInterface, private readonly options = DEFAULT_IDENTITY_CLIENT_OPTIONS, private readonly originator?: OriginatorDomainNameStringUnder250Bytes) \n    async publiclyRevealAttributes(certificate: WalletCertificate, fieldsToReveal: CertificateFieldNameUnder50Bytes[]): Promise&lt;BroadcastResponse | BroadcastFailure&gt; \n    async resolveByIdentityKey(args: DiscoverByIdentityKeyArgs, overrideWithContacts = true): Promise&lt;DisplayableIdentity[]&gt; \n    async resolveByAttributes(args: DiscoverByAttributesArgs, overrideWithContacts = true): Promise&lt;DisplayableIdentity[]&gt; \n    async revokeCertificateRevelation(serialNumber: Base64String): Promise&lt;void&gt; \n    public async getContacts(identityKey?: PubKeyHex, forceRefresh = false, limit = 1000): Promise&lt;Contact[]&gt; \n    public async saveContact(contact: DisplayableIdentity, metadata?: Record&lt;string, any&gt;): Promise&lt;void&gt; \n    public async removeContact(identityKey: PubKeyHex): Promise&lt;void&gt; \n    static parseIdentity(identityToParse: IdentityCertificate): DisplayableIdentity \n}\n</code></pre> <p>See also: Base64String, BroadcastFailure, BroadcastResponse, CertificateFieldNameUnder50Bytes, Contact, DEFAULT_IDENTITY_CLIENT_OPTIONS, DiscoverByAttributesArgs, DiscoverByIdentityKeyArgs, DisplayableIdentity, IdentityCertificate, OriginatorDomainNameStringUnder250Bytes, PubKeyHex, WalletCertificate, WalletInterface</p>"},{"location":"reference/identity/#method-getcontacts_1","title":"Method getContacts","text":"<p>Load all records from the contacts basket</p> <p><pre><code>public async getContacts(identityKey?: PubKeyHex, forceRefresh = false, limit = 1000): Promise&lt;Contact[]&gt; \n</code></pre> See also: Contact, PubKeyHex</p> <p>Returns</p> <p>A promise that resolves with an array of contacts</p> <p>Argument Details</p> <ul> <li>identityKey</li> <li>Optional specific identity key to fetch</li> <li>forceRefresh</li> <li>Whether to force a check for new contact data</li> <li>limit</li> <li>Optional limit on number of contacts to fetch</li> </ul>"},{"location":"reference/identity/#method-parseidentity","title":"Method parseIdentity","text":"<p>Parse out identity and certifier attributes to display from an IdentityCertificate</p> <p><pre><code>static parseIdentity(identityToParse: IdentityCertificate): DisplayableIdentity \n</code></pre> See also: DisplayableIdentity, IdentityCertificate</p> <p>Returns</p> <ul> <li>IdentityToDisplay</li> </ul> <p>Argument Details</p> <ul> <li>identityToParse</li> <li>The Identity Certificate to parse</li> </ul>"},{"location":"reference/identity/#method-publiclyrevealattributes","title":"Method publiclyRevealAttributes","text":"<p>Publicly reveals selected fields from a given certificate by creating a publicly verifiable certificate. The publicly revealed certificate is included in a blockchain transaction and broadcast to a federated overlay node.</p> <p><pre><code>async publiclyRevealAttributes(certificate: WalletCertificate, fieldsToReveal: CertificateFieldNameUnder50Bytes[]): Promise&lt;BroadcastResponse | BroadcastFailure&gt; \n</code></pre> See also: BroadcastFailure, BroadcastResponse, CertificateFieldNameUnder50Bytes, WalletCertificate</p> <p>Returns</p> <p>A promise that resolves with the broadcast result from the overlay network.</p> <p>Argument Details</p> <ul> <li>certificate</li> <li>The master certificate to selectively reveal.</li> <li>fieldsToReveal</li> <li>An array of certificate field names to reveal. Only these fields will be included in the public certificate.</li> </ul> <p>Throws</p> <p>Throws an error if the certificate is invalid, the fields cannot be revealed, or if the broadcast fails.</p>"},{"location":"reference/identity/#method-removecontact_1","title":"Method removeContact","text":"<p>Remove a contact from the contacts basket</p> <p><pre><code>public async removeContact(identityKey: PubKeyHex): Promise&lt;void&gt; \n</code></pre> See also: PubKeyHex</p> <p>Argument Details</p> <ul> <li>identityKey</li> <li>The identity key of the contact to remove</li> </ul>"},{"location":"reference/identity/#method-resolvebyattributes","title":"Method resolveByAttributes","text":"<p>Resolves displayable identity certificates by specific identity attributes, issued by a trusted entity.</p> <p><pre><code>async resolveByAttributes(args: DiscoverByAttributesArgs, overrideWithContacts = true): Promise&lt;DisplayableIdentity[]&gt; \n</code></pre> See also: DiscoverByAttributesArgs, DisplayableIdentity</p> <p>Returns</p> <p>The promise resolves to displayable identities.</p> <p>Argument Details</p> <ul> <li>args</li> <li>Attributes and optional parameters used to discover certificates.</li> <li>overrideWithContacts</li> <li>Whether to override the results with personal contacts if available.</li> </ul>"},{"location":"reference/identity/#method-resolvebyidentitykey","title":"Method resolveByIdentityKey","text":"<p>Resolves displayable identity certificates, issued to a given identity key by a trusted certifier.</p> <p><pre><code>async resolveByIdentityKey(args: DiscoverByIdentityKeyArgs, overrideWithContacts = true): Promise&lt;DisplayableIdentity[]&gt; \n</code></pre> See also: DiscoverByIdentityKeyArgs, DisplayableIdentity</p> <p>Returns</p> <p>The promise resolves to displayable identities.</p> <p>Argument Details</p> <ul> <li>args</li> <li>Arguments for requesting the discovery based on the identity key.</li> <li>overrideWithContacts</li> <li>Whether to override the results with personal contacts if available.</li> </ul>"},{"location":"reference/identity/#method-revokecertificaterevelation","title":"Method revokeCertificateRevelation","text":"<p>Remove public certificate revelation from overlay services by spending the identity token</p> <p><pre><code>async revokeCertificateRevelation(serialNumber: Base64String): Promise&lt;void&gt; \n</code></pre> See also: Base64String</p> <p>Argument Details</p> <ul> <li>serialNumber</li> <li>Unique serial number of the certificate to revoke revelation</li> </ul>"},{"location":"reference/identity/#method-savecontact_1","title":"Method saveContact","text":"<p>Save or update a Metanet contact</p> <p><pre><code>public async saveContact(contact: DisplayableIdentity, metadata?: Record&lt;string, any&gt;): Promise&lt;void&gt; \n</code></pre> See also: DisplayableIdentity</p> <p>Argument Details</p> <ul> <li>contact</li> <li>The displayable identity information for the contact</li> <li>metadata</li> <li>Optional metadata to store with the contact (ex. notes, aliases, etc)</li> </ul> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/identity/#functions","title":"Functions","text":""},{"location":"reference/identity/#types","title":"Types","text":""},{"location":"reference/identity/#type-contact","title":"Type: Contact","text":"<pre><code>export type Contact = DisplayableIdentity &amp; {\n    metadata?: Record&lt;string, any&gt;;\n}\n</code></pre> <p>See also: DisplayableIdentity</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/identity/#enums","title":"Enums","text":""},{"location":"reference/identity/#variables","title":"Variables","text":"DEFAULT_IDENTITY_CLIENT_OPTIONS KNOWN_IDENTITY_TYPES defaultIdentity <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/identity/#variable-default_identity_client_options","title":"Variable: DEFAULT_IDENTITY_CLIENT_OPTIONS","text":"<pre><code>DEFAULT_IDENTITY_CLIENT_OPTIONS: IdentityClientOptions = {\n    protocolID: [1, \"identity\"],\n    keyID: \"1\",\n    tokenAmount: 1,\n    outputIndex: 0\n}\n</code></pre> <p>See also: IdentityClientOptions</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/identity/#variable-known_identity_types","title":"Variable: KNOWN_IDENTITY_TYPES","text":"<pre><code>KNOWN_IDENTITY_TYPES = {\n    identiCert: \"z40BOInXkI8m7f/wBrv4MJ09bZfzZbTj2fJqCtONqCY=\",\n    discordCert: \"2TgqRC35B1zehGmB21xveZNc7i5iqHc0uxMb+1NMPW4=\",\n    phoneCert: \"mffUklUzxbHr65xLohn0hRL0Tq2GjW1GYF/OPfzqJ6A=\",\n    xCert: \"vdDWvftf1H+5+ZprUw123kjHlywH+v20aPQTuXgMpNc=\",\n    registrant: \"YoPsbfR6YQczjzPdHCoGC7nJsOdPQR50+SYqcWpJ0y0=\",\n    emailCert: \"exOl3KM0dIJ04EW5pZgbZmPag6MdJXd3/a1enmUU/BA=\",\n    anyone: \"mfkOMfLDQmrr3SBxBQ5WeE+6Hy3VJRFq6w4A5Ljtlis=\",\n    self: \"Hkge6X5JRxt1cWXtHLCrSTg6dCVTxjQJJ48iOYd7n3g=\",\n    coolCert: \"AGfk/WrT1eBDXpz3mcw386Zww2HmqcIn3uY6x4Af1eo=\"\n}\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/identity/#variable-defaultidentity","title":"Variable: defaultIdentity","text":"<pre><code>defaultIdentity: DisplayableIdentity = {\n    name: \"Unknown Identity\",\n    avatarURL: \"XUUB8bbn9fEthk15Ge3zTQXypUShfC94vFjp65v7u5CQ8qkpxzst\",\n    identityKey: \"\",\n    abbreviatedKey: \"\",\n    badgeIconURL: \"XUUV39HVPkpmMzYNTx7rpKzJvXfeiVyQWg2vfSpjBAuhunTCA9uG\",\n    badgeLabel: \"Not verified by anyone you trust.\",\n    badgeClickURL: \"https://projectbabbage.com/docs/unknown-identity\"\n}\n</code></pre> <p>See also: DisplayableIdentity</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/kvstore/","title":"API","text":"<p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/kvstore/#interfaces","title":"Interfaces","text":"KVContext KVStoreConfig KVStoreEntry KVStoreGetOptions KVStoreLookupResult KVStoreQuery KVStoreRemoveOptions KVStoreSetOptions KVStoreToken <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/kvstore/#interface-kvcontext","title":"Interface: KVContext","text":"<pre><code>export interface KVContext {\n    key: string;\n    protocolID: WalletProtocol;\n}\n</code></pre> <p>See also: WalletProtocol</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/kvstore/#interface-kvstoreconfig","title":"Interface: KVStoreConfig","text":"<p>Configuration interface for GlobalKVStore operations. Defines all options for connecting to overlay services and managing KVStore behavior.</p> <pre><code>export interface KVStoreConfig {\n    overlayHost?: string;\n    protocolID?: WalletProtocol;\n    serviceName?: string;\n    tokenAmount?: number;\n    topics?: string[];\n    originator?: string;\n    wallet?: WalletInterface;\n    networkPreset?: \"mainnet\" | \"testnet\" | \"local\";\n    acceptDelayedBroadcast?: boolean;\n    overlayBroadcast?: boolean;\n    tokenSetDescription?: string;\n    tokenUpdateDescription?: string;\n    tokenRemovalDescription?: string;\n}\n</code></pre> <p>See also: WalletInterface, WalletProtocol</p>"},{"location":"reference/kvstore/#property-acceptdelayedbroadcast","title":"Property acceptDelayedBroadcast","text":"<p>Whether to accept delayed broadcast</p> <pre><code>acceptDelayedBroadcast?: boolean\n</code></pre>"},{"location":"reference/kvstore/#property-networkpreset","title":"Property networkPreset","text":"<p>Network preset for overlay services</p> <pre><code>networkPreset?: \"mainnet\" | \"testnet\" | \"local\"\n</code></pre>"},{"location":"reference/kvstore/#property-originator","title":"Property originator","text":"<p>Originator</p> <pre><code>originator?: string\n</code></pre>"},{"location":"reference/kvstore/#property-overlaybroadcast","title":"Property overlayBroadcast","text":"<p>Whether to let overlay handle broadcasting (prevents UTXO spending on rejection)</p> <pre><code>overlayBroadcast?: boolean\n</code></pre>"},{"location":"reference/kvstore/#property-overlayhost","title":"Property overlayHost","text":"<p>The overlay service host URL</p> <pre><code>overlayHost?: string\n</code></pre>"},{"location":"reference/kvstore/#property-protocolid","title":"Property protocolID","text":"<p>Protocol ID for the KVStore protocol</p> <p><pre><code>protocolID?: WalletProtocol\n</code></pre> See also: WalletProtocol</p>"},{"location":"reference/kvstore/#property-servicename","title":"Property serviceName","text":"<p>Service name for overlay submission</p> <pre><code>serviceName?: string\n</code></pre>"},{"location":"reference/kvstore/#property-tokenamount","title":"Property tokenAmount","text":"<p>Amount of satoshis for each token</p> <pre><code>tokenAmount?: number\n</code></pre>"},{"location":"reference/kvstore/#property-tokenremovaldescription","title":"Property tokenRemovalDescription","text":"<p>Description for token removal</p> <pre><code>tokenRemovalDescription?: string\n</code></pre>"},{"location":"reference/kvstore/#property-tokensetdescription","title":"Property tokenSetDescription","text":"<p>Description for token set</p> <pre><code>tokenSetDescription?: string\n</code></pre>"},{"location":"reference/kvstore/#property-tokenupdatedescription","title":"Property tokenUpdateDescription","text":"<p>Description for token update</p> <pre><code>tokenUpdateDescription?: string\n</code></pre>"},{"location":"reference/kvstore/#property-topics","title":"Property topics","text":"<p>Topics for overlay submission</p> <pre><code>topics?: string[]\n</code></pre>"},{"location":"reference/kvstore/#property-wallet","title":"Property wallet","text":"<p>Wallet interface for operations</p> <p><pre><code>wallet?: WalletInterface\n</code></pre> See also: WalletInterface</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/kvstore/#interface-kvstoreentry","title":"Interface: KVStoreEntry","text":"<p>KVStore entry returned from queries</p> <pre><code>export interface KVStoreEntry {\n    key: string;\n    value: string;\n    controller: PubKeyHex;\n    protocolID: WalletProtocol;\n    tags?: string[];\n    token?: KVStoreToken;\n    history?: string[];\n}\n</code></pre> <p>See also: KVStoreToken, PubKeyHex, WalletProtocol</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/kvstore/#interface-kvstoregetoptions","title":"Interface: KVStoreGetOptions","text":"<p>Options for configuring KVStore get operations (local processing)</p> <pre><code>export interface KVStoreGetOptions {\n    history?: boolean;\n    includeToken?: boolean;\n    serviceName?: string;\n}\n</code></pre>"},{"location":"reference/kvstore/#property-history","title":"Property history","text":"<p>Whether to build and include history for each entry</p> <pre><code>history?: boolean\n</code></pre>"},{"location":"reference/kvstore/#property-includetoken","title":"Property includeToken","text":"<p>Whether to include token transaction data in results</p> <pre><code>includeToken?: boolean\n</code></pre>"},{"location":"reference/kvstore/#property-servicename_1","title":"Property serviceName","text":"<p>Service name for overlay retrieval</p> <pre><code>serviceName?: string\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/kvstore/#interface-kvstorelookupresult","title":"Interface: KVStoreLookupResult","text":"<p>Result structure for KVStore lookups from overlay services. Contains the transaction output information for a found key-value pair.</p> <pre><code>export interface KVStoreLookupResult {\n    txid: string;\n    outputIndex: number;\n    outputScript: string;\n    satoshis: number;\n    history?: (output: any, currentDepth: number) =&gt; Promise&lt;boolean&gt;;\n}\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/kvstore/#interface-kvstorequery","title":"Interface: KVStoreQuery","text":"<p>Query parameters for KVStore lookups from overlay services. Used when searching for existing key-value pairs in the network.</p> <pre><code>export interface KVStoreQuery {\n    key?: string;\n    controller?: PubKeyHex;\n    protocolID?: WalletProtocol;\n    tags?: string[];\n    tagQueryMode?: \"all\" | \"any\";\n    limit?: number;\n    skip?: number;\n    sortOrder?: \"asc\" | \"desc\";\n}\n</code></pre> <p>See also: PubKeyHex, WalletProtocol</p>"},{"location":"reference/kvstore/#property-tagquerymode","title":"Property tagQueryMode","text":"<p>Controls tag matching behavior when tags are specified. - 'all': Requires all specified tags to be present (default) - 'any': Requires at least one of the specified tags to be present</p> <pre><code>tagQueryMode?: \"all\" | \"any\"\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/kvstore/#interface-kvstoreremoveoptions","title":"Interface: KVStoreRemoveOptions","text":"<pre><code>export interface KVStoreRemoveOptions {\n    protocolID?: WalletProtocol;\n    tokenRemovalDescription?: string;\n}\n</code></pre> <p>See also: WalletProtocol</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/kvstore/#interface-kvstoresetoptions","title":"Interface: KVStoreSetOptions","text":"<pre><code>export interface KVStoreSetOptions {\n    protocolID?: WalletProtocol;\n    tokenSetDescription?: string;\n    tokenUpdateDescription?: string;\n    tokenAmount?: number;\n    tags?: string[];\n}\n</code></pre> <p>See also: WalletProtocol</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/kvstore/#interface-kvstoretoken","title":"Interface: KVStoreToken","text":"<p>Token structure containing a KVStore token from overlay services. Wraps the transaction data and metadata for a key-value pair.</p> <pre><code>export interface KVStoreToken {\n    txid: string;\n    outputIndex: number;\n    satoshis: number;\n    beef: Beef;\n}\n</code></pre> <p>See also: Beef</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/kvstore/#classes","title":"Classes","text":"GlobalKVStore LocalKVStore <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/kvstore/#class-globalkvstore","title":"Class: GlobalKVStore","text":"<p>Implements a global key-value storage system which uses an overlay service to track key-value pairs. Each key-value pair is represented by a PushDrop token output. Allows getting, setting, and removing key-value pairs with optional fetching by protocolID and history tracking.</p> <pre><code>export class GlobalKVStore {\n    constructor(config: KVStoreConfig = {}) \n    async get(query: KVStoreQuery, options: KVStoreGetOptions = {}): Promise&lt;KVStoreEntry | KVStoreEntry[] | undefined&gt; \n    async set(key: string, value: string, options: KVStoreSetOptions = {}): Promise&lt;OutpointString&gt; \n    async remove(key: string, outputs?: CreateActionOutput[], options: KVStoreRemoveOptions = {}): Promise&lt;HexString&gt; \n}\n</code></pre> <p>See also: CreateActionOutput, HexString, KVStoreConfig, KVStoreEntry, KVStoreGetOptions, KVStoreQuery, KVStoreRemoveOptions, KVStoreSetOptions, OutpointString</p>"},{"location":"reference/kvstore/#constructor","title":"Constructor","text":"<p>Creates an instance of the GlobalKVStore.</p> <p><pre><code>constructor(config: KVStoreConfig = {}) \n</code></pre> See also: KVStoreConfig</p> <p>Argument Details</p> <ul> <li>config</li> <li>Configuration options for the KVStore. Defaults to empty object.</li> <li>config.wallet</li> <li>Wallet to use for operations. Defaults to WalletClient.</li> </ul> <p>Throws</p> <p>If the configuration contains invalid parameters.</p>"},{"location":"reference/kvstore/#method-get","title":"Method get","text":"<p>Retrieves data from the KVStore. Can query by key+controller (single result), protocolID, controller, or key (multiple results).</p> <p><pre><code>async get(query: KVStoreQuery, options: KVStoreGetOptions = {}): Promise&lt;KVStoreEntry | KVStoreEntry[] | undefined&gt; \n</code></pre> See also: KVStoreEntry, KVStoreGetOptions, KVStoreQuery</p> <p>Returns</p> <p>Single entry for key+controller queries, array for all other queries</p> <p>Argument Details</p> <ul> <li>query</li> <li>Query parameters sent to overlay</li> <li>options</li> <li>Configuration options for the get operation</li> </ul>"},{"location":"reference/kvstore/#method-remove","title":"Method remove","text":"<p>Removes the key-value pair associated with the given key from the overlay service.</p> <p><pre><code>async remove(key: string, outputs?: CreateActionOutput[], options: KVStoreRemoveOptions = {}): Promise&lt;HexString&gt; \n</code></pre> See also: CreateActionOutput, HexString, KVStoreRemoveOptions</p> <p>Returns</p> <p>A promise that resolves to the txid of the removal transaction if successful.</p> <p>Argument Details</p> <ul> <li>key</li> <li>The key to remove.</li> <li>outputs</li> <li>Additional outputs to include in the removal transaction.</li> <li>options</li> <li>Optional parameters for the removal operation.</li> </ul> <p>Throws</p> <p>If the key is invalid.</p> <p>If the key does not exist in the store.</p> <p>If the overlay service is unreachable or the transaction fails.</p> <p>If there are existing tokens that cannot be unlocked.</p>"},{"location":"reference/kvstore/#method-set","title":"Method set","text":"<p>Sets a key-value pair. The current user (wallet identity) becomes the controller.</p> <p><pre><code>async set(key: string, value: string, options: KVStoreSetOptions = {}): Promise&lt;OutpointString&gt; \n</code></pre> See also: KVStoreSetOptions, OutpointString</p> <p>Returns</p> <p>The outpoint of the created token</p> <p>Argument Details</p> <ul> <li>key</li> <li>The key to set (user computes this however they want)</li> <li>value</li> <li>The value to store</li> <li>options</li> <li>Configuration options for the set operation</li> </ul> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/kvstore/#class-localkvstore","title":"Class: LocalKVStore","text":"<p>Implements a key-value storage system backed by transaction outputs managed by a wallet. Each key-value pair is represented by a PushDrop token output in a specific context (basket). Allows setting, getting, and removing key-value pairs, with optional encryption.</p> <pre><code>export default class LocalKVStore {\n    acceptDelayedBroadcast: boolean = false;\n    constructor(wallet: WalletInterface = new WalletClient(), context = \"kvstore default\", encrypt = true, originator?: string, acceptDelayedBroadcast = false) \n    async get(key: string, defaultValue: string | undefined = undefined): Promise&lt;string | undefined&gt; \n    async set(key: string, value: string): Promise&lt;OutpointString&gt; \n    async remove(key: string): Promise&lt;string[]&gt; \n}\n</code></pre> <p>See also: OutpointString, WalletClient, WalletInterface, encrypt</p>"},{"location":"reference/kvstore/#constructor_1","title":"Constructor","text":"<p>Creates an instance of the localKVStore.</p> <p><pre><code>constructor(wallet: WalletInterface = new WalletClient(), context = \"kvstore default\", encrypt = true, originator?: string, acceptDelayedBroadcast = false) \n</code></pre> See also: WalletClient, WalletInterface, encrypt</p> <p>Argument Details</p> <ul> <li>wallet</li> <li>The wallet interface to use. Defaults to a new WalletClient instance.</li> <li>context</li> <li>The context (basket) for namespacing keys. Defaults to 'kvstore default'.</li> <li>encrypt</li> <li>Whether to encrypt values. Defaults to true.</li> <li>originator</li> <li>\u2014 An originator to use with PushDrop and the wallet, if provided.</li> </ul> <p>Throws</p> <p>If the context is missing or empty.</p>"},{"location":"reference/kvstore/#method-get_1","title":"Method get","text":"<p>Retrieves the value associated with a given key.</p> <pre><code>async get(key: string, defaultValue: string | undefined = undefined): Promise&lt;string | undefined&gt; \n</code></pre> <p>Returns</p> <p>A promise that resolves to the value as a string, the defaultValue if the key is not found, or undefined if no defaultValue is provided.</p> <p>Argument Details</p> <ul> <li>key</li> <li>The key to retrieve the value for.</li> <li>defaultValue</li> <li>The value to return if the key is not found.</li> </ul> <p>Throws</p> <p>If too many outputs are found for the key (ambiguous state).</p> <p>If the found output's locking script cannot be decoded or represents an invalid token format.</p>"},{"location":"reference/kvstore/#method-remove_1","title":"Method remove","text":"<p>Removes the key-value pair associated with the given key. It finds the existing output(s) for the key and spends them without creating a new output. If multiple outputs exist, they are all spent in the same transaction. If the key does not exist, it does nothing. If signing the removal transaction fails, it relinquishes the original outputs instead of spending.</p> <pre><code>async remove(key: string): Promise&lt;string[]&gt; \n</code></pre> <p>Returns</p> <p>A promise that resolves to the txids of the removal transactions if successful.</p> <p>Argument Details</p> <ul> <li>key</li> <li>The key to remove.</li> </ul>"},{"location":"reference/kvstore/#method-set_1","title":"Method set","text":"<p>Sets or updates the value associated with a given key atomically. If the key already exists (one or more outputs found), it spends the existing output(s) and creates a new one with the updated value. If multiple outputs exist for the key, they are collapsed into a single new output. If the key does not exist, it creates a new output. Handles encryption if enabled. If signing the update/collapse transaction fails, it relinquishes the original outputs and starts over with a new chain. Ensures atomicity by locking the key during the operation, preventing concurrent updates to the same key from missing earlier changes.</p> <p><pre><code>async set(key: string, value: string): Promise&lt;OutpointString&gt; \n</code></pre> See also: OutpointString</p> <p>Returns</p> <p>A promise that resolves to the outpoint string (txid.vout) of the new or updated token output.</p> <p>Argument Details</p> <ul> <li>key</li> <li>The key to set or update.</li> <li>value</li> <li>The value to associate with the key.</li> </ul> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/kvstore/#functions","title":"Functions","text":""},{"location":"reference/kvstore/#types","title":"Types","text":""},{"location":"reference/kvstore/#enums","title":"Enums","text":""},{"location":"reference/kvstore/#variables","title":"Variables","text":"kvProtocol kvStoreInterpreter <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/kvstore/#variable-kvprotocol","title":"Variable: kvProtocol","text":"<pre><code>kvProtocol = {\n    protocolID: 0,\n    key: 1,\n    value: 2,\n    controller: 3,\n    tags: 4,\n    signature: 5\n}\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/kvstore/#variable-kvstoreinterpreter","title":"Variable: kvStoreInterpreter","text":"<pre><code>kvStoreInterpreter: InterpreterFunction&lt;string, KVContext&gt; = async (transaction: Transaction, outputIndex: number, ctx?: KVContext): Promise&lt;string | undefined&gt; =&gt; {\n    try {\n        const output = transaction.outputs[outputIndex];\n        if (output == null || output.lockingScript == null)\n            return undefined;\n        if (ctx == null || ctx.key == null)\n            return undefined;\n        const decoded = PushDrop.decode(output.lockingScript);\n        const expectedFieldCount = Object.keys(kvProtocol).length;\n        const hasTagsField = decoded.fields.length === expectedFieldCount;\n        const isOldFormat = decoded.fields.length === expectedFieldCount - 1;\n        if (!isOldFormat &amp;&amp; !hasTagsField)\n            return undefined;\n        const key = Utils.toUTF8(decoded.fields[kvProtocol.key]);\n        const protocolID = Utils.toUTF8(decoded.fields[kvProtocol.protocolID]);\n        if (key !== ctx.key || protocolID !== JSON.stringify(ctx.protocolID))\n            return undefined;\n        try {\n            return Utils.toUTF8(decoded.fields[kvProtocol.value]);\n        }\n        catch {\n            return undefined;\n        }\n    }\n    catch {\n        return undefined;\n    }\n}\n</code></pre> <p>See also: KVContext, PushDrop, Transaction, kvProtocol, toUTF8</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/messages/","title":"API","text":"<p>Links: API, Interfaces, Classes, Functions, Variables</p>"},{"location":"reference/messages/#interfaces","title":"Interfaces","text":""},{"location":"reference/messages/#classes","title":"Classes","text":""},{"location":"reference/messages/#functions","title":"Functions","text":""},{"location":"reference/messages/#variables","title":"Variables","text":"decrypt encrypt sign verify <p>Links: API, Interfaces, Classes, Functions, Variables</p>"},{"location":"reference/messages/#variable-decrypt","title":"Variable: decrypt","text":"<pre><code>decrypt = (message: number[], recipient: PrivateKey): number[] =&gt; {\n    const reader = new Reader(message);\n    const messageVersion = toHex(reader.read(4));\n    if (messageVersion !== VERSION) {\n        throw new Error(`Message version mismatch: Expected ${VERSION}, received ${messageVersion}`);\n    }\n    const sender = PublicKey.fromString(toHex(reader.read(33)));\n    const expectedRecipientDER = toHex(reader.read(33));\n    const actualRecipientDER = recipient\n        .toPublicKey()\n        .encode(true, \"hex\") as string;\n    if (expectedRecipientDER !== actualRecipientDER) {\n        throw new Error(`The encrypted message expects a recipient public key of ${expectedRecipientDER}, but the provided key is ${actualRecipientDER}`);\n    }\n    const keyID = toBase64(reader.read(32));\n    const encrypted = reader.read(reader.bin.length - reader.pos);\n    const invoiceNumber = `2-message encryption-${keyID}`;\n    const signingPriv = sender.deriveChild(recipient, invoiceNumber);\n    const recipientPub = recipient.deriveChild(sender, invoiceNumber);\n    const sharedSecret = signingPriv.deriveSharedSecret(recipientPub);\n    const symmetricKey = new SymmetricKey(sharedSecret.encode(true).slice(1));\n    return symmetricKey.decrypt(encrypted) as number[];\n}\n</code></pre> <p>See also: PrivateKey, PublicKey, Reader, SymmetricKey, encode, toBase64, toHex</p> <p>Links: API, Interfaces, Classes, Functions, Variables</p>"},{"location":"reference/messages/#variable-encrypt","title":"Variable: encrypt","text":"<pre><code>encrypt = (message: number[], sender: PrivateKey, recipient: PublicKey): number[] =&gt; {\n    const keyID = Random(32);\n    const keyIDBase64 = toBase64(keyID);\n    const invoiceNumber = `2-message encryption-${keyIDBase64}`;\n    const signingPriv = sender.deriveChild(recipient, invoiceNumber);\n    const recipientPub = recipient.deriveChild(sender, invoiceNumber);\n    const sharedSecret = signingPriv.deriveSharedSecret(recipientPub);\n    const symmetricKey = new SymmetricKey(sharedSecret.encode(true).slice(1));\n    const encrypted = symmetricKey.encrypt(message) as number[];\n    const senderPublicKey = sender.toPublicKey().encode(true);\n    const version = toArray(VERSION, \"hex\");\n    return [\n        ...version,\n        ...senderPublicKey,\n        ...recipient.encode(true),\n        ...keyID,\n        ...encrypted\n    ];\n}\n</code></pre> <p>See also: PrivateKey, PublicKey, SymmetricKey, encode, toArray, toBase64</p> <p>Links: API, Interfaces, Classes, Functions, Variables</p>"},{"location":"reference/messages/#variable-sign","title":"Variable: sign","text":"<pre><code>sign = (message: number[], signer: PrivateKey, verifier?: PublicKey): number[] =&gt; {\n    const recipientAnyone = typeof verifier !== \"object\";\n    if (recipientAnyone) {\n        const curve = new Curve();\n        const anyone = new PrivateKey(1);\n        const anyonePoint = curve.g.mul(anyone);\n        verifier = new PublicKey(anyonePoint.x, anyonePoint.y);\n    }\n    const keyID = Random(32);\n    const keyIDBase64 = toBase64(keyID);\n    const invoiceNumber = `2-message signing-${keyIDBase64}`;\n    const signingKey = signer.deriveChild(verifier, invoiceNumber);\n    const signature = signingKey.sign(message).toDER();\n    const senderPublicKey = signer.toPublicKey().encode(true);\n    const version = toArray(VERSION, \"hex\");\n    return [\n        ...version,\n        ...senderPublicKey,\n        ...(recipientAnyone ? [0] : verifier.encode(true)),\n        ...keyID,\n        ...signature\n    ];\n}\n</code></pre> <p>See also: Curve, PrivateKey, PublicKey, encode, toArray, toBase64</p> <p>Links: API, Interfaces, Classes, Functions, Variables</p>"},{"location":"reference/messages/#variable-verify","title":"Variable: verify","text":"<pre><code>verify = (message: number[], sig: number[], recipient?: PrivateKey): boolean =&gt; {\n    const reader = new Reader(sig);\n    const messageVersion = toHex(reader.read(4));\n    if (messageVersion !== VERSION) {\n        throw new Error(`Message version mismatch: Expected ${VERSION}, received ${messageVersion}`);\n    }\n    const signer = PublicKey.fromString(toHex(reader.read(33)));\n    const [verifierFirst] = reader.read(1);\n    if (verifierFirst === 0) {\n        recipient = new PrivateKey(1);\n    }\n    else {\n        const verifierRest = reader.read(32);\n        const verifierDER = toHex([verifierFirst, ...verifierRest]);\n        if (typeof recipient !== \"object\") {\n            throw new Error(`This signature can only be verified with knowledge of a specific private key. The associated public key is: ${verifierDER}`);\n        }\n        const recipientDER = recipient.toPublicKey().encode(true, \"hex\") as string;\n        if (verifierDER !== recipientDER) {\n            throw new Error(`The recipient public key is ${recipientDER} but the signature requres the recipient to have public key ${verifierDER}`);\n        }\n    }\n    const keyID = toBase64(reader.read(32));\n    const signatureDER = toHex(reader.read(reader.bin.length - reader.pos));\n    const signature = Signature.fromDER(signatureDER, \"hex\");\n    const invoiceNumber = `2-message signing-${keyID}`;\n    const signingKey = signer.deriveChild(recipient, invoiceNumber);\n    const verified = signingKey.verify(message, signature);\n    return verified;\n}\n</code></pre> <p>See also: PrivateKey, PublicKey, Reader, Signature, encode, toBase64, toHex</p> <p>Links: API, Interfaces, Classes, Functions, Variables</p>"},{"location":"reference/overlay-tools/","title":"API","text":"<p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/overlay-tools/#interfaces","title":"Interfaces","text":"AdmittanceInstructions LookupQuestion LookupResolverConfig OverlayBroadcastFacilitator OverlayLookupFacilitator RankedHost SHIPBroadcasterConfig TaggedBEEF <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/overlay-tools/#interface-admittanceinstructions","title":"Interface: AdmittanceInstructions","text":"<p>Instructs the Overlay Services Engine about which outputs to admit and which previous outputs to retain. Returned by a Topic Manager.</p> <pre><code>export interface AdmittanceInstructions {\n    outputsToAdmit: number[];\n    coinsToRetain: number[];\n    coinsRemoved?: number[];\n}\n</code></pre>"},{"location":"reference/overlay-tools/#property-coinsremoved","title":"Property coinsRemoved","text":"<p>The indices of all inputs from the provided transaction which reference previously-admitted outputs, which are now considered spent and have been removed from the managed topic.</p> <pre><code>coinsRemoved?: number[]\n</code></pre>"},{"location":"reference/overlay-tools/#property-coinstoretain","title":"Property coinsToRetain","text":"<p>The indices of all inputs from the provided transaction which spend previously-admitted outputs that should be retained for historical record-keeping.</p> <pre><code>coinsToRetain: number[]\n</code></pre>"},{"location":"reference/overlay-tools/#property-outputstoadmit","title":"Property outputsToAdmit","text":"<p>The indices of all admissible outputs into the managed topic from the provided transaction.</p> <pre><code>outputsToAdmit: number[]\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/overlay-tools/#interface-lookupquestion","title":"Interface: LookupQuestion","text":"<p>The question asked to the Overlay Services Engine when a consumer of state wishes to look up information.</p> <pre><code>export interface LookupQuestion {\n    service: string;\n    query: unknown;\n}\n</code></pre>"},{"location":"reference/overlay-tools/#property-query","title":"Property query","text":"<p>The query which will be forwarded to the Lookup Service. Its type depends on that prescribed by the Lookup Service employed.</p> <pre><code>query: unknown\n</code></pre>"},{"location":"reference/overlay-tools/#property-service","title":"Property service","text":"<p>The identifier for a Lookup Service which the person asking the question wishes to use.</p> <pre><code>service: string\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/overlay-tools/#interface-lookupresolverconfig","title":"Interface: LookupResolverConfig","text":"<p>Configuration options for the Lookup resolver.</p> <pre><code>export interface LookupResolverConfig {\n    networkPreset?: \"mainnet\" | \"testnet\" | \"local\";\n    facilitator?: OverlayLookupFacilitator;\n    slapTrackers?: string[];\n    hostOverrides?: Record&lt;string, string[]&gt;;\n    additionalHosts?: Record&lt;string, string[]&gt;;\n    cache?: CacheOptions;\n    reputationStorage?: \"localStorage\" | {\n        get: (key: string) =&gt; string | null | undefined;\n        set: (key: string, value: string) =&gt; void;\n    };\n}\n</code></pre> <p>See also: OverlayLookupFacilitator</p>"},{"location":"reference/overlay-tools/#property-additionalhosts","title":"Property additionalHosts","text":"<p>Map of lookup service names to arrays of hosts to use in addition to resolving via SLAP.</p> <pre><code>additionalHosts?: Record&lt;string, string[]&gt;\n</code></pre>"},{"location":"reference/overlay-tools/#property-cache","title":"Property cache","text":"<p>Optional cache tuning.</p> <pre><code>cache?: CacheOptions\n</code></pre>"},{"location":"reference/overlay-tools/#property-facilitator","title":"Property facilitator","text":"<p>The facilitator used to make requests to Overlay Services hosts.</p> <p><pre><code>facilitator?: OverlayLookupFacilitator\n</code></pre> See also: OverlayLookupFacilitator</p>"},{"location":"reference/overlay-tools/#property-hostoverrides","title":"Property hostOverrides","text":"<p>Map of lookup service names to arrays of hosts to use in place of resolving via SLAP.</p> <pre><code>hostOverrides?: Record&lt;string, string[]&gt;\n</code></pre>"},{"location":"reference/overlay-tools/#property-networkpreset","title":"Property networkPreset","text":"<p>The network preset to use, unless other options override it. - mainnet: use mainnet SLAP trackers and HTTPS facilitator - testnet: use testnet SLAP trackers and HTTPS facilitator - local: directly query from localhost:8080 and a facilitator that permits plain HTTP</p> <pre><code>networkPreset?: \"mainnet\" | \"testnet\" | \"local\"\n</code></pre>"},{"location":"reference/overlay-tools/#property-reputationstorage","title":"Property reputationStorage","text":"<p>Optional storage for host reputation data.</p> <pre><code>reputationStorage?: \"localStorage\" | {\n    get: (key: string) =&gt; string | null | undefined;\n    set: (key: string, value: string) =&gt; void;\n}\n</code></pre>"},{"location":"reference/overlay-tools/#property-slaptrackers","title":"Property slapTrackers","text":"<p>The list of SLAP trackers queried to resolve Overlay Services hosts for a given lookup service.</p> <pre><code>slapTrackers?: string[]\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/overlay-tools/#interface-overlaybroadcastfacilitator","title":"Interface: OverlayBroadcastFacilitator","text":"<p>Facilitates transaction broadcasts that return STEAK.</p> <pre><code>export interface OverlayBroadcastFacilitator {\n    send: (url: string, taggedBEEF: TaggedBEEF) =&gt; Promise&lt;STEAK&gt;;\n}\n</code></pre> <p>See also: STEAK, TaggedBEEF</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/overlay-tools/#interface-overlaylookupfacilitator","title":"Interface: OverlayLookupFacilitator","text":"<p>Facilitates lookups to URLs that return answers.</p> <pre><code>export interface OverlayLookupFacilitator {\n    lookup: (url: string, question: LookupQuestion, timeout?: number) =&gt; Promise&lt;LookupAnswer&gt;;\n}\n</code></pre> <p>See also: LookupAnswer, LookupQuestion</p>"},{"location":"reference/overlay-tools/#property-lookup","title":"Property lookup","text":"<p>Returns a lookup answer for a lookup question</p> <p><pre><code>lookup: (url: string, question: LookupQuestion, timeout?: number) =&gt; Promise&lt;LookupAnswer&gt;\n</code></pre> See also: LookupAnswer, LookupQuestion</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/overlay-tools/#interface-rankedhost","title":"Interface: RankedHost","text":"<pre><code>export interface RankedHost extends HostReputationEntry {\n    score: number;\n}\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/overlay-tools/#interface-shipbroadcasterconfig","title":"Interface: SHIPBroadcasterConfig","text":"<p>Configuration options for the SHIP broadcaster.</p> <pre><code>export interface SHIPBroadcasterConfig {\n    networkPreset?: \"mainnet\" | \"testnet\" | \"local\";\n    facilitator?: OverlayBroadcastFacilitator;\n    resolver?: LookupResolver;\n    requireAcknowledgmentFromAllHostsForTopics?: \"all\" | \"any\" | string[];\n    requireAcknowledgmentFromAnyHostForTopics?: \"all\" | \"any\" | string[];\n    requireAcknowledgmentFromSpecificHostsForTopics?: Record&lt;string, \"all\" | \"any\" | string[]&gt;;\n}\n</code></pre> <p>See also: LookupResolver, OverlayBroadcastFacilitator</p>"},{"location":"reference/overlay-tools/#property-facilitator_1","title":"Property facilitator","text":"<p>The facilitator used to make requests to Overlay Services hosts.</p> <p><pre><code>facilitator?: OverlayBroadcastFacilitator\n</code></pre> See also: OverlayBroadcastFacilitator</p>"},{"location":"reference/overlay-tools/#property-networkpreset_1","title":"Property networkPreset","text":"<p>The network preset to use, unless other options override it. - mainnet: use mainnet resolver and HTTPS facilitator - testnet: use testnet resolver and HTTPS facilitator - local: directly send to localhost:8080 and a facilitator that permits plain HTTP</p> <pre><code>networkPreset?: \"mainnet\" | \"testnet\" | \"local\"\n</code></pre>"},{"location":"reference/overlay-tools/#property-requireacknowledgmentfromallhostsfortopics","title":"Property requireAcknowledgmentFromAllHostsForTopics","text":"<p>Determines which topics (all, any, or a specific list) must be present within all STEAKs received from every host for the broadcast to be considered a success. By default, all hosts must acknowledge all topics.</p> <pre><code>requireAcknowledgmentFromAllHostsForTopics?: \"all\" | \"any\" | string[]\n</code></pre>"},{"location":"reference/overlay-tools/#property-requireacknowledgmentfromanyhostfortopics","title":"Property requireAcknowledgmentFromAnyHostForTopics","text":"<p>Determines which topics (all, any, or a specific list) must be present within STEAK received from at least one host for the broadcast to be considered a success.</p> <pre><code>requireAcknowledgmentFromAnyHostForTopics?: \"all\" | \"any\" | string[]\n</code></pre>"},{"location":"reference/overlay-tools/#property-requireacknowledgmentfromspecifichostsfortopics","title":"Property requireAcknowledgmentFromSpecificHostsForTopics","text":"<p>Determines a mapping whose keys are specific hosts and whose values are the topics (all, any, or a specific list) that must be present within the STEAK received by the given hosts, in order for the broadcast to be considered a success.</p> <pre><code>requireAcknowledgmentFromSpecificHostsForTopics?: Record&lt;string, \"all\" | \"any\" | string[]&gt;\n</code></pre>"},{"location":"reference/overlay-tools/#property-resolver","title":"Property resolver","text":"<p>The resolver used to locate suitable hosts with SHIP</p> <p><pre><code>resolver?: LookupResolver\n</code></pre> See also: LookupResolver</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/overlay-tools/#interface-taggedbeef","title":"Interface: TaggedBEEF","text":"<p>Tagged BEEF</p> <pre><code>export interface TaggedBEEF {\n    beef: number[];\n    topics: string[];\n    offChainValues?: number[];\n}\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/overlay-tools/#classes","title":"Classes","text":"HTTPSOverlayBroadcastFacilitator HTTPSOverlayLookupFacilitator HostReputationTracker LookupResolver OverlayAdminTokenTemplate TopicBroadcaster <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/overlay-tools/#class-httpsoverlaybroadcastfacilitator","title":"Class: HTTPSOverlayBroadcastFacilitator","text":"<pre><code>export class HTTPSOverlayBroadcastFacilitator implements OverlayBroadcastFacilitator {\n    httpClient: typeof fetch;\n    allowHTTP: boolean;\n    constructor(httpClient = fetch, allowHTTP: boolean = false) \n    async send(url: string, taggedBEEF: TaggedBEEF): Promise&lt;STEAK&gt; \n}\n</code></pre> <p>See also: OverlayBroadcastFacilitator, STEAK, TaggedBEEF</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/overlay-tools/#class-httpsoverlaylookupfacilitator","title":"Class: HTTPSOverlayLookupFacilitator","text":"<pre><code>export class HTTPSOverlayLookupFacilitator implements OverlayLookupFacilitator {\n    fetchClient: typeof fetch;\n    allowHTTP: boolean;\n    constructor(httpClient = defaultFetch, allowHTTP: boolean = false) \n    async lookup(url: string, question: LookupQuestion, timeout: number = 5000): Promise&lt;LookupAnswer&gt; \n}\n</code></pre> <p>See also: LookupAnswer, LookupQuestion, OverlayLookupFacilitator</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/overlay-tools/#class-hostreputationtracker","title":"Class: HostReputationTracker","text":"<pre><code>export class HostReputationTracker {\n    constructor(store?: KeyValueStore) \n    reset(): void \n    recordSuccess(host: string, latencyMs: number): void \n    recordFailure(host: string, reason?: unknown): void \n    rankHosts(hosts: string[], now: number = Date.now()): RankedHost[] \n    snapshot(host: string): HostReputationEntry | undefined \n}\n</code></pre> <p>See also: RankedHost</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/overlay-tools/#class-lookupresolver","title":"Class: LookupResolver","text":"<p>Represents a Lookup Resolver.</p> <pre><code>export default class LookupResolver {\n    constructor(config: LookupResolverConfig = {}) \n    async query(question: LookupQuestion, timeout?: number): Promise&lt;LookupAnswer&gt; \n}\n</code></pre> <p>See also: LookupAnswer, LookupQuestion, LookupResolverConfig</p>"},{"location":"reference/overlay-tools/#method-query","title":"Method query","text":"<p>Given a LookupQuestion, returns a LookupAnswer. Aggregates across multiple services and supports resiliency.</p> <p><pre><code>async query(question: LookupQuestion, timeout?: number): Promise&lt;LookupAnswer&gt; \n</code></pre> See also: LookupAnswer, LookupQuestion</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/overlay-tools/#class-overlayadmintokentemplate","title":"Class: OverlayAdminTokenTemplate","text":"<p>Script template enabling the creation, unlocking, and decoding of SHIP and SLAP advertisements.</p> <pre><code>export default class OverlayAdminTokenTemplate implements ScriptTemplate {\n    pushDrop: PushDrop;\n    static decode(script: LockingScript): {\n        protocol: \"SHIP\" | \"SLAP\";\n        identityKey: string;\n        domain: string;\n        topicOrService: string;\n    } \n    constructor(wallet: WalletInterface, originator?: OriginatorDomainNameStringUnder250Bytes) \n    async lock(protocol: \"SHIP\" | \"SLAP\", domain: string, topicOrService: string): Promise&lt;LockingScript&gt; \n    unlock(protocol: \"SHIP\" | \"SLAP\"): {\n        sign: (tx: Transaction, inputIndex: number) =&gt; Promise&lt;UnlockingScript&gt;;\n        estimateLength: (tx: Transaction, inputIndex: number) =&gt; Promise&lt;number&gt;;\n    } \n}\n</code></pre> <p>See also: LockingScript, OriginatorDomainNameStringUnder250Bytes, PushDrop, ScriptTemplate, Transaction, UnlockingScript, WalletInterface, sign</p>"},{"location":"reference/overlay-tools/#constructor","title":"Constructor","text":"<p>Constructs a new Overlay Admin template instance</p> <p><pre><code>constructor(wallet: WalletInterface, originator?: OriginatorDomainNameStringUnder250Bytes) \n</code></pre> See also: OriginatorDomainNameStringUnder250Bytes, WalletInterface</p> <p>Argument Details</p> <ul> <li>wallet</li> <li>Wallet to use for locking and unlocking</li> </ul>"},{"location":"reference/overlay-tools/#method-decode","title":"Method decode","text":"<p>Decodes a SHIP or SLAP advertisement from a given locking script.</p> <p><pre><code>static decode(script: LockingScript): {\n    protocol: \"SHIP\" | \"SLAP\";\n    identityKey: string;\n    domain: string;\n    topicOrService: string;\n} \n</code></pre> See also: LockingScript</p> <p>Returns</p> <p>Decoded SHIP or SLAP advertisement</p> <p>Argument Details</p> <ul> <li>script</li> <li>Locking script comprising a SHIP or SLAP token to decode</li> </ul>"},{"location":"reference/overlay-tools/#method-lock","title":"Method lock","text":"<p>Creates a new advertisement locking script</p> <p><pre><code>async lock(protocol: \"SHIP\" | \"SLAP\", domain: string, topicOrService: string): Promise&lt;LockingScript&gt; \n</code></pre> See also: LockingScript</p> <p>Returns</p> <p>Locking script comprising the advertisement token</p> <p>Argument Details</p> <ul> <li>protocol</li> <li>SHIP or SLAP</li> <li>domain</li> <li>Domain where the topic or service is available</li> <li>topicOrService</li> <li>Topic or service to advertise</li> </ul>"},{"location":"reference/overlay-tools/#method-unlock","title":"Method unlock","text":"<p>Unlocks an advertisement token as part of a transaction.</p> <p><pre><code>unlock(protocol: \"SHIP\" | \"SLAP\"): {\n    sign: (tx: Transaction, inputIndex: number) =&gt; Promise&lt;UnlockingScript&gt;;\n    estimateLength: (tx: Transaction, inputIndex: number) =&gt; Promise&lt;number&gt;;\n} \n</code></pre> See also: Transaction, UnlockingScript, sign</p> <p>Returns</p> <p>Script unlocker capable of unlocking the advertisement token</p> <p>Argument Details</p> <ul> <li>protocol</li> <li>SHIP or SLAP, depending on the token to unlock</li> </ul> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/overlay-tools/#class-topicbroadcaster","title":"Class: TopicBroadcaster","text":"<p>Broadcasts transactions to one or more overlay topics.</p> <pre><code>export default class TopicBroadcaster implements Broadcaster {\n    constructor(topics: string[], config: SHIPBroadcasterConfig = {}) \n    async broadcast(tx: Transaction): Promise&lt;BroadcastResponse | BroadcastFailure&gt; \n}\n</code></pre> <p>See also: BroadcastFailure, BroadcastResponse, Broadcaster, SHIPBroadcasterConfig, Transaction</p>"},{"location":"reference/overlay-tools/#constructor_1","title":"Constructor","text":"<p>Constructs an instance of the SHIP broadcaster.</p> <p><pre><code>constructor(topics: string[], config: SHIPBroadcasterConfig = {}) \n</code></pre> See also: SHIPBroadcasterConfig</p> <p>Argument Details</p> <ul> <li>topics</li> <li>The list of SHIP topic names where transactions are to be sent.</li> <li>config</li> <li>Configuration options for the SHIP broadcaster.</li> </ul>"},{"location":"reference/overlay-tools/#method-broadcast","title":"Method broadcast","text":"<p>Broadcasts a transaction to Overlay Services via SHIP.</p> <p><pre><code>async broadcast(tx: Transaction): Promise&lt;BroadcastResponse | BroadcastFailure&gt; \n</code></pre> See also: BroadcastFailure, BroadcastResponse, Transaction</p> <p>Returns</p> <p>A promise that resolves to either a success or failure response.</p> <p>Argument Details</p> <ul> <li>tx</li> <li>The transaction to be sent.</li> </ul> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/overlay-tools/#functions","title":"Functions","text":""},{"location":"reference/overlay-tools/#function-withdoublespendretry","title":"Function: withDoubleSpendRetry","text":"<p>Executes an operation with automatic retry logic for double-spend errors. When a double-spend is detected, broadcasts the competing transaction to update the overlay with missing state, then retries the operation.</p> <pre><code>export async function withDoubleSpendRetry&lt;T&gt;(operation: () =&gt; Promise&lt;T&gt;, broadcaster: TopicBroadcaster, maxRetries: number = MAX_DOUBLE_SPEND_RETRIES): Promise&lt;T&gt; \n</code></pre> <p>See also: TopicBroadcaster</p> <p>Returns</p> <p>The result of the successful operation</p> <p>Argument Details</p> <ul> <li>operation</li> <li>The async operation to execute (e.g., createAction + signAction)</li> <li>broadcaster</li> <li>The TopicBroadcaster to use for syncing missing state</li> <li>maxRetries</li> <li>Maximum number of retry attempts (default: MAX_DOUBLE_SPEND_RETRIES)</li> </ul> <p>Throws</p> <p>If max retries exceeded or non-double-spend error occurs</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/overlay-tools/#types","title":"Types","text":"LookupAnswer STEAK <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/overlay-tools/#type-lookupanswer","title":"Type: LookupAnswer","text":"<p>How the Overlay Services Engine responds to a Lookup Question. It may comprise either an output list or a freeform response from the Lookup Service.</p> <pre><code>export type LookupAnswer = {\n    type: \"output-list\";\n    outputs: Array&lt;{\n        beef: number[];\n        outputIndex: number;\n        context?: number[];\n    }&gt;;\n}\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/overlay-tools/#type-steak","title":"Type: STEAK","text":"<p>Submitted Transaction Execution AcKnowledgment</p> <pre><code>export type STEAK = Record&lt;string, AdmittanceInstructions&gt;\n</code></pre> <p>See also: AdmittanceInstructions</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/overlay-tools/#enums","title":"Enums","text":""},{"location":"reference/overlay-tools/#variables","title":"Variables","text":"DEFAULT_SLAP_TRACKERS DEFAULT_TESTNET_SLAP_TRACKERS getOverlayHostReputationTracker <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/overlay-tools/#variable-default_slap_trackers","title":"Variable: DEFAULT_SLAP_TRACKERS","text":"<pre><code>DEFAULT_SLAP_TRACKERS: string[] = [\n    \"https://overlay-us-1.bsvb.tech\",\n    \"https://overlay-eu-1.bsvb.tech\",\n    \"https://overlay-ap-1.bsvb.tech\",\n    \"https://users.bapp.dev\"\n]\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/overlay-tools/#variable-default_testnet_slap_trackers","title":"Variable: DEFAULT_TESTNET_SLAP_TRACKERS","text":"<pre><code>DEFAULT_TESTNET_SLAP_TRACKERS: string[] = [\n    \"https://testnet-users.bapp.dev\"\n]\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/overlay-tools/#variable-getoverlayhostreputationtracker","title":"Variable: getOverlayHostReputationTracker","text":"<pre><code>getOverlayHostReputationTracker = (): HostReputationTracker =&gt; globalTracker\n</code></pre> <p>See also: HostReputationTracker</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/","title":"API","text":"<p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#interfaces","title":"Interfaces","text":"JacobianPointBI SignatureHashCache <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#interface-jacobianpointbi","title":"Interface: JacobianPointBI","text":"<pre><code>export interface JacobianPointBI {\n    X: bigint;\n    Y: bigint;\n    Z: bigint;\n}\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#interface-signaturehashcache","title":"Interface: SignatureHashCache","text":"<pre><code>export interface SignatureHashCache {\n    hashPrevouts?: number[];\n    hashSequence?: number[];\n    hashOutputsAll?: number[];\n    hashOutputsSingle?: Map&lt;number, number[]&gt;;\n}\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#classes","title":"Classes","text":"BasePoint PointInFiniteField SHA256HMAC BigNumber Polynomial SHA512 Curve PrivateKey SHA512HMAC DRBG PublicKey Schnorr JacobianPoint RIPEMD160 Signature K256 Reader SymmetricKey KeyShares ReductionContext TransactionSignature Mersenne SHA1 Writer MontgomoryMethod SHA1HMAC Point SHA256 <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#class-basepoint","title":"Class: BasePoint","text":"<p>Base class for Point (affine coordinates) and JacobianPoint classes, defining their curve and type.</p> <pre><code>export default abstract class BasePoint {\n    curve: Curve;\n    type: \"affine\" | \"jacobian\";\n    precomputed: {\n        doubles?: {\n            step: number;\n            points: BasePoint[];\n        };\n        naf?: {\n            wnd: number;\n            points: BasePoint[];\n        };\n        beta?: BasePoint | null;\n    } | null;\n    constructor(type: \"affine\" | \"jacobian\") \n}\n</code></pre> <p>See also: Curve</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#class-bignumber","title":"Class: BigNumber","text":"<p>JavaScript numbers are only precise up to 53 bits. Since Bitcoin relies on 256-bit cryptography, this BigNumber class enables operations on larger numbers.</p> <pre><code>export default class BigNumber {\n    public static readonly zeros: string[] \n    static readonly groupSizes: number[] \n    static readonly groupBases: number[] \n    static readonly wordSize: number = 26;\n    public red: ReductionContext | null;\n    public get negative(): number \n    public set negative(val: number) \n    public get words(): number[] \n    public set words(newWords: number[]) \n    public get length(): number \n    static isBN(num: any): boolean \n    static max(left: BigNumber, right: BigNumber): BigNumber \n    static min(left: BigNumber, right: BigNumber): BigNumber \n    constructor(number: number | string | number[] | bigint | undefined = 0, base: number | \"be\" | \"le\" | \"hex\" = 10, endian: \"be\" | \"le\" = \"be\") \n    copy(dest: BigNumber): void \n    static move(dest: BigNumber, src: BigNumber): void \n    clone(): BigNumber \n    expand(size: number): this \n    strip(): this \n    normSign(): this { if (this._magnitude === 0n)\n        this._sign = 0; return this; }\n    inspect(): string \n    toString(base: number | \"hex\" = 10, padding: number = 1): string \n    toNumber(): number \n    toBigInt(): bigint \n    toJSON(): string \n    toArray(endian: \"le\" | \"be\" = \"be\", length?: number): number[] \n    bitLength(): number { if (this._magnitude === 0n)\n        return 0; return this._magnitude.toString(2).length; }\n    static toBitArray(num: BigNumber): Array&lt;0 | 1&gt; \n    toBitArray(): Array&lt;0 | 1&gt; \n    zeroBits(): number \n    byteLength(): number { if (this._magnitude === 0n)\n        return 0; return Math.ceil(this.bitLength() / 8); }\n    toTwos(width: number): BigNumber \n    fromTwos(width: number): BigNumber \n    isNeg(): boolean \n    neg(): BigNumber \n    ineg(): this { if (this._magnitude !== 0n)\n        this._sign = this._sign === 1 ? 0 : 1; return this; }\n    iuor(num: BigNumber): this \n    iuand(num: BigNumber): this \n    iuxor(num: BigNumber): this \n    ior(num: BigNumber): this \n    iand(num: BigNumber): this \n    ixor(num: BigNumber): this \n    or(num: BigNumber): BigNumber \n    uor(num: BigNumber): BigNumber \n    and(num: BigNumber): BigNumber \n    uand(num: BigNumber): BigNumber \n    xor(num: BigNumber): BigNumber \n    uxor(num: BigNumber): BigNumber \n    inotn(width: number): this \n    notn(width: number): BigNumber \n    setn(bit: number, val: any): this { this.assert(typeof bit === \"number\" &amp;&amp; bit &gt;= 0); const Bb = BigInt(bit); if (val === 1 || val === true)\n        this._magnitude |= (1n &lt;&lt; Bb);\n    else\n        this._magnitude &amp;= ~(1n &lt;&lt; Bb); const wnb = Math.floor(bit / BigNumber.wordSize) + 1; this._nominalWordLength = Math.max(this._nominalWordLength, wnb); this._finishInitialization(); return this.strip(); }\n    iadd(num: BigNumber): this \n    add(num: BigNumber): BigNumber \n    isub(num: BigNumber): this \n    sub(num: BigNumber): BigNumber \n    mul(num: BigNumber): BigNumber \n    imul(num: BigNumber): this \n    imuln(num: number): this \n    muln(num: number): BigNumber \n    sqr(): BigNumber \n    isqr(): this \n    pow(num: BigNumber): BigNumber \n    iushln(bits: number | bigint): this \n    ishln(bits: number | bigint): this \n    iushrn(bits: number | bigint, hint?: number, extended?: BigNumber): this \n    ishrn(bits: number | bigint, hint?: number, extended?: BigNumber): this \n    shln(bits: number | bigint): BigNumber \n    ushln(bits: number | bigint): BigNumber \n    shrn(bits: number | bigint): BigNumber \n    ushrn(bits: number | bigint): BigNumber \n    testn(bit: number): boolean \n    imaskn(bits: number): this \n    maskn(bits: number): BigNumber \n    iaddn(num: number): this \n    _iaddn(num: number): this \n    isubn(num: number): this \n    addn(num: number): BigNumber \n    subn(num: number): BigNumber \n    iabs(): this \n    abs(): BigNumber \n    divmod(num: BigNumber, mode?: \"div\" | \"mod\", positive?: boolean): any \n    div(num: BigNumber): BigNumber \n    mod(num: BigNumber): BigNumber \n    umod(num: BigNumber): BigNumber \n    divRound(num: BigNumber): BigNumber \n    modrn(numArg: number): number \n    idivn(num: number): this \n    divn(num: number): BigNumber \n    egcd(p: BigNumber): {\n        a: BigNumber;\n        b: BigNumber;\n        gcd: BigNumber;\n    } \n    gcd(num: BigNumber): BigNumber \n    invm(num: BigNumber): BigNumber \n    isEven(): boolean \n    isOdd(): boolean \n    andln(num: number): number \n    bincn(bit: number): this \n    isZero(): boolean \n    cmpn(num: number): 1 | 0 | -1 { this.assert(Math.abs(num) &lt;= BigNumber.MAX_IMULN_ARG, \"Number is too big\"); const tV = this._getSignedValue(); const nV = BigInt(num); if (tV &lt; nV)\n        return -1; if (tV &gt; nV)\n        return 1; return 0; }\n    cmp(num: BigNumber): 1 | 0 | -1 { const tV = this._getSignedValue(); const nV = num._getSignedValue(); if (tV &lt; nV)\n        return -1; if (tV &gt; nV)\n        return 1; return 0; }\n    ucmp(num: BigNumber): 1 | 0 | -1 { if (this._magnitude &lt; num._magnitude)\n        return -1; if (this._magnitude &gt; num._magnitude)\n        return 1; return 0; }\n    gtn(num: number): boolean \n    gt(num: BigNumber): boolean \n    gten(num: number): boolean \n    gte(num: BigNumber): boolean \n    ltn(num: number): boolean \n    lt(num: BigNumber): boolean \n    lten(num: number): boolean \n    lte(num: BigNumber): boolean \n    eqn(num: number): boolean \n    eq(num: BigNumber): boolean \n    toRed(ctx: ReductionContext): BigNumber \n    fromRed(): BigNumber \n    forceRed(ctx: ReductionContext): this \n    redAdd(num: BigNumber): BigNumber \n    redIAdd(num: BigNumber): BigNumber \n    redSub(num: BigNumber): BigNumber \n    redISub(num: BigNumber): BigNumber \n    redShl(num: number): BigNumber \n    redMul(num: BigNumber): BigNumber \n    redIMul(num: BigNumber): BigNumber \n    redSqr(): BigNumber \n    redISqr(): BigNumber \n    redSqrt(): BigNumber \n    redInvm(): BigNumber \n    redNeg(): BigNumber \n    redPow(num: BigNumber): BigNumber \n    static fromHex(hex: string, endian?: \"le\" | \"be\" | \"little\" | \"big\"): BigNumber \n    toHex(byteLength: number = 0): string \n    static fromJSON(str: string): BigNumber \n    static fromNumber(n: number): BigNumber \n    static fromString(str: string, base?: number | \"hex\"): BigNumber \n    static fromSm(bytes: number[], endian: \"big\" | \"little\" = \"big\"): BigNumber \n    toSm(endian: \"big\" | \"little\" = \"big\"): number[] \n    static fromBits(bits: number, strict: boolean = false): BigNumber \n    toBits(): number \n    static fromScriptNum(num: number[], requireMinimal: boolean = false, maxNumSize?: number): BigNumber \n    toScriptNum(): number[] \n    _invmp(p: BigNumber): BigNumber \n    mulTo(num: BigNumber, out: BigNumber): BigNumber \n}\n</code></pre> <p>See also: ReductionContext, red, toArray, toHex</p>"},{"location":"reference/primitives/#constructor","title":"Constructor","text":"<pre><code>constructor(number: number | string | number[] | bigint | undefined = 0, base: number | \"be\" | \"le\" | \"hex\" = 10, endian: \"be\" | \"le\" = \"be\") \n</code></pre> <p>Argument Details</p> <ul> <li>number</li> <li>The number (various types accepted) to construct a BigNumber from. Default is 0.</li> <li>base</li> <li>The base of number provided. By default is 10.</li> <li>endian</li> <li>The endianness provided. By default is 'big endian'.</li> </ul>"},{"location":"reference/primitives/#property-red","title":"Property red","text":"<p>Reduction context of the big number.</p> <p><pre><code>public red: ReductionContext | null\n</code></pre> See also: ReductionContext</p>"},{"location":"reference/primitives/#property-wordsize","title":"Property wordSize","text":"<p>The word size of big number chunks.</p> <pre><code>static readonly wordSize: number = 26\n</code></pre> <p>Example</p> <pre><code>console.log(BigNumber.wordSize);  // output: 26\n</code></pre>"},{"location":"reference/primitives/#method-_invmp","title":"Method _invmp","text":"<p>Compute the multiplicative inverse of the current BigNumber in the modulus field specified by <code>p</code>. The multiplicative inverse is a number which when multiplied with the current BigNumber gives '1' in the modulus field.</p> <p><pre><code>_invmp(p: BigNumber): BigNumber \n</code></pre> See also: BigNumber</p> <p>Returns</p> <p>The multiplicative inverse <code>BigNumber</code> in the modulus field specified by <code>p</code>.</p> <p>Argument Details</p> <ul> <li>p</li> <li>The <code>BigNumber</code> specifying the modulus field.</li> </ul>"},{"location":"reference/primitives/#method-bitlength","title":"Method bitLength","text":"<p>Calculates the number of bits required to represent the BigNumber.</p> <pre><code>bitLength(): number { if (this._magnitude === 0n)\n    return 0; return this._magnitude.toString(2).length; }\n</code></pre> <p>Returns</p> <p>The bit length of the BigNumber.</p>"},{"location":"reference/primitives/#method-bytelength","title":"Method byteLength","text":"<p>Calculates the number of bytes required to represent the BigNumber.</p> <pre><code>byteLength(): number { if (this._magnitude === 0n)\n    return 0; return Math.ceil(this.bitLength() / 8); }\n</code></pre> <p>Returns</p> <p>The byte length of the BigNumber.</p>"},{"location":"reference/primitives/#method-frombits","title":"Method fromBits","text":"<p>Creates a BigNumber from a number representing the \"bits\" value in a block header.</p> <p><pre><code>static fromBits(bits: number, strict: boolean = false): BigNumber \n</code></pre> See also: BigNumber</p> <p>Returns</p> <p>Returns a BigNumber equivalent to the \"bits\" value in a block header.</p> <p>Argument Details</p> <ul> <li>bits</li> <li>The number representing the bits value in a block header.</li> <li>strict</li> <li>If true, an error is thrown if the number has negative bit set.</li> </ul> <p>Throws</p> <p>Will throw an error if <code>strict</code> is <code>true</code> and the number has negative bit set.</p>"},{"location":"reference/primitives/#method-fromhex","title":"Method fromHex","text":"<p>Creates a BigNumber from a hexadecimal string.</p> <p><pre><code>static fromHex(hex: string, endian?: \"le\" | \"be\" | \"little\" | \"big\"): BigNumber \n</code></pre> See also: BigNumber</p> <p>Returns</p> <p>Returns a BigNumber created from the hexadecimal input string.</p> <p>Argument Details</p> <ul> <li>hex</li> <li>The hexadecimal string to create a BigNumber from.</li> <li>endian</li> <li>Optional endianness for parsing the hex string.</li> </ul> <p>Example</p> <pre><code>const exampleHex = 'a1b2c3';\nconst bigNumber = BigNumber.fromHex(exampleHex);\n</code></pre>"},{"location":"reference/primitives/#method-fromjson","title":"Method fromJSON","text":"<p>Creates a BigNumber from a JSON-serialized string.</p> <p><pre><code>static fromJSON(str: string): BigNumber \n</code></pre> See also: BigNumber</p> <p>Returns</p> <p>Returns a BigNumber created from the JSON input string.</p> <p>Argument Details</p> <ul> <li>str</li> <li>The JSON-serialized string to create a BigNumber from.</li> </ul>"},{"location":"reference/primitives/#method-fromnumber","title":"Method fromNumber","text":"<p>Creates a BigNumber from a number.</p> <p><pre><code>static fromNumber(n: number): BigNumber \n</code></pre> See also: BigNumber</p> <p>Returns</p> <p>Returns a BigNumber equivalent to the input number.</p> <p>Argument Details</p> <ul> <li>n</li> <li>The number to create a BigNumber from.</li> </ul>"},{"location":"reference/primitives/#method-fromscriptnum","title":"Method fromScriptNum","text":"<p>Creates a BigNumber from the format used in Bitcoin scripts.</p> <p><pre><code>static fromScriptNum(num: number[], requireMinimal: boolean = false, maxNumSize?: number): BigNumber \n</code></pre> See also: BigNumber</p> <p>Returns</p> <p>Returns a BigNumber equivalent to the number used in a Bitcoin script.</p> <p>Argument Details</p> <ul> <li>num</li> <li>The number in the format used in Bitcoin scripts.</li> <li>requireMinimal</li> <li>If true, non-minimally encoded values will throw an error.</li> <li>maxNumSize</li> <li>The maximum allowed size for the number.</li> </ul>"},{"location":"reference/primitives/#method-fromsm","title":"Method fromSm","text":"<p>Creates a BigNumber from a signed magnitude number.</p> <p><pre><code>static fromSm(bytes: number[], endian: \"big\" | \"little\" = \"big\"): BigNumber \n</code></pre> See also: BigNumber</p> <p>Returns</p> <p>Returns a BigNumber equivalent to the signed magnitude number interpreted with specified endianess.</p> <p>Argument Details</p> <ul> <li>bytes</li> <li>The signed magnitude number to convert to a BigNumber.</li> <li>endian</li> <li>Defines endianess. If not provided, big endian is assumed.</li> </ul>"},{"location":"reference/primitives/#method-fromstring","title":"Method fromString","text":"<p>Creates a BigNumber from a string, considering an optional base.</p> <p><pre><code>static fromString(str: string, base?: number | \"hex\"): BigNumber \n</code></pre> See also: BigNumber</p> <p>Returns</p> <p>Returns a BigNumber equivalent to the string after conversion from the specified base.</p> <p>Argument Details</p> <ul> <li>str</li> <li>The string to create a BigNumber from.</li> <li>base</li> <li>The base used for conversion. If not provided, base 10 is assumed.</li> </ul>"},{"location":"reference/primitives/#method-isbn","title":"Method isBN","text":"<p>Checks whether a value is an instance of BigNumber. Regular JS numbers fail this check.</p> <pre><code>static isBN(num: any): boolean \n</code></pre> <p>Returns</p> <ul> <li>Returns a boolean value determining whether or not the checked num parameter is a BigNumber.</li> </ul> <p>Argument Details</p> <ul> <li>num</li> <li>The value to be checked.</li> </ul>"},{"location":"reference/primitives/#method-max","title":"Method max","text":"<p>Returns the bigger value between two BigNumbers</p> <p><pre><code>static max(left: BigNumber, right: BigNumber): BigNumber \n</code></pre> See also: BigNumber</p> <p>Returns</p> <ul> <li>Returns the bigger BigNumber between left and right.</li> </ul> <p>Argument Details</p> <ul> <li>left</li> <li>The first BigNumber to be compared.</li> <li>right</li> <li>The second BigNumber to be compared.</li> </ul>"},{"location":"reference/primitives/#method-min","title":"Method min","text":"<p>Returns the smaller value between two BigNumbers</p> <p><pre><code>static min(left: BigNumber, right: BigNumber): BigNumber \n</code></pre> See also: BigNumber</p> <p>Returns</p> <ul> <li>Returns the smaller value between left and right.</li> </ul> <p>Argument Details</p> <ul> <li>left</li> <li>The first BigNumber to be compared.</li> <li>right</li> <li>The second BigNumber to be compared.</li> </ul>"},{"location":"reference/primitives/#method-multo","title":"Method mulTo","text":"<p>Performs multiplication between the BigNumber instance and a given BigNumber. It chooses the multiplication method based on the lengths of the numbers to optimize execution time.</p> <p><pre><code>mulTo(num: BigNumber, out: BigNumber): BigNumber \n</code></pre> See also: BigNumber</p> <p>Returns</p> <p>The BigNumber resulting from the multiplication operation.</p> <p>Argument Details</p> <ul> <li>num</li> <li>The BigNumber multiply with.</li> <li>out</li> <li>The BigNumber where to store the result.</li> </ul>"},{"location":"reference/primitives/#method-toarray","title":"Method toArray","text":"<p>Converts the BigNumber instance to an array of bytes.</p> <pre><code>toArray(endian: \"le\" | \"be\" = \"be\", length?: number): number[] \n</code></pre> <p>Returns</p> <p>Array of bytes representing the BigNumber.</p> <p>Argument Details</p> <ul> <li>endian</li> <li>Endianness of the output array, defaults to 'be'.</li> <li>length</li> <li>Optional length of the output array.</li> </ul>"},{"location":"reference/primitives/#method-tobigint","title":"Method toBigInt","text":"<p>Returns the signed BigInt representation of this BigNumber without any safety checks.</p> <pre><code>toBigInt(): bigint \n</code></pre> <p>Returns</p> <p>bigint value for this BigNumber.</p>"},{"location":"reference/primitives/#method-tobitarray","title":"Method toBitArray","text":"<p>Converts a BigNumber to an array of bits.</p> <p><pre><code>static toBitArray(num: BigNumber): Array&lt;0 | 1&gt; \n</code></pre> See also: BigNumber</p> <p>Returns</p> <p>An array of bits.</p> <p>Argument Details</p> <ul> <li>num</li> <li>The BigNumber to convert.</li> </ul>"},{"location":"reference/primitives/#method-tobits","title":"Method toBits","text":"<p>Converts this BigNumber to a number representing the \"bits\" value in a block header.</p> <pre><code>toBits(): number \n</code></pre> <p>Returns</p> <p>Returns a number equivalent to the \"bits\" value in a block header.</p>"},{"location":"reference/primitives/#method-tohex","title":"Method toHex","text":"<p>Converts this BigNumber to a hexadecimal string.</p> <pre><code>toHex(byteLength: number = 0): string \n</code></pre> <p>Returns</p> <p>Returns a string representing the hexadecimal value of this BigNumber.</p> <p>Argument Details</p> <ul> <li>length</li> <li>The minimum length of the hex string</li> </ul> <p>Example</p> <pre><code>const bigNumber = new BigNumber(255)\nconst hex = bigNumber.toHex()\n</code></pre>"},{"location":"reference/primitives/#method-tojson","title":"Method toJSON","text":"<p>Converts the BigNumber instance to a JSON-formatted string.</p> <pre><code>toJSON(): string \n</code></pre> <p>Returns</p> <p>The JSON string representation of the BigNumber instance.</p>"},{"location":"reference/primitives/#method-tonumber","title":"Method toNumber","text":"<p>Converts the BigNumber instance to a JavaScript number. Please note that JavaScript numbers are only precise up to 53 bits.</p> <pre><code>toNumber(): number \n</code></pre> <p>Returns</p> <p>The JavaScript number representation of the BigNumber instance.</p> <p>Throws</p> <p>If the BigNumber instance cannot be safely stored in a JavaScript number</p>"},{"location":"reference/primitives/#method-toscriptnum","title":"Method toScriptNum","text":"<p>Converts this BigNumber to a number in the format used in Bitcoin scripts.</p> <pre><code>toScriptNum(): number[] \n</code></pre> <p>Returns</p> <p>Returns the equivalent to this BigNumber as a Bitcoin script number.</p>"},{"location":"reference/primitives/#method-tosm","title":"Method toSm","text":"<p>Converts this BigNumber to a signed magnitude number.</p> <pre><code>toSm(endian: \"big\" | \"little\" = \"big\"): number[] \n</code></pre> <p>Returns</p> <p>Returns an array equivalent to this BigNumber interpreted as a signed magnitude with specified endianess.</p> <p>Argument Details</p> <ul> <li>endian</li> <li>Defines endianess. If not provided, big endian is assumed.</li> </ul>"},{"location":"reference/primitives/#method-tostring","title":"Method toString","text":"<p>function toString() { [native code] }</p> <p>Converts the BigNumber instance to a string representation.</p> <pre><code>toString(base: number | \"hex\" = 10, padding: number = 1): string \n</code></pre> <p>Returns</p> <p>The string representation of the BigNumber instance</p> <p>Argument Details</p> <ul> <li>base</li> <li>The base for representing number. Default is 10. Other accepted values are 16 and 'hex'.</li> <li>padding</li> <li>Represents the minimum number of digits to represent the BigNumber as a string. Default is 1.</li> </ul>"},{"location":"reference/primitives/#method-zerobits","title":"Method zeroBits","text":"<p>Returns the number of trailing zero bits in the big number.</p> <pre><code>zeroBits(): number \n</code></pre> <p>Returns</p> <p>Returns the number of trailing zero bits in the binary representation of the big number.</p> <p>Example</p> <pre><code>const bn = new BigNumber('8'); // binary: 1000\nconst zeroBits = bn.zeroBits(); // 3\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#class-curve","title":"Class: Curve","text":"<pre><code>export default class Curve {\n    p: BigNumber;\n    red: ReductionContext;\n    redN: BigNumber | null;\n    zero: BigNumber;\n    one: BigNumber;\n    two: BigNumber;\n    g: Point;\n    n: BigNumber;\n    a: BigNumber;\n    b: BigNumber;\n    tinv: BigNumber;\n    zeroA: boolean;\n    threeA: boolean;\n    endo: {\n        beta: BigNumber;\n        lambda: BigNumber;\n        basis: Array&lt;{\n            a: BigNumber;\n            b: BigNumber;\n        }&gt;;\n    } | undefined;\n    _endoWnafT1: BigNumber[];\n    _endoWnafT2: BigNumber[];\n    _wnafT1: BigNumber[];\n    _wnafT2: BigNumber[];\n    _wnafT3: BigNumber[];\n    _wnafT4: BigNumber[];\n    _bitLength: number;\n    static assert(expression: unknown, message: string = \"Elliptic curve assertion failed\"): void \n    getNAF(num: BigNumber, w: number, bits: number): number[] \n    getJSF(k1: BigNumber, k2: BigNumber): number[][] \n    static cachedProperty(obj, name: string, computer): void \n    static parseBytes(bytes: string | number[]): number[] \n    static intFromLE(bytes: number[]): BigNumber \n    constructor() \n    _getEndomorphism(conf): {\n        beta: BigNumber;\n        lambda: BigNumber;\n        basis: Array&lt;{\n            a: BigNumber;\n            b: BigNumber;\n        }&gt;;\n    } | undefined \n    _getEndoRoots(num: BigNumber): [\n        BigNumber,\n        BigNumber\n    ] \n    _getEndoBasis(lambda: BigNumber): [\n        {\n            a: BigNumber;\n            b: BigNumber;\n        },\n        {\n            a: BigNumber;\n            b: BigNumber;\n        }\n    ] \n    _endoSplit(k: BigNumber): {\n        k1: BigNumber;\n        k2: BigNumber;\n    } \n    validate(point: Point): boolean \n}\n</code></pre> <p>See also: BigNumber, Point, ReductionContext, red</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#class-drbg","title":"Class: DRBG","text":"<p>This class behaves as a HMAC-based deterministic random bit generator (DRBG). It implements a deterministic random number generator using SHA256HMAC HASH function. It takes an initial entropy and nonce when instantiated for seeding purpose.</p> <p>Example</p> <pre><code>const drbg = new DRBG('af12de...', '123ef...');\n</code></pre> <pre><code>export default class DRBG {\n    K: number[];\n    V: number[];\n    constructor(entropy: number[] | string, nonce: number[] | string) \n    hmac(): SHA256HMAC \n    update(seed?): void \n    generate(len: number): string \n}\n</code></pre> <p>See also: SHA256HMAC</p>"},{"location":"reference/primitives/#method-generate","title":"Method generate","text":"<p>Generates deterministic random hexadecimal string of given length. In every generation process, it also updates the internal state <code>K</code> and <code>V</code>.</p> <pre><code>generate(len: number): string \n</code></pre> <p>Returns</p> <p>The required deterministic random hexadecimal string.</p> <p>Argument Details</p> <ul> <li>len</li> <li>The length of required random number.</li> </ul> <p>Example</p> <pre><code>const randomHex = drbg.generate(256);\n</code></pre>"},{"location":"reference/primitives/#method-hmac","title":"Method hmac","text":"<p>Generates HMAC using the K value of the instance. This method is used internally for operations.</p> <p><pre><code>hmac(): SHA256HMAC \n</code></pre> See also: SHA256HMAC</p> <p>Returns</p> <p>The SHA256HMAC object created with K value.</p> <p>Example</p> <pre><code>const hmac = drbg.hmac();\n</code></pre>"},{"location":"reference/primitives/#method-update","title":"Method update","text":"<p>Updates the <code>K</code> and <code>V</code> values of the instance based on the seed. The seed if not provided uses <code>V</code> as seed.</p> <pre><code>update(seed?): void \n</code></pre> <p>Returns</p> <p>Nothing, but updates the internal state <code>K</code> and <code>V</code> value.</p> <p>Argument Details</p> <ul> <li>seed</li> <li>an optional value that used to update <code>K</code> and <code>V</code>. Default is <code>undefined</code>.</li> </ul> <p>Example</p> <pre><code>drbg.update('e13af...');\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#class-jacobianpoint","title":"Class: JacobianPoint","text":"<p>The <code>JacobianPoint</code> class extends the <code>BasePoint</code> class for handling Jacobian coordinates on an Elliptic Curve. This class defines the properties and the methods needed to work with points in Jacobian coordinates.</p> <p>The Jacobian coordinates represent a point (x, y, z) on an Elliptic Curve such that the usual (x, y) coordinates are given by (x/z^2, y/z^3).</p> <p>Example</p> <pre><code>const pointJ = new JacobianPoint('3', '4', '1');\n</code></pre> <pre><code>export default class JacobianPoint extends BasePoint {\n    x: BigNumber;\n    y: BigNumber;\n    z: BigNumber;\n    zOne: boolean;\n    constructor(x: string | BigNumber | null, y: string | BigNumber | null, z: string | BigNumber | null) \n    toP(): Point \n    neg(): JacobianPoint \n    add(p: JacobianPoint): JacobianPoint \n    mixedAdd(p: Point): JacobianPoint \n    dblp(pow: number): JacobianPoint \n    dbl(): JacobianPoint \n    eq(p: Point | JacobianPoint): boolean \n    eqXToP(x: BigNumber): boolean \n    inspect(): string \n    isInfinity(): boolean \n}\n</code></pre> <p>See also: BasePoint, BigNumber, Point</p>"},{"location":"reference/primitives/#constructor_1","title":"Constructor","text":"<p>Constructs a new <code>JacobianPoint</code> instance.</p> <p><pre><code>constructor(x: string | BigNumber | null, y: string | BigNumber | null, z: string | BigNumber | null) \n</code></pre> See also: BigNumber</p> <p>Argument Details</p> <ul> <li>x</li> <li>If <code>null</code>, the x-coordinate will default to the curve's defined 'one' constant. If <code>x</code> is not a BigNumber, <code>x</code> will be converted to a <code>BigNumber</code> assuming it is a hex string.</li> <li>y</li> <li>If <code>null</code>, the y-coordinate will default to the curve's defined 'one' constant. If <code>y</code> is not a BigNumber, <code>y</code> will be converted to a <code>BigNumber</code> assuming it is a hex string.</li> <li>z</li> <li>If <code>null</code>, the z-coordinate will default to 0. If <code>z</code> is not a BigNumber, <code>z</code> will be converted to a <code>BigNumber</code> assuming it is a hex string.</li> </ul> <p>Example</p> <pre><code>const pointJ1 = new JacobianPoint(null, null, null); // creates point at infinity\nconst pointJ2 = new JacobianPoint('3', '4', '1'); // creates point (3, 4, 1)\n</code></pre>"},{"location":"reference/primitives/#property-x","title":"Property x","text":"<p>The <code>x</code> coordinate of the point in the Jacobian form.</p> <p><pre><code>x: BigNumber\n</code></pre> See also: BigNumber</p>"},{"location":"reference/primitives/#property-y","title":"Property y","text":"<p>The <code>y</code> coordinate of the point in the Jacobian form.</p> <p><pre><code>y: BigNumber\n</code></pre> See also: BigNumber</p>"},{"location":"reference/primitives/#property-z","title":"Property z","text":"<p>The <code>z</code> coordinate of the point in the Jacobian form.</p> <p><pre><code>z: BigNumber\n</code></pre> See also: BigNumber</p>"},{"location":"reference/primitives/#property-zone","title":"Property zOne","text":"<p>Flag that indicates if the <code>z</code> coordinate is one.</p> <pre><code>zOne: boolean\n</code></pre>"},{"location":"reference/primitives/#method-add","title":"Method add","text":"<p>Addition operation in the Jacobian coordinates. It takes a Jacobian point as an argument and returns a new Jacobian point as a result of the addition. In the special cases, when either one of the points is the point at infinity, it will return the other point.</p> <p><pre><code>add(p: JacobianPoint): JacobianPoint \n</code></pre> See also: JacobianPoint</p> <p>Returns</p> <p>Returns a new Jacobian point as the result of the addition.</p> <p>Argument Details</p> <ul> <li>p</li> <li>The Jacobian point to be added.</li> </ul> <p>Example</p> <pre><code>const p1 = new JacobianPoint(x1, y1, z1)\nconst p2 = new JacobianPoint(x2, y2, z2)\nconst result = p1.add(p2)\n</code></pre>"},{"location":"reference/primitives/#method-dbl","title":"Method dbl","text":"<p>Point doubling operation in the Jacobian coordinates. A special case is when the point is the point at infinity, in this case, this function will return the point itself.</p> <p><pre><code>dbl(): JacobianPoint \n</code></pre> See also: JacobianPoint</p> <p>Returns</p> <p>Returns a new Jacobian point as the result of the doubling.</p> <p>Example</p> <pre><code>const jp = new JacobianPoint(x, y, z)\nconst result = jp.dbl()\n</code></pre>"},{"location":"reference/primitives/#method-dblp","title":"Method dblp","text":"<p>Multiple doubling operation. It doubles the Jacobian point as many times as the pow parameter specifies. If pow is 0 or the point is the point at infinity, it will return the point itself.</p> <p><pre><code>dblp(pow: number): JacobianPoint \n</code></pre> See also: JacobianPoint</p> <p>Returns</p> <p>Returns a new Jacobian point as the result of multiple doublings.</p> <p>Argument Details</p> <ul> <li>pow</li> <li>The number of times the point should be doubled.</li> </ul> <p>Example</p> <pre><code>const jp = new JacobianPoint(x, y, z)\nconst result = jp.dblp(3)\n</code></pre>"},{"location":"reference/primitives/#method-eq","title":"Method eq","text":"<p>Equality check operation. It checks whether the affine or Jacobian point is equal to this Jacobian point.</p> <p><pre><code>eq(p: Point | JacobianPoint): boolean \n</code></pre> See also: JacobianPoint, Point</p> <p>Returns</p> <p>Returns true if the points are equal, otherwise returns false.</p> <p>Argument Details</p> <ul> <li>p</li> <li>The affine or Jacobian point to compare with.</li> </ul> <p>Example</p> <pre><code>const jp1 = new JacobianPoint(x1, y1, z1)\nconst jp2 = new JacobianPoint(x2, y2, z2)\nconst areEqual = jp1.eq(jp2)\n</code></pre>"},{"location":"reference/primitives/#method-eqxtop","title":"Method eqXToP","text":"<p>Equality check operation in relation to an x coordinate of a point in projective coordinates. It checks whether the x coordinate of the Jacobian point is equal to the provided x coordinate of a point in projective coordinates.</p> <p><pre><code>eqXToP(x: BigNumber): boolean \n</code></pre> See also: BigNumber</p> <p>Returns</p> <p>Returns true if the x coordinates are equal, otherwise returns false.</p> <p>Argument Details</p> <ul> <li>x</li> <li>The x coordinate of a point in projective coordinates.</li> </ul> <p>Example</p> <pre><code>const jp = new JacobianPoint(x1, y1, z1)\nconst isXEqual = jp.eqXToP(x2)\n</code></pre>"},{"location":"reference/primitives/#method-inspect","title":"Method inspect","text":"<p>Returns the string representation of the JacobianPoint instance.</p> <pre><code>inspect(): string \n</code></pre> <p>Returns</p> <p>Returns the string description of the JacobianPoint. If the JacobianPoint represents a point at infinity, the return value of this function is ''. For a normal point, it returns the string description format as ''. <p>Example</p> <pre><code>const point = new JacobianPoint('5', '6', '1');\nconsole.log(point.inspect()); // Output: '&lt;EC JPoint x: 5 y: 6 z: 1&gt;'\n</code></pre>"},{"location":"reference/primitives/#method-isinfinity","title":"Method isInfinity","text":"<p>Checks whether the JacobianPoint instance represents a point at infinity.</p> <pre><code>isInfinity(): boolean \n</code></pre> <p>Returns</p> <p>Returns true if the JacobianPoint's z-coordinate equals to zero (which represents the point at infinity in Jacobian coordinates). Returns false otherwise.</p> <p>Example</p> <pre><code>const point = new JacobianPoint('5', '6', '0');\nconsole.log(point.isInfinity()); // Output: true\n</code></pre>"},{"location":"reference/primitives/#method-mixedadd","title":"Method mixedAdd","text":"<p>Mixed addition operation. This function combines the standard point addition with the transformation from the affine to Jacobian coordinates. It first converts the affine point to Jacobian, and then preforms the addition.</p> <p><pre><code>mixedAdd(p: Point): JacobianPoint \n</code></pre> See also: JacobianPoint, Point</p> <p>Returns</p> <p>Returns the result of the mixed addition as a new Jacobian point.</p> <p>Argument Details</p> <ul> <li>p</li> <li>The affine point to be added.</li> </ul> <p>Example</p> <pre><code>const jp = new JacobianPoint(x1, y1, z1)\nconst ap = new Point(x2, y2)\nconst result = jp.mixedAdd(ap)\n</code></pre>"},{"location":"reference/primitives/#method-neg","title":"Method neg","text":"<p>Negation operation. It returns the additive inverse of the Jacobian point.</p> <p><pre><code>neg(): JacobianPoint \n</code></pre> See also: JacobianPoint</p> <p>Returns</p> <p>Returns a new Jacobian point as the result of the negation.</p> <p>Example</p> <pre><code>const jp = new JacobianPoint(x, y, z)\nconst result = jp.neg()\n</code></pre>"},{"location":"reference/primitives/#method-top","title":"Method toP","text":"<p>Converts the <code>JacobianPoint</code> object instance to standard affine <code>Point</code> format and returns <code>Point</code> type.</p> <p><pre><code>toP(): Point \n</code></pre> See also: Point</p> <p>Returns</p> <p>The <code>Point</code>(affine) object representing the same point as the original <code>JacobianPoint</code>.</p> <p>If the initial <code>JacobianPoint</code> represents point at infinity, an instance of <code>Point</code> at infinity is returned.</p> <p>Example</p> <pre><code>const pointJ = new JacobianPoint('3', '4', '1');\nconst pointP = pointJ.toP();  // The point in affine coordinates.\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#class-k256","title":"Class: K256","text":"<p>A class representing K-256, a prime number with optimizations, specifically used in the secp256k1 curve. It extends the functionalities of the Mersenne class. K-256 prime is represented as 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f'</p> <p>Example</p> <pre><code>const k256 = new K256();\n</code></pre> <pre><code>export default class K256 extends Mersenne {\n    constructor() \n    split(input: BigNumber, output: BigNumber): void \n    imulK(num: BigNumber): BigNumber \n}\n</code></pre> <p>See also: BigNumber, Mersenne</p>"},{"location":"reference/primitives/#constructor_2","title":"Constructor","text":"<p>Constructor for the K256 class. Creates an instance of K256 using the super constructor from Mersenne.</p> <pre><code>constructor() \n</code></pre> <p>Example</p> <pre><code>const k256 = new K256();\n</code></pre>"},{"location":"reference/primitives/#method-imulk","title":"Method imulK","text":"<p>Multiplies a BigNumber ('num') with the constant 'K' in-place and returns the result. 'K' is equal to 0x1000003d1 or in decimal representation: [ 64, 977 ].</p> <p><pre><code>imulK(num: BigNumber): BigNumber \n</code></pre> See also: BigNumber</p> <p>Returns</p> <p>Returns the mutated BigNumber after multiplication.</p> <p>Argument Details</p> <ul> <li>num</li> <li>The BigNumber to multiply with K.</li> </ul> <p>Example</p> <pre><code>const number = new BigNumber(12345);\nconst result = k256.imulK(number);\n</code></pre>"},{"location":"reference/primitives/#method-split","title":"Method split","text":"<p>Splits a BigNumber into a new BigNumber based on specific computation rules. This method modifies the input and output big numbers.</p> <p><pre><code>split(input: BigNumber, output: BigNumber): void \n</code></pre> See also: BigNumber</p> <p>Argument Details</p> <ul> <li>input</li> <li>The BigNumber to be split.</li> <li>output</li> <li>The BigNumber that results from the split.</li> </ul> <p>Example</p> <pre><code>const input = new BigNumber(3456);\nconst output = new BigNumber(0);\nk256.split(input, output);\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#class-keyshares","title":"Class: KeyShares","text":"<p>Example</p> <pre><code>const key = PrivateKey.fromShares(shares)\n</code></pre> <pre><code>export class KeyShares {\n    points: PointInFiniteField[];\n    threshold: number;\n    integrity: string;\n    constructor(points: PointInFiniteField[], threshold: number, integrity: string) \n    static fromBackupFormat(shares: string[]): KeyShares \n    toBackupFormat(): string[] \n}\n</code></pre> <p>See also: PointInFiniteField</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#class-mersenne","title":"Class: Mersenne","text":"<p>A representation of a pseudo-Mersenne prime. A pseudo-Mersenne prime has the general form 2^n - k, where n and k are integers.</p> <pre><code>export default class Mersenne {\n    name: string;\n    p: BigNumber;\n    k: BigNumber;\n    n: number;\n    constructor(name: string, p: string) \n    ireduce(num: BigNumber): BigNumber \n    split(input: BigNumber, out: BigNumber): void \n    imulK(num: BigNumber): BigNumber \n}\n</code></pre> <p>See also: BigNumber</p>"},{"location":"reference/primitives/#constructor_3","title":"Constructor","text":"<pre><code>constructor(name: string, p: string) \n</code></pre> <p>Argument Details</p> <ul> <li>name</li> <li>An identifier for the Mersenne instance.</li> <li>p</li> <li>A string representation of the pseudo-Mersenne prime, expressed in hexadecimal.</li> </ul> <p>Example</p> <pre><code>const mersenne = new Mersenne('M31', '7FFFFFFF');\n</code></pre>"},{"location":"reference/primitives/#property-k","title":"Property k","text":"<p>The constant subtracted from 2^n to derive a pseudo-Mersenne prime.</p> <p><pre><code>k: BigNumber\n</code></pre> See also: BigNumber</p>"},{"location":"reference/primitives/#property-n","title":"Property n","text":"<p>The exponent which determines the magnitude of the prime.</p> <pre><code>n: number\n</code></pre>"},{"location":"reference/primitives/#property-name","title":"Property name","text":"<p>The identifier for the Mersenne instance.</p> <pre><code>name: string\n</code></pre>"},{"location":"reference/primitives/#property-p","title":"Property p","text":"<p>BigNumber equivalent to 2^n - k.</p> <p><pre><code>p: BigNumber\n</code></pre> See also: BigNumber</p>"},{"location":"reference/primitives/#method-imulk_1","title":"Method imulK","text":"<p>Performs an in-place multiplication of the parameter by constant k.</p> <p><pre><code>imulK(num: BigNumber): BigNumber \n</code></pre> See also: BigNumber</p> <p>Returns</p> <p>The result of the multiplication, in BigNumber format.</p> <p>Argument Details</p> <ul> <li>num</li> <li>The BigNumber to multiply with k.</li> </ul> <p>Example</p> <pre><code>const multiplied = mersenne.imulK(new BigNumber('2345', 16));\n</code></pre>"},{"location":"reference/primitives/#method-ireduce","title":"Method ireduce","text":"<p>Reduces an input BigNumber in place, under the assumption that it is less than the square of the pseudo-Mersenne prime.</p> <p><pre><code>ireduce(num: BigNumber): BigNumber \n</code></pre> See also: BigNumber</p> <p>Returns</p> <p>The reduced BigNumber.</p> <p>Argument Details</p> <ul> <li>num</li> <li>The BigNumber to be reduced.</li> </ul> <p>Example</p> <pre><code>const reduced = mersenne.ireduce(new BigNumber('2345', 16));\n</code></pre>"},{"location":"reference/primitives/#method-split_1","title":"Method split","text":"<p>Shifts bits of the input BigNumber to the right, in place, to meet the magnitude of the pseudo-Mersenne prime.</p> <p><pre><code>split(input: BigNumber, out: BigNumber): void \n</code></pre> See also: BigNumber</p> <p>Argument Details</p> <ul> <li>input</li> <li>The BigNumber to be shifted (will contain HI part).</li> <li>out</li> <li>The BigNumber to hold the shifted result (LO part).</li> </ul> <p>Example</p> <pre><code>mersenne.split(new BigNumber('2345', 16), new BigNumber());\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#class-montgomorymethod","title":"Class: MontgomoryMethod","text":"<p>Represents a Montgomery reduction context, which is a mathematical method for performing modular multiplication without division.</p> <p>Montgomery reduction is an algorithm used mainly in cryptography which can help to speed up calculations in contexts where there are many repeated computations.</p> <p>This class extends the <code>ReductionContext</code> class.</p> <pre><code>export default class MontgomoryMethod extends ReductionContext {\n    shift: number;\n    r: BigNumber;\n    r2: BigNumber;\n    rinv: BigNumber;\n    minv: BigNumber;\n    constructor(m: BigNumber | \"k256\") \n    convertTo(num: BigNumber): BigNumber \n    convertFrom(num: BigNumber): BigNumber \n    imul(a: BigNumber, b: BigNumber): BigNumber \n    mul(a: BigNumber, b: BigNumber): BigNumber \n    invm(a: BigNumber): BigNumber \n}\n</code></pre> <p>See also: BigNumber, ReductionContext</p>"},{"location":"reference/primitives/#constructor_4","title":"Constructor","text":"<p><pre><code>constructor(m: BigNumber | \"k256\") \n</code></pre> See also: BigNumber</p> <p>Argument Details</p> <ul> <li>m</li> <li>The modulus to be used for the Montgomery method reductions.</li> </ul>"},{"location":"reference/primitives/#property-minv","title":"Property minv","text":"<p>The modular multiplicative inverse of <code>m</code> mod <code>r</code>.</p> <p><pre><code>minv: BigNumber\n</code></pre> See also: BigNumber</p>"},{"location":"reference/primitives/#property-r","title":"Property r","text":"<p>The 2^shift, shifted left by the bit length of modulus <code>m</code>.</p> <p><pre><code>r: BigNumber\n</code></pre> See also: BigNumber</p>"},{"location":"reference/primitives/#property-r2","title":"Property r2","text":"<p>The square of <code>r</code> modulo <code>m</code>.</p> <p><pre><code>r2: BigNumber\n</code></pre> See also: BigNumber</p>"},{"location":"reference/primitives/#property-rinv","title":"Property rinv","text":"<p>The modular multiplicative inverse of <code>r</code> mod <code>m</code>.</p> <p><pre><code>rinv: BigNumber\n</code></pre> See also: BigNumber</p>"},{"location":"reference/primitives/#property-shift","title":"Property shift","text":"<p>The number of bits in the modulus.</p> <pre><code>shift: number\n</code></pre>"},{"location":"reference/primitives/#method-convertfrom","title":"Method convertFrom","text":"<p>Converts a number from the Montgomery domain back to the original domain.</p> <p><pre><code>convertFrom(num: BigNumber): BigNumber \n</code></pre> See also: BigNumber</p> <p>Returns</p> <p>The result of the conversion from the Montgomery domain.</p> <p>Argument Details</p> <ul> <li>num</li> <li>The number to be converted from the Montgomery domain.</li> </ul> <p>Example</p> <pre><code>const montMethod = new MontgomoryMethod(m);\nconst convertedNum = montMethod.convertFrom(num);\n</code></pre>"},{"location":"reference/primitives/#method-convertto","title":"Method convertTo","text":"<p>Converts a number into the Montgomery domain.</p> <p><pre><code>convertTo(num: BigNumber): BigNumber \n</code></pre> See also: BigNumber</p> <p>Returns</p> <p>The result of the conversion into the Montgomery domain.</p> <p>Argument Details</p> <ul> <li>num</li> <li>The number to be converted into the Montgomery domain.</li> </ul> <p>Example</p> <pre><code>const montMethod = new MontgomoryMethod(m);\nconst convertedNum = montMethod.convertTo(num);\n</code></pre>"},{"location":"reference/primitives/#method-imul","title":"Method imul","text":"<p>Performs an in-place multiplication of two numbers in the Montgomery domain.</p> <p><pre><code>imul(a: BigNumber, b: BigNumber): BigNumber \n</code></pre> See also: BigNumber</p> <p>Returns</p> <p>The result of the in-place multiplication.</p> <p>Argument Details</p> <ul> <li>a</li> <li>The first number to multiply.</li> <li>b</li> <li>The second number to multiply.</li> </ul> <p>Example</p> <pre><code>const montMethod = new MontgomoryMethod(m);\nconst product = montMethod.imul(a, b);\n</code></pre>"},{"location":"reference/primitives/#method-invm","title":"Method invm","text":"<p>Calculates the modular multiplicative inverse of a number in the Montgomery domain.</p> <p><pre><code>invm(a: BigNumber): BigNumber \n</code></pre> See also: BigNumber</p> <p>Returns</p> <p>The modular multiplicative inverse of 'a'.</p> <p>Argument Details</p> <ul> <li>a</li> <li>The number to compute the modular multiplicative inverse of.</li> </ul> <p>Example</p> <pre><code>const montMethod = new MontgomoryMethod(m);\nconst inverse = montMethod.invm(a);\n</code></pre>"},{"location":"reference/primitives/#method-mul","title":"Method mul","text":"<p>Performs the multiplication of two numbers in the Montgomery domain.</p> <p><pre><code>mul(a: BigNumber, b: BigNumber): BigNumber \n</code></pre> See also: BigNumber</p> <p>Returns</p> <p>The result of the multiplication.</p> <p>Argument Details</p> <ul> <li>a</li> <li>The first number to multiply.</li> <li>b</li> <li>The second number to multiply.</li> </ul> <p>Example</p> <pre><code>const montMethod = new MontgomoryMethod(m);\nconst product = montMethod.mul(a, b);\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#class-point","title":"Class: Point","text":"<p><code>Point</code> class is a representation of an elliptic curve point with affine coordinates. It extends the functionality of BasePoint and carries x, y coordinates of point on the curve. It also introduces new methods for handling Point operations in elliptic curve.</p> <pre><code>export default class Point extends BasePoint {\n    x: BigNumber | null;\n    y: BigNumber | null;\n    inf: boolean;\n    static fromDER(bytes: number[]): Point \n    static fromString(str: string): Point \n    static fromX(x: BigNumber | number | number[] | string, odd: boolean): Point \n    static fromJSON(obj: string | any[], isRed: boolean): Point \n    constructor(x: BigNumber | number | number[] | string | null, y: BigNumber | number | number[] | string | null, isRed: boolean = true) \n    validate(): boolean \n    encode(compact: boolean = true, enc?: \"hex\"): number[] | string \n    toString(): string \n    toJSON(): [\n        BigNumber | null,\n        BigNumber | null,\n        {\n            doubles: {\n                step: any;\n                points: any[];\n            } | undefined;\n            naf: {\n                wnd: any;\n                points: any[];\n            } | undefined;\n        }?\n    ] \n    inspect(): string \n    isInfinity(): boolean \n    add(p: Point): Point \n    dbl(): Point \n    getX(): BigNumber \n    getY(): BigNumber \n    mul(k: BigNumber | number | number[] | string): Point \n    mulAdd(k1: BigNumber, p2: Point, k2: BigNumber): Point \n    jmulAdd(k1: BigNumber, p2: Point, k2: BigNumber): JPoint \n    eq(p: Point): boolean \n    neg(_precompute?: boolean): Point \n    dblp(k: number): Point \n    toJ(): JPoint \n}\n</code></pre> <p>See also: BasePoint, BigNumber, encode</p>"},{"location":"reference/primitives/#constructor_5","title":"Constructor","text":"<p><pre><code>constructor(x: BigNumber | number | number[] | string | null, y: BigNumber | number | number[] | string | null, isRed: boolean = true) \n</code></pre> See also: BigNumber</p> <p>Argument Details</p> <ul> <li>x</li> <li>The x-coordinate of the point. May be a number, a BigNumber, a string (which will be interpreted as hex), a number array, or null. If null, an \"Infinity\" point is constructed.</li> <li>y</li> <li>The y-coordinate of the point, similar to x.</li> <li>isRed</li> <li>A boolean indicating if the point is a member of the field of integers modulo the k256 prime. Default is true.</li> </ul> <p>Example</p> <pre><code>new Point('abc123', 'def456');\nnew Point(null, null); // Generates Infinity point.\n</code></pre>"},{"location":"reference/primitives/#property-inf","title":"Property inf","text":"<p>Flag to record if the point is at infinity in the Elliptic Curve.</p> <pre><code>inf: boolean\n</code></pre>"},{"location":"reference/primitives/#property-x_1","title":"Property x","text":"<p>The x-coordinate of the point.</p> <p><pre><code>x: BigNumber | null\n</code></pre> See also: BigNumber</p>"},{"location":"reference/primitives/#property-y_1","title":"Property y","text":"<p>The y-coordinate of the point.</p> <p><pre><code>y: BigNumber | null\n</code></pre> See also: BigNumber</p>"},{"location":"reference/primitives/#method-add_1","title":"Method add","text":"<p>Adds another Point to this Point, returning a new Point.</p> <p><pre><code>add(p: Point): Point \n</code></pre> See also: Point</p> <p>Returns</p> <p>A new Point that results from the addition.</p> <p>Argument Details</p> <ul> <li>p</li> <li>The Point to add to this one.</li> </ul> <p>Example</p> <pre><code>const p1 = new Point(1, 2);\nconst p2 = new Point(2, 3);\nconst result = p1.add(p2);\n</code></pre>"},{"location":"reference/primitives/#method-dbl_1","title":"Method dbl","text":"<p>Doubles the current point.</p> <p><pre><code>dbl(): Point \n</code></pre> See also: Point</p> <p>Example</p> <pre><code>const P = new Point('123', '456');\nconst result = P.dbl();\n</code></pre>"},{"location":"reference/primitives/#method-dblp_1","title":"Method dblp","text":"<p>Performs the \"doubling\" operation on the Point a given number of times. This is used in elliptic curve operations to perform multiplication by 2, multiple times. If the point is at infinity, it simply returns the point because doubling a point at infinity is still infinity.</p> <p><pre><code>dblp(k: number): Point \n</code></pre> See also: Point</p> <p>Returns</p> <p>The Point after 'k' \"doubling\" operations have been performed.</p> <p>Argument Details</p> <ul> <li>k</li> <li>The number of times the \"doubling\" operation is to be performed on the Point.</li> </ul> <p>Example</p> <pre><code>const p = new Point(5, 20);\nconst doubledPoint = p.dblp(10); // returns the point after \"doubled\" 10 times\n</code></pre>"},{"location":"reference/primitives/#method-encode","title":"Method encode","text":"<p>Encodes the coordinates of a point into an array or a hexadecimal string. The details of encoding are determined by the optional compact and enc parameters.</p> <pre><code>encode(compact: boolean = true, enc?: \"hex\"): number[] | string \n</code></pre> <p>Returns</p> <p>If enc is undefined, a byte array representation of the point will be returned. if enc is 'hex', a hexadecimal string representation of the point will be returned.</p> <p>Argument Details</p> <ul> <li>compact</li> <li>If true, an additional prefix byte 0x02 or 0x03 based on the 'y' coordinate being even or odd respectively is used. If false, byte 0x04 is used.</li> <li>enc</li> <li>Expects the string 'hex' if hexadecimal string encoding is required instead of an array of numbers.</li> </ul> <p>Throws</p> <p>Will throw an error if the specified encoding method is not recognized. Expects 'hex'.</p> <p>Example</p> <pre><code>const aPoint = new Point(x, y);\nconst encodedPointArray = aPoint.encode();\nconst encodedPointHex = aPoint.encode(true, 'hex');\n</code></pre>"},{"location":"reference/primitives/#method-eq_1","title":"Method eq","text":"<p>Checks if the Point instance is equal to another given Point.</p> <p><pre><code>eq(p: Point): boolean \n</code></pre> See also: Point</p> <p>Returns</p> <p>Whether the two Point instances are equal. Both the 'x' and 'y' coordinates have to match, and both points have to either be valid or at infinity for equality. If both conditions are true, it returns true, else it returns false.</p> <p>Argument Details</p> <ul> <li>p</li> <li>The Point to be checked if equal to the current instance.</li> </ul> <p>Example</p> <pre><code>const p1 = new Point(5, 20);\nconst p2 = new Point(5, 20);\nconst areEqual = p1.eq(p2); // returns true\n</code></pre>"},{"location":"reference/primitives/#method-fromder","title":"Method fromDER","text":"<p>Creates a point object from a given Array. These numbers can represent coordinates in hex format, or points in multiple established formats. The function verifies the integrity of the provided data and throws errors if inconsistencies are found.</p> <p><pre><code>static fromDER(bytes: number[]): Point \n</code></pre> See also: Point</p> <p>Returns</p> <p>Returns a new point representing the given string.</p> <p>Argument Details</p> <ul> <li>bytes</li> <li>The point representation number array.</li> </ul> <p>Throws</p> <p><code>Error</code> If the point number[] value has a wrong length.</p> <p><code>Error</code> If the point format is unknown.</p> <p>Example</p> <pre><code>const derPoint = [ 2, 18, 123, 108, 125, 83, 1, 251, 164, 214, 16, 119, 200, 216, 210, 193, 251, 193, 129, 67, 97, 146, 210, 216, 77, 254, 18, 6, 150, 190, 99, 198, 128 ];\nconst point = Point.fromDER(derPoint);\n</code></pre>"},{"location":"reference/primitives/#method-fromjson_1","title":"Method fromJSON","text":"<p>Generates a point from a serialized JSON object. The function accounts for different options in the JSON object, including precomputed values for optimization of EC operations, and calls another helper function to turn nested JSON points into proper Point objects.</p> <p><pre><code>static fromJSON(obj: string | any[], isRed: boolean): Point \n</code></pre> See also: Point</p> <p>Returns</p> <p>Returns a new point based on the deserialized JSON object.</p> <p>Argument Details</p> <ul> <li>obj</li> <li>An object or array that holds the data for the point.</li> <li>isRed</li> <li>A boolean to direct how the Point is constructed from the JSON object.</li> </ul> <p>Example</p> <pre><code>const serializedPoint = '{\"x\":52,\"y\":15}';\nconst point = Point.fromJSON(serializedPoint, true);\n</code></pre>"},{"location":"reference/primitives/#method-fromstring_1","title":"Method fromString","text":"<p>Creates a point object from a given string. This string can represent coordinates in hex format, or points in multiple established formats. The function verifies the integrity of the provided data and throws errors if inconsistencies are found.</p> <p><pre><code>static fromString(str: string): Point \n</code></pre> See also: Point</p> <p>Returns</p> <p>Returns a new point representing the given string.</p> <p>Argument Details</p> <ul> <li>str</li> <li>The point representation string.</li> </ul> <p>Throws</p> <p><code>Error</code> If the point string value has a wrong length.</p> <p><code>Error</code> If the point format is unknown.</p> <p>Example</p> <pre><code>const pointStr = 'abcdef';\nconst point = Point.fromString(pointStr);\n</code></pre>"},{"location":"reference/primitives/#method-fromx","title":"Method fromX","text":"<p>Generates a point from an x coordinate and a boolean indicating whether the corresponding y coordinate is odd.</p> <p><pre><code>static fromX(x: BigNumber | number | number[] | string, odd: boolean): Point \n</code></pre> See also: BigNumber, Point</p> <p>Returns</p> <p>Returns the new point.</p> <p>Argument Details</p> <ul> <li>x</li> <li>The x coordinate of the point.</li> <li>odd</li> <li>Boolean indicating whether the corresponding y coordinate is odd or not.</li> </ul> <p>Throws</p> <p><code>Error</code> If the point is invalid.</p> <p>Example</p> <pre><code>const xCoordinate = new BigNumber('10');\nconst point = Point.fromX(xCoordinate, true);\n</code></pre>"},{"location":"reference/primitives/#method-getx","title":"Method getX","text":"<p>Returns X coordinate of point</p> <p><pre><code>getX(): BigNumber \n</code></pre> See also: BigNumber</p> <p>Example</p> <pre><code>const P = new Point('123', '456');\nconst x = P.getX();\n</code></pre>"},{"location":"reference/primitives/#method-gety","title":"Method getY","text":"<p>Returns X coordinate of point</p> <p><pre><code>getY(): BigNumber \n</code></pre> See also: BigNumber</p> <p>Example</p> <pre><code>const P = new Point('123', '456');\nconst x = P.getX();\n</code></pre>"},{"location":"reference/primitives/#method-inspect_1","title":"Method inspect","text":"<p>Provides the point coordinates in a human-readable string format for debugging purposes.</p> <pre><code>inspect(): string \n</code></pre> <p>Returns</p> <p>String of the format '', or '' if the point is at infinity. <p>Example</p> <pre><code>const aPoint = new Point(x, y);\nconsole.log(aPoint.inspect());\n</code></pre>"},{"location":"reference/primitives/#method-isinfinity_1","title":"Method isInfinity","text":"<p>Checks if the point is at infinity.</p> <pre><code>isInfinity(): boolean \n</code></pre> <p>Returns</p> <p>Returns whether or not the point is at infinity.</p> <p>Example</p> <pre><code>const p = new Point(null, null);\nconsole.log(p.isInfinity()); // outputs: true\n</code></pre>"},{"location":"reference/primitives/#method-jmuladd","title":"Method jmulAdd","text":"<p>Performs the Jacobian multiplication and addition operation in a single step. Instead of returning a regular Point, the result is a JacobianPoint.</p> <p><pre><code>jmulAdd(k1: BigNumber, p2: Point, k2: BigNumber): JPoint \n</code></pre> See also: BigNumber, Point</p> <p>Returns</p> <p>A JacobianPoint that results from the combined multiplication and addition operation.</p> <p>Argument Details</p> <ul> <li>k1</li> <li>The scalar value to multiply this Point by.</li> <li>p2</li> <li>The other Point to be involved in the operation</li> <li>k2</li> <li>The scalar value to multiply the Point p2 by.</li> </ul> <p>Example</p> <pre><code>const p1 = new Point(1, 2);\nconst p2 = new Point(2, 3);\nconst result = p1.jmulAdd(2, p2, 3);\n</code></pre>"},{"location":"reference/primitives/#method-mul_1","title":"Method mul","text":"<p>Multiplies this Point by a scalar value, returning a new Point.</p> <p><pre><code>mul(k: BigNumber | number | number[] | string): Point \n</code></pre> See also: BigNumber, Point</p> <p>Returns</p> <p>A new Point that results from the multiplication.</p> <p>Argument Details</p> <ul> <li>k</li> <li>The scalar value to multiply this Point by.</li> </ul> <p>Example</p> <pre><code>const p = new Point(1, 2);\nconst result = p.mul(2); // this doubles the Point\n</code></pre>"},{"location":"reference/primitives/#method-muladd","title":"Method mulAdd","text":"<p>Performs a multiplication and addition operation in a single step. Multiplies this Point by k1, adds the resulting Point to the result of p2 multiplied by k2.</p> <p><pre><code>mulAdd(k1: BigNumber, p2: Point, k2: BigNumber): Point \n</code></pre> See also: BigNumber, Point</p> <p>Returns</p> <p>A Point that results from the combined multiplication and addition operations.</p> <p>Argument Details</p> <ul> <li>k1</li> <li>The scalar value to multiply this Point by.</li> <li>p2</li> <li>The other Point to be involved in the operation.</li> <li>k2</li> <li>The scalar value to multiply the Point p2 by.</li> </ul> <p>Example</p> <pre><code>const p1 = new Point(1, 2);\nconst p2 = new Point(2, 3);\nconst result = p1.mulAdd(2, p2, 3);\n</code></pre>"},{"location":"reference/primitives/#method-neg_1","title":"Method neg","text":"<p>Negate a point. The negation of a point P is the mirror of P about x-axis.</p> <p><pre><code>neg(_precompute?: boolean): Point \n</code></pre> See also: Point</p> <p>Example</p> <pre><code>const P = new Point('123', '456');\nconst result = P.neg();\n</code></pre>"},{"location":"reference/primitives/#method-toj","title":"Method toJ","text":"<p>Converts the point to a Jacobian point. If the point is at infinity, the corresponding Jacobian point will also be at infinity.</p> <pre><code>toJ(): JPoint \n</code></pre> <p>Returns</p> <p>Returns a new Jacobian point based on the current point.</p> <p>Example</p> <pre><code>const point = new Point(xCoordinate, yCoordinate);\nconst jacobianPoint = point.toJ();\n</code></pre>"},{"location":"reference/primitives/#method-tojson_1","title":"Method toJSON","text":"<p>Exports the x and y coordinates of the point, and the precomputed doubles and non-adjacent form (NAF) for optimization. The output is an array.</p> <p><pre><code>toJSON(): [\n    BigNumber | null,\n    BigNumber | null,\n    {\n        doubles: {\n            step: any;\n            points: any[];\n        } | undefined;\n        naf: {\n            wnd: any;\n            points: any[];\n        } | undefined;\n    }?\n] \n</code></pre> See also: BigNumber</p> <p>Returns</p> <p>An Array where first two elements are the coordinates of the point and optional third element is an object with doubles and NAF points.</p> <p>Example</p> <pre><code>const aPoint = new Point(x, y);\nconst jsonPoint = aPoint.toJSON();\n</code></pre>"},{"location":"reference/primitives/#method-tostring_1","title":"Method toString","text":"<p>function toString() { [native code] }</p> <p>Converts the point coordinates to a hexadecimal string. A wrapper method for encode. Byte 0x02 or 0x03 is used as prefix based on the 'y' coordinate being even or odd respectively.</p> <pre><code>toString(): string \n</code></pre> <p>Returns</p> <p>A hexadecimal string representation of the point coordinates.</p> <p>Example</p> <pre><code>const aPoint = new Point(x, y);\nconst stringPoint = aPoint.toString();\n</code></pre>"},{"location":"reference/primitives/#method-validate","title":"Method validate","text":"<p>Validates if a point belongs to the curve. Follows the short Weierstrass equation for elliptic curves: y^2 = x^3 + ax + b.</p> <pre><code>validate(): boolean \n</code></pre> <p>Returns</p> <p>true if the point is on the curve, false otherwise.</p> <p>Example</p> <pre><code>const aPoint = new Point(x, y);\nconst isValid = aPoint.validate();\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#class-pointinfinitefield","title":"Class: PointInFiniteField","text":"<pre><code>export class PointInFiniteField {\n    x: BigNumber;\n    y: BigNumber;\n    constructor(x: BigNumber, y: BigNumber) \n    toString(): string \n    static fromString(str: string): PointInFiniteField \n}\n</code></pre> <p>See also: BigNumber</p>"},{"location":"reference/primitives/#method-tostring_2","title":"Method toString","text":"<p>function toString() { [native code] }</p> <pre><code>toString(): string \n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#class-polynomial","title":"Class: Polynomial","text":"<p>Polynomial class</p> <p>This class is used to create a polynomial with a given threshold and a private key. The polynomial is used to create shares of the private key.</p> <p>Example</p> <pre><code>const key = new PrivateKey()\nconst threshold = 2\nconst polynomial = new Polynomial(key, threshold)\n</code></pre> <pre><code>export default class Polynomial {\n    readonly points: PointInFiniteField[];\n    readonly threshold: number;\n    constructor(points: PointInFiniteField[], threshold?: number) \n    static fromPrivateKey(key: PrivateKey, threshold: number): Polynomial \n    valueAt(x: BigNumber): BigNumber \n}\n</code></pre> <p>See also: BigNumber, PointInFiniteField, PrivateKey</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#class-privatekey","title":"Class: PrivateKey","text":"<p>Represents a Private Key, which is a secret that can be used to generate signatures in a cryptographic system.</p> <p>The <code>PrivateKey</code> class extends from the <code>BigNumber</code> class. It offers methods to create signatures, verify them, create a corresponding public key and derive a shared secret from a public key.</p> <pre><code>export default class PrivateKey extends BigNumber {\n    static fromRandom(): PrivateKey \n    static fromString(str: string, base: number | \"hex\" = \"hex\"): PrivateKey \n    static fromHex(str: string): PrivateKey \n    static fromWif(wif: string, prefixLength: number = 1): PrivateKey \n    constructor(number: BigNumber | number | string | number[] = 0, base: number | \"be\" | \"le\" | \"hex\" = 10, endian: \"be\" | \"le\" = \"be\", modN: \"apply\" | \"nocheck\" | \"error\" = \"apply\") \n    checkInField(): {\n        inField: boolean;\n        modN: BigNumber;\n    } \n    isValid(): boolean \n    sign(msg: number[] | string, enc?: \"hex\" | \"utf8\", forceLowS: boolean = true, customK?: ((iter: number) =&gt; BigNumber) | BigNumber): Signature \n    verify(msg: number[] | string, sig: Signature, enc?: \"hex\"): boolean \n    toPublicKey(): PublicKey \n    toWif(prefix: number[] = [128]): string \n    toAddress(prefix: number[] | string = [0]): string \n    toHex(): string \n    toString(base: number | \"hex\" = \"hex\", padding: number = 64): string \n    deriveSharedSecret(key: PublicKey): Point \n    deriveChild(publicKey: PublicKey, invoiceNumber: string, cacheSharedSecret?: ((priv: PrivateKey, pub: Point, point: Point) =&gt; void), retrieveCachedSharedSecret?: ((priv: PrivateKey, pub: Point) =&gt; (Point | undefined))): PrivateKey \n    toKeyShares(threshold: number, totalShares: number): KeyShares \n    toBackupShares(threshold: number, totalShares: number): string[] \n    static fromBackupShares(shares: string[]): PrivateKey \n    static fromKeyShares(keyShares: KeyShares): PrivateKey \n}\n</code></pre> <p>See also: BigNumber, KeyShares, Point, PublicKey, Signature, modN, sign, toHex, verify</p>"},{"location":"reference/primitives/#constructor_6","title":"Constructor","text":"<p><pre><code>constructor(number: BigNumber | number | string | number[] = 0, base: number | \"be\" | \"le\" | \"hex\" = 10, endian: \"be\" | \"le\" = \"be\", modN: \"apply\" | \"nocheck\" | \"error\" = \"apply\") \n</code></pre> See also: BigNumber, modN</p> <p>Argument Details</p> <ul> <li>number</li> <li>The number (various types accepted) to construct a BigNumber from. Default is 0.</li> <li>base</li> <li>The base of number provided. By default is 10. Ignored if number is BigNumber.</li> <li>endian</li> <li>The endianness provided. By default is 'big endian'. Ignored if number is BigNumber.</li> <li>modN</li> <li>Optional. Default 'apply. If 'apply', apply modN to input to guarantee a valid PrivateKey. If 'error', if input is out of field throw new Error('Input is out of field'). If 'nocheck', assumes input is in field.</li> </ul> <p>Example</p> <pre><code>import PrivateKey from './PrivateKey';\nimport BigNumber from './BigNumber';\nconst privKey = new PrivateKey(new BigNumber('123456', 10, 'be'));\n</code></pre>"},{"location":"reference/primitives/#method-checkinfield","title":"Method checkInField","text":"<p>A utility function to check that the value of this PrivateKey lies in the field limited by curve.n</p> <p><pre><code>checkInField(): {\n    inField: boolean;\n    modN: BigNumber;\n} \n</code></pre> See also: BigNumber, modN</p> <p>Returns</p> <p>, modN } where modN is this PrivateKey's current BigNumber value mod curve.n, and inField is true only if modN equals current BigNumber value.</p>"},{"location":"reference/primitives/#method-derivechild","title":"Method deriveChild","text":"<p>Derives a child key with BRC-42.</p> <p><pre><code>deriveChild(publicKey: PublicKey, invoiceNumber: string, cacheSharedSecret?: ((priv: PrivateKey, pub: Point, point: Point) =&gt; void), retrieveCachedSharedSecret?: ((priv: PrivateKey, pub: Point) =&gt; (Point | undefined))): PrivateKey \n</code></pre> See also: Point, PrivateKey, PublicKey</p> <p>Returns</p> <p>The derived child key.</p> <p>Argument Details</p> <ul> <li>publicKey</li> <li>The public key of the other party</li> <li>invoiceNumber</li> <li>The invoice number used to derive the child key</li> <li>cacheSharedSecret</li> <li>Optional function to cache shared secrets</li> <li>retrieveCachedSharedSecret</li> <li>Optional function to retrieve shared secrets from the cache</li> </ul>"},{"location":"reference/primitives/#method-derivesharedsecret","title":"Method deriveSharedSecret","text":"<p>Derives a shared secret from the public key.</p> <p><pre><code>deriveSharedSecret(key: PublicKey): Point \n</code></pre> See also: Point, PublicKey</p> <p>Returns</p> <p>The derived shared secret (a point on the curve).</p> <p>Argument Details</p> <ul> <li>key</li> <li>The public key to derive the shared secret from.</li> </ul> <p>Throws</p> <p>Will throw an error if the public key is not valid.</p> <p>Example</p> <pre><code>const privateKey = PrivateKey.fromRandom();\nconst publicKey = privateKey.toPublicKey();\nconst sharedSecret = privateKey.deriveSharedSecret(publicKey);\n</code></pre>"},{"location":"reference/primitives/#method-frombackupshares","title":"Method fromBackupShares","text":"<p><pre><code>static fromBackupShares(shares: string[]): PrivateKey \n</code></pre> See also: PrivateKey</p> <p>Returns</p> <p>PrivateKey</p> <p>Example</p> <pre><code>const share1 = '3znuzt7DZp8HzZTfTh5MF9YQKNX3oSxTbSYmSRGrH2ev.2Nm17qoocmoAhBTCs8TEBxNXCskV9N41rB2PckcgYeqV.2.35449bb9'\nconst share2 = 'Cm5fuUc39X5xgdedao8Pr1kvCSm8Gk7Cfenc7xUKcfLX.2juyK9BxCWn2DiY5JUAgj9NsQ77cc9bWksFyW45haXZm.2.35449bb9'\n\nconst recoveredKey = PrivateKey.fromBackupShares([share1, share2])\n</code></pre>"},{"location":"reference/primitives/#method-fromhex_1","title":"Method fromHex","text":"<p>Generates a private key from a hexadecimal string.</p> <p><pre><code>static fromHex(str: string): PrivateKey \n</code></pre> See also: PrivateKey</p> <p>Returns</p> <p>The generated Private Key instance.</p> <p>Argument Details</p> <ul> <li>str</li> <li>The hexadecimal string representing the private key. The string must represent a valid private key in big-endian format.</li> </ul> <p>Throws</p> <p>If the string is not a valid hexadecimal or represents an invalid private key.</p>"},{"location":"reference/primitives/#method-fromkeyshares","title":"Method fromKeyShares","text":"<p>Combines shares to reconstruct the private key.</p> <p><pre><code>static fromKeyShares(keyShares: KeyShares): PrivateKey \n</code></pre> See also: KeyShares, PrivateKey</p> <p>Returns</p> <p>The reconstructed private key.</p> <p>Argument Details</p> <ul> <li>shares</li> <li>An array of points (shares) to be used to reconstruct the private key.</li> <li>threshold</li> <li>The minimum number of shares required to reconstruct the private key.</li> </ul>"},{"location":"reference/primitives/#method-fromrandom","title":"Method fromRandom","text":"<p>Generates a private key randomly.</p> <p><pre><code>static fromRandom(): PrivateKey \n</code></pre> See also: PrivateKey</p> <p>Returns</p> <p>The newly generated Private Key.</p> <p>Example</p> <pre><code>const privateKey = PrivateKey.fromRandom();\n</code></pre>"},{"location":"reference/primitives/#method-fromstring_2","title":"Method fromString","text":"<p>Generates a private key from a string.</p> <p><pre><code>static fromString(str: string, base: number | \"hex\" = \"hex\"): PrivateKey \n</code></pre> See also: PrivateKey</p> <p>Returns</p> <p>The generated Private Key.</p> <p>Argument Details</p> <ul> <li>str</li> <li>The string to generate the private key from.</li> <li>base</li> <li>The base of the string.</li> </ul> <p>Throws</p> <p>Will throw an error if the string is not valid.</p>"},{"location":"reference/primitives/#method-fromwif","title":"Method fromWif","text":"<p>Generates a private key from a WIF (Wallet Import Format) string.</p> <p><pre><code>static fromWif(wif: string, prefixLength: number = 1): PrivateKey \n</code></pre> See also: PrivateKey</p> <p>Returns</p> <p>The generated Private Key.</p> <p>Argument Details</p> <ul> <li>wif</li> <li>The WIF string to generate the private key from.</li> <li>base</li> <li>The base of the string.</li> </ul> <p>Throws</p> <p>Will throw an error if the string is not a valid WIF.</p>"},{"location":"reference/primitives/#method-isvalid","title":"Method isValid","text":"<pre><code>isValid(): boolean \n</code></pre> <p>Returns</p> <p>true if the PrivateKey's current BigNumber value lies in the field limited by curve.n</p>"},{"location":"reference/primitives/#method-sign","title":"Method sign","text":"<p>Signs a message using the private key.</p> <p><pre><code>sign(msg: number[] | string, enc?: \"hex\" | \"utf8\", forceLowS: boolean = true, customK?: ((iter: number) =&gt; BigNumber) | BigNumber): Signature \n</code></pre> See also: BigNumber, Signature</p> <p>Returns</p> <p>A digital signature generated from the hash of the message and the private key.</p> <p>Argument Details</p> <ul> <li>msg</li> <li>The message (array of numbers or string) to be signed.</li> <li>enc</li> <li>If 'hex' the string will be treated as hex, utf8 otherwise.</li> <li>forceLowS</li> <li>If true (the default), the signature will be forced to have a low S value.</li> <li>customK</li> <li>\u2014 If provided, uses a custom K-value for the signature. Provie a function that returns a BigNumber, or the BigNumber itself.</li> </ul> <p>Example</p> <pre><code>const privateKey = PrivateKey.fromRandom();\nconst signature = privateKey.sign('Hello, World!');\n</code></pre>"},{"location":"reference/primitives/#method-toaddress","title":"Method toAddress","text":"<p>Base58Check encodes the hash of the public key associated with this private key with a prefix to indicate locking script type. Defaults to P2PKH for mainnet, otherwise known as a \"Bitcoin Address\".</p> <pre><code>toAddress(prefix: number[] | string = [0]): string \n</code></pre> <p>Returns</p> <p>Returns the address encoding associated with the hash of the public key associated with this private key.</p> <p>Argument Details</p> <ul> <li>prefix</li> <li>defaults to [0x00] for mainnet, set to [0x6f] for testnet or use the strings 'testnet' or 'mainnet'</li> </ul> <p>Example</p> <pre><code>const address = privkey.toAddress()\nconst address = privkey.toAddress('mainnet')\nconst testnetAddress = privkey.toAddress([0x6f])\nconst testnetAddress = privkey.toAddress('testnet')\n</code></pre>"},{"location":"reference/primitives/#method-tobackupshares","title":"Method toBackupShares","text":"<pre><code>toBackupShares(threshold: number, totalShares: number): string[] \n</code></pre> <p>Argument Details</p> <ul> <li>threshold</li> <li>The number of shares which will be required to reconstruct the private key.</li> <li>totalShares</li> <li>The number of shares to generate for distribution.</li> </ul>"},{"location":"reference/primitives/#method-tohex_1","title":"Method toHex","text":"<p>Converts this PrivateKey to a hexadecimal string.</p> <pre><code>toHex(): string \n</code></pre> <p>Returns</p> <p>Returns a string representing the hexadecimal value of this BigNumber.</p> <p>Argument Details</p> <ul> <li>length</li> <li>The minimum length of the hex string</li> </ul> <p>Example</p> <pre><code>const bigNumber = new BigNumber(255);\nconst hex = bigNumber.toHex();\n</code></pre>"},{"location":"reference/primitives/#method-tokeyshares","title":"Method toKeyShares","text":"<p>Splits the private key into shares using Shamir's Secret Sharing Scheme.</p> <p><pre><code>toKeyShares(threshold: number, totalShares: number): KeyShares \n</code></pre> See also: KeyShares</p> <p>Returns</p> <p>An array of shares.</p> <p>Argument Details</p> <ul> <li>threshold</li> <li>The minimum number of shares required to reconstruct the private key.</li> <li>totalShares</li> <li>The total number of shares to generate.</li> <li>prime</li> <li>The prime number to be used in Shamir's Secret Sharing Scheme.</li> </ul> <p>Example</p> <pre><code>const key = PrivateKey.fromRandom()\nconst shares = key.toKeyShares(2, 5)\n</code></pre>"},{"location":"reference/primitives/#method-topublickey","title":"Method toPublicKey","text":"<p>Converts the private key to its corresponding public key.</p> <p>The public key is generated by multiplying the base point G of the curve and the private key.</p> <p><pre><code>toPublicKey(): PublicKey \n</code></pre> See also: PublicKey</p> <p>Returns</p> <p>The generated PublicKey.</p> <p>Example</p> <pre><code>const privateKey = PrivateKey.fromRandom();\nconst publicKey = privateKey.toPublicKey();\n</code></pre>"},{"location":"reference/primitives/#method-tostring_3","title":"Method toString","text":"<p>function toString() { [native code] }</p> <p>Converts this PrivateKey to a string representation.</p> <pre><code>toString(base: number | \"hex\" = \"hex\", padding: number = 64): string \n</code></pre> <p>Returns</p> <p>A string representation of the PrivateKey in the specified base, padded to the specified length.</p> <p>Argument Details</p> <ul> <li>base</li> <li>The base for representing the number. Default is hexadecimal ('hex').</li> <li>padding</li> <li>The minimum number of digits for the output string. Default is 64, ensuring a 256-bit representation in hexadecimal.</li> </ul>"},{"location":"reference/primitives/#method-towif","title":"Method toWif","text":"<p>Converts the private key to a Wallet Import Format (WIF) string.</p> <p>Base58Check encoding is used for encoding the private key. The prefix</p> <pre><code>toWif(prefix: number[] = [128]): string \n</code></pre> <p>Returns</p> <p>The WIF string.</p> <p>Argument Details</p> <ul> <li>prefix</li> <li>defaults to [0x80] for mainnet, set it to [0xef] for testnet.</li> </ul> <p>Throws</p> <p>Error('Value is out of field') if current BigNumber value is out of field limited by curve.n</p> <p>Example</p> <pre><code>const privateKey = PrivateKey.fromRandom();\nconst wif = privateKey.toWif();\nconst testnetWif = privateKey.toWif([0xef]);\n</code></pre>"},{"location":"reference/primitives/#method-verify","title":"Method verify","text":"<p>Verifies a message's signature using the public key associated with this private key.</p> <p><pre><code>verify(msg: number[] | string, sig: Signature, enc?: \"hex\"): boolean \n</code></pre> See also: Signature</p> <p>Returns</p> <p>Whether or not the signature is valid.</p> <p>Argument Details</p> <ul> <li>msg</li> <li>The original message which has been signed.</li> <li>sig</li> <li>The signature to be verified.</li> <li>enc</li> <li>The data encoding method.</li> </ul> <p>Example</p> <pre><code>const privateKey = PrivateKey.fromRandom();\nconst signature = privateKey.sign('Hello, World!');\nconst isSignatureValid = privateKey.verify('Hello, World!', signature);\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#class-publickey","title":"Class: PublicKey","text":"<p>The PublicKey class extends the Point class. It is used in public-key cryptography to derive shared secret, verify message signatures, and encode the public key in the DER format. The class comes with static methods to generate PublicKey instances from private keys or from strings.</p> <pre><code>export default class PublicKey extends Point {\n    static fromPrivateKey(key: PrivateKey): PublicKey \n    static fromString(str: string): PublicKey \n    static fromDER(bytes: number[]): PublicKey \n    constructor(x: Point | BigNumber | number | number[] | string | null, y: BigNumber | number | number[] | string | null = null, isRed: boolean = true) \n    deriveSharedSecret(priv: PrivateKey): Point \n    verify(msg: number[] | string, sig: Signature, enc?: \"hex\" | \"utf8\"): boolean \n    toDER(enc?: \"hex\" | undefined): number[] | string \n    toHash(enc?: \"hex\"): number[] | string \n    toAddress(prefix: number[] | string = [0]): string \n    deriveChild(privateKey: PrivateKey, invoiceNumber: string, cacheSharedSecret?: ((priv: PrivateKey, pub: Point, point: Point) =&gt; void), retrieveCachedSharedSecret?: ((priv: PrivateKey, pub: Point) =&gt; (Point | undefined))): PublicKey \n    static fromMsgHashAndCompactSignature(msgHash: BigNumber, signature: number[] | string, enc?: \"hex\" | \"base64\"): PublicKey \n}\n</code></pre> <p>See also: BigNumber, Point, PrivateKey, Signature, verify</p>"},{"location":"reference/primitives/#constructor_7","title":"Constructor","text":"<p><pre><code>constructor(x: Point | BigNumber | number | number[] | string | null, y: BigNumber | number | number[] | string | null = null, isRed: boolean = true) \n</code></pre> See also: BigNumber, Point</p> <p>Argument Details</p> <ul> <li>x</li> <li>A point or the x-coordinate of the point. May be a number, a BigNumber, a string (which will be interpreted as hex), a number array, or null. If null, an \"Infinity\" point is constructed.</li> <li>y</li> <li>If x is not a point, the y-coordinate of the point, similar to x.</li> <li>isRed</li> <li>A boolean indicating if the point is a member of the field of integers modulo the k256 prime. Default is true.</li> </ul> <p>Example</p> <pre><code>new PublicKey(point1);\nnew PublicKey('abc123', 'def456');\n</code></pre>"},{"location":"reference/primitives/#method-derivechild_1","title":"Method deriveChild","text":"<p>Derives a child key with BRC-42.</p> <p><pre><code>deriveChild(privateKey: PrivateKey, invoiceNumber: string, cacheSharedSecret?: ((priv: PrivateKey, pub: Point, point: Point) =&gt; void), retrieveCachedSharedSecret?: ((priv: PrivateKey, pub: Point) =&gt; (Point | undefined))): PublicKey \n</code></pre> See also: Point, PrivateKey, PublicKey</p> <p>Returns</p> <p>The derived child key.</p> <p>Argument Details</p> <ul> <li>privateKey</li> <li>The private key of the other party</li> <li>invoiceNumber</li> <li>The invoice number used to derive the child key</li> <li>cacheSharedSecret</li> <li>Optional function to cache shared secrets</li> <li>retrieveCachedSharedSecret</li> <li>Optional function to retrieve shared secrets from the cache</li> </ul>"},{"location":"reference/primitives/#method-derivesharedsecret_1","title":"Method deriveSharedSecret","text":"<p>Derive a shared secret from a public key and a private key for use in symmetric encryption. This method multiplies the public key (an instance of Point) with a private key.</p> <p><pre><code>deriveSharedSecret(priv: PrivateKey): Point \n</code></pre> See also: Point, PrivateKey</p> <p>Returns</p> <p>Returns the Point representing the shared secret.</p> <p>Argument Details</p> <ul> <li>priv</li> <li>The private key to use in deriving the shared secret.</li> </ul> <p>Throws</p> <p>Will throw an error if the public key is not valid for ECDH secret derivation.</p> <p>Example</p> <pre><code>const myPrivKey = new PrivateKey(...)\nconst sharedSecret = myPubKey.deriveSharedSecret(myPrivKey)\n</code></pre>"},{"location":"reference/primitives/#method-fromder_1","title":"Method fromDER","text":"<p>Static factory method to create a PublicKey instance from a number array.</p> <p><pre><code>static fromDER(bytes: number[]): PublicKey \n</code></pre> See also: PublicKey</p> <p>Returns</p> <p>Returns the PublicKey created from the number array.</p> <p>Argument Details</p> <ul> <li>bytes</li> <li>A number array representing a public key.</li> </ul> <p>Example</p> <pre><code>const myPubKey = PublicKey.fromString(\"03....\")\n</code></pre>"},{"location":"reference/primitives/#method-frommsghashandcompactsignature","title":"Method fromMsgHashAndCompactSignature","text":"<p>Takes an array of numbers or a string and returns a new PublicKey instance. This method will throw an error if the Compact encoding is invalid. If a string is provided, it is assumed to represent a hexadecimal sequence. compactByte value 27-30 means uncompressed public key. 31-34 means compressed public key. The range represents the recovery param which can be 0,1,2,3.</p> <p><pre><code>static fromMsgHashAndCompactSignature(msgHash: BigNumber, signature: number[] | string, enc?: \"hex\" | \"base64\"): PublicKey \n</code></pre> See also: BigNumber, PublicKey</p> <p>Returns</p> <p>A PublicKey instance derived from the message hash and compact signature.</p> <p>Argument Details</p> <ul> <li>msgHash</li> <li>The message hash which was signed.</li> <li>signature</li> <li>The signature in compact format.</li> <li>enc</li> <li>The encoding of the signature string.</li> </ul> <p>Example</p> <pre><code>const publicKey = Signature.fromMsgHashAndCompactSignature(msgHash, 'IMOl2mVKfDgsSsHT4uIYBNN4e...', 'base64');\n</code></pre>"},{"location":"reference/primitives/#method-fromprivatekey","title":"Method fromPrivateKey","text":"<p>Static factory method to derive a public key from a private key. It multiplies the generator point 'g' on the elliptic curve by the private key.</p> <p><pre><code>static fromPrivateKey(key: PrivateKey): PublicKey \n</code></pre> See also: PrivateKey, PublicKey</p> <p>Returns</p> <p>Returns the PublicKey derived from the given PrivateKey.</p> <p>Argument Details</p> <ul> <li>key</li> <li>The private key from which to derive the public key.</li> </ul> <p>Example</p> <pre><code>const myPrivKey = new PrivateKey(...)\nconst myPubKey = PublicKey.fromPrivateKey(myPrivKey)\n</code></pre>"},{"location":"reference/primitives/#method-fromstring_3","title":"Method fromString","text":"<p>Static factory method to create a PublicKey instance from a string.</p> <p><pre><code>static fromString(str: string): PublicKey \n</code></pre> See also: PublicKey</p> <p>Returns</p> <p>Returns the PublicKey created from the string.</p> <p>Argument Details</p> <ul> <li>str</li> <li>A string representing a public key.</li> </ul> <p>Example</p> <pre><code>const myPubKey = PublicKey.fromString(\"03....\")\n</code></pre>"},{"location":"reference/primitives/#method-toaddress_1","title":"Method toAddress","text":"<p>Base58Check encodes the hash of the public key with a prefix to indicate locking script type. Defaults to P2PKH for mainnet, otherwise known as a \"Bitcoin Address\".</p> <pre><code>toAddress(prefix: number[] | string = [0]): string \n</code></pre> <p>Returns</p> <p>Returns the address encoding associated with the hash of the public key.</p> <p>Argument Details</p> <ul> <li>prefix</li> <li>defaults to [0x00] for mainnet, set to [0x6f] for testnet or use the strings 'mainnet' or 'testnet'</li> </ul> <p>Example</p> <pre><code>const address = pubkey.toAddress()\nconst address = pubkey.toAddress('mainnet')\nconst testnetAddress = pubkey.toAddress([0x6f])\nconst testnetAddress = pubkey.toAddress('testnet')\n</code></pre>"},{"location":"reference/primitives/#method-toder","title":"Method toDER","text":"<p>Encode the public key to DER (Distinguished Encoding Rules) format.</p> <pre><code>toDER(enc?: \"hex\" | undefined): number[] | string \n</code></pre> <p>Returns</p> <p>Returns the DER-encoded public key in number array or string.</p> <p>Argument Details</p> <ul> <li>enc</li> <li>The encoding of the DER string. undefined = number array, 'hex' = hex string.</li> </ul> <p>Example</p> <pre><code>const derPublicKey = myPubKey.toDER()\n</code></pre>"},{"location":"reference/primitives/#method-tohash","title":"Method toHash","text":"<p>Hash sha256 and ripemd160 of the public key.</p> <pre><code>toHash(enc?: \"hex\"): number[] | string \n</code></pre> <p>Returns</p> <p>Returns the hash of the public key.</p> <p>Example</p> <pre><code>const publicKeyHash = pubkey.toHash()\n</code></pre>"},{"location":"reference/primitives/#method-verify_1","title":"Method verify","text":"<p>Verify a signature of a message using this public key.</p> <p><pre><code>verify(msg: number[] | string, sig: Signature, enc?: \"hex\" | \"utf8\"): boolean \n</code></pre> See also: Signature</p> <p>Returns</p> <p>Returns true if the signature is verified successfully, otherwise false.</p> <p>Argument Details</p> <ul> <li>msg</li> <li>The message to verify. It can be a string or an array of numbers.</li> <li>sig</li> <li>The Signature of the message that needs verification.</li> <li>enc</li> <li>The encoding of the message. It defaults to 'utf8'.</li> </ul> <p>Example</p> <pre><code>const myMessage = \"Hello, world!\"\nconst mySignature = new Signature(...)\nconst isVerified = myPubKey.verify(myMessage, mySignature)\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#class-ripemd160","title":"Class: RIPEMD160","text":"<p>An implementation of RIPEMD160 cryptographic hash function. Extends the BaseHash class. It provides a way to compute a 'digest' for any kind of input data; transforming the data into a unique output of fixed size. The output is deterministic; it will always be the same for the same input.</p> <p>Example</p> <pre><code>const ripemd160 = new RIPEMD160();\n</code></pre> <pre><code>export class RIPEMD160 extends BaseHash {\n    h: number[];\n    constructor() \n    _update(msg: number[], start: number): void \n    _digest(): number[] \n    _digestHex(): string \n}\n</code></pre>"},{"location":"reference/primitives/#property-h","title":"Property h","text":"<p>Array that is updated iteratively as part of hashing computation.</p> <pre><code>h: number[]\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#class-reader","title":"Class: Reader","text":"<pre><code>export class Reader {\n    public bin: number[];\n    public pos: number;\n    constructor(bin: number[] = [], pos: number = 0) \n    public eof(): boolean \n    public read(len = this.length): number[] \n    public readReverse(len = this.length): number[] \n    public readUInt8(): number \n    public readInt8(): number \n    public readUInt16BE(): number \n    public readInt16BE(): number \n    public readUInt16LE(): number \n    public readInt16LE(): number \n    public readUInt32BE(): number \n    public readInt32BE(): number \n    public readUInt32LE(): number \n    public readInt32LE(): number \n    public readUInt64BEBn(): BigNumber \n    public readUInt64LEBn(): BigNumber \n    public readInt64LEBn(): BigNumber \n    public readVarIntNum(signed: boolean = true): number \n    public readVarInt(): number[] \n    public readVarIntBn(): BigNumber \n}\n</code></pre> <p>See also: BigNumber</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#class-reductioncontext","title":"Class: ReductionContext","text":"<p>A base reduction engine that provides several arithmetic operations over big numbers under a modulus context. It's particularly suitable for calculations required in cryptography algorithms and encoding schemas.</p> <pre><code>export default class ReductionContext {\n    prime: Mersenne | null;\n    m: BigNumber;\n    constructor(m: BigNumber | \"k256\") \n    verify1(a: BigNumber): void \n    verify2(a: BigNumber, b: BigNumber): void \n    imod(a: BigNumber): BigNumber \n    neg(a: BigNumber): BigNumber \n    add(a: BigNumber, b: BigNumber): BigNumber \n    iadd(a: BigNumber, b: BigNumber): BigNumber \n    sub(a: BigNumber, b: BigNumber): BigNumber \n    isub(a: BigNumber, b: BigNumber): BigNumber \n    shl(a: BigNumber, num: number): BigNumber \n    imul(a: BigNumber, b: BigNumber): BigNumber \n    mul(a: BigNumber, b: BigNumber): BigNumber \n    isqr(a: BigNumber): BigNumber \n    sqr(a: BigNumber): BigNumber \n    sqrt(a: BigNumber): BigNumber \n    invm(a: BigNumber): BigNumber \n    pow(a: BigNumber, num: BigNumber): BigNumber \n    convertTo(num: BigNumber): BigNumber \n    convertFrom(num: BigNumber): BigNumber \n}\n</code></pre> <p>See also: BigNumber, Mersenne</p>"},{"location":"reference/primitives/#constructor_8","title":"Constructor","text":"<p>Constructs a new ReductionContext.</p> <p><pre><code>constructor(m: BigNumber | \"k256\") \n</code></pre> See also: BigNumber</p> <p>Argument Details</p> <ul> <li>m</li> <li>A BigNumber representing the modulus, or 'k256' to create a context for Koblitz curve.</li> </ul> <p>Example</p> <pre><code>new ReductionContext(new BigNumber(11));\nnew ReductionContext('k256');\n</code></pre>"},{"location":"reference/primitives/#property-m","title":"Property m","text":"<p>The modulus used for reduction operations.</p> <p><pre><code>m: BigNumber\n</code></pre> See also: BigNumber</p>"},{"location":"reference/primitives/#property-prime","title":"Property prime","text":"<p>The prime number utilised in the reduction context, typically an instance of Mersenne class.</p> <p><pre><code>prime: Mersenne | null\n</code></pre> See also: Mersenne</p>"},{"location":"reference/primitives/#method-add_2","title":"Method add","text":"<p>Performs the addition operation on two BigNumbers in the reduction context.</p> <p><pre><code>add(a: BigNumber, b: BigNumber): BigNumber \n</code></pre> See also: BigNumber</p> <p>Returns</p> <p>Returns the result of 'a + b' in the reduction context.</p> <p>Argument Details</p> <ul> <li>a</li> <li>First BigNumber to add.</li> <li>b</li> <li>Second BigNumber to add.</li> </ul> <p>Example</p> <pre><code>const context = new ReductionContext(new BigNumber(5));\ncontext.add(new BigNumber(2), new BigNumber(4)); // Returns 1\n</code></pre>"},{"location":"reference/primitives/#method-convertfrom_1","title":"Method convertFrom","text":"<p>Converts a BigNumber from reduction context to its regular form.</p> <p><pre><code>convertFrom(num: BigNumber): BigNumber \n</code></pre> See also: BigNumber</p> <p>Returns</p> <p>Returns the converted BigNumber in its regular form.</p> <p>Argument Details</p> <ul> <li>num</li> <li>The BigNumber to convert from the reduction context.</li> </ul> <p>Example</p> <pre><code>const context = new ReductionContext(new BigNumber(7));\nconst a = context.convertTo(new BigNumber(8)); // 'a' is now 1 in the reduction context\ncontext.convertFrom(a); // Returns 1\n</code></pre>"},{"location":"reference/primitives/#method-convertto_1","title":"Method convertTo","text":"<p>Converts a BigNumber to its equivalent in the reduction context.</p> <p><pre><code>convertTo(num: BigNumber): BigNumber \n</code></pre> See also: BigNumber</p> <p>Returns</p> <p>Returns the converted BigNumber compatible with the reduction context.</p> <p>Argument Details</p> <ul> <li>num</li> <li>The BigNumber to convert to the reduction context.</li> </ul> <p>Example</p> <pre><code>const context = new ReductionContext(new BigNumber(7));\ncontext.convertTo(new BigNumber(8)); // Returns 1 (8 % 7)\n</code></pre>"},{"location":"reference/primitives/#method-iadd","title":"Method iadd","text":"<p>Performs an in-place addition operation on two BigNumbers in the reduction context in order to avoid creating a new BigNumber, it modifies the first one with the result.</p> <p><pre><code>iadd(a: BigNumber, b: BigNumber): BigNumber \n</code></pre> See also: BigNumber</p> <p>Returns</p> <p>Returns the modified 'a' after addition with 'b' in the reduction context.</p> <p>Argument Details</p> <ul> <li>a</li> <li>First BigNumber to add.</li> <li>b</li> <li>Second BigNumber to add.</li> </ul> <p>Example</p> <pre><code>const context = new ReductionContext(new BigNumber(5));\nconst a = new BigNumber(2);\ncontext.iadd(a, new BigNumber(4)); // Modifies 'a' to be 1\n</code></pre>"},{"location":"reference/primitives/#method-imod","title":"Method imod","text":"<p>Performs an in-place reduction of the given BigNumber by the modulus of the reduction context, 'm'.</p> <p><pre><code>imod(a: BigNumber): BigNumber \n</code></pre> See also: BigNumber</p> <p>Returns</p> <p>Returns the reduced result.</p> <p>Argument Details</p> <ul> <li>a</li> <li>BigNumber to be reduced.</li> </ul> <p>Example</p> <pre><code>const context = new ReductionContext(new BigNumber(7));\ncontext.imod(new BigNumber(19)); // Returns 5\n</code></pre>"},{"location":"reference/primitives/#method-imul_1","title":"Method imul","text":"<p>Performs in-place multiplication of two BigNumbers in the reduction context, modifying the first BigNumber with the result.</p> <p><pre><code>imul(a: BigNumber, b: BigNumber): BigNumber \n</code></pre> See also: BigNumber</p> <p>Returns</p> <p>Returns the modified 'a' after multiplication with 'b' in the reduction context.</p> <p>Argument Details</p> <ul> <li>a</li> <li>First BigNumber to multiply.</li> <li>b</li> <li>Second BigNumber to multiply.</li> </ul> <p>Example</p> <pre><code>const context = new ReductionContext(new BigNumber(7));\nconst a = new BigNumber(3);\ncontext.imul(a, new BigNumber(2)); // Modifies 'a' to be 6\n</code></pre>"},{"location":"reference/primitives/#method-invm_1","title":"Method invm","text":"<p>Calculates the multiplicative inverse of a BigNumber in the reduction context.</p> <p><pre><code>invm(a: BigNumber): BigNumber \n</code></pre> See also: BigNumber</p> <p>Returns</p> <p>Returns the multiplicative inverse of 'a' in the reduction context.</p> <p>Argument Details</p> <ul> <li>a</li> <li>The BigNumber to find the multiplicative inverse of.</li> </ul> <p>Example</p> <pre><code>const context = new ReductionContext(new BigNumber(11));\ncontext.invm(new BigNumber(3)); // Returns 4 (3*4 mod 11 = 1)\n</code></pre>"},{"location":"reference/primitives/#method-isqr","title":"Method isqr","text":"<p>Calculates the square of a BigNumber in the reduction context, modifying the original BigNumber with the result.</p> <p><pre><code>isqr(a: BigNumber): BigNumber \n</code></pre> See also: BigNumber</p> <p>Returns</p> <p>Returns the squared 'a' in the reduction context.</p> <p>Argument Details</p> <ul> <li>a</li> <li>BigNumber to be squared.</li> </ul> <p>Example</p> <pre><code>const context = new ReductionContext(new BigNumber(7));\nconst a = new BigNumber(3);\ncontext.isqr(a); // Modifies 'a' to be 2 (9 % 7 = 2)\n</code></pre>"},{"location":"reference/primitives/#method-isub","title":"Method isub","text":"<p>Performs in-place subtraction of one BigNumber from another in the reduction context, it modifies the first BigNumber with the result.</p> <p><pre><code>isub(a: BigNumber, b: BigNumber): BigNumber \n</code></pre> See also: BigNumber</p> <p>Returns</p> <p>Returns the modified 'a' after subtraction of 'b' in the reduction context.</p> <p>Argument Details</p> <ul> <li>a</li> <li>BigNumber to be subtracted from.</li> <li>b</li> <li>BigNumber to subtract.</li> </ul> <p>Example</p> <pre><code>const context = new ReductionContext(new BigNumber(5));\nconst a = new BigNumber(4);\ncontext.isub(a, new BigNumber(2)); // Modifies 'a' to be 2\n</code></pre>"},{"location":"reference/primitives/#method-mul_2","title":"Method mul","text":"<p>Multiplies two BigNumbers in the reduction context.</p> <p><pre><code>mul(a: BigNumber, b: BigNumber): BigNumber \n</code></pre> See also: BigNumber</p> <p>Returns</p> <p>Returns the result of 'a * b' in the reduction context.</p> <p>Argument Details</p> <ul> <li>a</li> <li>First BigNumber to multiply.</li> <li>b</li> <li>Second BigNumber to multiply.</li> </ul> <p>Example</p> <pre><code>const context = new ReductionContext(new BigNumber(7));\ncontext.mul(new BigNumber(3), new BigNumber(2)); // Returns 6\n</code></pre>"},{"location":"reference/primitives/#method-neg_2","title":"Method neg","text":"<p>Negates a BigNumber in the context of the modulus.</p> <p><pre><code>neg(a: BigNumber): BigNumber \n</code></pre> See also: BigNumber</p> <p>Returns</p> <p>Returns the negation of 'a' in the reduction context.</p> <p>Argument Details</p> <ul> <li>a</li> <li>BigNumber to negate.</li> </ul> <p>Example</p> <pre><code>const context = new ReductionContext(new BigNumber(7));\ncontext.neg(new BigNumber(3)); // Returns 4\n</code></pre>"},{"location":"reference/primitives/#method-pow","title":"Method pow","text":"<p>Raises a BigNumber to a power in the reduction context.</p> <p><pre><code>pow(a: BigNumber, num: BigNumber): BigNumber \n</code></pre> See also: BigNumber</p> <p>Returns</p> <p>Returns the result of 'a' raised to the power of 'num' in the reduction context.</p> <p>Argument Details</p> <ul> <li>a</li> <li>The BigNumber to be raised to a power.</li> <li>num</li> <li>The power to raise the BigNumber to.</li> </ul> <p>Example</p> <pre><code>const context = new ReductionContext(new BigNumber(7));\ncontext.pow(new BigNumber(3), new BigNumber(2)); // Returns 2 (3^2 % 7)\n</code></pre>"},{"location":"reference/primitives/#method-shl","title":"Method shl","text":"<p>Performs bitwise shift left operation on a BigNumber in the reduction context.</p> <p><pre><code>shl(a: BigNumber, num: number): BigNumber \n</code></pre> See also: BigNumber</p> <p>Returns</p> <p>Returns the result of shifting 'a' left by 'num' positions in the reduction context.</p> <p>Argument Details</p> <ul> <li>a</li> <li>BigNumber to perform shift on.</li> <li>num</li> <li>The number of positions to shift.</li> </ul> <p>Example</p> <pre><code>const context = new ReductionContext(new BigNumber(32));\ncontext.shl(new BigNumber(4), 2); // Returns 16\n</code></pre>"},{"location":"reference/primitives/#method-sqr","title":"Method sqr","text":"<p>Calculates the square of a BigNumber in the reduction context.</p> <p><pre><code>sqr(a: BigNumber): BigNumber \n</code></pre> See also: BigNumber</p> <p>Returns</p> <p>Returns the result of 'a^2' in the reduction context.</p> <p>Argument Details</p> <ul> <li>a</li> <li>BigNumber to be squared.</li> </ul> <p>Example</p> <pre><code>const context = new ReductionContext(new BigNumber(7));\ncontext.sqr(new BigNumber(3)); // Returns 2 (9 % 7 = 2)\n</code></pre>"},{"location":"reference/primitives/#method-sqrt","title":"Method sqrt","text":"<p>Calculates the square root of a BigNumber in the reduction context.</p> <p><pre><code>sqrt(a: BigNumber): BigNumber \n</code></pre> See also: BigNumber</p> <p>Returns</p> <p>Returns the square root of 'a' in the reduction context.</p> <p>Argument Details</p> <ul> <li>a</li> <li>The BigNumber to calculate the square root of.</li> </ul> <p>Example</p> <pre><code>const context = new ReductionContext(new BigNumber(9));\ncontext.sqrt(new BigNumber(4)); // Returns 2\n</code></pre>"},{"location":"reference/primitives/#method-sub","title":"Method sub","text":"<p>Subtracts one BigNumber from another BigNumber in the reduction context.</p> <p><pre><code>sub(a: BigNumber, b: BigNumber): BigNumber \n</code></pre> See also: BigNumber</p> <p>Returns</p> <p>Returns the result of 'a - b' in the reduction context.</p> <p>Argument Details</p> <ul> <li>a</li> <li>BigNumber to be subtracted from.</li> <li>b</li> <li>BigNumber to subtract.</li> </ul> <p>Example</p> <pre><code>const context = new ReductionContext(new BigNumber(7));\ncontext.sub(new BigNumber(3), new BigNumber(2)); // Returns 1\n</code></pre>"},{"location":"reference/primitives/#method-verify1","title":"Method verify1","text":"<p>Verifies that a BigNumber is positive and red. Throws an error if these conditions are not met.</p> <p><pre><code>verify1(a: BigNumber): void \n</code></pre> See also: BigNumber</p> <p>Argument Details</p> <ul> <li>a</li> <li>The BigNumber to be verified.</li> </ul> <p>Example</p> <pre><code>this.verify1(new BigNumber(10).toRed());\nthis.verify1(new BigNumber(-10).toRed()); //throws an Error\nthis.verify1(new BigNumber(10)); //throws an Error\n</code></pre>"},{"location":"reference/primitives/#method-verify2","title":"Method verify2","text":"<p>Verifies that two BigNumbers are both positive and red. Also checks that they have the same reduction context. Throws an error if these conditions are not met.</p> <p><pre><code>verify2(a: BigNumber, b: BigNumber): void \n</code></pre> See also: BigNumber</p> <p>Argument Details</p> <ul> <li>a</li> <li>The first BigNumber to be verified.</li> <li>b</li> <li>The second BigNumber to be verified.</li> </ul> <p>Example</p> <pre><code>this.verify2(new BigNumber(10).toRed(this), new BigNumber(20).toRed(this));\nthis.verify2(new BigNumber(-10).toRed(this), new BigNumber(20).toRed(this)); //throws an Error\nthis.verify2(new BigNumber(10).toRed(this), new BigNumber(20)); //throws an Error\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#class-sha1","title":"Class: SHA1","text":"<p>An implementation of SHA1 cryptographic hash function. Extends the BaseHash class. It provides a way to compute a 'digest' for any kind of input data; transforming the data into a unique output of fixed size. The output is deterministic; it will always be the same for the same input.</p> <p>Example</p> <pre><code>const sha1 = new SHA1();\n</code></pre> <pre><code>export class SHA1 extends BaseHash {\n    h: number[];\n    W: number[];\n    k: number[];\n    constructor() \n    _update(msg: number[], start?: number): void \n    _digest(): number[] \n    _digestHex(): string \n}\n</code></pre>"},{"location":"reference/primitives/#property-w","title":"Property W","text":"<p>Provides a way to recycle usage of the array memory.</p> <pre><code>W: number[]\n</code></pre>"},{"location":"reference/primitives/#property-h_1","title":"Property h","text":"<p>The initial hash constants.</p> <pre><code>h: number[]\n</code></pre>"},{"location":"reference/primitives/#property-k_1","title":"Property k","text":"<p>The round constants used for each round of SHA-1.</p> <pre><code>k: number[]\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#class-sha1hmac","title":"Class: SHA1HMAC","text":"<pre><code>export class SHA1HMAC {\n    inner: SHA1;\n    outer: SHA1;\n    blockSize = 64;\n    constructor(key: number[] | string) \n    update(msg: number[] | string, enc?: \"hex\"): SHA1HMAC \n    digest(): number[] \n    digestHex(): string \n}\n</code></pre> <p>See also: SHA1</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#class-sha256","title":"Class: SHA256","text":"<p>An implementation of SHA256 cryptographic hash function. Extends the BaseHash class. It provides a way to compute a 'digest' for any kind of input data; transforming the data into a unique output of fixed size. The output is deterministic; it will always be the same for the same input.</p> <p>Example</p> <pre><code>const sha256 = new SHA256();\n</code></pre> <pre><code>export class SHA256 {\n    constructor() \n    update(msg: Uint8Array | number[] | string, enc?: \"hex\" | \"utf8\"): this \n    digest(): number[] \n    digestHex(): string \n}\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#class-sha256hmac","title":"Class: SHA256HMAC","text":"<p>The <code>SHA256HMAC</code> class is used to create Hash-based Message Authentication Code (HMAC) using the SHA-256 cryptographic hash function.</p> <p>HMAC is a specific type of MAC involving a cryptographic hash function and a secret cryptographic key. It may be used to simultaneously verify both the data integrity and the authenticity of a message.</p> <p>This class also uses the SHA-256 cryptographic hash algorithm that produces a 256-bit (32-byte) hash value.</p> <pre><code>export class SHA256HMAC {\n    blockSize = 64;\n    outSize = 32;\n    constructor(key: Uint8Array | number[] | string) \n    update(msg: Uint8Array | number[] | string, enc?: \"hex\"): SHA256HMAC \n    digest(): number[] \n    digestHex(): string \n}\n</code></pre>"},{"location":"reference/primitives/#constructor_9","title":"Constructor","text":"<p>The constructor for the <code>SHA256HMAC</code> class.</p> <p>It initializes the <code>SHA256HMAC</code> object and sets up the inner and outer padded keys. If the key size is larger than the blockSize, it is digested using SHA-256. If the key size is less than the blockSize, it is padded with zeroes.</p> <pre><code>constructor(key: Uint8Array | number[] | string) \n</code></pre> <p>Argument Details</p> <ul> <li>key</li> <li>The key to use to create the HMAC. Can be a number array or a string in hexadecimal format.</li> </ul> <p>Example</p> <pre><code>const myHMAC = new SHA256HMAC('deadbeef');\n</code></pre>"},{"location":"reference/primitives/#property-blocksize","title":"Property blockSize","text":"<p>The block size for the SHA-256 hash function, in bytes. It's set to 64 bytes.</p> <pre><code>blockSize = 64\n</code></pre>"},{"location":"reference/primitives/#property-outsize","title":"Property outSize","text":"<p>The output size of the SHA-256 hash function, in bytes. It's set to 32 bytes.</p> <pre><code>outSize = 32\n</code></pre>"},{"location":"reference/primitives/#method-digest","title":"Method digest","text":"<p>Finalizes the HMAC computation and returns the resultant hash.</p> <pre><code>digest(): number[] \n</code></pre> <p>Returns</p> <p>Returns the digest of the hashed data. Can be a number array or a string.</p> <p>Example</p> <pre><code>let hashedMessage = myHMAC.digest();\n</code></pre>"},{"location":"reference/primitives/#method-digesthex","title":"Method digestHex","text":"<p>Finalizes the HMAC computation and returns the resultant hash as a hex string.</p> <pre><code>digestHex(): string \n</code></pre> <p>Returns</p> <p>Returns the digest of the hashed data as a hex string</p> <p>Example</p> <pre><code>let hashedMessage = myHMAC.digestHex();\n</code></pre>"},{"location":"reference/primitives/#method-update_1","title":"Method update","text":"<p>Updates the <code>SHA256HMAC</code> object with part of the message to be hashed.</p> <p><pre><code>update(msg: Uint8Array | number[] | string, enc?: \"hex\"): SHA256HMAC \n</code></pre> See also: SHA256HMAC</p> <p>Returns</p> <p>Returns the instance of <code>SHA256HMAC</code> for chaining calls.</p> <p>Argument Details</p> <ul> <li>msg</li> <li>Part of the message to hash. Can be a number array or a string.</li> <li>enc</li> <li>If 'hex', then the input is encoded as hexadecimal. If undefined or not 'hex', then no encoding is performed.</li> </ul> <p>Example</p> <pre><code>myHMAC.update('deadbeef', 'hex');\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#class-sha512","title":"Class: SHA512","text":"<p>An implementation of SHA512 cryptographic hash function. Extends the BaseHash class. It provides a way to compute a 'digest' for any kind of input data; transforming the data into a unique output of fixed size. The output is deterministic; it will always be the same for the same input.</p> <p>Example</p> <pre><code>const sha512 = new SHA512();\n</code></pre> <pre><code>export class SHA512 {\n    constructor() \n    update(msg: number[] | string, enc?: \"hex\" | \"utf8\"): this \n    digest(): number[] \n    digestHex(): string \n}\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#class-sha512hmac","title":"Class: SHA512HMAC","text":"<p>The <code>SHA512HMAC</code> class is used to create Hash-based Message Authentication Code (HMAC) using the SHA-512 cryptographic hash function.</p> <p>HMAC is a specific type of MAC involving a cryptographic hash function and a secret cryptographic key. It may be used to simultaneously verify both the data integrity and the authenticity of a message.</p> <p>This class also uses the SHA-512 cryptographic hash algorithm that produces a 512-bit (64-byte) hash value.</p> <pre><code>export class SHA512HMAC {\n    blockSize = 128;\n    outSize = 32;\n    constructor(key: Uint8Array | number[] | string) \n    update(msg: Uint8Array | number[] | string, enc?: \"hex\" | \"utf8\"): SHA512HMAC \n    digest(): number[] \n    digestHex(): string \n}\n</code></pre>"},{"location":"reference/primitives/#constructor_10","title":"Constructor","text":"<p>The constructor for the <code>SHA512HMAC</code> class.</p> <p>It initializes the <code>SHA512HMAC</code> object and sets up the inner and outer padded keys. If the key size is larger than the blockSize, it is digested using SHA-512. If the key size is less than the blockSize, it is padded with zeroes.</p> <pre><code>constructor(key: Uint8Array | number[] | string) \n</code></pre> <p>Argument Details</p> <ul> <li>key</li> <li>The key to use to create the HMAC. Can be a number array or a string in hexadecimal format.</li> </ul> <p>Example</p> <pre><code>const myHMAC = new SHA512HMAC('deadbeef');\n</code></pre>"},{"location":"reference/primitives/#property-blocksize_1","title":"Property blockSize","text":"<p>The block size for the SHA-512 hash function, in bytes. It's set to 128 bytes.</p> <pre><code>blockSize = 128\n</code></pre>"},{"location":"reference/primitives/#property-outsize_1","title":"Property outSize","text":"<p>The output size of the SHA-512 hash function, in bytes. It's set to 64 bytes.</p> <pre><code>outSize = 32\n</code></pre>"},{"location":"reference/primitives/#method-digest_1","title":"Method digest","text":"<p>Finalizes the HMAC computation and returns the resultant hash.</p> <pre><code>digest(): number[] \n</code></pre> <p>Returns</p> <p>Returns the digest of the hashed data as a number array.</p> <p>Example</p> <pre><code>let hashedMessage = myHMAC.digest();\n</code></pre>"},{"location":"reference/primitives/#method-digesthex_1","title":"Method digestHex","text":"<p>Finalizes the HMAC computation and returns the resultant hash as a hex string.</p> <pre><code>digestHex(): string \n</code></pre> <p>Returns</p> <p>Returns the digest of the hashed data as a hex string</p> <p>Example</p> <pre><code>let hashedMessage = myHMAC.digestHex();\n</code></pre>"},{"location":"reference/primitives/#method-update_2","title":"Method update","text":"<p>Updates the <code>SHA512HMAC</code> object with part of the message to be hashed.</p> <p><pre><code>update(msg: Uint8Array | number[] | string, enc?: \"hex\" | \"utf8\"): SHA512HMAC \n</code></pre> See also: SHA512HMAC</p> <p>Returns</p> <p>Returns the instance of <code>SHA512HMAC</code> for chaining calls.</p> <p>Argument Details</p> <ul> <li>msg</li> <li>Part of the message to hash. Can be a number array or a string.</li> <li>enc</li> <li>If 'hex', then the input is encoded as hexadecimal. If undefined or not 'hex', then no encoding is performed.</li> </ul> <p>Example</p> <pre><code>myHMAC.update('deadbeef', 'hex');\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#class-schnorr","title":"Class: Schnorr","text":"<p>Class representing the Schnorr Zero-Knowledge Proof (ZKP) protocol.</p> <p>This class provides methods to generate and verify proofs that demonstrate knowledge of a secret without revealing it. Specifically, it allows one party to prove to another that they know the private key corresponding to a public key and have correctly computed a shared secret, without disclosing the private key itself.</p> <p>The protocol involves two main methods: - <code>generateProof</code>: Generates a proof linking a public key <code>A</code> and a shared secret <code>S</code>, proving knowledge of the corresponding private key <code>a</code>. - <code>verifyProof</code>: Verifies the provided proof, ensuring its validity without revealing any secret information.</p> <p>The class utilizes elliptic curve cryptography (ECC) and the SHA-256 hash function to compute challenges within the proof.</p> <p>Example</p> <p><pre><code>const schnorr = new Schnorr();\nconst a = PrivateKey.fromRandom(); // Prover's private key\nconst A = a.toPublicKey();         // Prover's public key\nconst b = PrivateKey.fromRandom(); // Other party's private key\nconst B = b.toPublicKey();         // Other party's public key\nconst S = B.mul(a);                // Shared secret\n\n// Prover generates the proof\nconst proof = schnorr.generateProof(a, A, B, S);\n\n// Verifier verifies the proof\nconst isValid = schnorr.verifyProof(A.point, B.point, S.point, proof);\nconsole.log(`Proof is valid: ${isValid}`);\n</code></pre> <pre><code>export default class Schnorr {\n    constructor() \n    generateProof(aArg: PrivateKey, AArg: PublicKey, BArg: PublicKey, S: Point): {\n        R: Point;\n        SPrime: Point;\n        z: BigNumber;\n    } \n    verifyProof(A: Point, B: Point, S: Point, proof: {\n        R: Point;\n        SPrime: Point;\n        z: BigNumber;\n    }): boolean \n}\n</code></pre></p> <p>See also: BigNumber, Point, PrivateKey, PublicKey</p>"},{"location":"reference/primitives/#method-generateproof","title":"Method generateProof","text":"<p>Generates a proof that demonstrates the link between public key A and shared secret S</p> <p><pre><code>generateProof(aArg: PrivateKey, AArg: PublicKey, BArg: PublicKey, S: Point): {\n    R: Point;\n    SPrime: Point;\n    z: BigNumber;\n} \n</code></pre> See also: BigNumber, Point, PrivateKey, PublicKey</p> <p>Returns</p> <p>Proof (R, S', z)</p> <p>Argument Details</p> <ul> <li>a</li> <li>Private key corresponding to public key A</li> <li>A</li> <li>Public key</li> <li>B</li> <li>Other party's public key</li> <li>S</li> <li>Shared secret</li> </ul>"},{"location":"reference/primitives/#method-verifyproof","title":"Method verifyProof","text":"<p>Verifies the proof of the link between public key A and shared secret S</p> <p><pre><code>verifyProof(A: Point, B: Point, S: Point, proof: {\n    R: Point;\n    SPrime: Point;\n    z: BigNumber;\n}): boolean \n</code></pre> See also: BigNumber, Point</p> <p>Returns</p> <p>True if the proof is valid, false otherwise</p> <p>Argument Details</p> <ul> <li>A</li> <li>Public key</li> <li>B</li> <li>Other party's public key</li> <li>S</li> <li>Shared secret</li> <li>proof</li> <li>Proof (R, S', z)</li> </ul> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#class-signature","title":"Class: Signature","text":"<p>Represents a digital signature.</p> <p>A digital signature is a mathematical scheme for verifying the authenticity of digital messages or documents. In many scenarios, it is equivalent to a handwritten signature or stamped seal. The signature pair (R, S) corresponds to the raw ECDSA (Elliptic Curve Digital Signature Algorithm) signature. Signatures are often serialized into a format known as 'DER encoding' for transmission.</p> <pre><code>export default class Signature {\n    r: BigNumber;\n    s: BigNumber;\n    static fromDER(data: number[] | string, enc?: \"hex\" | \"base64\"): Signature \n    static fromCompact(data: number[] | string, enc?: \"hex\" | \"base64\"): Signature \n    constructor(r: BigNumber, s: BigNumber) \n    verify(msg: number[] | string, key: PublicKey, enc?: \"hex\"): boolean \n    toString(enc?: \"hex\" | \"base64\"): number[] | string \n    toDER(enc?: \"hex\" | \"base64\"): number[] | string \n    toCompact(recovery: number, compressed: boolean, enc?: \"hex\" | \"base64\"): number[] | string \n    RecoverPublicKey(recovery: number, e: BigNumber): PublicKey \n    CalculateRecoveryFactor(pubkey: PublicKey, msgHash: BigNumber): number \n}\n</code></pre> <p>See also: BigNumber, PublicKey, verify</p>"},{"location":"reference/primitives/#constructor_11","title":"Constructor","text":"<p>Creates an instance of the Signature class.</p> <p><pre><code>constructor(r: BigNumber, s: BigNumber) \n</code></pre> See also: BigNumber</p> <p>Argument Details</p> <ul> <li>r</li> <li>The R component of the signature.</li> <li>s</li> <li>The S component of the signature.</li> </ul> <p>Example</p> <pre><code>const r = new BigNumber('208755674028...');\nconst s = new BigNumber('564745627577...');\nconst signature = new Signature(r, s);\n</code></pre>"},{"location":"reference/primitives/#method-calculaterecoveryfactor","title":"Method CalculateRecoveryFactor","text":"<p>Calculates the recovery factor which will work for a particular public key and message hash. This method will return the recovery factor if it finds a valid recovery factor. If it does not find a valid recovery factor, it will throw an error. The recovery factor is a number between 0 and 3.</p> <p><pre><code>CalculateRecoveryFactor(pubkey: PublicKey, msgHash: BigNumber): number \n</code></pre> See also: BigNumber, PublicKey</p> <p>Returns</p> <p>the recovery factor: number /</p> <p>Argument Details</p> <ul> <li>msgHash</li> <li>The message hash.</li> </ul> <p>Example</p> <pre><code>const recovery = signature.CalculateRecoveryFactor(publicKey, msgHash);\n</code></pre>"},{"location":"reference/primitives/#method-recoverpublickey","title":"Method RecoverPublicKey","text":"<p>Recovers the public key from a signature. This method will return the public key if it finds a valid public key. If it does not find a valid public key, it will throw an error. The recovery factor is a number between 0 and 3.</p> <p><pre><code>RecoverPublicKey(recovery: number, e: BigNumber): PublicKey \n</code></pre> See also: BigNumber, PublicKey</p> <p>Returns</p> <p>The public key associated with the signature.</p> <p>Argument Details</p> <ul> <li>recovery</li> <li>The recovery factor.</li> <li>e</li> <li>The message hash.</li> </ul> <p>Example</p> <pre><code>const publicKey = signature.RecoverPublicKey(0, msgHash);\n</code></pre>"},{"location":"reference/primitives/#method-fromcompact","title":"Method fromCompact","text":"<p>Takes an array of numbers or a string and returns a new Signature instance. This method will throw an error if the Compact encoding is invalid. If a string is provided, it is assumed to represent a hexadecimal sequence. compactByte value 27-30 means uncompressed public key. 31-34 means compressed public key. The range represents the recovery param which can be 0,1,2,3. We could support recovery functions in future if there's demand.</p> <p><pre><code>static fromCompact(data: number[] | string, enc?: \"hex\" | \"base64\"): Signature \n</code></pre> See also: Signature</p> <p>Returns</p> <p>The decoded data in the form of Signature instance.</p> <p>Argument Details</p> <ul> <li>data</li> <li>The sequence to decode from Compact encoding.</li> <li>enc</li> <li>The encoding of the data string.</li> </ul> <p>Example</p> <pre><code>const signature = Signature.fromCompact('1b18c1f5502f8...', 'hex');\n</code></pre>"},{"location":"reference/primitives/#method-fromder_2","title":"Method fromDER","text":"<p>Takes an array of numbers or a string and returns a new Signature instance. This method will throw an error if the DER encoding is invalid. If a string is provided, it is assumed to represent a hexadecimal sequence.</p> <p><pre><code>static fromDER(data: number[] | string, enc?: \"hex\" | \"base64\"): Signature \n</code></pre> See also: Signature</p> <p>Returns</p> <p>The decoded data in the form of Signature instance.</p> <p>Argument Details</p> <ul> <li>data</li> <li>The sequence to decode from DER encoding.</li> <li>enc</li> <li>The encoding of the data string.</li> </ul> <p>Example</p> <pre><code>const signature = Signature.fromDER('30440220018c1f5502f8...', 'hex');\n</code></pre>"},{"location":"reference/primitives/#method-tocompact","title":"Method toCompact","text":"<p>Converts an instance of Signature into Compact encoding.</p> <p>If the encoding parameter is set to 'hex', the function will return a hex string. If 'base64', it will return a base64 string. Otherwise, it will return an array of numbers.</p> <pre><code>toCompact(recovery: number, compressed: boolean, enc?: \"hex\" | \"base64\"): number[] | string \n</code></pre> <p>Returns</p> <p>The current instance in DER encoding.</p> <p>Argument Details</p> <ul> <li>enc</li> <li>The encoding to use for the output.</li> </ul> <p>Example</p> <pre><code>const compact = signature.toCompact(3, true, 'base64');\n</code></pre>"},{"location":"reference/primitives/#method-toder_1","title":"Method toDER","text":"<p>Converts an instance of Signature into DER encoding.</p> <p>If the encoding parameter is set to 'hex', the function will return a hex string. If 'base64', it will return a base64 string. Otherwise, it will return an array of numbers.</p> <pre><code>toDER(enc?: \"hex\" | \"base64\"): number[] | string \n</code></pre> <p>Returns</p> <p>The current instance in DER encoding.</p> <p>Argument Details</p> <ul> <li>enc</li> <li>The encoding to use for the output.</li> </ul> <p>Example</p> <pre><code>const der = signature.toDER('hex');\n</code></pre>"},{"location":"reference/primitives/#method-tostring_4","title":"Method toString","text":"<p>function toString() { [native code] }</p> <p>Converts an instance of Signature into DER encoding. An alias for the toDER method.</p> <p>If the encoding parameter is set to 'hex', the function will return a hex string. If 'base64', it will return a base64 string. Otherwise, it will return an array of numbers.</p> <pre><code>toString(enc?: \"hex\" | \"base64\"): number[] | string \n</code></pre> <p>Returns</p> <p>The current instance in DER encoding.</p> <p>Argument Details</p> <ul> <li>enc</li> <li>The encoding to use for the output.</li> </ul> <p>Example</p> <pre><code>const der = signature.toString('base64');\n</code></pre>"},{"location":"reference/primitives/#method-verify_2","title":"Method verify","text":"<p>Verifies a digital signature.</p> <p>This method will return true if the signature, key, and message hash match. If the data or key do not match the signature, the function returns false.</p> <p><pre><code>verify(msg: number[] | string, key: PublicKey, enc?: \"hex\"): boolean \n</code></pre> See also: PublicKey</p> <p>Returns</p> <p>A boolean representing whether the signature is valid.</p> <p>Argument Details</p> <ul> <li>msg</li> <li>The message to verify.</li> <li>key</li> <li>The public key used to sign the original message.</li> <li>enc</li> <li>The encoding of the msg string.</li> </ul> <p>Example</p> <pre><code>const msg = 'The quick brown fox jumps over the lazy dog';\nconst publicKey = PublicKey.fromString('04188ca1050...');\nconst isVerified = signature.verify(msg, publicKey);\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#class-symmetrickey","title":"Class: SymmetricKey","text":"<p><code>SymmetricKey</code> is a class that extends the <code>BigNumber</code> class and implements symmetric encryption and decryption methods. Symmetric-Key encryption is a form of encryption where the same key is used to encrypt and decrypt the message. It leverages the Advanced Encryption Standard Galois/Counter Mode (AES-GCM) for encryption and decryption of messages.</p> <pre><code>export default class SymmetricKey extends BigNumber {\n    static fromRandom(): SymmetricKey \n    encrypt(msg: number[] | string, enc?: \"hex\"): string | number[] \n    decrypt(msg: number[] | string, enc?: \"hex\" | \"utf8\"): string | number[] \n}\n</code></pre> <p>See also: BigNumber, decrypt, encrypt</p>"},{"location":"reference/primitives/#method-decrypt","title":"Method decrypt","text":"<p>Decrypts a given AES-GCM encrypted message using the same key that was used for encryption. The method extracts the IV and the authentication tag from the encrypted message, then attempts to decrypt it. If the decryption fails (e.g., due to message tampering), an error is thrown.</p> <pre><code>decrypt(msg: number[] | string, enc?: \"hex\" | \"utf8\"): string | number[] \n</code></pre> <p>Returns</p> <p>Returns the decrypted message as a string or an array of numbers, depending on <code>enc</code> argument. If absent, an array of numbers is returned.</p> <p>Argument Details</p> <ul> <li>msg</li> <li>The encrypted message to be decrypted. It can be a string or an array of numbers.</li> <li>enc</li> <li>optional. The encoding of the message (if no encoding is provided, uses utf8 for strings, unless specified as hex).</li> </ul> <p>Throws</p> <p>Will throw an error if the decryption fails, likely due to message tampering or incorrect decryption key.</p> <p>Example</p> <pre><code>const key = new SymmetricKey(1234);\nconst decryptedMessage = key.decrypt(encryptedMessage, 'utf8');\n</code></pre>"},{"location":"reference/primitives/#method-encrypt","title":"Method encrypt","text":"<p>Encrypts a given message using AES-GCM encryption. The generated Initialization Vector (IV) is attached to the encrypted message for decryption purposes. The OpenSSL format of |IV|encryptedContent|authTag| is used.</p> <pre><code>encrypt(msg: number[] | string, enc?: \"hex\"): string | number[] \n</code></pre> <p>Returns</p> <p>Returns the encrypted message as a string or an array of numbers, depending on <code>enc</code> argument.</p> <p>Argument Details</p> <ul> <li>msg</li> <li>The message to be encrypted. It can be a string or an array of numbers.</li> <li>enc</li> <li>optional. The encoding of the message. If hex, the string is assumed to be hex, UTF-8 otherwise.</li> </ul> <p>Example</p> <pre><code>const key = new SymmetricKey(1234);\nconst encryptedMessage = key.encrypt('plainText', 'utf8');\n</code></pre>"},{"location":"reference/primitives/#method-fromrandom_1","title":"Method fromRandom","text":"<p>Generates a symmetric key randomly.</p> <p><pre><code>static fromRandom(): SymmetricKey \n</code></pre> See also: SymmetricKey</p> <p>Returns</p> <p>The newly generated Symmetric Key.</p> <p>Example</p> <pre><code>const symmetricKey = SymmetricKey.fromRandom();\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#class-transactionsignature","title":"Class: TransactionSignature","text":"<pre><code>export default class TransactionSignature extends Signature {\n    public static readonly SIGHASH_ALL = 1;\n    public static readonly SIGHASH_NONE = 2;\n    public static readonly SIGHASH_SINGLE = 3;\n    public static readonly SIGHASH_FORKID = 64;\n    public static readonly SIGHASH_ANYONECANPAY = 128;\n    scope: number;\n    static format(params: TransactionSignatureFormatParams): number[] \n    static formatBytes(params: TransactionSignatureFormatParams): Uint8Array \n    static fromChecksigFormat(buf: number[]): TransactionSignature \n    constructor(r: BigNumber, s: BigNumber, scope: number) \n    public hasLowS(): boolean \n    toChecksigFormat(): number[] \n}\n</code></pre> <p>See also: BigNumber, Signature</p>"},{"location":"reference/primitives/#method-format","title":"Method format","text":"<p>Formats the SIGHASH preimage for the targeted input, optionally using a cache to skip recomputing shared hash prefixes.</p> <pre><code>static format(params: TransactionSignatureFormatParams): number[] \n</code></pre> <p>Argument Details</p> <ul> <li>params</li> <li>Context for the signing input plus transaction metadata.</li> <li>params.cache</li> <li>Optional cache storing previously computed <code>hashPrevouts</code>, <code>hashSequence</code>, or <code>hashOutputs*</code> values; it will be populated if present.</li> </ul>"},{"location":"reference/primitives/#method-formatbytes","title":"Method formatBytes","text":"<p>Formats the same SIGHASH preimage bytes as <code>format</code>, supporting the optional cache for hash reuse.</p> <pre><code>static formatBytes(params: TransactionSignatureFormatParams): Uint8Array \n</code></pre> <p>Returns</p> <p>Bytes for signing.</p> <p>Argument Details</p> <ul> <li>params</li> <li>Context for the signing operation.</li> <li>params.cache</li> <li>Optional <code>SignatureHashCache</code> that may already contain hashed prefixes and is populated during formatting.</li> </ul>"},{"location":"reference/primitives/#method-haslows","title":"Method hasLowS","text":"<p>Compares to bitcoind's IsLowDERSignature See also Ecdsa signature algorithm which enforces this. See also Bip 62, \"low S values in signatures\"</p> <pre><code>public hasLowS(): boolean \n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#class-writer","title":"Class: Writer","text":"<pre><code>export class Writer {\n    public bufs: WriterChunk[];\n    constructor(bufs?: WriterChunk[]) \n    getLength(): number \n    toUint8Array(): Uint8Array \n    toArray(): number[] \n    write(buf: WriterChunk): this \n    writeReverse(buf: number[]): this \n    writeUInt8(n: number): this \n    writeInt8(n: number): this \n    writeUInt16BE(n: number): this \n    writeInt16BE(n: number): this \n    writeUInt16LE(n: number): this \n    writeInt16LE(n: number): this \n    writeUInt32BE(n: number): this \n    writeInt32BE(n: number): this \n    writeUInt32LE(n: number): this \n    writeInt32LE(n: number): this \n    writeUInt64BEBn(bn: BigNumber): this \n    writeUInt64LEBn(bn: BigNumber): this \n    writeUInt64LE(n: number): this \n    writeVarIntNum(n: number): this \n    writeVarIntBn(bn: BigNumber): this \n    static varIntNum(n: number): number[] \n    static varIntBn(bn: BigNumber): number[] \n}\n</code></pre> <p>See also: BigNumber, toArray</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#functions","title":"Functions","text":"AES AESGCM AESGCMDecrypt base64ToArray ghash pbkdf2 red toArray toBase64 verifyNotNull <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#function-aes","title":"Function: AES","text":"<pre><code>export function AES(input: number[], key: number[]): number[] \n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#function-aesgcm","title":"Function: AESGCM","text":"<pre><code>export function AESGCM(plainText: number[], additionalAuthenticatedData: number[], initializationVector: number[], key: number[]): {\n    result: number[];\n    authenticationTag: number[];\n} \n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#function-aesgcmdecrypt","title":"Function: AESGCMDecrypt","text":"<pre><code>export function AESGCMDecrypt(cipherText: number[], additionalAuthenticatedData: number[], initializationVector: number[], authenticationTag: number[], key: number[]): number[] | null \n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#function-base64toarray","title":"Function: base64ToArray","text":"<pre><code>export function base64ToArray(msg: string): number[] \n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#function-ghash","title":"Function: ghash","text":"<pre><code>export function ghash(input: number[], hashSubKey: number[]): number[] \n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#function-pbkdf2","title":"Function: pbkdf2","text":"<p>Limited SHA-512-only PBKDF2 function for use in deprecated BIP39 code.</p> <pre><code>export function pbkdf2(password: number[], salt: number[], iterations: number, keylen: number, digest = \"sha512\"): number[] \n</code></pre> <p>Returns</p> <p>The computed key</p> <p>Argument Details</p> <ul> <li>password</li> <li>The PBKDF2 password</li> <li>salt</li> <li>The PBKDF2 salt</li> <li>iterations</li> <li>The number of of iterations to run</li> <li>keylen</li> <li>The length of the key</li> <li>digest</li> <li>The digest (must be sha512 for this implementation)</li> </ul> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#function-red","title":"Function: red","text":"<pre><code>export function red(x: bigint): bigint \n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#function-toarray","title":"Function: toArray","text":"<pre><code>export function toArray(msg: number[] | string, enc?: \"hex\" | \"utf8\"): number[] \n</code></pre> <p>Returns</p> <p>array of byte values from msg. If msg is an array, a copy is returned.</p> <p>Argument Details</p> <ul> <li>enc</li> <li>Optional. Encoding to use if msg is string. Default is 'utf8'.</li> </ul> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#function-tobase64","title":"Function: toBase64","text":"<p>Converts an array of bytes (each between 0 and 255) into a base64 encoded string.</p> <p>Example</p> <pre><code>const bytes = [72, 101, 108, 108, 111]; // Represents the string \"Hello\"\nconsole.log(toBase64(bytes)); // Outputs: SGVsbG8=\n</code></pre> <pre><code>export function toBase64(byteArray: number[]): string \n</code></pre> <p>Returns</p> <p>The base64 encoded string.</p> <p>Argument Details</p> <ul> <li>byteArray</li> <li>An array of numbers where each number is a byte (0-255).</li> </ul> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#function-verifynotnull","title":"Function: verifyNotNull","text":"<p>Verifies that a value is not null or undefined, throwing an error if it is.</p> <p>Example</p> <pre><code>const myValue = verifyNotNull(someValue, 'someValue must be defined')\n</code></pre> <pre><code>export function verifyNotNull&lt;T&gt;(value: T | undefined | null, errorMessage: string = \"Expected a valid value, but got undefined or null.\"): T \n</code></pre> <p>Returns</p> <ul> <li>The verified value</li> </ul> <p>Argument Details</p> <ul> <li>value</li> <li>The value to verify</li> <li>errorMessage</li> <li>The error message to throw if the value is null or undefined</li> </ul> <p>Throws</p> <ul> <li>If the value is null or undefined</li> </ul> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#types","title":"Types","text":""},{"location":"reference/primitives/#enums","title":"Enums","text":""},{"location":"reference/primitives/#variables","title":"Variables","text":"BI_EIGHT biModSqrt multiply BI_FOUR biModSub rightShift BI_ONE checkBit ripemd160 BI_THREE encode scalarMultiplyWNAF BI_TWO exclusiveOR sha1 BI_ZERO fromBase58 sha256 GX_BIGINT fromBase58Check sha256hmac GY_BIGINT getBytes sha512 MASK_256 hash160 sha512hmac N_BIGINT hash256 sign P_BIGINT incrementLeastSignificantThirtyTwoBits toArray P_PLUS1_DIV4 jpAdd toBase58 biMod jpDouble toBase58Check biModAdd jpNeg toHex biModInv minimallyEncode toUTF8 biModMul modInvN verify biModPow modMulN zero2 biModSqr modN <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#variable-bi_eight","title":"Variable: BI_EIGHT","text":"<pre><code>BI_EIGHT = 8n\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#variable-bi_four","title":"Variable: BI_FOUR","text":"<pre><code>BI_FOUR = 4n\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#variable-bi_one","title":"Variable: BI_ONE","text":"<pre><code>BI_ONE = 1n\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#variable-bi_three","title":"Variable: BI_THREE","text":"<pre><code>BI_THREE = 3n\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#variable-bi_two","title":"Variable: BI_TWO","text":"<pre><code>BI_TWO = 2n\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#variable-bi_zero","title":"Variable: BI_ZERO","text":"<pre><code>BI_ZERO = 0n\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#variable-gx_bigint","title":"Variable: GX_BIGINT","text":"<pre><code>GX_BIGINT = BigInt(\"0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798\")\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#variable-gy_bigint","title":"Variable: GY_BIGINT","text":"<pre><code>GY_BIGINT = BigInt(\"0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8\")\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#variable-mask_256","title":"Variable: MASK_256","text":"<pre><code>MASK_256 = (1n &lt;&lt; 256n) - 1n\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#variable-n_bigint","title":"Variable: N_BIGINT","text":"<pre><code>N_BIGINT = 0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141n\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#variable-p_bigint","title":"Variable: P_BIGINT","text":"<pre><code>P_BIGINT = 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2fn\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#variable-p_plus1_div4","title":"Variable: P_PLUS1_DIV4","text":"<pre><code>P_PLUS1_DIV4 = (P_BIGINT + 1n) &gt;&gt; 2n\n</code></pre> <p>See also: P_BIGINT</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#variable-bimod","title":"Variable: biMod","text":"<pre><code>biMod = (a: bigint): bigint =&gt; red((a % P_BIGINT + P_BIGINT) % P_BIGINT)\n</code></pre> <p>See also: P_BIGINT, red</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#variable-bimodadd","title":"Variable: biModAdd","text":"<pre><code>biModAdd = (a: bigint, b: bigint): bigint =&gt; red(a + b)\n</code></pre> <p>See also: red</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#variable-bimodinv","title":"Variable: biModInv","text":"<pre><code>biModInv = (a: bigint): bigint =&gt; {\n    let lm = BI_ONE;\n    let hm = BI_ZERO;\n    let low = biMod(a);\n    let high = P_BIGINT;\n    while (low &gt; BI_ONE) {\n        const r = high / low;\n        [lm, hm] = [hm - lm * r, lm];\n        [low, high] = [high - low * r, low];\n    }\n    return biMod(lm);\n}\n</code></pre> <p>See also: BI_ONE, BI_ZERO, P_BIGINT, biMod</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#variable-bimodmul","title":"Variable: biModMul","text":"<pre><code>biModMul = (a: bigint, b: bigint): bigint =&gt; red(a * b)\n</code></pre> <p>See also: red</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#variable-bimodpow","title":"Variable: biModPow","text":"<pre><code>biModPow = (base: bigint, exp: bigint): bigint =&gt; {\n    let result = BI_ONE;\n    base = biMod(base);\n    let e = exp;\n    while (e &gt; BI_ZERO) {\n        if ((e &amp; BI_ONE) === BI_ONE)\n            result = biModMul(result, base);\n        base = biModMul(base, base);\n        e &gt;&gt;= BI_ONE;\n    }\n    return result;\n}\n</code></pre> <p>See also: BI_ONE, BI_ZERO, biMod, biModMul</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#variable-bimodsqr","title":"Variable: biModSqr","text":"<pre><code>biModSqr = (a: bigint): bigint =&gt; biModMul(a, a)\n</code></pre> <p>See also: biModMul</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#variable-bimodsqrt","title":"Variable: biModSqrt","text":"<pre><code>biModSqrt = (a: bigint): bigint | null =&gt; {\n    const r = biModPow(a, P_PLUS1_DIV4);\n    return biModMul(r, r) === biMod(a) ? r : null;\n}\n</code></pre> <p>See also: P_PLUS1_DIV4, biMod, biModMul, biModPow</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#variable-bimodsub","title":"Variable: biModSub","text":"<pre><code>biModSub = (a: bigint, b: bigint): bigint =&gt; (a &gt;= b ? a - b : P_BIGINT - (b - a))\n</code></pre> <p>See also: P_BIGINT</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#variable-checkbit","title":"Variable: checkBit","text":"<pre><code>checkBit = function (byteArray: number[], byteIndex: number, bitIndex: number): 1 | 0 {\n    return (byteArray[byteIndex] &amp; (1 &lt;&lt; bitIndex)) !== 0 ? 1 : 0;\n}\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#variable-encode","title":"Variable: encode","text":"<pre><code>encode = (arr: number[], enc?: \"hex\" | \"utf8\"): string | number[] =&gt; {\n    switch (enc) {\n        case \"hex\":\n            return toHex(arr);\n        case \"utf8\":\n            return toUTF8(arr);\n        default:\n            return arr;\n    }\n}\n</code></pre> <p>See also: toHex, toUTF8</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#variable-exclusiveor","title":"Variable: exclusiveOR","text":"<pre><code>exclusiveOR = function (block0: number[], block1: number[]): number[] {\n    const len = block0.length;\n    const result = new Array(len);\n    for (let i = 0; i &lt; len; i++) {\n        result[i] = block0[i] ^ block1[i];\n    }\n    return result;\n}\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#variable-frombase58","title":"Variable: fromBase58","text":"<pre><code>fromBase58 = (str: string): number[] =&gt; {\n    if (str === \"\" || typeof str !== \"string\") {\n        throw new Error(`Expected base58 string but got \u201c${str}\u201d`);\n    }\n    const match: string[] | null = str.match(/[IOl0]/gmu);\n    if (match !== null) {\n        throw new Error(`Invalid base58 character \u201c${match.join(\"\")}\u201d`);\n    }\n    const lz = str.match(/^1+/gmu);\n    const psz: number = (lz !== null) ? lz[0].length : 0;\n    const size = ((str.length - psz) * (Math.log(58) / Math.log(256)) + 1) &gt;&gt;&gt; 0;\n    const uint8 = new Uint8Array([\n        ...new Uint8Array(psz),\n        ...(str.match(/./gmu) ?? [])\n            .map((i) =&gt; base58chars.indexOf(i))\n            .reduce((acc, i) =&gt; {\n            acc = acc.map((j) =&gt; {\n                const x = j * 58 + i;\n                i = x &gt;&gt; 8;\n                return x;\n            });\n            return acc;\n        }, new Uint8Array(size))\n            .reverse()\n            .filter(((lastValue) =&gt; (value) =&gt; (lastValue = lastValue || value))(false))\n    ]);\n    return [...uint8];\n}\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#variable-frombase58check","title":"Variable: fromBase58Check","text":"<pre><code>fromBase58Check = (str: string, enc?: \"hex\", prefixLength: number = 1): {\n    data: number[] | string;\n    prefix: number[] | string;\n} =&gt; {\n    const bin = fromBase58(str);\n    let prefix: string | number[] = bin.slice(0, prefixLength);\n    let data: string | number[] = bin.slice(prefixLength, -4);\n    let hash = [...prefix, ...data];\n    hash = hash256(hash);\n    bin.slice(-4).forEach((check, index) =&gt; {\n        if (check !== hash[index]) {\n            throw new Error(\"Invalid checksum\");\n        }\n    });\n    if (enc === \"hex\") {\n        prefix = toHex(prefix);\n        data = toHex(data);\n    }\n    return { prefix, data };\n}\n</code></pre> <p>See also: fromBase58, hash256, toHex</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#variable-getbytes","title":"Variable: getBytes","text":"<pre><code>getBytes = function (numericValue: number): number[] {\n    return [\n        (numericValue &amp; 4278190080) &gt;&gt;&gt; 24,\n        (numericValue &amp; 16711680) &gt;&gt; 16,\n        (numericValue &amp; 65280) &gt;&gt; 8,\n        numericValue &amp; 255\n    ];\n}\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#variable-hash160","title":"Variable: hash160","text":"<pre><code>hash160 = (msg: Uint8Array | number[] | string, enc?: \"hex\" | \"utf8\"): number[] =&gt; {\n    const first = new SHA256().update(msg, enc).digest();\n    return new RIPEMD160().update(first).digest();\n}\n</code></pre> <p>See also: RIPEMD160, SHA256</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#variable-hash256","title":"Variable: hash256","text":"<pre><code>hash256 = (msg: Uint8Array | number[] | string, enc?: \"hex\" | \"utf8\"): number[] =&gt; {\n    const first = new SHA256().update(msg, enc).digest();\n    return new SHA256().update(first).digest();\n}\n</code></pre> <p>See also: SHA256</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#variable-incrementleastsignificantthirtytwobits","title":"Variable: incrementLeastSignificantThirtyTwoBits","text":"<pre><code>incrementLeastSignificantThirtyTwoBits = function (block: number[]): number[] {\n    let i;\n    const result = block.slice();\n    for (i = 15; i !== 11; i--) {\n        result[i] = result[i] + 1;\n        if (result[i] === 256) {\n            result[i] = 0;\n        }\n        else {\n            break;\n        }\n    }\n    return result;\n}\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#variable-jpadd","title":"Variable: jpAdd","text":"<pre><code>jpAdd = (P: JacobianPointBI, Q: JacobianPointBI): JacobianPointBI =&gt; {\n    if (P.Z === BI_ZERO)\n        return Q;\n    if (Q.Z === BI_ZERO)\n        return P;\n    const Z1Z1 = biModMul(P.Z, P.Z);\n    const Z2Z2 = biModMul(Q.Z, Q.Z);\n    const U1 = biModMul(P.X, Z2Z2);\n    const U2 = biModMul(Q.X, Z1Z1);\n    const S1 = biModMul(P.Y, biModMul(Z2Z2, Q.Z));\n    const S2 = biModMul(Q.Y, biModMul(Z1Z1, P.Z));\n    const H = biModSub(U2, U1);\n    const r = biModSub(S2, S1);\n    if (H === BI_ZERO) {\n        if (r === BI_ZERO)\n            return jpDouble(P);\n        return { X: BI_ZERO, Y: BI_ONE, Z: BI_ZERO };\n    }\n    const HH = biModMul(H, H);\n    const HHH = biModMul(H, HH);\n    const V = biModMul(U1, HH);\n    const X3 = biModSub(biModSub(biModMul(r, r), HHH), biModMul(BI_TWO, V));\n    const Y3 = biModSub(biModMul(r, biModSub(V, X3)), biModMul(S1, HHH));\n    const Z3 = biModMul(H, biModMul(P.Z, Q.Z));\n    return { X: X3, Y: Y3, Z: Z3 };\n}\n</code></pre> <p>See also: BI_ONE, BI_TWO, BI_ZERO, JacobianPointBI, biModMul, biModSub, jpDouble</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#variable-jpdouble","title":"Variable: jpDouble","text":"<pre><code>jpDouble = (P: JacobianPointBI): JacobianPointBI =&gt; {\n    const { X: X1, Y: Y1, Z: Z1 } = P;\n    if (Y1 === BI_ZERO)\n        return { X: BI_ZERO, Y: BI_ONE, Z: BI_ZERO };\n    const Y1sq = biModMul(Y1, Y1);\n    const S = biModMul(BI_FOUR, biModMul(X1, Y1sq));\n    const M = biModMul(BI_THREE, biModMul(X1, X1));\n    const X3 = biModSub(biModMul(M, M), biModMul(BI_TWO, S));\n    const Y3 = biModSub(biModMul(M, biModSub(S, X3)), biModMul(BI_EIGHT, biModMul(Y1sq, Y1sq)));\n    const Z3 = biModMul(BI_TWO, biModMul(Y1, Z1));\n    return { X: X3, Y: Y3, Z: Z3 };\n}\n</code></pre> <p>See also: BI_EIGHT, BI_FOUR, BI_ONE, BI_THREE, BI_TWO, BI_ZERO, JacobianPointBI, biModMul, biModSub</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#variable-jpneg","title":"Variable: jpNeg","text":"<pre><code>jpNeg = (P: JacobianPointBI): JacobianPointBI =&gt; {\n    if (P.Z === BI_ZERO)\n        return P;\n    return { X: P.X, Y: P_BIGINT - P.Y, Z: P.Z };\n}\n</code></pre> <p>See also: BI_ZERO, JacobianPointBI, P_BIGINT</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#variable-minimallyencode","title":"Variable: minimallyEncode","text":"<pre><code>minimallyEncode = (buf: number[]): number[] =&gt; {\n    if (buf.length === 0) {\n        return buf;\n    }\n    const last = buf[buf.length - 1];\n    if ((last &amp; 127) !== 0) {\n        return buf;\n    }\n    if (buf.length === 1) {\n        return [];\n    }\n    if ((buf[buf.length - 2] &amp; 128) !== 0) {\n        return buf;\n    }\n    for (let i = buf.length - 1; i &gt; 0; i--) {\n        if (buf[i - 1] !== 0) {\n            if ((buf[i - 1] &amp; 128) !== 0) {\n                buf[i] = last;\n                return buf.slice(0, i + 1);\n            }\n            else {\n                buf[i - 1] |= last;\n                return buf.slice(0, i);\n            }\n        }\n    }\n    return [];\n}\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#variable-modinvn","title":"Variable: modInvN","text":"<pre><code>modInvN = (a: bigint): bigint =&gt; {\n    let lm = 1n;\n    let hm = 0n;\n    let low = modN(a);\n    let high = N_BIGINT;\n    while (low &gt; 1n) {\n        const q = high / low;\n        [lm, hm] = [hm - lm * q, lm];\n        [low, high] = [high - low * q, low];\n    }\n    return modN(lm);\n}\n</code></pre> <p>See also: N_BIGINT, modN</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#variable-modmuln","title":"Variable: modMulN","text":"<pre><code>modMulN = (a: bigint, b: bigint): bigint =&gt; modN(a * b)\n</code></pre> <p>See also: modN</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#variable-modn","title":"Variable: modN","text":"<pre><code>modN = (a: bigint): bigint =&gt; {\n    let r = a % N_BIGINT;\n    if (r &lt; 0n)\n        r += N_BIGINT;\n    return r;\n}\n</code></pre> <p>See also: N_BIGINT</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#variable-multiply","title":"Variable: multiply","text":"<pre><code>multiply = function (block0: number[], block1: number[]): number[] {\n    const v = block1.slice();\n    const z = createZeroBlock(16);\n    for (let i = 0; i &lt; 16; i++) {\n        for (let j = 7; j &gt;= 0; j--) {\n            if ((block0[i] &amp; (1 &lt;&lt; j)) !== 0) {\n                xorInto(z, v);\n            }\n            if ((v[15] &amp; 1) !== 0) {\n                rightShift(v);\n                xorInto(v, R);\n            }\n            else {\n                rightShift(v);\n            }\n        }\n    }\n    return z;\n}\n</code></pre> <p>See also: rightShift</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#variable-rightshift","title":"Variable: rightShift","text":"<pre><code>rightShift = function (block: number[]): number[] {\n    let i: number;\n    let carry = 0;\n    let oldCarry = 0;\n    for (i = 0; i &lt; block.length; i++) {\n        oldCarry = carry;\n        carry = block[i] &amp; 1;\n        block[i] = block[i] &gt;&gt; 1;\n        if (oldCarry !== 0) {\n            block[i] = block[i] | 128;\n        }\n    }\n    return block;\n}\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#variable-ripemd160","title":"Variable: ripemd160","text":"<pre><code>ripemd160 = (msg: number[] | string, enc?: \"hex\" | \"utf8\"): number[] =&gt; {\n    return new RIPEMD160().update(msg, enc).digest();\n}\n</code></pre> <p>See also: RIPEMD160</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#variable-scalarmultiplywnaf","title":"Variable: scalarMultiplyWNAF","text":"<pre><code>scalarMultiplyWNAF = (k: bigint, P0: {\n    x: bigint;\n    y: bigint;\n}, window: number = 5): JacobianPointBI =&gt; {\n    const key = `${window}:${P0.x.toString(16)}:${P0.y.toString(16)}`;\n    let tbl = WNAF_TABLE_CACHE.get(key);\n    let P: JacobianPointBI;\n    if (tbl === undefined) {\n        const tblSize = 1 &lt;&lt; (window - 1);\n        tbl = new Array(tblSize);\n        P = { X: P0.x, Y: P0.y, Z: BI_ONE };\n        tbl[0] = P;\n        const twoP = jpDouble(P);\n        for (let i = 1; i &lt; tblSize; i++) {\n            tbl[i] = jpAdd(tbl[i - 1], twoP);\n        }\n        WNAF_TABLE_CACHE.set(key, tbl);\n    }\n    else {\n        P = tbl[0];\n    }\n    const wnaf: number[] = [];\n    const wBig = 1n &lt;&lt; BigInt(window);\n    const wHalf = wBig &gt;&gt; 1n;\n    let kTmp = k;\n    while (kTmp &gt; 0n) {\n        if ((kTmp &amp; BI_ONE) === BI_ZERO) {\n            wnaf.push(0);\n            kTmp &gt;&gt;= BI_ONE;\n        }\n        else {\n            let z = kTmp &amp; (wBig - 1n);\n            if (z &gt; wHalf)\n                z -= wBig;\n            wnaf.push(Number(z));\n            kTmp -= z;\n            kTmp &gt;&gt;= BI_ONE;\n        }\n    }\n    let Q: JacobianPointBI = { X: BI_ZERO, Y: BI_ONE, Z: BI_ZERO };\n    for (let i = wnaf.length - 1; i &gt;= 0; i--) {\n        Q = jpDouble(Q);\n        const di = wnaf[i];\n        if (di !== 0) {\n            const idx = Math.abs(di) &gt;&gt; 1;\n            const addend = di &gt; 0 ? tbl[idx] : jpNeg(tbl[idx]);\n            Q = jpAdd(Q, addend);\n        }\n    }\n    return Q;\n}\n</code></pre> <p>See also: BI_ONE, BI_ZERO, JacobianPointBI, jpAdd, jpDouble, jpNeg</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#variable-sha1","title":"Variable: sha1","text":"<pre><code>sha1 = (msg: number[] | string, enc?: \"hex\" | \"utf8\"): number[] =&gt; {\n    return new SHA1().update(msg, enc).digest();\n}\n</code></pre> <p>See also: SHA1</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#variable-sha256","title":"Variable: sha256","text":"<pre><code>sha256 = (msg: Uint8Array | number[] | string, enc?: \"hex\" | \"utf8\"): number[] =&gt; {\n    return new SHA256().update(msg, enc).digest();\n}\n</code></pre> <p>See also: SHA256</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#variable-sha256hmac","title":"Variable: sha256hmac","text":"<pre><code>sha256hmac = (key: Uint8Array | number[] | string, msg: Uint8Array | number[] | string, enc?: \"hex\"): number[] =&gt; {\n    return new SHA256HMAC(key).update(msg, enc).digest();\n}\n</code></pre> <p>See also: SHA256HMAC</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#variable-sha512","title":"Variable: sha512","text":"<pre><code>sha512 = (msg: number[] | string, enc?: \"hex\" | \"utf8\"): number[] =&gt; {\n    return new SHA512().update(msg, enc).digest();\n}\n</code></pre> <p>See also: SHA512</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#variable-sha512hmac","title":"Variable: sha512hmac","text":"<pre><code>sha512hmac = (key: Uint8Array | number[] | string, msg: Uint8Array | number[] | string, enc?: \"hex\"): number[] =&gt; {\n    return new SHA512HMAC(key).update(msg, enc).digest();\n}\n</code></pre> <p>See also: SHA512HMAC</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#variable-sign","title":"Variable: sign","text":"<pre><code>sign = (msg: BigNumber, key: BigNumber, forceLowS: boolean = false, customK?: BigNumber | ((iter: number) =&gt; BigNumber)): Signature =&gt; {\n    msg = truncateToN(msg);\n    const msgBig = BigInt(\"0x\" + msg.toString(16));\n    const keyBig = BigInt(\"0x\" + key.toString(16));\n    const bkey = key.toArray(\"be\", bytes);\n    const nonce = msg.toArray(\"be\", bytes);\n    const drbg = new DRBG(bkey, nonce);\n    for (let iter = 0;; iter++) {\n        let kBN = typeof customK === \"function\"\n            ? customK(iter)\n            : BigNumber.isBN(customK)\n                ? customK\n                : new BigNumber(drbg.generate(bytes), 16);\n        if (kBN == null)\n            throw new Error(\"k is undefined\");\n        kBN = truncateToN(kBN, true);\n        if (kBN.cmpn(1) &lt;= 0 || kBN.cmp(ns1) &gt;= 0) {\n            if (BigNumber.isBN(customK)) {\n                throw new Error(\"Invalid fixed custom K value (must be &gt;1 and &lt;N\\u20111)\");\n            }\n            continue;\n        }\n        const kBig = BigInt(\"0x\" + kBN.toString(16));\n        const R = scalarMultiplyWNAF(kBig, { x: GX_BIGINT, y: GY_BIGINT });\n        if (R.Z === 0n) {\n            if (BigNumber.isBN(customK)) {\n                throw new Error(\"Invalid fixed custom K value (k\\u00B7G at infinity)\");\n            }\n            continue;\n        }\n        const zInv = biModInv(R.Z);\n        const zInv2 = biModMul(zInv, zInv);\n        const xAff = biModMul(R.X, zInv2);\n        const rBig = modN(xAff);\n        if (rBig === 0n) {\n            if (BigNumber.isBN(customK)) {\n                throw new Error(\"Invalid fixed custom K value (r == 0)\");\n            }\n            continue;\n        }\n        const kInv = modInvN(kBig);\n        const rTimesKey = modMulN(rBig, keyBig);\n        const sum = modN(msgBig + rTimesKey);\n        let sBig = modMulN(kInv, sum);\n        if (sBig === 0n) {\n            if (BigNumber.isBN(customK)) {\n                throw new Error(\"Invalid fixed custom K value (s == 0)\");\n            }\n            continue;\n        }\n        if (forceLowS &amp;&amp; sBig &gt; halfN) {\n            sBig = N_BIGINT - sBig;\n        }\n        const r = new BigNumber(rBig.toString(16), 16);\n        const s = new BigNumber(sBig.toString(16), 16);\n        return new Signature(r, s);\n    }\n}\n</code></pre> <p>See also: BigNumber, DRBG, GX_BIGINT, GY_BIGINT, N_BIGINT, Signature, biModInv, biModMul, modInvN, modMulN, modN, scalarMultiplyWNAF, toArray</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#variable-toarray","title":"Variable: toArray","text":"<pre><code>toArray = (msg: any, enc?: \"hex\" | \"utf8\" | \"base64\"): any[] =&gt; {\n    if (Array.isArray(msg))\n        return msg.slice();\n    if (msg === undefined)\n        return [];\n    if (typeof msg !== \"string\") {\n        return Array.from(msg, (item: any) =&gt; item | 0);\n    }\n    switch (enc) {\n        case \"hex\":\n            return hexToArray(msg);\n        case \"base64\":\n            return base64ToArray(msg);\n        default:\n            return utf8ToArray(msg);\n    }\n}\n</code></pre> <p>See also: base64ToArray</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#variable-tobase58","title":"Variable: toBase58","text":"<pre><code>toBase58 = (bin: number[]): string =&gt; {\n    const base58Map = Array(256).fill(-1);\n    for (let i = 0; i &lt; base58chars.length; ++i) {\n        base58Map[base58chars.charCodeAt(i)] = i;\n    }\n    const result: number[] = [];\n    for (const byte of bin) {\n        let carry = byte;\n        for (let j = 0; j &lt; result.length; ++j) {\n            const x = (base58Map[result[j]] &lt;&lt; 8) + carry;\n            result[j] = base58chars.charCodeAt(x % 58);\n            carry = (x / 58) | 0;\n        }\n        while (carry !== 0) {\n            result.push(base58chars.charCodeAt(carry % 58));\n            carry = (carry / 58) | 0;\n        }\n    }\n    for (const byte of bin) {\n        if (byte !== 0)\n            break;\n        else\n            result.push(\"1\".charCodeAt(0));\n    }\n    result.reverse();\n    return String.fromCharCode(...result);\n}\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#variable-tobase58check","title":"Variable: toBase58Check","text":"<pre><code>toBase58Check = (bin: number[], prefix: number[] = [0]): string =&gt; {\n    let hash = hash256([...prefix, ...bin]);\n    hash = [...prefix, ...bin, ...hash.slice(0, 4)];\n    return toBase58(hash);\n}\n</code></pre> <p>See also: hash256, toBase58</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#variable-tohex","title":"Variable: toHex","text":"<pre><code>toHex = (msg: number[]): string =&gt; {\n    if (CAN_USE_BUFFER) {\n        return BufferCtor.from(msg).toString(\"hex\");\n    }\n    if (msg.length === 0)\n        return \"\";\n    const out = new Array(msg.length);\n    for (let i = 0; i &lt; msg.length; i++) {\n        out[i] = HEX_BYTE_STRINGS[msg[i] &amp; 255];\n    }\n    return out.join(\"\");\n}\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#variable-toutf8","title":"Variable: toUTF8","text":"<pre><code>toUTF8 = (arr: number[]): string =&gt; {\n    let result = \"\";\n    let skip = 0;\n    for (let i = 0; i &lt; arr.length; i++) {\n        const byte = arr[i];\n        if (skip &gt; 0) {\n            skip--;\n            continue;\n        }\n        if (byte &lt;= 127) {\n            result += String.fromCharCode(byte);\n        }\n        else if (byte &gt;= 192 &amp;&amp; byte &lt;= 223) {\n            const byte2 = arr[i + 1];\n            skip = 1;\n            const codePoint = ((byte &amp; 31) &lt;&lt; 6) | (byte2 &amp; 63);\n            result += String.fromCharCode(codePoint);\n        }\n        else if (byte &gt;= 224 &amp;&amp; byte &lt;= 239) {\n            const byte2 = arr[i + 1];\n            const byte3 = arr[i + 2];\n            skip = 2;\n            const codePoint = ((byte &amp; 15) &lt;&lt; 12) | ((byte2 &amp; 63) &lt;&lt; 6) | (byte3 &amp; 63);\n            result += String.fromCharCode(codePoint);\n        }\n        else if (byte &gt;= 240 &amp;&amp; byte &lt;= 247) {\n            const byte2 = arr[i + 1];\n            const byte3 = arr[i + 2];\n            const byte4 = arr[i + 3];\n            skip = 3;\n            const codePoint = ((byte &amp; 7) &lt;&lt; 18) |\n                ((byte2 &amp; 63) &lt;&lt; 12) |\n                ((byte3 &amp; 63) &lt;&lt; 6) |\n                (byte4 &amp; 63);\n            const surrogate1 = 55296 + ((codePoint - 65536) &gt;&gt; 10);\n            const surrogate2 = 56320 + ((codePoint - 65536) &amp; 1023);\n            result += String.fromCharCode(surrogate1, surrogate2);\n        }\n    }\n    return result;\n}\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#variable-verify","title":"Variable: verify","text":"<pre><code>verify = (msg: BigNumber, sig: Signature, key: Point): boolean =&gt; {\n    const hash = BigInt(\"0x\" + msg.toString(16));\n    if ((key.x == null) || (key.y == null)) {\n        throw new Error(\"Invalid public key: missing coordinates.\");\n    }\n    const publicKey = {\n        x: BigInt(\"0x\" + key.x.toString(16)),\n        y: BigInt(\"0x\" + key.y.toString(16))\n    };\n    const signature = {\n        r: BigInt(\"0x\" + sig.r.toString(16)),\n        s: BigInt(\"0x\" + sig.s.toString(16))\n    };\n    const { r, s } = signature;\n    const z = hash;\n    if (r &lt;= BI_ZERO || r &gt;= N_BIGINT || s &lt;= BI_ZERO || s &gt;= N_BIGINT) {\n        return false;\n    }\n    const w = modInvN(s);\n    if (w === 0n)\n        return false;\n    const u1 = modMulN(z, w);\n    const u2 = modMulN(r, w);\n    const RG = scalarMultiplyWNAF(u1, { x: GX_BIGINT, y: GY_BIGINT });\n    const RQ = scalarMultiplyWNAF(u2, publicKey);\n    const R = jpAdd(RG, RQ);\n    if (R.Z === 0n)\n        return false;\n    const zInv = biModInv(R.Z);\n    const zInv2 = biModMul(zInv, zInv);\n    const xAff = biModMul(R.X, zInv2);\n    const v = modN(xAff);\n    return v === r;\n}\n</code></pre> <p>See also: BI_ZERO, BigNumber, GX_BIGINT, GY_BIGINT, N_BIGINT, Point, Signature, biModInv, biModMul, jpAdd, modInvN, modMulN, modN, scalarMultiplyWNAF</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/primitives/#variable-zero2","title":"Variable: zero2","text":"<pre><code>zero2 = (word: string): string =&gt; {\n    if (word.length % 2 === 1) {\n        return \"0\" + word;\n    }\n    else {\n        return word;\n    }\n}\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/registry/","title":"API","text":"<p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/registry/#interfaces","title":"Interfaces","text":"BasketDefinitionData BasketQuery CertificateDefinitionData CertificateFieldDescriptor CertificateQuery ProtocolDefinitionData ProtocolQuery RegistryQueryMapping TokenData <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/registry/#interface-basketdefinitiondata","title":"Interface: BasketDefinitionData","text":"<p>Registry data for a Basket-style record.</p> <pre><code>export interface BasketDefinitionData {\n    definitionType: \"basket\";\n    basketID: string;\n    name: string;\n    iconURL: string;\n    description: string;\n    documentationURL: string;\n    registryOperator?: PubKeyHex;\n}\n</code></pre> <p>See also: PubKeyHex</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/registry/#interface-basketquery","title":"Interface: BasketQuery","text":"<p>When searching for basket definitions, we can filter by:  - basketID  - registryOperators  - name</p> <pre><code>export interface BasketQuery {\n    basketID?: string;\n    registryOperators?: string[];\n    name?: string;\n}\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/registry/#interface-certificatedefinitiondata","title":"Interface: CertificateDefinitionData","text":"<p>Registry data for a Certificate-style record.</p> <pre><code>export interface CertificateDefinitionData {\n    definitionType: \"certificate\";\n    type: string;\n    name: string;\n    iconURL: string;\n    description: string;\n    documentationURL: string;\n    fields: Record&lt;string, CertificateFieldDescriptor&gt;;\n    registryOperator?: PubKeyHex;\n}\n</code></pre> <p>See also: CertificateFieldDescriptor, PubKeyHex</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/registry/#interface-certificatefielddescriptor","title":"Interface: CertificateFieldDescriptor","text":"<p>Describes a re-usable structure for certificate fields (used by CertMap).</p> <pre><code>export interface CertificateFieldDescriptor {\n    friendlyName: string;\n    description: string;\n    type: \"text\" | \"imageURL\" | \"other\";\n    fieldIcon: string;\n}\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/registry/#interface-certificatequery","title":"Interface: CertificateQuery","text":"<p>When searching for certificate definitions, we can filter by:  - type  - name  - registryOperators</p> <pre><code>export interface CertificateQuery {\n    type?: string;\n    name?: string;\n    registryOperators?: string[];\n}\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/registry/#interface-protocoldefinitiondata","title":"Interface: ProtocolDefinitionData","text":"<p>Registry data for a Protocol-style record.</p> <pre><code>export interface ProtocolDefinitionData {\n    definitionType: \"protocol\";\n    protocolID: WalletProtocol;\n    name: string;\n    iconURL: string;\n    description: string;\n    documentationURL: string;\n    registryOperator?: PubKeyHex;\n}\n</code></pre> <p>See also: PubKeyHex, WalletProtocol</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/registry/#interface-protocolquery","title":"Interface: ProtocolQuery","text":"<p>When searching for protocol definitions, we can filter by:  - name  - registryOperators  - protocolID</p> <pre><code>export interface ProtocolQuery {\n    name?: string;\n    registryOperators?: string[];\n    protocolID?: WalletProtocol;\n}\n</code></pre> <p>See also: WalletProtocol</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/registry/#interface-registryquerymapping","title":"Interface: RegistryQueryMapping","text":"<p>A lookup-service mapping of queries by each definition type.</p> <pre><code>export interface RegistryQueryMapping {\n    basket: BasketQuery;\n    protocol: ProtocolQuery;\n    certificate: CertificateQuery;\n}\n</code></pre> <p>See also: BasketQuery, CertificateQuery, ProtocolQuery</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/registry/#interface-tokendata","title":"Interface: TokenData","text":"<p>Common info for the on-chain token/UTXO that points to a registry entry.</p> <pre><code>export interface TokenData {\n    txid: string;\n    outputIndex: number;\n    satoshis: number;\n    lockingScript: string;\n    beef: BEEF;\n}\n</code></pre> <p>See also: BEEF</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/registry/#classes","title":"Classes","text":""},{"location":"reference/registry/#class-registryclient","title":"Class: RegistryClient","text":"<p>RegistryClient manages on-chain registry definitions for three types: - basket (basket-based items) - protocol (protocol-based items) - certificate (certificate-based items)</p> <p>It provides methods to: - Register new definitions using pushdrop-based UTXOs. - Resolve existing definitions using a lookup service. - List registry entries associated with the operator's wallet. - Remove existing registry entries by spending their UTXOs. - Update existing registry entries.</p> <p>Registry operators use this client to establish and manage canonical references for baskets, protocols, and certificate types.</p> <pre><code>export class RegistryClient {\n    constructor(private readonly wallet: WalletInterface = new WalletClient(), options: {\n        acceptDelayedBroadcast?: boolean;\n        resolver?: LookupResolver;\n    } = {}, private readonly originator?: OriginatorDomainNameStringUnder250Bytes) \n    async registerDefinition(data: DefinitionData): Promise&lt;BroadcastResponse | BroadcastFailure&gt; \n    async resolve&lt;T extends DefinitionType&gt;(definitionType: T, query: RegistryQueryMapping[T]): Promise&lt;DefinitionData[]&gt; \n    async listOwnRegistryEntries(definitionType: DefinitionType): Promise&lt;RegistryRecord[]&gt; \n    async removeDefinition(registryRecord: RegistryRecord): Promise&lt;BroadcastResponse | BroadcastFailure&gt; \n    async updateDefinition(registryRecord: RegistryRecord, updatedData: DefinitionData): Promise&lt;BroadcastResponse | BroadcastFailure&gt; \n}\n</code></pre> <p>See also: BroadcastFailure, BroadcastResponse, DefinitionData, DefinitionType, LookupResolver, OriginatorDomainNameStringUnder250Bytes, RegistryQueryMapping, RegistryRecord, WalletClient, WalletInterface</p>"},{"location":"reference/registry/#method-listownregistryentries","title":"Method listOwnRegistryEntries","text":"<p>Lists the registry operator's published definitions for the given type.</p> <p>Returns parsed registry records including transaction details such as txid, outputIndex, satoshis, and the locking script.</p> <p><pre><code>async listOwnRegistryEntries(definitionType: DefinitionType): Promise&lt;RegistryRecord[]&gt; \n</code></pre> See also: DefinitionType, RegistryRecord</p> <p>Returns</p> <p>A promise that resolves to an array of RegistryRecord objects.</p> <p>Argument Details</p> <ul> <li>definitionType</li> <li>The type of registry definition to list ('basket', 'protocol', or 'certificate').</li> </ul>"},{"location":"reference/registry/#method-registerdefinition","title":"Method registerDefinition","text":"<p>Publishes a new on-chain definition for baskets, protocols, or certificates. The definition data is encoded in a pushdrop-based UTXO.</p> <p>Registry operators (i.e., identity key owners) can create these definitions to establish canonical references for basket IDs, protocol specs, or certificate schemas.</p> <p><pre><code>async registerDefinition(data: DefinitionData): Promise&lt;BroadcastResponse | BroadcastFailure&gt; \n</code></pre> See also: BroadcastFailure, BroadcastResponse, DefinitionData</p> <p>Returns</p> <p>A promise with the broadcast result or failure.</p> <p>Argument Details</p> <ul> <li>data</li> <li>Structured information about a 'basket', 'protocol', or 'certificate'.</li> </ul>"},{"location":"reference/registry/#method-removedefinition","title":"Method removeDefinition","text":"<p>Removes a registry definition by spending its associated UTXO.</p> <p><pre><code>async removeDefinition(registryRecord: RegistryRecord): Promise&lt;BroadcastResponse | BroadcastFailure&gt; \n</code></pre> See also: BroadcastFailure, BroadcastResponse, RegistryRecord</p> <p>Returns</p> <p>Broadcast success/failure.</p> <p>Argument Details</p> <ul> <li>registryRecord</li> <li>The registry record to remove (must have valid txid, outputIndex, and lockingScript).</li> </ul>"},{"location":"reference/registry/#method-resolve","title":"Method resolve","text":"<p>Resolves registrant tokens of a particular type using a lookup service.</p> <p>The query object shape depends on the registry type: - For \"basket\", the query is of type BasketMapQuery:   { basketID?: string; name?: string; registryOperators?: string[]; } - For \"protocol\", the query is of type ProtoMapQuery:   { name?: string; registryOperators?: string[]; protocolID?: WalletProtocol; } - For \"certificate\", the query is of type CertMapQuery:   { type?: string; name?: string; registryOperators?: string[]; }</p> <p><pre><code>async resolve&lt;T extends DefinitionType&gt;(definitionType: T, query: RegistryQueryMapping[T]): Promise&lt;DefinitionData[]&gt; \n</code></pre> See also: DefinitionData, DefinitionType, RegistryQueryMapping</p> <p>Returns</p> <p>A promise that resolves to an array of matching registry records.</p> <p>Argument Details</p> <ul> <li>definitionType</li> <li>The registry type, which can be 'basket', 'protocol', or 'certificate'.</li> <li>query</li> <li>The query object used to filter registry records, whose shape is determined by the registry type.</li> </ul>"},{"location":"reference/registry/#method-updatedefinition","title":"Method updateDefinition","text":"<p>Updates an existing registry record by spending its UTXO and creating a new one with updated data.</p> <p><pre><code>async updateDefinition(registryRecord: RegistryRecord, updatedData: DefinitionData): Promise&lt;BroadcastResponse | BroadcastFailure&gt; \n</code></pre> See also: BroadcastFailure, BroadcastResponse, DefinitionData, RegistryRecord</p> <p>Returns</p> <p>Broadcast success/failure.</p> <p>Argument Details</p> <ul> <li>registryRecord</li> <li>The existing registry record to update (must have valid txid, outputIndex, and lockingScript).</li> <li>updatedData</li> <li>The new definition data to replace the old record.</li> </ul> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/registry/#functions","title":"Functions","text":""},{"location":"reference/registry/#function-deserializewalletprotocol","title":"Function: deserializeWalletProtocol","text":"<pre><code>export function deserializeWalletProtocol(str: string): WalletProtocol \n</code></pre> <p>See also: WalletProtocol</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/registry/#types","title":"Types","text":"DefinitionData DefinitionType RegistryRecord <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/registry/#type-definitiondata","title":"Type: DefinitionData","text":"<p>Union of all possible definition data objects.</p> <pre><code>export type DefinitionData = BasketDefinitionData | ProtocolDefinitionData | CertificateDefinitionData\n</code></pre> <p>See also: BasketDefinitionData, CertificateDefinitionData, ProtocolDefinitionData</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/registry/#type-definitiontype","title":"Type: DefinitionType","text":"<p>We unify the registry \u201ctype\u201d to these three strings everywhere:   'basket' | 'protocol' | 'certificate'</p> <pre><code>export type DefinitionType = \"basket\" | \"protocol\" | \"certificate\"\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/registry/#type-registryrecord","title":"Type: RegistryRecord","text":"<p>A registry record is a combination of the typed definition data plus the on-chain token data for the UTXO holding it.</p> <pre><code>export type RegistryRecord = DefinitionData &amp; TokenData\n</code></pre> <p>See also: DefinitionData, TokenData</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/registry/#enums","title":"Enums","text":""},{"location":"reference/registry/#variables","title":"Variables","text":""},{"location":"reference/script/","title":"API","text":"<p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/script/#interfaces","title":"Interfaces","text":"ScriptChunk ScriptTemplate ScriptTemplateUnlock <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/script/#interface-scriptchunk","title":"Interface: ScriptChunk","text":"<p>A representation of a chunk of a script, which includes an opcode. For push operations, the associated data to push onto the stack is also included.</p> <pre><code>export default interface ScriptChunk {\n    op: number;\n    data?: number[];\n}\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/script/#interface-scripttemplate","title":"Interface: ScriptTemplate","text":"<pre><code>export default interface ScriptTemplate {\n    lock: (...params: any[]) =&gt; LockingScript | Promise&lt;LockingScript&gt;;\n    unlock: (...params: any[]) =&gt; ScriptTemplateUnlock;\n}\n</code></pre> <p>See also: LockingScript, ScriptTemplateUnlock</p>"},{"location":"reference/script/#property-lock","title":"Property lock","text":"<p>Creates a locking script with the given parameters.</p> <p><pre><code>lock: (...params: any[]) =&gt; LockingScript | Promise&lt;LockingScript&gt;\n</code></pre> See also: LockingScript</p>"},{"location":"reference/script/#property-unlock","title":"Property unlock","text":"<p>Creates a function that generates an unlocking script along with its signature and length estimation.</p> <p>This method returns an object containing two functions: 1. <code>sign</code> - A function that, when called with a transaction and an input index, returns an UnlockingScript instance. 2. <code>estimateLength</code> - A function that returns the estimated length of the unlocking script in bytes.</p> <p><pre><code>unlock: (...params: any[]) =&gt; ScriptTemplateUnlock\n</code></pre> See also: ScriptTemplateUnlock</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/script/#interface-scripttemplateunlock","title":"Interface: ScriptTemplateUnlock","text":"<pre><code>export default interface ScriptTemplateUnlock {\n    sign: (tx: Transaction, inputIndex: number) =&gt; Promise&lt;UnlockingScript&gt;;\n    estimateLength: (tx: Transaction, inputIndex: number) =&gt; Promise&lt;number&gt;;\n}\n</code></pre> <p>See also: Transaction, UnlockingScript, sign</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/script/#classes","title":"Classes","text":"LockingScript P2PKH PushDrop RPuzzle Script ScriptEvaluationError Spend UnlockingScript <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/script/#class-lockingscript","title":"Class: LockingScript","text":"<p>The LockingScript class represents a locking script in a Bitcoin SV transaction. It extends the Script class and is used specifically for output scripts that lock funds.</p> <p>Inherits all properties and methods from the Script class.</p> <pre><code>export default class LockingScript extends Script {\n    isLockingScript(): boolean \n    isUnlockingScript(): boolean \n}\n</code></pre> <p>See also: Script</p>"},{"location":"reference/script/#method-islockingscript","title":"Method isLockingScript","text":"<pre><code>isLockingScript(): boolean \n</code></pre> <p>Returns</p> <p>Always returns true for a LockingScript instance.</p>"},{"location":"reference/script/#method-isunlockingscript","title":"Method isUnlockingScript","text":"<pre><code>isUnlockingScript(): boolean \n</code></pre> <p>Returns</p> <p>Always returns false for a LockingScript instance.</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/script/#class-p2pkh","title":"Class: P2PKH","text":"<p>P2PKH (Pay To Public Key Hash) class implementing ScriptTemplate.</p> <p>This class provides methods to create Pay To Public Key Hash locking and unlocking scripts, including the unlocking of P2PKH UTXOs with the private key.</p> <pre><code>export default class P2PKH implements ScriptTemplate {\n    lock(pubkeyhash: string | number[]): LockingScript \n    unlock(privateKey: PrivateKey, signOutputs: \"all\" | \"none\" | \"single\" = \"all\", anyoneCanPay: boolean = false, sourceSatoshis?: number, lockingScript?: Script): {\n        sign: (tx: Transaction, inputIndex: number) =&gt; Promise&lt;UnlockingScript&gt;;\n        estimateLength: () =&gt; Promise&lt;108&gt;;\n    } \n}\n</code></pre> <p>See also: LockingScript, PrivateKey, Script, ScriptTemplate, Transaction, UnlockingScript, sign</p>"},{"location":"reference/script/#method-lock","title":"Method lock","text":"<p>Creates a P2PKH locking script for a given public key hash or address string</p> <p><pre><code>lock(pubkeyhash: string | number[]): LockingScript \n</code></pre> See also: LockingScript</p> <p>Returns</p> <ul> <li>A P2PKH locking script.</li> </ul> <p>Argument Details</p> <ul> <li>pubkeyhash</li> <li>or address - An array or address representing the public key hash.</li> </ul>"},{"location":"reference/script/#method-unlock","title":"Method unlock","text":"<p>Creates a function that generates a P2PKH unlocking script along with its signature and length estimation.</p> <p>The returned object contains: 1. <code>sign</code> - A function that, when invoked with a transaction and an input index,    produces an unlocking script suitable for a P2PKH locked output. 2. <code>estimateLength</code> - A function that returns the estimated length of the unlocking script in bytes.</p> <p><pre><code>unlock(privateKey: PrivateKey, signOutputs: \"all\" | \"none\" | \"single\" = \"all\", anyoneCanPay: boolean = false, sourceSatoshis?: number, lockingScript?: Script): {\n    sign: (tx: Transaction, inputIndex: number) =&gt; Promise&lt;UnlockingScript&gt;;\n    estimateLength: () =&gt; Promise&lt;108&gt;;\n} \n</code></pre> See also: PrivateKey, Script, Transaction, UnlockingScript, sign</p> <p>Returns</p> <ul> <li>An object containing the <code>sign</code> and <code>estimateLength</code> functions.</li> </ul> <p>Argument Details</p> <ul> <li>privateKey</li> <li>The private key used for signing the transaction.</li> <li>signOutputs</li> <li>The signature scope for outputs.</li> <li>anyoneCanPay</li> <li>Flag indicating if the signature allows for other inputs to be added later.</li> <li>sourceSatoshis</li> <li>Optional. The amount being unlocked. Otherwise the input.sourceTransaction is required.</li> <li>lockingScript</li> <li>Optional. The lockinScript. Otherwise the input.sourceTransaction is required.</li> </ul> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/script/#class-pushdrop","title":"Class: PushDrop","text":"<pre><code>export default class PushDrop implements ScriptTemplate {\n    wallet: WalletInterface;\n    originator?: string;\n    static decode(script: LockingScript): {\n        lockingPublicKey: PublicKey;\n        fields: number[][];\n    } \n    constructor(wallet: WalletInterface, originator?: string) \n    async lock(fields: number[][], protocolID: WalletProtocol, keyID: string, counterparty: string, forSelf = false, includeSignature = true, lockPosition: \"before\" | \"after\" = \"before\"): Promise&lt;LockingScript&gt; \n    unlock(protocolID: WalletProtocol, keyID: string, counterparty: string, signOutputs: \"all\" | \"none\" | \"single\" = \"all\", anyoneCanPay = false, sourceSatoshis?: number, lockingScript?: LockingScript): {\n        sign: (tx: Transaction, inputIndex: number) =&gt; Promise&lt;UnlockingScript&gt;;\n        estimateLength: () =&gt; Promise&lt;73&gt;;\n    } \n}\n</code></pre> <p>See also: LockingScript, PublicKey, ScriptTemplate, Transaction, UnlockingScript, WalletInterface, WalletProtocol, sign</p>"},{"location":"reference/script/#constructor","title":"Constructor","text":"<p>Constructs a new instance of the PushDrop class.</p> <p><pre><code>constructor(wallet: WalletInterface, originator?: string) \n</code></pre> See also: WalletInterface</p> <p>Argument Details</p> <ul> <li>wallet</li> <li>The wallet interface used for creating signatures and accessing public keys.</li> <li>originator</li> <li>\u2014 The originator to use with Wallet requests</li> </ul>"},{"location":"reference/script/#method-decode","title":"Method decode","text":"<p>Decodes a PushDrop script back into its token fields and the locking public key. If a signature was present, it will be the last field returned. Warning: Only works with a P2PK lock at the beginning of the script.</p> <p><pre><code>static decode(script: LockingScript): {\n    lockingPublicKey: PublicKey;\n    fields: number[][];\n} \n</code></pre> See also: LockingScript, PublicKey</p> <p>Returns</p> <p>An object containing PushDrop token fields and the locking public key. If a signature was included, it will be the last field.</p> <p>Argument Details</p> <ul> <li>script</li> <li>PushDrop script to decode back into token fields</li> </ul>"},{"location":"reference/script/#method-lock_1","title":"Method lock","text":"<p>Creates a PushDrop locking script with arbitrary data fields and a public key lock.</p> <p><pre><code>async lock(fields: number[][], protocolID: WalletProtocol, keyID: string, counterparty: string, forSelf = false, includeSignature = true, lockPosition: \"before\" | \"after\" = \"before\"): Promise&lt;LockingScript&gt; \n</code></pre> See also: LockingScript, WalletProtocol</p> <p>Returns</p> <p>The generated PushDrop locking script.</p> <p>Argument Details</p> <ul> <li>fields</li> <li>The token fields to include in the locking script.</li> <li>protocolID</li> <li>The protocol ID to use.</li> <li>keyID</li> <li>The key ID to use.</li> <li>counterparty</li> <li>The counterparty involved in the transaction, \"self\" or \"anyone\".</li> <li>forSelf</li> <li>Flag indicating if the lock is for the creator (default no).</li> <li>includeSignature</li> <li>Flag indicating if a signature should be included in the script (default yes).</li> </ul>"},{"location":"reference/script/#method-unlock_1","title":"Method unlock","text":"<p>Creates an unlocking script for spending a PushDrop token output.</p> <p><pre><code>unlock(protocolID: WalletProtocol, keyID: string, counterparty: string, signOutputs: \"all\" | \"none\" | \"single\" = \"all\", anyoneCanPay = false, sourceSatoshis?: number, lockingScript?: LockingScript): {\n    sign: (tx: Transaction, inputIndex: number) =&gt; Promise&lt;UnlockingScript&gt;;\n    estimateLength: () =&gt; Promise&lt;73&gt;;\n} \n</code></pre> See also: LockingScript, Transaction, UnlockingScript, WalletProtocol, sign</p> <p>Returns</p> <p>An object containing functions to sign the transaction and estimate the script length.</p> <p>Argument Details</p> <ul> <li>protocolID</li> <li>The protocol ID to use.</li> <li>keyID</li> <li>The key ID to use.</li> <li>counterparty</li> <li>The counterparty involved in the transaction, \"self\" or \"anyone\".</li> <li>sourceTXID</li> <li>The TXID of the source transaction.</li> <li>sourceSatoshis</li> <li>The number of satoshis in the source output.</li> <li>lockingScript</li> <li>The locking script of the source output.</li> <li>signOutputs</li> <li>Specifies which outputs to sign.</li> <li>anyoneCanPay</li> <li>Specifies if the anyone-can-pay flag is set.</li> </ul> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/script/#class-rpuzzle","title":"Class: RPuzzle","text":"<p>RPuzzle class implementing ScriptTemplate.</p> <p>This class provides methods to create R Puzzle and R Puzzle Hash locking and unlocking scripts, including the unlocking of UTXOs with the correct K value.</p> <pre><code>export default class RPuzzle implements ScriptTemplate {\n    type: \"raw\" | \"SHA1\" | \"SHA256\" | \"HASH256\" | \"RIPEMD160\" | \"HASH160\" = \"raw\";\n    constructor(type: \"raw\" | \"SHA1\" | \"SHA256\" | \"HASH256\" | \"RIPEMD160\" | \"HASH160\" = \"raw\") \n    lock(value: number[]): LockingScript \n    unlock(k: BigNumber, privateKey: PrivateKey, signOutputs: \"all\" | \"none\" | \"single\" = \"all\", anyoneCanPay: boolean = false): {\n        sign: (tx: Transaction, inputIndex: number) =&gt; Promise&lt;UnlockingScript&gt;;\n        estimateLength: () =&gt; Promise&lt;108&gt;;\n    } \n}\n</code></pre> <p>See also: BigNumber, LockingScript, PrivateKey, ScriptTemplate, Transaction, UnlockingScript, sign</p>"},{"location":"reference/script/#constructor_1","title":"Constructor","text":"<pre><code>constructor(type: \"raw\" | \"SHA1\" | \"SHA256\" | \"HASH256\" | \"RIPEMD160\" | \"HASH160\" = \"raw\") \n</code></pre> <p>Argument Details</p> <ul> <li>type</li> <li>Denotes the type of puzzle to create</li> </ul>"},{"location":"reference/script/#method-lock_2","title":"Method lock","text":"<p>Creates an R puzzle locking script for a given R value or R value hash.</p> <p><pre><code>lock(value: number[]): LockingScript \n</code></pre> See also: LockingScript</p> <p>Returns</p> <ul> <li>An R puzzle locking script.</li> </ul> <p>Argument Details</p> <ul> <li>value</li> <li>An array representing the R value or its hash.</li> </ul>"},{"location":"reference/script/#method-unlock_2","title":"Method unlock","text":"<p>Creates a function that generates an R puzzle unlocking script along with its signature and length estimation.</p> <p>The returned object contains: 1. <code>sign</code> - A function that, when invoked with a transaction and an input index,    produces an unlocking script suitable for an R puzzle locked output. 2. <code>estimateLength</code> - A function that returns the estimated length of the unlocking script in bytes.</p> <p><pre><code>unlock(k: BigNumber, privateKey: PrivateKey, signOutputs: \"all\" | \"none\" | \"single\" = \"all\", anyoneCanPay: boolean = false): {\n    sign: (tx: Transaction, inputIndex: number) =&gt; Promise&lt;UnlockingScript&gt;;\n    estimateLength: () =&gt; Promise&lt;108&gt;;\n} \n</code></pre> See also: BigNumber, PrivateKey, Transaction, UnlockingScript, sign</p> <p>Returns</p> <ul> <li>An object containing the <code>sign</code> and <code>estimateLength</code> functions.</li> </ul> <p>Argument Details</p> <ul> <li>k</li> <li>\u2014 The K-value used to unlock the R-puzzle.</li> <li>privateKey</li> <li>The private key used for signing the transaction. If not provided, a random key will be generated.</li> <li>signOutputs</li> <li>The signature scope for outputs.</li> <li>anyoneCanPay</li> <li>Flag indicating if the signature allows for other inputs to be added later.</li> </ul> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/script/#class-script","title":"Class: Script","text":"<pre><code>export default class Script {\n    static fromASM(asm: string): Script \n    static fromHex(hex: string): Script \n    static fromBinary(bin: number[]): Script \n    constructor(chunks: ScriptChunk[] = [], rawBytesCache?: Uint8Array, hexCache?: string, parsed: boolean = true) \n    get chunks(): ScriptChunk[] \n    set chunks(value: ScriptChunk[]) \n    toASM(): string \n    toHex(): string \n    toBinary(): number[] \n    toUint8Array(): Uint8Array \n    writeScript(script: Script): Script \n    writeOpCode(op: number): Script \n    setChunkOpCode(i: number, op: number): Script \n    writeBn(bn: BigNumber): Script \n    writeBin(bin: number[]): Script \n    writeNumber(num: number): Script \n    removeCodeseparators(): Script \n    findAndDelete(script: Script): Script \n    isPushOnly(): boolean \n    isLockingScript(): boolean \n    isUnlockingScript(): boolean \n}\n</code></pre> <p>See also: BigNumber, ScriptChunk, toHex</p>"},{"location":"reference/script/#constructor_2","title":"Constructor","text":"<p><pre><code>constructor(chunks: ScriptChunk[] = [], rawBytesCache?: Uint8Array, hexCache?: string, parsed: boolean = true) \n</code></pre> See also: ScriptChunk</p> <p>Argument Details</p> <ul> <li>chunks</li> <li>=[] - An array of script chunks to directly initialize the script.</li> <li>rawBytesCache</li> <li>Optional serialized bytes that can be reused instead of reserializing <code>chunks</code>.</li> <li>hexCache</li> <li>Optional lowercase hex string that matches the serialized bytes, used to satisfy <code>toHex</code> quickly.</li> <li>parsed</li> <li>When false the script defers parsing <code>rawBytesCache</code> until <code>chunks</code> is accessed; defaults to true.</li> </ul>"},{"location":"reference/script/#method-findanddelete","title":"Method findAndDelete","text":"<p>Deletes the given item wherever it appears in the current script.</p> <p><pre><code>findAndDelete(script: Script): Script \n</code></pre> See also: Script</p> <p>Returns</p> <p>This script instance for chaining.</p> <p>Argument Details</p> <ul> <li>script</li> <li>The script containing the item to delete from the current script.</li> </ul>"},{"location":"reference/script/#method-fromasm","title":"Method fromASM","text":"<p><pre><code>static fromASM(asm: string): Script \n</code></pre> See also: Script</p> <p>Returns</p> <p>A new Script instance.</p> <p>Argument Details</p> <ul> <li>asm</li> <li>The script in ASM string format.</li> </ul> <p>Example</p> <pre><code>const script = Script.fromASM(\"OP_DUP OP_HASH160 abcd... OP_EQUALVERIFY OP_CHECKSIG\")\n</code></pre>"},{"location":"reference/script/#method-frombinary","title":"Method fromBinary","text":"<p><pre><code>static fromBinary(bin: number[]): Script \n</code></pre> See also: Script</p> <p>Returns</p> <p>A new Script instance.</p> <p>Argument Details</p> <ul> <li>bin</li> <li>The script in binary array format.</li> </ul> <p>Example</p> <pre><code>const script = Script.fromBinary([0x76, 0xa9, ...])\n</code></pre>"},{"location":"reference/script/#method-fromhex","title":"Method fromHex","text":"<p><pre><code>static fromHex(hex: string): Script \n</code></pre> See also: Script</p> <p>Returns</p> <p>A new Script instance.</p> <p>Argument Details</p> <ul> <li>hex</li> <li>The script in hexadecimal format.</li> </ul> <p>Example</p> <pre><code>const script = Script.fromHex(\"76a9...\");\n</code></pre>"},{"location":"reference/script/#method-islockingscript_1","title":"Method isLockingScript","text":"<pre><code>isLockingScript(): boolean \n</code></pre> <p>Returns</p> <p>True if the script is a locking script, otherwise false.</p>"},{"location":"reference/script/#method-ispushonly","title":"Method isPushOnly","text":"<pre><code>isPushOnly(): boolean \n</code></pre> <p>Returns</p> <p>True if the script is push-only, otherwise false.</p>"},{"location":"reference/script/#method-isunlockingscript_1","title":"Method isUnlockingScript","text":"<pre><code>isUnlockingScript(): boolean \n</code></pre> <p>Returns</p> <p>True if the script is an unlocking script, otherwise false.</p>"},{"location":"reference/script/#method-removecodeseparators","title":"Method removeCodeseparators","text":"<p><pre><code>removeCodeseparators(): Script \n</code></pre> See also: Script</p> <p>Returns</p> <p>This script instance for chaining.</p>"},{"location":"reference/script/#method-setchunkopcode","title":"Method setChunkOpCode","text":"<p><pre><code>setChunkOpCode(i: number, op: number): Script \n</code></pre> See also: Script</p> <p>Returns</p> <p>This script instance for chaining.</p> <p>Argument Details</p> <ul> <li>i</li> <li>The index of the chunk.</li> <li>op</li> <li>The opcode to set.</li> </ul>"},{"location":"reference/script/#method-toasm","title":"Method toASM","text":"<pre><code>toASM(): string \n</code></pre> <p>Returns</p> <p>The script in ASM string format.</p>"},{"location":"reference/script/#method-tobinary","title":"Method toBinary","text":"<pre><code>toBinary(): number[] \n</code></pre> <p>Returns</p> <p>The script in binary array format.</p>"},{"location":"reference/script/#method-tohex","title":"Method toHex","text":"<pre><code>toHex(): string \n</code></pre> <p>Returns</p> <p>The script in hexadecimal format.</p>"},{"location":"reference/script/#method-writebin","title":"Method writeBin","text":"<p><pre><code>writeBin(bin: number[]): Script \n</code></pre> See also: Script</p> <p>Returns</p> <p>This script instance for chaining.</p> <p>Argument Details</p> <ul> <li>bin</li> <li>The binary data to append.</li> </ul> <p>Throws</p> <p>Throws an error if the data is too large to be pushed.</p>"},{"location":"reference/script/#method-writebn","title":"Method writeBn","text":"<p><pre><code>writeBn(bn: BigNumber): Script \n</code></pre> See also: BigNumber, Script</p> <p>Returns</p> <p>This script instance for chaining.</p> <p>Argument Details</p> <ul> <li>bn</li> <li>The BigNumber to append.</li> </ul>"},{"location":"reference/script/#method-writenumber","title":"Method writeNumber","text":"<p><pre><code>writeNumber(num: number): Script \n</code></pre> See also: Script</p> <p>Returns</p> <p>This script instance for chaining.</p> <p>Argument Details</p> <ul> <li>num</li> <li>The number to append.</li> </ul>"},{"location":"reference/script/#method-writeopcode","title":"Method writeOpCode","text":"<p><pre><code>writeOpCode(op: number): Script \n</code></pre> See also: Script</p> <p>Returns</p> <p>This script instance for chaining.</p> <p>Argument Details</p> <ul> <li>op</li> <li>The opcode to append.</li> </ul>"},{"location":"reference/script/#method-writescript","title":"Method writeScript","text":"<p><pre><code>writeScript(script: Script): Script \n</code></pre> See also: Script</p> <p>Returns</p> <p>This script instance for chaining.</p> <p>Argument Details</p> <ul> <li>script</li> <li>The script to append.</li> </ul> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/script/#class-scriptevaluationerror","title":"Class: ScriptEvaluationError","text":"<pre><code>export default class ScriptEvaluationError extends Error {\n    txid: string;\n    outputIndex: number;\n    context: \"UnlockingScript\" | \"LockingScript\";\n    programCounter: number;\n    stackState: number[][];\n    altStackState: number[][];\n    ifStackState: boolean[];\n    stackMem: number;\n    altStackMem: number;\n    constructor(params: {\n        message: string;\n        txid: string;\n        outputIndex: number;\n        context: \"UnlockingScript\" | \"LockingScript\";\n        programCounter: number;\n        stackState: number[][];\n        altStackState: number[][];\n        ifStackState: boolean[];\n        stackMem: number;\n        altStackMem: number;\n    }) \n}\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/script/#class-spend","title":"Class: Spend","text":"<p>The Spend class represents a spend action within a Bitcoin SV transaction. It encapsulates all the necessary data required for spending a UTXO (Unspent Transaction Output) and includes details about the source transaction, output, and the spending transaction itself.</p> <pre><code>export default class Spend {\n    sourceTXID: string;\n    sourceOutputIndex: number;\n    sourceSatoshis: number;\n    lockingScript: LockingScript;\n    transactionVersion: number;\n    otherInputs: TransactionInput[];\n    outputs: TransactionOutput[];\n    inputIndex: number;\n    unlockingScript: UnlockingScript;\n    inputSequence: number;\n    lockTime: number;\n    context: \"UnlockingScript\" | \"LockingScript\";\n    programCounter: number;\n    lastCodeSeparator: number | null;\n    stack: number[][];\n    altStack: number[][];\n    ifStack: boolean[];\n    memoryLimit: number;\n    stackMem: number;\n    altStackMem: number;\n    constructor(params: {\n        sourceTXID: string;\n        sourceOutputIndex: number;\n        sourceSatoshis: number;\n        lockingScript: LockingScript;\n        transactionVersion: number;\n        otherInputs: TransactionInput[];\n        outputs: TransactionOutput[];\n        unlockingScript: UnlockingScript;\n        inputSequence: number;\n        inputIndex: number;\n        lockTime: number;\n        memoryLimit?: number;\n    }) \n    reset(): void \n    step(): boolean \n    validate(): boolean \n}\n</code></pre> <p>See also: LockingScript, TransactionInput, TransactionOutput, UnlockingScript</p>"},{"location":"reference/script/#constructor_3","title":"Constructor","text":"<p><pre><code>constructor(params: {\n    sourceTXID: string;\n    sourceOutputIndex: number;\n    sourceSatoshis: number;\n    lockingScript: LockingScript;\n    transactionVersion: number;\n    otherInputs: TransactionInput[];\n    outputs: TransactionOutput[];\n    unlockingScript: UnlockingScript;\n    inputSequence: number;\n    inputIndex: number;\n    lockTime: number;\n    memoryLimit?: number;\n}) \n</code></pre> See also: LockingScript, TransactionInput, TransactionOutput, UnlockingScript</p> <p>Argument Details</p> <ul> <li>params.sourceTXID</li> <li>The transaction ID of the source UTXO.</li> <li>params.sourceOutputIndex</li> <li>The index of the output in the source transaction.</li> <li>params.sourceSatoshis</li> <li>The amount of satoshis in the source UTXO.</li> <li>params.lockingScript</li> <li>The locking script associated with the UTXO.</li> <li>params.transactionVersion</li> <li>The version of the current transaction.</li> <li>params.otherInputs</li> <li>- An array of other inputs in the transaction.</li> <li>params.outputs</li> <li>- The outputs of the current transaction.</li> <li>params.inputIndex</li> <li>The index of this input in the current transaction.</li> <li>params.unlockingScript</li> <li>The unlocking script for this spend.</li> <li>params.inputSequence</li> <li>The sequence number of this input.</li> <li>params.lockTime</li> <li>The lock time of the transaction.</li> </ul> <p>Example</p> <pre><code>const spend = new Spend({\n  sourceTXID: \"abcd1234\", // sourceTXID\n  sourceOutputIndex: 0, // sourceOutputIndex\n  sourceSatoshis: new BigNumber(1000), // sourceSatoshis\n  lockingScript: LockingScript.fromASM(\"OP_DUP OP_HASH160 abcd1234... OP_EQUALVERIFY OP_CHECKSIG\"),\n  transactionVersion: 1, // transactionVersion\n  otherInputs: [{ sourceTXID: \"abcd1234\", sourceOutputIndex: 1, sequence: 0xffffffff }], // otherInputs\n  outputs: [{ satoshis: new BigNumber(500), lockingScript: LockingScript.fromASM(\"OP_DUP...\") }], // outputs\n  inputIndex: 0, // inputIndex\n  unlockingScript: UnlockingScript.fromASM(\"3045... 02ab...\"),\n  inputSequence: 0xffffffff // inputSequence\n  memoryLimit: 100000 // memoryLimit\n});\n</code></pre>"},{"location":"reference/script/#method-validate","title":"Method validate","text":"<pre><code>validate(): boolean \n</code></pre> <p>Returns</p> <p>Returns true if the scripts are valid and the spend is legitimate, otherwise false.</p> <p>Example</p> <pre><code>if (spend.validate()) {\n  console.log(\"Spend is valid!\");\n} else {\n  console.log(\"Invalid spend!\");\n}\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/script/#class-unlockingscript","title":"Class: UnlockingScript","text":"<p>The UnlockingScript class represents an unlocking script in a Bitcoin SV transaction. It extends the Script class and is used specifically for input scripts that unlock funds.</p> <p>Inherits all properties and methods from the Script class.</p> <pre><code>export default class UnlockingScript extends Script {\n    isLockingScript(): boolean \n    isUnlockingScript(): boolean \n}\n</code></pre> <p>See also: Script</p>"},{"location":"reference/script/#method-islockingscript_2","title":"Method isLockingScript","text":"<pre><code>isLockingScript(): boolean \n</code></pre> <p>Returns</p> <p>Always returns false for an UnlockingScript instance.</p>"},{"location":"reference/script/#method-isunlockingscript_2","title":"Method isUnlockingScript","text":"<pre><code>isUnlockingScript(): boolean \n</code></pre> <p>Returns</p> <p>Always returns true for an UnlockingScript instance.</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/script/#functions","title":"Functions","text":""},{"location":"reference/script/#types","title":"Types","text":""},{"location":"reference/script/#enums","title":"Enums","text":""},{"location":"reference/script/#variables","title":"Variables","text":""},{"location":"reference/storage/","title":"API","text":"<p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/storage/#interfaces","title":"Interfaces","text":"DownloadResult DownloaderConfig FindFileData RenewFileResult UploadFileResult UploadableFile UploaderConfig <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/storage/#interface-downloadresult","title":"Interface: DownloadResult","text":"<pre><code>export interface DownloadResult {\n    data: Uint8Array;\n    mimeType: string | null;\n}\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/storage/#interface-downloaderconfig","title":"Interface: DownloaderConfig","text":"<pre><code>export interface DownloaderConfig {\n    networkPreset: \"mainnet\" | \"testnet\" | \"local\";\n}\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/storage/#interface-findfiledata","title":"Interface: FindFileData","text":"<pre><code>export interface FindFileData {\n    name: string;\n    size: string;\n    mimeType: string;\n    expiryTime: number;\n}\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/storage/#interface-renewfileresult","title":"Interface: RenewFileResult","text":"<pre><code>export interface RenewFileResult {\n    status: string;\n    prevExpiryTime?: number;\n    newExpiryTime?: number;\n    amount?: number;\n}\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/storage/#interface-uploadfileresult","title":"Interface: UploadFileResult","text":"<pre><code>export interface UploadFileResult {\n    published: boolean;\n    uhrpURL: string;\n}\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/storage/#interface-uploadablefile","title":"Interface: UploadableFile","text":"<pre><code>export interface UploadableFile {\n    data: Uint8Array | number[];\n    type: string;\n}\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/storage/#interface-uploaderconfig","title":"Interface: UploaderConfig","text":"<pre><code>export interface UploaderConfig {\n    storageURL: string;\n    wallet: WalletInterface;\n}\n</code></pre> <p>See also: WalletInterface</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/storage/#classes","title":"Classes","text":"StorageDownloader StorageUploader <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/storage/#class-storagedownloader","title":"Class: StorageDownloader","text":"<pre><code>export class StorageDownloader {\n    constructor(config?: DownloaderConfig) \n    public async resolve(uhrpUrl: string): Promise&lt;string[]&gt; \n    public async download(uhrpUrl: string): Promise&lt;DownloadResult&gt; \n}\n</code></pre> <p>See also: DownloadResult, DownloaderConfig</p>"},{"location":"reference/storage/#method-download","title":"Method download","text":"<p>Downloads the content from the UHRP URL after validating the hash for integrity.</p> <p><pre><code>public async download(uhrpUrl: string): Promise&lt;DownloadResult&gt; \n</code></pre> See also: DownloadResult</p> <p>Returns</p> <p>A promise that resolves to the downloaded content.</p> <p>Argument Details</p> <ul> <li>uhrpUrl</li> <li>The UHRP URL to download.</li> </ul>"},{"location":"reference/storage/#method-resolve","title":"Method resolve","text":"<p>Resolves the UHRP URL to a list of HTTP URLs where content can be downloaded.</p> <pre><code>public async resolve(uhrpUrl: string): Promise&lt;string[]&gt; \n</code></pre> <p>Returns</p> <p>A promise that resolves to an array of HTTP URLs.</p> <p>Argument Details</p> <ul> <li>uhrpUrl</li> <li>The UHRP URL to resolve.</li> </ul> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/storage/#class-storageuploader","title":"Class: StorageUploader","text":"<p>The StorageUploader class provides client-side methods for: - Uploading files with a specified retention period - Finding file metadata by UHRP URL - Listing all user uploads - Renewing an existing advertisement's expiry time</p> <pre><code>export class StorageUploader {\n    constructor(config: UploaderConfig) \n    public async publishFile(params: {\n        file: UploadableFile;\n        retentionPeriod: number;\n    }): Promise&lt;UploadFileResult&gt; \n    public async findFile(uhrpUrl: string): Promise&lt;FindFileData&gt; \n    public async listUploads(): Promise&lt;any&gt; \n    public async renewFile(uhrpUrl: string, additionalMinutes: number): Promise&lt;RenewFileResult&gt; \n}\n</code></pre> <p>See also: FindFileData, RenewFileResult, UploadFileResult, UploadableFile, UploaderConfig</p>"},{"location":"reference/storage/#constructor","title":"Constructor","text":"<p>Creates a new StorageUploader instance.</p> <p><pre><code>constructor(config: UploaderConfig) \n</code></pre> See also: UploaderConfig</p> <p>Argument Details</p> <ul> <li>config</li> <li>An object containing the storage server's URL and a wallet interface</li> </ul>"},{"location":"reference/storage/#method-findfile","title":"Method findFile","text":"<p>Retrieves metadata for a file matching the given UHRP URL from the <code>/find</code> route.</p> <p><pre><code>public async findFile(uhrpUrl: string): Promise&lt;FindFileData&gt; \n</code></pre> See also: FindFileData</p> <p>Returns</p> <p>An object with file name, size, MIME type, and expiry time</p> <p>Argument Details</p> <ul> <li>uhrpUrl</li> <li>The UHRP URL, e.g. \"uhrp://abcd...\"</li> </ul> <p>Throws</p> <p>If the server or the route returns an error</p>"},{"location":"reference/storage/#method-listuploads","title":"Method listUploads","text":"<p>Lists all advertisements belonging to the user from the <code>/list</code> route.</p> <pre><code>public async listUploads(): Promise&lt;any&gt; \n</code></pre> <p>Returns</p> <p>The array of uploads returned by the server</p> <p>Throws</p> <p>If the server or the route returns an error</p>"},{"location":"reference/storage/#method-publishfile","title":"Method publishFile","text":"<p>Publishes a file to the storage server with the specified retention period.</p> <p>This will: 1. Request an upload URL from the server. 2. Perform an HTTP PUT to upload the file\u2019s raw bytes. 3. Return a UHRP URL referencing the file once published.</p> <p><pre><code>public async publishFile(params: {\n    file: UploadableFile;\n    retentionPeriod: number;\n}): Promise&lt;UploadFileResult&gt; \n</code></pre> See also: UploadFileResult, UploadableFile</p> <p>Returns</p> <p>An object with the file's UHRP URL</p> <p>Throws</p> <p>If the server or upload step returns a non-OK response</p>"},{"location":"reference/storage/#method-renewfile","title":"Method renewFile","text":"<p>Renews the hosting time for an existing file advertisement identified by uhrpUrl. Calls the <code>/renew</code> route to add <code>additionalMinutes</code> to the GCS customTime and re-mint the advertisement token on-chain.</p> <p><pre><code>public async renewFile(uhrpUrl: string, additionalMinutes: number): Promise&lt;RenewFileResult&gt; \n</code></pre> See also: RenewFileResult</p> <p>Returns</p> <p>An object with the new and previous expiry times, plus any cost</p> <p>Argument Details</p> <ul> <li>uhrpUrl</li> <li>The UHRP URL of the file (e.g., \"uhrp://abcd1234...\")</li> <li>additionalMinutes</li> <li>The number of minutes to extend</li> </ul> <p>Throws</p> <p>If the request fails or the server returns an error</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/storage/#functions","title":"Functions","text":""},{"location":"reference/storage/#types","title":"Types","text":""},{"location":"reference/storage/#enums","title":"Enums","text":""},{"location":"reference/storage/#variables","title":"Variables","text":"getHashFromURL getURLForFile getURLForHash isValidURL normalizeURL <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/storage/#variable-gethashfromurl","title":"Variable: getHashFromURL","text":"<pre><code>getHashFromURL = (URL: string): number[] =&gt; {\n    URL = normalizeURL(URL);\n    const { data, prefix } = fromBase58Check(URL, undefined, 2);\n    if (data.length !== 32) {\n        throw new Error(\"Invalid length!\");\n    }\n    if (toHex(prefix as number[]) !== \"ce00\") {\n        throw new Error(\"Bad prefix\");\n    }\n    return data as number[];\n}\n</code></pre> <p>See also: fromBase58Check, normalizeURL, toHex</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/storage/#variable-geturlforfile","title":"Variable: getURLForFile","text":"<pre><code>getURLForFile = (file: Uint8Array | number[]): string =&gt; {\n    const data = file instanceof Uint8Array ? file : Uint8Array.from(file);\n    const hasher = new Hash.SHA256();\n    const chunkSize = 1024 * 1024;\n    for (let i = 0; i &lt; data.length; i += chunkSize) {\n        const chunk = data.subarray(i, i + chunkSize);\n        hasher.update(Array.from(chunk));\n    }\n    const hash = hasher.digest();\n    return getURLForHash(hash);\n}\n</code></pre> <p>See also: SHA256, getURLForHash</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/storage/#variable-geturlforhash","title":"Variable: getURLForHash","text":"<pre><code>getURLForHash = (hash: number[]): string =&gt; {\n    if (hash.length !== 32) {\n        throw new Error(\"Hash length must be 32 bytes (sha256)\");\n    }\n    return toBase58Check(hash, toArray(\"ce00\", \"hex\"));\n}\n</code></pre> <p>See also: toArray, toBase58Check</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/storage/#variable-isvalidurl","title":"Variable: isValidURL","text":"<pre><code>isValidURL = (URL: string): boolean =&gt; {\n    try {\n        getHashFromURL(URL);\n        return true;\n    }\n    catch (e) {\n        return false;\n    }\n}\n</code></pre> <p>See also: getHashFromURL</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/storage/#variable-normalizeurl","title":"Variable: normalizeURL","text":"<pre><code>normalizeURL = (URL: string): string =&gt; {\n    if (URL.toLowerCase().startsWith(\"uhrp:\"))\n        URL = URL.slice(5);\n    if (URL.startsWith(\"//\"))\n        URL = URL.slice(2);\n    return URL;\n}\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/totp/","title":"API","text":"<p>Links: API, Interfaces, Classes, Functions, Types, Variables</p>"},{"location":"reference/totp/#interfaces","title":"Interfaces","text":""},{"location":"reference/totp/#interface-totpoptions","title":"Interface: TOTPOptions","text":"<p>Options for TOTP generation.</p> <pre><code>export interface TOTPOptions {\n    digits?: number;\n    algorithm?: TOTPAlgorithm;\n    period?: number;\n    timestamp?: number;\n}\n</code></pre> <p>See also: TOTPAlgorithm</p> <p>Links: API, Interfaces, Classes, Functions, Types, Variables</p>"},{"location":"reference/totp/#classes","title":"Classes","text":""},{"location":"reference/totp/#class-totp","title":"Class: TOTP","text":"<pre><code>export class TOTP {\n    static generate(secret: number[], options?: TOTPOptions): string \n    static validate(secret: number[], passcode: string, options?: TOTPValidateOptions): boolean \n}\n</code></pre> <p>See also: TOTPOptions, TOTPValidateOptions</p>"},{"location":"reference/totp/#method-generate","title":"Method generate","text":"<p>Generates a Time-based One-Time Password (TOTP).</p> <p><pre><code>static generate(secret: number[], options?: TOTPOptions): string \n</code></pre> See also: TOTPOptions</p> <p>Returns</p> <p>The generated TOTP.</p> <p>Argument Details</p> <ul> <li>secret</li> <li>The secret key for TOTP.</li> <li>options</li> <li>Optional parameters for TOTP.</li> </ul>"},{"location":"reference/totp/#method-validate","title":"Method validate","text":"<p>Validates a Time-based One-Time Password (TOTP).</p> <p><pre><code>static validate(secret: number[], passcode: string, options?: TOTPValidateOptions): boolean \n</code></pre> See also: TOTPValidateOptions</p> <p>Returns</p> <p>A boolean indicating whether the passcode is valid.</p> <p>Argument Details</p> <ul> <li>secret</li> <li>The secret key for TOTP.</li> <li>passcode</li> <li>The passcode to validate.</li> <li>options</li> <li>Optional parameters for TOTP validation.</li> </ul> <p>Links: API, Interfaces, Classes, Functions, Types, Variables</p>"},{"location":"reference/totp/#functions","title":"Functions","text":""},{"location":"reference/totp/#types","title":"Types","text":"TOTPAlgorithm TOTPValidateOptions <p>Links: API, Interfaces, Classes, Functions, Types, Variables</p>"},{"location":"reference/totp/#type-totpalgorithm","title":"Type: TOTPAlgorithm","text":"<pre><code>export type TOTPAlgorithm = \"SHA-1\" | \"SHA-256\" | \"SHA-512\"\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Variables</p>"},{"location":"reference/totp/#type-totpvalidateoptions","title":"Type: TOTPValidateOptions","text":"<p>Options for TOTP validation.</p> <pre><code>export type TOTPValidateOptions = TOTPOptions &amp; {\n    skew?: number;\n}\n</code></pre> <p>See also: TOTPOptions</p> <p>Links: API, Interfaces, Classes, Functions, Types, Variables</p>"},{"location":"reference/totp/#variables","title":"Variables","text":""},{"location":"reference/transaction/","title":"API","text":"<p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/transaction/#interfaces","title":"Interfaces","text":"ArcConfig HttpClientRequestOptions BroadcastFailure HttpsNodejs BroadcastResponse MerklePathLeaf Broadcaster NodejsHttpClientRequest ChainTracker TransactionInput FeeModel TransactionOutput FetchOptions WhatsOnChainConfig HttpClient <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/transaction/#interface-arcconfig","title":"Interface: ArcConfig","text":"<p>Configuration options for the ARC broadcaster.</p> <pre><code>export interface ArcConfig {\n    apiKey?: string;\n    httpClient?: HttpClient;\n    deploymentId?: string;\n    callbackUrl?: string;\n    callbackToken?: string;\n    headers?: Record&lt;string, string&gt;;\n}\n</code></pre> <p>See also: HttpClient</p>"},{"location":"reference/transaction/#property-apikey","title":"Property apiKey","text":"<p>Authentication token for the ARC API</p> <pre><code>apiKey?: string\n</code></pre>"},{"location":"reference/transaction/#property-callbacktoken","title":"Property callbackToken","text":"<p>default access token for notification callback endpoint. It will be used as a Authorization header for the http callback</p> <pre><code>callbackToken?: string\n</code></pre>"},{"location":"reference/transaction/#property-callbackurl","title":"Property callbackUrl","text":"<p>notification callback endpoint for proofs and double spend notification</p> <pre><code>callbackUrl?: string\n</code></pre>"},{"location":"reference/transaction/#property-deploymentid","title":"Property deploymentId","text":"<p>Deployment id used annotating api calls in XDeployment-ID header - this value will be randomly generated if not set</p> <pre><code>deploymentId?: string\n</code></pre>"},{"location":"reference/transaction/#property-headers","title":"Property headers","text":"<p>additional headers to be attached to all tx submissions.</p> <pre><code>headers?: Record&lt;string, string&gt;\n</code></pre>"},{"location":"reference/transaction/#property-httpclient","title":"Property httpClient","text":"<p>The HTTP client used to make requests to the ARC API.</p> <p><pre><code>httpClient?: HttpClient\n</code></pre> See also: HttpClient</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/transaction/#interface-broadcastfailure","title":"Interface: BroadcastFailure","text":"<p>Defines the structure of a failed broadcast response.</p> <pre><code>export interface BroadcastFailure {\n    status: \"error\";\n    code: string;\n    txid?: string;\n    description: string;\n    more?: object;\n}\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/transaction/#interface-broadcastresponse","title":"Interface: BroadcastResponse","text":"<p>Defines the structure of a successful broadcast response.</p> <pre><code>export interface BroadcastResponse {\n    status: \"success\";\n    txid: string;\n    message: string;\n    competingTxs?: string[];\n}\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/transaction/#interface-broadcaster","title":"Interface: Broadcaster","text":"<p>Represents the interface for a transaction broadcaster. This interface defines a standard method for broadcasting transactions.</p> <pre><code>export interface Broadcaster {\n    broadcast: (transaction: Transaction) =&gt; Promise&lt;BroadcastResponse | BroadcastFailure&gt;;\n    broadcastMany?: (txs: Transaction[]) =&gt; Promise&lt;object[]&gt;;\n}\n</code></pre> <p>See also: BroadcastFailure, BroadcastResponse, Transaction</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/transaction/#interface-chaintracker","title":"Interface: ChainTracker","text":"<p>The Chain Tracker is responsible for verifying the validity of a given Merkle root for a specific block height within the blockchain.</p> <p>Chain Trackers ensure the integrity of the blockchain by validating new headers against the chain's history. They use accumulated proof-of-work and protocol adherence as metrics to assess the legitimacy of blocks.</p> <p>Example</p> <pre><code>const chainTracker = {\n  isValidRootForHeight: async (root, height) =&gt; {\n    // Implementation to check if the Merkle root is valid for the specified block height.\n  }\n currentHeight: async () =&gt; {\n    // Implementation to get the current block height.\n  }\n};\n</code></pre> <pre><code>export default interface ChainTracker {\n    isValidRootForHeight: (root: string, height: number) =&gt; Promise&lt;boolean&gt;;\n    currentHeight: () =&gt; Promise&lt;number&gt;;\n}\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/transaction/#interface-feemodel","title":"Interface: FeeModel","text":"<p>Represents the interface for a transaction fee model. This interface defines a standard method for computing a fee when given a transaction.</p> <pre><code>export default interface FeeModel {\n    computeFee: (transaction: Transaction) =&gt; Promise&lt;number&gt;;\n}\n</code></pre> <p>See also: Transaction</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/transaction/#interface-fetchoptions","title":"Interface: FetchOptions","text":"<p>An interface for configuration of the request to be passed to the fetch method limited to options needed by ts-sdk.</p> <pre><code>export interface FetchOptions {\n    method?: string;\n    headers?: Record&lt;string, string&gt;;\n    body?: string | null;\n}\n</code></pre>"},{"location":"reference/transaction/#property-body","title":"Property body","text":"<p>An object or null to set request's body.</p> <pre><code>body?: string | null\n</code></pre>"},{"location":"reference/transaction/#property-headers_1","title":"Property headers","text":"<p>An object literal set request's headers.</p> <pre><code>headers?: Record&lt;string, string&gt;\n</code></pre>"},{"location":"reference/transaction/#property-method","title":"Property method","text":"<p>A string to set request's method.</p> <pre><code>method?: string\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/transaction/#interface-httpclient","title":"Interface: HttpClient","text":"<p>An interface for HTTP client used to make HTTP requests.</p> <pre><code>export interface HttpClient {\n    request: &lt;T = any, D = any&gt;(url: string, options: HttpClientRequestOptions&lt;D&gt;) =&gt; Promise&lt;HttpClientResponse&lt;T&gt;&gt;;\n}\n</code></pre> <p>See also: HttpClientRequestOptions, HttpClientResponse</p>"},{"location":"reference/transaction/#property-request","title":"Property request","text":"<p>Makes a request to the server.</p> <p><pre><code>request: &lt;T = any, D = any&gt;(url: string, options: HttpClientRequestOptions&lt;D&gt;) =&gt; Promise&lt;HttpClientResponse&lt;T&gt;&gt;\n</code></pre> See also: HttpClientRequestOptions, HttpClientResponse</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/transaction/#interface-httpclientrequestoptions","title":"Interface: HttpClientRequestOptions","text":"<p>An interface for configuration of the request to be passed to the request method.</p> <pre><code>export interface HttpClientRequestOptions&lt;Data = any&gt; {\n    method?: string;\n    headers?: Record&lt;string, string&gt;;\n    data?: Data;\n    signal?: AbortSignal;\n}\n</code></pre>"},{"location":"reference/transaction/#property-data","title":"Property data","text":"<p>An object or null to set request's body.</p> <pre><code>data?: Data\n</code></pre>"},{"location":"reference/transaction/#property-headers_2","title":"Property headers","text":"<p>An object literal set request's headers.</p> <pre><code>headers?: Record&lt;string, string&gt;\n</code></pre>"},{"location":"reference/transaction/#property-method_1","title":"Property method","text":"<p>A string to set request's method.</p> <pre><code>method?: string\n</code></pre>"},{"location":"reference/transaction/#property-signal","title":"Property signal","text":"<p>An optional AbortSignal to cancel the request, including by explicit timeout.</p> <pre><code>signal?: AbortSignal\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/transaction/#interface-httpsnodejs","title":"Interface: HttpsNodejs","text":"<p>Node Https module interface limited to options needed by ts-sdk</p> <pre><code>export interface HttpsNodejs {\n    request: (url: string, options: HttpClientRequestOptions, callback: (res: any) =&gt; void) =&gt; NodejsHttpClientRequest;\n}\n</code></pre> <p>See also: HttpClientRequestOptions, NodejsHttpClientRequest</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/transaction/#interface-merklepathleaf","title":"Interface: MerklePathLeaf","text":"<pre><code>export interface MerklePathLeaf {\n    offset: number;\n    hash?: string;\n    txid?: boolean;\n    duplicate?: boolean;\n}\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/transaction/#interface-nodejshttpclientrequest","title":"Interface: NodejsHttpClientRequest","text":"<p>Nodejs result of the Node https.request call limited to options needed by ts-sdk</p> <pre><code>export interface NodejsHttpClientRequest {\n    write: (chunk: string) =&gt; void;\n    on: (event: string, callback: (data: any) =&gt; void) =&gt; void;\n    end: (() =&gt; void) &amp; (() =&gt; void);\n}\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/transaction/#interface-transactioninput","title":"Interface: TransactionInput","text":"<p>Represents an input to a Bitcoin transaction. This interface defines the structure and components required to construct a transaction input in the Bitcoin blockchain.</p> <p>Example</p> <pre><code>// Creating a simple transaction input\nlet txInput = {\n  sourceTXID: '123abc...',\n  sourceOutputIndex: 0,\n  sequence: 0xFFFFFFFF\n};\n\n// Using an unlocking script template\ntxInput.unlockingScriptTemplate = {\n  sign: async (tx, index) =&gt; { ... },\n  estimateLength: async (tx, index) =&gt; { ... }\n};\n</code></pre> <pre><code>export default interface TransactionInput {\n    sourceTransaction?: Transaction;\n    sourceTXID?: string;\n    sourceOutputIndex: number;\n    unlockingScript?: UnlockingScript;\n    unlockingScriptTemplate?: {\n        sign: (tx: Transaction, inputIndex: number) =&gt; Promise&lt;UnlockingScript&gt;;\n        estimateLength: (tx: Transaction, inputIndex: number) =&gt; Promise&lt;number&gt;;\n    };\n    sequence?: number;\n}\n</code></pre> <p>See also: Transaction, UnlockingScript, sign</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/transaction/#interface-transactionoutput","title":"Interface: TransactionOutput","text":"<p>Represents an output in a Bitcoin transaction. This interface defines the structure and components necessary to construct a transaction output, which secures owned Bitcoins to be unlocked later.</p> <p>Example</p> <pre><code>// Creating a simple transaction output\nlet txOutput = {\n  satoshis: 1000,\n  lockingScript: LockingScript.fromASM('OP_DUP OP_HASH160 ... OP_EQUALVERIFY OP_CHECKSIG'),\n  change: false\n};\n</code></pre> <pre><code>export default interface TransactionOutput {\n    satoshis?: number;\n    lockingScript: LockingScript;\n    change?: boolean;\n}\n</code></pre> <p>See also: LockingScript</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/transaction/#interface-whatsonchainconfig","title":"Interface: WhatsOnChainConfig","text":"<p>Configuration options for the WhatsOnChain ChainTracker.</p> <pre><code>export interface WhatsOnChainConfig {\n    apiKey?: string;\n    httpClient?: HttpClient;\n}\n</code></pre> <p>See also: HttpClient</p>"},{"location":"reference/transaction/#property-apikey_1","title":"Property apiKey","text":"<p>Authentication token for the WhatsOnChain API</p> <pre><code>apiKey?: string\n</code></pre>"},{"location":"reference/transaction/#property-httpclient_1","title":"Property httpClient","text":"<p>The HTTP client used to make requests to the API.</p> <p><pre><code>httpClient?: HttpClient\n</code></pre> See also: HttpClient</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/transaction/#classes","title":"Classes","text":"ARC Beef BeefParty BeefTx FetchHttpClient LivePolicy MerklePath NodejsHttpClient SatoshisPerKilobyte Transaction WhatsOnChain <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/transaction/#class-arc","title":"Class: ARC","text":"<p>Represents an ARC transaction broadcaster.</p> <pre><code>export default class ARC implements Broadcaster {\n    readonly URL: string;\n    readonly apiKey: string | undefined;\n    readonly deploymentId: string;\n    readonly callbackUrl: string | undefined;\n    readonly callbackToken: string | undefined;\n    readonly headers: Record&lt;string, string&gt; | undefined;\n    constructor(URL: string, config?: ArcConfig);\n    constructor(URL: string, apiKey?: string);\n    constructor(URL: string, config?: string | ArcConfig) \n    async broadcast(tx: Transaction): Promise&lt;BroadcastResponse | BroadcastFailure&gt; \n    async broadcastMany(txs: Transaction[]): Promise&lt;object[]&gt; \n}\n</code></pre> <p>See also: ArcConfig, BroadcastFailure, BroadcastResponse, Broadcaster, Transaction</p>"},{"location":"reference/transaction/#constructor","title":"Constructor","text":"<p>Constructs an instance of the ARC broadcaster.</p> <p><pre><code>constructor(URL: string, config?: ArcConfig)\n</code></pre> See also: ArcConfig</p> <p>Argument Details</p> <ul> <li>URL</li> <li>The URL endpoint for the ARC API.</li> <li>config</li> <li>Configuration options for the ARC broadcaster.</li> </ul>"},{"location":"reference/transaction/#constructor_1","title":"Constructor","text":"<p>Constructs an instance of the ARC broadcaster.</p> <pre><code>constructor(URL: string, apiKey?: string)\n</code></pre> <p>Argument Details</p> <ul> <li>URL</li> <li>The URL endpoint for the ARC API.</li> <li>apiKey</li> <li>The API key used for authorization with the ARC API.</li> </ul>"},{"location":"reference/transaction/#method-broadcast","title":"Method broadcast","text":"<p>Broadcasts a transaction via ARC.</p> <p><pre><code>async broadcast(tx: Transaction): Promise&lt;BroadcastResponse | BroadcastFailure&gt; \n</code></pre> See also: BroadcastFailure, BroadcastResponse, Transaction</p> <p>Returns</p> <p>A promise that resolves to either a success or failure response.</p> <p>Argument Details</p> <ul> <li>tx</li> <li>The transaction to be broadcasted.</li> </ul>"},{"location":"reference/transaction/#method-broadcastmany","title":"Method broadcastMany","text":"<p>Broadcasts multiple transactions via ARC. Handles mixed responses where some transactions succeed and others fail.</p> <p><pre><code>async broadcastMany(txs: Transaction[]): Promise&lt;object[]&gt; \n</code></pre> See also: Transaction</p> <p>Returns</p> <p>A promise that resolves to an array of objects.</p> <p>Argument Details</p> <ul> <li>txs</li> <li>Array of transactions to be broadcasted.</li> </ul> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/transaction/#class-beef","title":"Class: Beef","text":"<pre><code>export class Beef {\n    bumps: MerklePath[] = [];\n    txs: BeefTx[] = [];\n    version: number = BEEF_V2;\n    atomicTxid: string | undefined = undefined;\n    constructor(version: number = BEEF_V2) \n    findTxid(txid: string): BeefTx | undefined \n    makeTxidOnly(txid: string): BeefTx | undefined \n    findBump(txid: string): MerklePath | undefined \n    findTransactionForSigning(txid: string): Transaction | undefined \n    findAtomicTransaction(txid: string): Transaction | undefined \n    mergeBump(bump: MerklePath): number \n    mergeRawTx(rawTx: number[], bumpIndex?: number): BeefTx \n    mergeTransaction(tx: Transaction): BeefTx \n    removeExistingTxid(txid: string): void \n    mergeTxidOnly(txid: string): BeefTx \n    mergeBeefTx(btx: BeefTx): BeefTx \n    mergeBeef(beef: number[] | Beef): void \n    isValid(allowTxidOnly?: boolean): boolean \n    async verify(chainTracker: ChainTracker, allowTxidOnly?: boolean): Promise&lt;boolean&gt; \n    verifyValid(allowTxidOnly?: boolean): {\n        valid: boolean;\n        roots: Record&lt;number, string&gt;;\n    } \n    toWriter(writer: Writer): void \n    toBinary(): number[] \n    toUint8Array(): Uint8Array \n    toBinaryAtomic(txid: string): number[] \n    toHex(): string \n    static fromReader(br: Reader): Beef \n    static fromBinary(bin: number[]): Beef \n    static fromString(s: string, enc: \"hex\" | \"utf8\" | \"base64\" = \"hex\"): Beef \n    sortTxs(): {\n        missingInputs: string[];\n        notValid: string[];\n        valid: string[];\n        withMissingInputs: string[];\n        txidOnly: string[];\n    } \n    clone(): Beef \n    trimKnownTxids(knownTxids: string[]): void \n    getValidTxids(): string[] \n    toLogString(): string \n    addComputedLeaves(): void \n}\n</code></pre> <p>See also: BEEF_V2, BeefTx, ChainTracker, MerklePath, Reader, Transaction, Writer, toHex, verify</p>"},{"location":"reference/transaction/#method-addcomputedleaves","title":"Method addComputedLeaves","text":"<p>In some circumstances it may be helpful for the BUMP MerklePaths to include leaves that can be computed from row zero.</p> <pre><code>addComputedLeaves(): void \n</code></pre>"},{"location":"reference/transaction/#method-clone","title":"Method clone","text":"<p><pre><code>clone(): Beef \n</code></pre> See also: Beef</p> <p>Returns</p> <p>a shallow copy of this beef</p>"},{"location":"reference/transaction/#method-findatomictransaction","title":"Method findAtomicTransaction","text":"<p>Builds the proof tree rooted at a specific <code>Transaction</code>.</p> <p>To succeed, the Beef must contain all the required transaction and merkle path data.</p> <p><pre><code>findAtomicTransaction(txid: string): Transaction | undefined \n</code></pre> See also: Transaction</p> <p>Returns</p> <p>Transaction with input <code>SourceTransaction</code> and <code>MerklePath</code> populated from this Beef.</p> <p>Argument Details</p> <ul> <li>txid</li> <li>The id of the target transaction.</li> </ul>"},{"location":"reference/transaction/#method-findbump","title":"Method findBump","text":"<p><pre><code>findBump(txid: string): MerklePath | undefined \n</code></pre> See also: MerklePath</p> <p>Returns</p> <p><code>MerklePath</code> with level zero hash equal to txid or undefined.</p>"},{"location":"reference/transaction/#method-findtransactionforsigning","title":"Method findTransactionForSigning","text":"<p>Finds a Transaction in this <code>Beef</code> and adds any missing input SourceTransactions from this <code>Beef</code>.</p> <p>The result is suitable for signing.</p> <p><pre><code>findTransactionForSigning(txid: string): Transaction | undefined \n</code></pre> See also: Transaction</p> <p>Returns</p> <p>Transaction with all available input <code>SourceTransaction</code>s from this Beef.</p> <p>Argument Details</p> <ul> <li>txid</li> <li>The id of the target transaction.</li> </ul>"},{"location":"reference/transaction/#method-findtxid","title":"Method findTxid","text":"<p><pre><code>findTxid(txid: string): BeefTx | undefined \n</code></pre> See also: BeefTx</p> <p>Returns</p> <p><code>BeefTx</code> in <code>txs</code> with <code>txid</code>.</p> <p>Argument Details</p> <ul> <li>txid</li> <li>of <code>beefTx</code> to find</li> </ul>"},{"location":"reference/transaction/#method-frombinary","title":"Method fromBinary","text":"<p>Constructs an instance of the Beef class based on the provided binary array</p> <p><pre><code>static fromBinary(bin: number[]): Beef \n</code></pre> See also: Beef</p> <p>Returns</p> <p>An instance of the Beef class constructed from the binary data</p> <p>Argument Details</p> <ul> <li>bin</li> <li>The binary array from which to construct BEEF</li> </ul>"},{"location":"reference/transaction/#method-fromstring","title":"Method fromString","text":"<p>Constructs an instance of the Beef class based on the provided string</p> <p><pre><code>static fromString(s: string, enc: \"hex\" | \"utf8\" | \"base64\" = \"hex\"): Beef \n</code></pre> See also: Beef</p> <p>Returns</p> <p>An instance of the Beef class constructed from the string</p> <p>Argument Details</p> <ul> <li>s</li> <li>The string value from which to construct BEEF</li> <li>enc</li> <li>The encoding of the string value from which BEEF should be constructed</li> </ul>"},{"location":"reference/transaction/#method-getvalidtxids","title":"Method getValidTxids","text":"<pre><code>getValidTxids(): string[] \n</code></pre> <p>Returns</p> <p>array of transaction txids that either have a proof or whose inputs chain back to a proven transaction.</p>"},{"location":"reference/transaction/#method-isvalid","title":"Method isValid","text":"<p>Sorts <code>txs</code> and checks structural validity of beef.</p> <p>Does NOT verify merkle roots.</p> <p>Validity requirements: 1. No 'known' txids, unless <code>allowTxidOnly</code> is true. 2. All transactions have bumps or their inputs chain back to bumps (or are known). 3. Order of transactions satisfies dependencies before dependents. 4. No transactions with duplicate txids.</p> <pre><code>isValid(allowTxidOnly?: boolean): boolean \n</code></pre> <p>Argument Details</p> <ul> <li>allowTxidOnly</li> <li>optional. If true, transaction txid only is assumed valid</li> </ul>"},{"location":"reference/transaction/#method-maketxidonly","title":"Method makeTxidOnly","text":"<p>Replaces <code>BeefTx</code> for this txid with txidOnly.</p> <p>Replacement is done so that a <code>clone()</code> can be updated by this method without affecting the original.</p> <p><pre><code>makeTxidOnly(txid: string): BeefTx | undefined \n</code></pre> See also: BeefTx</p> <p>Returns</p> <p>undefined if txid is unknown.</p>"},{"location":"reference/transaction/#method-mergebump","title":"Method mergeBump","text":"<p>Merge a MerklePath that is assumed to be fully valid.</p> <p><pre><code>mergeBump(bump: MerklePath): number \n</code></pre> See also: MerklePath</p> <p>Returns</p> <p>index of merged bump</p>"},{"location":"reference/transaction/#method-mergerawtx","title":"Method mergeRawTx","text":"<p>Merge a serialized transaction.</p> <p>Checks that a transaction with the same txid hasn't already been merged.</p> <p>Replaces existing transaction with same txid.</p> <p><pre><code>mergeRawTx(rawTx: number[], bumpIndex?: number): BeefTx \n</code></pre> See also: BeefTx</p> <p>Returns</p> <p>txid of rawTx</p> <p>Argument Details</p> <ul> <li>bumpIndex</li> <li>Optional. If a number, must be valid index into bumps array.</li> </ul>"},{"location":"reference/transaction/#method-mergetransaction","title":"Method mergeTransaction","text":"<p>Merge a <code>Transaction</code> and any referenced <code>merklePath</code> and <code>sourceTransaction</code>, recursifely.</p> <p>Replaces existing transaction with same txid.</p> <p>Attempts to match an existing bump to the new transaction.</p> <p><pre><code>mergeTransaction(tx: Transaction): BeefTx \n</code></pre> See also: BeefTx, Transaction</p> <p>Returns</p> <p>txid of tx</p>"},{"location":"reference/transaction/#method-removeexistingtxid","title":"Method removeExistingTxid","text":"<p>Removes an existing transaction from the BEEF, given its TXID</p> <pre><code>removeExistingTxid(txid: string): void \n</code></pre> <p>Argument Details</p> <ul> <li>txid</li> <li>TXID of the transaction to remove</li> </ul>"},{"location":"reference/transaction/#method-sorttxs","title":"Method sortTxs","text":"<p>Sort the <code>txs</code> by input txid dependency order: - Oldest Tx Anchored by Path or txid only - Newer Txs depending on Older parents - Newest Tx</p> <p>with proof (MerklePath) last, longest chain of dependencies first</p> <pre><code>sortTxs(): {\n    missingInputs: string[];\n    notValid: string[];\n    valid: string[];\n    withMissingInputs: string[];\n    txidOnly: string[];\n} \n</code></pre> <p>Returns</p> <p><code>{ missingInputs, notValid, valid, withMissingInputs }</code></p>"},{"location":"reference/transaction/#method-tobinary","title":"Method toBinary","text":"<p>Returns a binary array representing the serialized BEEF</p> <pre><code>toBinary(): number[] \n</code></pre> <p>Returns</p> <p>A binary array representing the BEEF</p>"},{"location":"reference/transaction/#method-tobinaryatomic","title":"Method toBinaryAtomic","text":"<p>Serialize this Beef as AtomicBEEF.</p> <p><code>txid</code> must exist</p> <p>after sorting, if txid is not last txid, creates a clone and removes newer txs</p> <pre><code>toBinaryAtomic(txid: string): number[] \n</code></pre> <p>Returns</p> <p>serialized contents of this Beef with AtomicBEEF prefix.</p>"},{"location":"reference/transaction/#method-tohex","title":"Method toHex","text":"<p>Returns a hex string representing the serialized BEEF</p> <pre><code>toHex(): string \n</code></pre> <p>Returns</p> <p>A hex string representing the BEEF</p>"},{"location":"reference/transaction/#method-tologstring","title":"Method toLogString","text":"<pre><code>toLogString(): string \n</code></pre> <p>Returns</p> <p>Summary of <code>Beef</code> contents as multi-line string.</p>"},{"location":"reference/transaction/#method-towriter","title":"Method toWriter","text":"<p>Serializes this data to <code>writer</code></p> <p><pre><code>toWriter(writer: Writer): void \n</code></pre> See also: Writer</p>"},{"location":"reference/transaction/#method-trimknowntxids","title":"Method trimKnownTxids","text":"<p>Ensure that all the txids in <code>knownTxids</code> are txidOnly</p> <pre><code>trimKnownTxids(knownTxids: string[]): void \n</code></pre>"},{"location":"reference/transaction/#method-verify","title":"Method verify","text":"<p>Sorts <code>txs</code> and confirms validity of transaction data contained in beef by validating structure of this beef and confirming computed merkle roots using <code>chainTracker</code>.</p> <p>Validity requirements: 1. No 'known' txids, unless <code>allowTxidOnly</code> is true. 2. All transactions have bumps or their inputs chain back to bumps (or are known). 3. Order of transactions satisfies dependencies before dependents. 4. No transactions with duplicate txids.</p> <p><pre><code>async verify(chainTracker: ChainTracker, allowTxidOnly?: boolean): Promise&lt;boolean&gt; \n</code></pre> See also: ChainTracker</p> <p>Argument Details</p> <ul> <li>chainTracker</li> <li>Used to verify computed merkle path roots for all bump txids.</li> <li>allowTxidOnly</li> <li>optional. If true, transaction txid is assumed valid</li> </ul>"},{"location":"reference/transaction/#method-verifyvalid","title":"Method verifyValid","text":"<p>Sorts <code>txs</code> and confirms validity of transaction data contained in beef by validating structure of this beef.</p> <p>Returns block heights and merkle root values to be confirmed by a chaintracker.</p> <p>Validity requirements: 1. No 'known' txids, unless <code>allowTxidOnly</code> is true. 2. All transactions have bumps or their inputs chain back to bumps (or are known). 3. Order of transactions satisfies dependencies before dependents. 4. No transactions with duplicate txids.</p> <pre><code>verifyValid(allowTxidOnly?: boolean): {\n    valid: boolean;\n    roots: Record&lt;number, string&gt;;\n} \n</code></pre> <p>Returns</p> <p><code>valid</code> is true iff this Beef is structuraly valid. <code>roots</code> is a record where keys are block heights and values are the corresponding merkle roots to be validated.</p> <p>Argument Details</p> <ul> <li>allowTxidOnly</li> <li>optional. If true, transaction txid is assumed valid</li> </ul> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/transaction/#class-beefparty","title":"Class: BeefParty","text":"<p>Extends <code>Beef</code> that is used to exchange transaction validity data with more than one external party.</p> <p>Use <code>addKnownTxidsForParty</code> to keep track of who knows what to reduce re-transmission of potentially large transactions.</p> <p>Use <code>getTrimmedBeefForParty</code> to obtain a <code>Beef</code> trimmed of transaction validity data known to a specific party.</p> <p>Typical usage scenario:</p> <ol> <li>Query a wallet storage provider for spendable outputs.</li> <li>The provider replies with a Beef validating the returned outputs.</li> <li>Construct a new transaction using some of the queried outputs as inputs, including Beef validating all the inputs.</li> <li>Receive new valid raw transaction after processing and Beef validating change outputs added to original inputs.</li> <li>Return to step 1, continuing to build on old and new spendable outputs.</li> </ol> <p>By default, each Beef is required to be complete and valid: All transactions appear as full serialized bitcoin transactions and each transaction either has a merkle path proof (it has been mined) or all of its input transactions are included.</p> <p>The size and redundancy of these Beefs becomes a problem when chained transaction creation out-paces the block mining rate.</p> <pre><code>export class BeefParty extends Beef {\n    knownTo: Record&lt;string, Record&lt;string, boolean&gt;&gt; = {};\n    constructor(parties?: string[]) \n    isParty(party: string): boolean \n    addParty(party: string): void \n    getKnownTxidsForParty(party: string): string[] \n    getTrimmedBeefForParty(party: string): Beef \n    addKnownTxidsForParty(party: string, knownTxids: string[]): void \n    mergeBeefFromParty(party: string, beef: number[] | Beef): void \n}\n</code></pre> <p>See also: Beef</p>"},{"location":"reference/transaction/#constructor_2","title":"Constructor","text":"<pre><code>constructor(parties?: string[]) \n</code></pre> <p>Argument Details</p> <ul> <li>parties</li> <li>Optional array of initial unique party identifiers.</li> </ul>"},{"location":"reference/transaction/#property-knownto","title":"Property knownTo","text":"<p>keys are party identifiers. values are records of txids with truthy value for which the party already has validity proof.</p> <pre><code>knownTo: Record&lt;string, Record&lt;string, boolean&gt;&gt; = {}\n</code></pre>"},{"location":"reference/transaction/#method-addknowntxidsforparty","title":"Method addKnownTxidsForParty","text":"<p>Make note of additional txids \"known\" to <code>party</code>.</p> <pre><code>addKnownTxidsForParty(party: string, knownTxids: string[]): void \n</code></pre> <p>Argument Details</p> <ul> <li>party</li> <li>unique identifier, added if new.</li> </ul>"},{"location":"reference/transaction/#method-addparty","title":"Method addParty","text":"<p>Adds a new unique party identifier to this <code>BeefParty</code>.</p> <pre><code>addParty(party: string): void \n</code></pre>"},{"location":"reference/transaction/#method-getknowntxidsforparty","title":"Method getKnownTxidsForParty","text":"<pre><code>getKnownTxidsForParty(party: string): string[] \n</code></pre> <p>Returns</p> <p>Array of txids \"known\" to <code>party</code>.</p>"},{"location":"reference/transaction/#method-gettrimmedbeefforparty","title":"Method getTrimmedBeefForParty","text":"<p><pre><code>getTrimmedBeefForParty(party: string): Beef \n</code></pre> See also: Beef</p> <p>Returns</p> <p>trimmed beef of unknown transactions and proofs for <code>party</code></p>"},{"location":"reference/transaction/#method-isparty","title":"Method isParty","text":"<pre><code>isParty(party: string): boolean \n</code></pre> <p>Returns</p> <p><code>true</code> if <code>party</code> has already been added to this <code>BeefParty</code>.</p>"},{"location":"reference/transaction/#method-mergebeeffromparty","title":"Method mergeBeefFromParty","text":"<p>Merge a <code>beef</code> received from a specific <code>party</code>.</p> <p>Updates this <code>BeefParty</code> to track all the txids corresponding to transactions for which <code>party</code> has raw transaction and validity proof data.</p> <p><pre><code>mergeBeefFromParty(party: string, beef: number[] | Beef): void \n</code></pre> See also: Beef</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/transaction/#class-beeftx","title":"Class: BeefTx","text":"<p>A single bitcoin transaction associated with a <code>Beef</code> validity proof set.</p> <p>Simple case is transaction data included directly, either as raw bytes or fully parsed data, or both.</p> <p>Supports 'known' transactions which are represented by just their txid. It is assumed that intended consumer of this beef already has validity proof for such a transaction, which they can merge if necessary to create a valid beef.</p> <pre><code>export default class BeefTx {\n    _bumpIndex?: number;\n    _tx?: Transaction;\n    _rawTx?: number[];\n    _txid?: string;\n    inputTxids: string[] = [];\n    isValid?: boolean = undefined;\n    get bumpIndex(): number | undefined \n    set bumpIndex(v: number | undefined) \n    get hasProof(): boolean \n    get isTxidOnly(): boolean \n    get txid(): string \n    get tx(): Transaction | undefined \n    get rawTx(): number[] | undefined \n    constructor(tx: Transaction | number[] | string, bumpIndex?: number) \n    static fromTx(tx: Transaction, bumpIndex?: number): BeefTx \n    static fromRawTx(rawTx: number[], bumpIndex?: number): BeefTx \n    static fromTxid(txid: string, bumpIndex?: number): BeefTx \n    toWriter(writer: Writer, version: number): void \n    static fromReader(br: Reader, version: number): BeefTx \n}\n</code></pre> <p>See also: Reader, Transaction, Writer</p>"},{"location":"reference/transaction/#constructor_3","title":"Constructor","text":"<p><pre><code>constructor(tx: Transaction | number[] | string, bumpIndex?: number) \n</code></pre> See also: Transaction</p> <p>Argument Details</p> <ul> <li>tx</li> <li>If string, must be a valid txid. If <code>number[]</code> must be a valid serialized transaction.</li> <li>bumpIndex</li> <li>If transaction already has a proof in the beef to which it will be added.</li> </ul>"},{"location":"reference/transaction/#property-isvalid","title":"Property isValid","text":"<p>true if <code>hasProof</code> or all inputs chain to <code>hasProof</code>.</p> <p>Typically set by sorting transactions by proven dependency chains.</p> <pre><code>isValid?: boolean = undefined\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/transaction/#class-fetchhttpclient","title":"Class: FetchHttpClient","text":"<p>Adapter for Node Https module to be used as HttpClient</p> <pre><code>export class FetchHttpClient implements HttpClient {\n    constructor(private readonly fetch: Fetch) \n    async request&lt;D&gt;(url: string, options: HttpClientRequestOptions): Promise&lt;HttpClientResponse&lt;D&gt;&gt; \n}\n</code></pre> <p>See also: Fetch, HttpClient, HttpClientRequestOptions, HttpClientResponse</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/transaction/#class-livepolicy","title":"Class: LivePolicy","text":"<p>Represents a live fee policy that fetches current rates from ARC GorillaPool. Extends SatoshisPerKilobyte to reuse transaction size calculation logic.</p> <pre><code>export default class LivePolicy extends SatoshisPerKilobyte {\n    constructor(cacheValidityMs: number = 5 * 60 * 1000) \n    static getInstance(cacheValidityMs: number = 5 * 60 * 1000): LivePolicy \n    async computeFee(tx: Transaction): Promise&lt;number&gt; \n}\n</code></pre> <p>See also: SatoshisPerKilobyte, Transaction</p>"},{"location":"reference/transaction/#constructor_4","title":"Constructor","text":"<p>Constructs an instance of the live policy fee model.</p> <pre><code>constructor(cacheValidityMs: number = 5 * 60 * 1000) \n</code></pre> <p>Argument Details</p> <ul> <li>cacheValidityMs</li> <li>How long to cache the fee rate in milliseconds (default: 5 minutes)</li> </ul>"},{"location":"reference/transaction/#method-computefee","title":"Method computeFee","text":"<p>Computes the fee for a given transaction using the current live rate. Overrides the parent method to use dynamic rate fetching.</p> <p><pre><code>async computeFee(tx: Transaction): Promise&lt;number&gt; \n</code></pre> See also: Transaction</p> <p>Returns</p> <p>The fee in satoshis for the transaction.</p> <p>Argument Details</p> <ul> <li>tx</li> <li>The transaction for which a fee is to be computed.</li> </ul>"},{"location":"reference/transaction/#method-getinstance","title":"Method getInstance","text":"<p>Gets the singleton instance of LivePolicy to ensure cache sharing across the application.</p> <p><pre><code>static getInstance(cacheValidityMs: number = 5 * 60 * 1000): LivePolicy \n</code></pre> See also: LivePolicy</p> <p>Returns</p> <p>The singleton LivePolicy instance</p> <p>Argument Details</p> <ul> <li>cacheValidityMs</li> <li>How long to cache the fee rate in milliseconds (default: 5 minutes)</li> </ul> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/transaction/#class-merklepath","title":"Class: MerklePath","text":"<p>Represents a Merkle Path, which is used to provide a compact proof of inclusion for a transaction in a block. This class encapsulates all the details required for creating and verifying Merkle Proofs.</p> <p>Example</p> <pre><code>// Creating and verifying a Merkle Path\nconst merklePath = MerklePath.fromHex('...');\nconst isValid = merklePath.verify(txid, chainTracker);\n</code></pre> <pre><code>export default class MerklePath {\n    blockHeight: number;\n    path: Array&lt;Array&lt;{\n        offset: number;\n        hash?: string;\n        txid?: boolean;\n        duplicate?: boolean;\n    }&gt;&gt;;\n    static fromHex(hex: string): MerklePath \n    static fromReader(reader: Reader, legalOffsetsOnly: boolean = true): MerklePath \n    static fromBinary(bump: number[]): MerklePath \n    static fromCoinbaseTxidAndHeight(txid: string, height: number): MerklePath \n    constructor(blockHeight: number, path: Array&lt;Array&lt;{\n        offset: number;\n        hash?: string;\n        txid?: boolean;\n        duplicate?: boolean;\n    }&gt;&gt;, legalOffsetsOnly: boolean = true) \n    toBinary(): number[] \n    toHex(): string \n    computeRoot(txid?: string): string \n    findOrComputeLeaf(height: number, offset: number): MerklePathLeaf | undefined \n    async verify(txid: string, chainTracker: ChainTracker): Promise&lt;boolean&gt; \n    combine(other: MerklePath): void \n    trim(): void \n}\n</code></pre> <p>See also: ChainTracker, MerklePathLeaf, Reader, toHex, verify</p>"},{"location":"reference/transaction/#method-combine","title":"Method combine","text":"<p>Combines this MerklePath with another to create a compound proof.</p> <p><pre><code>combine(other: MerklePath): void \n</code></pre> See also: MerklePath</p> <p>Argument Details</p> <ul> <li>other</li> <li>Another MerklePath to combine with this path.</li> </ul> <p>Throws</p> <ul> <li>If the paths have different block heights or roots.</li> </ul>"},{"location":"reference/transaction/#method-computeroot","title":"Method computeRoot","text":"<p>Computes the Merkle root from the provided transaction ID.</p> <pre><code>computeRoot(txid?: string): string \n</code></pre> <p>Returns</p> <ul> <li>The computed Merkle root as a hexadecimal string.</li> </ul> <p>Argument Details</p> <ul> <li>txid</li> <li>The transaction ID to compute the Merkle root for. If not provided, the root will be computed from an unspecified branch, and not all branches will be validated!</li> </ul> <p>Throws</p> <ul> <li>If the transaction ID is not part of the Merkle Path.</li> </ul>"},{"location":"reference/transaction/#method-findorcomputeleaf","title":"Method findOrComputeLeaf","text":"<p>Find leaf with <code>offset</code> at <code>height</code> or compute from level below, recursively.</p> <p>Does not add computed leaves to path.</p> <p><pre><code>findOrComputeLeaf(height: number, offset: number): MerklePathLeaf | undefined \n</code></pre> See also: MerklePathLeaf</p>"},{"location":"reference/transaction/#method-frombinary_1","title":"Method fromBinary","text":"<p>Creates a MerklePath instance from a binary array.</p> <p><pre><code>static fromBinary(bump: number[]): MerklePath \n</code></pre> See also: MerklePath</p> <p>Returns</p> <ul> <li>A new MerklePath instance.</li> </ul> <p>Argument Details</p> <ul> <li>bump</li> <li>The binary array representation of the Merkle Path.</li> </ul>"},{"location":"reference/transaction/#method-fromcoinbasetxidandheight","title":"Method fromCoinbaseTxidAndHeight","text":"<p><pre><code>static fromCoinbaseTxidAndHeight(txid: string, height: number): MerklePath \n</code></pre> See also: MerklePath</p> <p>Returns</p> <ul> <li>A new MerklePath instance which assumes the tx is in a block with no other transactions.</li> </ul> <p>Argument Details</p> <ul> <li>txid</li> <li>The coinbase txid.</li> <li>height</li> <li>The height of the block.</li> </ul>"},{"location":"reference/transaction/#method-fromhex","title":"Method fromHex","text":"<p>Creates a MerklePath instance from a hexadecimal string.</p> <p><pre><code>static fromHex(hex: string): MerklePath \n</code></pre> See also: MerklePath</p> <p>Returns</p> <ul> <li>A new MerklePath instance.</li> </ul> <p>Argument Details</p> <ul> <li>hex</li> <li>The hexadecimal string representation of the Merkle Path.</li> </ul>"},{"location":"reference/transaction/#method-tobinary_1","title":"Method toBinary","text":"<p>Converts the MerklePath to a binary array format.</p> <pre><code>toBinary(): number[] \n</code></pre> <p>Returns</p> <ul> <li>The binary array representation of the Merkle Path.</li> </ul>"},{"location":"reference/transaction/#method-tohex_1","title":"Method toHex","text":"<p>Converts the MerklePath to a hexadecimal string format.</p> <pre><code>toHex(): string \n</code></pre> <p>Returns</p> <ul> <li>The hexadecimal string representation of the Merkle Path.</li> </ul>"},{"location":"reference/transaction/#method-trim","title":"Method trim","text":"<p>Remove all internal nodes that are not required by level zero txid nodes. Assumes that at least all required nodes are present. Leaves all levels sorted by increasing offset.</p> <pre><code>trim(): void \n</code></pre>"},{"location":"reference/transaction/#method-verify_1","title":"Method verify","text":"<p>Verifies if the given transaction ID is part of the Merkle tree at the specified block height.</p> <p><pre><code>async verify(txid: string, chainTracker: ChainTracker): Promise&lt;boolean&gt; \n</code></pre> See also: ChainTracker</p> <p>Returns</p> <ul> <li>True if the transaction ID is valid within the Merkle Path at the specified block height.</li> </ul> <p>Argument Details</p> <ul> <li>txid</li> <li>The transaction ID to verify.</li> <li>chainTracker</li> <li>The ChainTracker instance used to verify the Merkle root.</li> </ul> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/transaction/#class-nodejshttpclient","title":"Class: NodejsHttpClient","text":"<p>Adapter for Node Https module to be used as HttpClient</p> <pre><code>export class NodejsHttpClient implements HttpClient {\n    constructor(private readonly https: HttpsNodejs) \n    async request(url: string, requestOptions: HttpClientRequestOptions): Promise&lt;HttpClientResponse&gt; \n}\n</code></pre> <p>See also: HttpClient, HttpClientRequestOptions, HttpClientResponse, HttpsNodejs</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/transaction/#class-satoshisperkilobyte","title":"Class: SatoshisPerKilobyte","text":"<p>Represents the \"satoshis per kilobyte\" transaction fee model.</p> <pre><code>export default class SatoshisPerKilobyte implements FeeModel {\n    value: number;\n    constructor(value: number) \n    async computeFee(tx: Transaction): Promise&lt;number&gt; \n}\n</code></pre> <p>See also: FeeModel, Transaction</p>"},{"location":"reference/transaction/#constructor_5","title":"Constructor","text":"<p>Constructs an instance of the sat/kb fee model.</p> <pre><code>constructor(value: number) \n</code></pre> <p>Argument Details</p> <ul> <li>value</li> <li>The number of satoshis per kilobyte to charge as a fee.</li> </ul>"},{"location":"reference/transaction/#method-computefee_1","title":"Method computeFee","text":"<p>Computes the fee for a given transaction.</p> <p><pre><code>async computeFee(tx: Transaction): Promise&lt;number&gt; \n</code></pre> See also: Transaction</p> <p>Returns</p> <p>The fee in satoshis for the transaction, as a BigNumber.</p> <p>Argument Details</p> <ul> <li>tx</li> <li>The transaction for which a fee is to be computed.</li> </ul> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/transaction/#class-transaction","title":"Class: Transaction","text":"<p>Represents a complete Bitcoin transaction. This class encapsulates all the details required for creating, signing, and processing a Bitcoin transaction, including inputs, outputs, and various transaction-related methods.</p> <p>Example</p> <pre><code>// Creating a new transaction\nlet tx = new Transaction();\ntx.addInput(...);\ntx.addOutput(...);\nawait tx.fee();\nawait tx.sign();\nawait tx.broadcast();\n</code></pre> <pre><code>export default class Transaction {\n    version: number;\n    inputs: TransactionInput[];\n    outputs: TransactionOutput[];\n    lockTime: number;\n    metadata: Record&lt;string, any&gt;;\n    merklePath?: MerklePath;\n    static fromBEEF(beef: number[], txid?: string): Transaction \n    static fromAtomicBEEF(beef: number[]): Transaction \n    static fromEF(ef: number[]): Transaction \n    static parseScriptOffsets(bin: number[]): {\n        inputs: Array&lt;{\n            vin: number;\n            offset: number;\n            length: number;\n        }&gt;;\n        outputs: Array&lt;{\n            vout: number;\n            offset: number;\n            length: number;\n        }&gt;;\n    } \n    static fromReader(br: Reader): Transaction \n    static fromBinary(bin: number[]): Transaction \n    static fromHex(hex: string): Transaction \n    static fromHexEF(hex: string): Transaction \n    static fromHexBEEF(hex: string, txid?: string): Transaction \n    constructor(version: number = 1, inputs: TransactionInput[] = [], outputs: TransactionOutput[] = [], lockTime: number = 0, metadata: Record&lt;string, any&gt; = new Map(), merklePath?: MerklePath) \n    addInput(input: TransactionInput): void \n    addOutput(output: TransactionOutput): void \n    addP2PKHOutput(address: number[] | string, satoshis?: number): void \n    updateMetadata(metadata: Record&lt;string, any&gt;): void \n    async fee(modelOrFee: FeeModel | number = LivePolicy.getInstance(), changeDistribution: \"equal\" | \"random\" = \"equal\"): Promise&lt;void&gt; \n    getFee(): number \n    async sign(): Promise&lt;void&gt; \n    async broadcast(broadcaster: Broadcaster = defaultBroadcaster()): Promise&lt;BroadcastResponse | BroadcastFailure&gt; \n    toBinary(): number[] \n    toUint8Array(): Uint8Array \n    toEF(): number[] \n    toHexEF(): string \n    toHex(): string \n    toHexBEEF(): string \n    toHexAtomicBEEF(): string \n    hash(enc?: \"hex\"): number[] | string \n    id(): number[];\n    id(enc: \"hex\"): string;\n    id(enc?: \"hex\"): number[] | string \n    async verify(chainTracker: ChainTracker | \"scripts only\" = defaultChainTracker(), feeModel?: FeeModel, memoryLimit?: number): Promise&lt;boolean&gt; \n    toBEEF(allowPartial?: boolean): number[] \n    toAtomicBEEF(allowPartial?: boolean): number[] \n}\n</code></pre> <p>See also: BroadcastFailure, BroadcastResponse, Broadcaster, ChainTracker, FeeModel, LivePolicy, MerklePath, Reader, TransactionInput, TransactionOutput, defaultBroadcaster, defaultChainTracker, sign, toHex, verify</p>"},{"location":"reference/transaction/#method-addinput","title":"Method addInput","text":"<p>Adds a new input to the transaction.</p> <p><pre><code>addInput(input: TransactionInput): void \n</code></pre> See also: TransactionInput</p> <p>Argument Details</p> <ul> <li>input</li> <li>The TransactionInput object to add to the transaction.</li> </ul> <p>Throws</p> <ul> <li>If the input does not have a sourceTXID or sourceTransaction defined.</li> </ul>"},{"location":"reference/transaction/#method-addoutput","title":"Method addOutput","text":"<p>Adds a new output to the transaction.</p> <p><pre><code>addOutput(output: TransactionOutput): void \n</code></pre> See also: TransactionOutput</p> <p>Argument Details</p> <ul> <li>output</li> <li>The TransactionOutput object to add to the transaction.</li> </ul>"},{"location":"reference/transaction/#method-addp2pkhoutput","title":"Method addP2PKHOutput","text":"<p>Adds a new P2PKH output to the transaction.</p> <pre><code>addP2PKHOutput(address: number[] | string, satoshis?: number): void \n</code></pre> <p>Argument Details</p> <ul> <li>address</li> <li>The P2PKH address of the output.</li> <li>satoshis</li> <li>The number of satoshis to send to the address - if not provided, the output is considered a change output.</li> </ul>"},{"location":"reference/transaction/#method-broadcast_1","title":"Method broadcast","text":"<p>Broadcasts a transaction.</p> <p><pre><code>async broadcast(broadcaster: Broadcaster = defaultBroadcaster()): Promise&lt;BroadcastResponse | BroadcastFailure&gt; \n</code></pre> See also: BroadcastFailure, BroadcastResponse, Broadcaster, defaultBroadcaster</p> <p>Returns</p> <p>A BroadcastResponse or BroadcastFailure from the Broadcaster</p> <p>Argument Details</p> <ul> <li>broadcaster</li> <li>The Broadcaster instance wwhere the transaction will be sent</li> </ul>"},{"location":"reference/transaction/#method-fee","title":"Method fee","text":"<p>Computes fees prior to signing. If no fee model is provided, uses a LivePolicy fee model that fetches current rates from ARC. If fee is a number, the transaction uses that value as fee.</p> <p><pre><code>async fee(modelOrFee: FeeModel | number = LivePolicy.getInstance(), changeDistribution: \"equal\" | \"random\" = \"equal\"): Promise&lt;void&gt; \n</code></pre> See also: FeeModel, LivePolicy</p> <p>Argument Details</p> <ul> <li>modelOrFee</li> <li>The initialized fee model to use or fixed fee for the transaction</li> <li>changeDistribution</li> <li>Specifies how the change should be distributed amongst the change outputs</li> </ul>"},{"location":"reference/transaction/#method-fromatomicbeef","title":"Method fromAtomicBEEF","text":"<p>Creates a new transaction from an Atomic BEEF (BRC-95) structure. Extracts the subject transaction and supporting merkle path and source transactions contained in the BEEF data</p> <p><pre><code>static fromAtomicBEEF(beef: number[]): Transaction \n</code></pre> See also: Transaction</p> <p>Returns</p> <p>The subject transaction, linked to its associated inputs populated with merkle paths.</p> <p>Argument Details</p> <ul> <li>beef</li> <li>A binary representation of an Atomic BEEF structure.</li> </ul>"},{"location":"reference/transaction/#method-frombeef","title":"Method fromBEEF","text":"<p>Creates a new transaction, linked to its inputs and their associated merkle paths, from a BEEF V1, V2 or Atomic. Optionally, you can provide a specific TXID to retrieve a particular transaction from the BEEF data. If the TXID is provided but not found in the BEEF data, an error will be thrown. If no TXID is provided, the last transaction in the BEEF data is returned, or the atomic txid.</p> <p><pre><code>static fromBEEF(beef: number[], txid?: string): Transaction \n</code></pre> See also: Transaction</p> <p>Returns</p> <p>An anchored transaction, linked to its associated inputs populated with merkle paths.</p> <p>Argument Details</p> <ul> <li>beef</li> <li>A binary representation of transactions in BEEF format.</li> <li>txid</li> <li>Optional TXID of the transaction to retrieve from the BEEF data.</li> </ul>"},{"location":"reference/transaction/#method-frombinary_2","title":"Method fromBinary","text":"<p>Creates a Transaction instance from a binary array.</p> <p><pre><code>static fromBinary(bin: number[]): Transaction \n</code></pre> See also: Transaction</p> <p>Returns</p> <ul> <li>A new Transaction instance.</li> </ul> <p>Argument Details</p> <ul> <li>bin</li> <li>The binary array representation of the transaction.</li> </ul>"},{"location":"reference/transaction/#method-fromef","title":"Method fromEF","text":"<p>Creates a new transaction, linked to its inputs and their associated merkle paths, from a EF (BRC-30) structure.</p> <p><pre><code>static fromEF(ef: number[]): Transaction \n</code></pre> See also: Transaction</p> <p>Returns</p> <p>An extended transaction, linked to its associated inputs by locking script and satoshis amounts only.</p> <p>Argument Details</p> <ul> <li>ef</li> <li>A binary representation of a transaction in EF format.</li> </ul>"},{"location":"reference/transaction/#method-fromhex_1","title":"Method fromHex","text":"<p>Creates a Transaction instance from a hexadecimal string.</p> <p><pre><code>static fromHex(hex: string): Transaction \n</code></pre> See also: Transaction</p> <p>Returns</p> <ul> <li>A new Transaction instance.</li> </ul> <p>Argument Details</p> <ul> <li>hex</li> <li>The hexadecimal string representation of the transaction.</li> </ul>"},{"location":"reference/transaction/#method-fromhexbeef","title":"Method fromHexBEEF","text":"<p>Creates a Transaction instance from a hexadecimal string encoded BEEF. Optionally, you can provide a specific TXID to retrieve a particular transaction from the BEEF data. If the TXID is provided but not found in the BEEF data, an error will be thrown. If no TXID is provided, the last transaction in the BEEF data is returned.</p> <p><pre><code>static fromHexBEEF(hex: string, txid?: string): Transaction \n</code></pre> See also: Transaction</p> <p>Returns</p> <ul> <li>A new Transaction instance.</li> </ul> <p>Argument Details</p> <ul> <li>hex</li> <li>The hexadecimal string representation of the transaction BEEF.</li> <li>txid</li> <li>Optional TXID of the transaction to retrieve from the BEEF data.</li> </ul>"},{"location":"reference/transaction/#method-fromhexef","title":"Method fromHexEF","text":"<p>Creates a Transaction instance from a hexadecimal string encoded EF.</p> <p><pre><code>static fromHexEF(hex: string): Transaction \n</code></pre> See also: Transaction</p> <p>Returns</p> <ul> <li>A new Transaction instance.</li> </ul> <p>Argument Details</p> <ul> <li>hex</li> <li>The hexadecimal string representation of the transaction EF.</li> </ul>"},{"location":"reference/transaction/#method-getfee","title":"Method getFee","text":"<p>Utility method that returns the current fee based on inputs and outputs</p> <pre><code>getFee(): number \n</code></pre> <p>Returns</p> <p>The current transaction fee</p>"},{"location":"reference/transaction/#method-hash","title":"Method hash","text":"<p>Calculates the transaction's hash.</p> <pre><code>hash(enc?: \"hex\"): number[] | string \n</code></pre> <p>Returns</p> <ul> <li>The hash of the transaction in the specified format.</li> </ul> <p>Argument Details</p> <ul> <li>enc</li> <li>The encoding to use for the hash. If 'hex', returns a hexadecimal string; otherwise returns a binary array.</li> </ul>"},{"location":"reference/transaction/#method-id","title":"Method id","text":"<p>Calculates the transaction's ID in binary array.</p> <pre><code>id(): number[]\n</code></pre> <p>Returns</p> <ul> <li>The ID of the transaction in the binary array format.</li> </ul>"},{"location":"reference/transaction/#method-id_1","title":"Method id","text":"<p>Calculates the transaction's ID in hexadecimal format.</p> <pre><code>id(enc: \"hex\"): string\n</code></pre> <p>Returns</p> <ul> <li>The ID of the transaction in the hex format.</li> </ul> <p>Argument Details</p> <ul> <li>enc</li> <li>The encoding to use for the ID. If 'hex', returns a hexadecimal string.</li> </ul>"},{"location":"reference/transaction/#method-id_2","title":"Method id","text":"<p>Calculates the transaction's ID.</p> <pre><code>id(enc?: \"hex\"): number[] | string \n</code></pre> <p>Returns</p> <ul> <li>The ID of the transaction in the specified format.</li> </ul> <p>Argument Details</p> <ul> <li>enc</li> <li>The encoding to use for the ID. If 'hex', returns a hexadecimal string; otherwise returns a binary array.</li> </ul>"},{"location":"reference/transaction/#method-parsescriptoffsets","title":"Method parseScriptOffsets","text":"<p>Since the validation of blockchain data is atomically transaction data validation, any application seeking to validate data in output scripts must store the entire transaction as well. Since the transaction data includes the output script data, saving a second copy of potentially large scripts can bloat application storage requirements.</p> <p>This function efficiently parses binary transaction data to determine the offsets and lengths of each script. This supports the efficient retreival of script data from transaction data.</p> <pre><code>static parseScriptOffsets(bin: number[]): {\n    inputs: Array&lt;{\n        vin: number;\n        offset: number;\n        length: number;\n    }&gt;;\n    outputs: Array&lt;{\n        vout: number;\n        offset: number;\n        length: number;\n    }&gt;;\n} \n</code></pre> <p>Returns</p> <p>inputs: { vin: number, offset: number, length: number }[] outputs: { vout: number, offset: number, length: number }[] }</p> <p>Argument Details</p> <ul> <li>bin</li> <li>binary transaction data</li> </ul>"},{"location":"reference/transaction/#method-sign","title":"Method sign","text":"<p>Signs a transaction, hydrating all its unlocking scripts based on the provided script templates where they are available.</p> <pre><code>async sign(): Promise&lt;void&gt; \n</code></pre>"},{"location":"reference/transaction/#method-toatomicbeef","title":"Method toAtomicBEEF","text":"<p>Serializes this transaction and its inputs into the Atomic BEEF (BRC-95) format. The Atomic BEEF format starts with a 4-byte prefix <code>0x01010101</code>, followed by the TXID of the subject transaction, and then the BEEF data containing only the subject transaction and its dependencies. This format ensures that the BEEF structure is atomic and contains no unrelated transactions.</p> <pre><code>toAtomicBEEF(allowPartial?: boolean): number[] \n</code></pre> <p>Returns</p> <ul> <li>The serialized Atomic BEEF structure.</li> </ul> <p>Argument Details</p> <ul> <li>allowPartial</li> <li>If true, error will not be thrown if there are any missing sourceTransactions.</li> </ul> <p>Throws</p> <p>Error if there are any missing sourceTransactions unless <code>allowPartial</code> is true.</p>"},{"location":"reference/transaction/#method-tobeef","title":"Method toBEEF","text":"<p>Serializes this transaction, together with its inputs and the respective merkle proofs, into the BEEF (BRC-62) format. This enables efficient verification of its compliance with the rules of SPV.</p> <pre><code>toBEEF(allowPartial?: boolean): number[] \n</code></pre> <p>Returns</p> <p>The serialized BEEF structure</p> <p>Argument Details</p> <ul> <li>allowPartial</li> <li>If true, error will not be thrown if there are any missing sourceTransactions.</li> </ul> <p>Throws</p> <p>Error if there are any missing sourceTransactions unless <code>allowPartial</code> is true.</p>"},{"location":"reference/transaction/#method-tobinary_2","title":"Method toBinary","text":"<p>Converts the transaction to a binary array format.</p> <pre><code>toBinary(): number[] \n</code></pre> <p>Returns</p> <ul> <li>The binary array representation of the transaction.</li> </ul>"},{"location":"reference/transaction/#method-toef","title":"Method toEF","text":"<p>Converts the transaction to a BRC-30 EF format.</p> <pre><code>toEF(): number[] \n</code></pre> <p>Returns</p> <ul> <li>The BRC-30 EF representation of the transaction.</li> </ul>"},{"location":"reference/transaction/#method-tohex_2","title":"Method toHex","text":"<p>Converts the transaction to a hexadecimal string format.</p> <pre><code>toHex(): string \n</code></pre> <p>Returns</p> <ul> <li>The hexadecimal string representation of the transaction.</li> </ul>"},{"location":"reference/transaction/#method-tohexatomicbeef","title":"Method toHexAtomicBEEF","text":"<p>Converts the transaction to a hexadecimal string Atomic BEEF.</p> <pre><code>toHexAtomicBEEF(): string \n</code></pre> <p>Returns</p> <ul> <li>The hexadecimal string representation of the transaction Atomic BEEF.</li> </ul>"},{"location":"reference/transaction/#method-tohexbeef","title":"Method toHexBEEF","text":"<p>Converts the transaction to a hexadecimal string BEEF.</p> <pre><code>toHexBEEF(): string \n</code></pre> <p>Returns</p> <ul> <li>The hexadecimal string representation of the transaction BEEF.</li> </ul>"},{"location":"reference/transaction/#method-tohexef","title":"Method toHexEF","text":"<p>Converts the transaction to a hexadecimal string EF.</p> <pre><code>toHexEF(): string \n</code></pre> <p>Returns</p> <ul> <li>The hexadecimal string representation of the transaction EF.</li> </ul>"},{"location":"reference/transaction/#method-updatemetadata","title":"Method updateMetadata","text":"<p>Updates the transaction's metadata.</p> <pre><code>updateMetadata(metadata: Record&lt;string, any&gt;): void \n</code></pre> <p>Argument Details</p> <ul> <li>metadata</li> <li>The metadata object to merge into the existing metadata.</li> </ul>"},{"location":"reference/transaction/#method-verify_2","title":"Method verify","text":"<p>Verifies the legitimacy of the Bitcoin transaction according to the rules of SPV by ensuring all the input transactions link back to valid block headers, the chain of spends for all inputs are valid, and the sum of inputs is not less than the sum of outputs.</p> <p><pre><code>async verify(chainTracker: ChainTracker | \"scripts only\" = defaultChainTracker(), feeModel?: FeeModel, memoryLimit?: number): Promise&lt;boolean&gt; \n</code></pre> See also: ChainTracker, FeeModel, defaultChainTracker</p> <p>Returns</p> <p>Whether the transaction is valid according to the rules of SPV.</p> <p>Argument Details</p> <ul> <li>chainTracker</li> <li>An instance of ChainTracker, a Bitcoin block header tracker. If the value is set to 'scripts only', headers will not be verified. If not provided then the default chain tracker will be used.</li> <li>feeModel</li> <li>An instance of FeeModel, a fee model to use for fee calculation. If not provided then the default fee model will be used.</li> <li>memoryLimit</li> <li>The maximum memory in bytes usage allowed for script evaluation. If not provided then the default memory limit will be used.</li> </ul> <p>Example</p> <pre><code>tx.verify(new WhatsOnChain(), LivePolicy.getInstance())\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/transaction/#class-whatsonchain","title":"Class: WhatsOnChain","text":"<p>Represents a chain tracker based on What's On Chain .</p> <pre><code>export default class WhatsOnChain implements ChainTracker {\n    readonly network: string;\n    readonly apiKey: string;\n    protected readonly URL: string;\n    protected readonly httpClient: HttpClient;\n    constructor(network: \"main\" | \"test\" | \"stn\" = \"main\", config: WhatsOnChainConfig = {}) \n    async isValidRootForHeight(root: string, height: number): Promise&lt;boolean&gt; \n    async currentHeight(): Promise&lt;number&gt; \n    protected getHttpHeaders(): Record&lt;string, string&gt; \n}\n</code></pre> <p>See also: ChainTracker, HttpClient, WhatsOnChainConfig</p>"},{"location":"reference/transaction/#constructor_6","title":"Constructor","text":"<p>Constructs an instance of the WhatsOnChain ChainTracker.</p> <p><pre><code>constructor(network: \"main\" | \"test\" | \"stn\" = \"main\", config: WhatsOnChainConfig = {}) \n</code></pre> See also: WhatsOnChainConfig</p> <p>Argument Details</p> <ul> <li>network</li> <li>The BSV network to use when calling the WhatsOnChain API.</li> <li>config</li> <li>Configuration options for the WhatsOnChain ChainTracker.</li> </ul> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/transaction/#functions","title":"Functions","text":"defaultBroadcaster defaultChainTracker defaultHttpClient isBroadcastFailure isBroadcastResponse <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/transaction/#function-defaultbroadcaster","title":"Function: defaultBroadcaster","text":"<pre><code>export function defaultBroadcaster(isTestnet: boolean = false, config: ArcConfig = {}): Broadcaster \n</code></pre> <p>See also: ArcConfig, Broadcaster</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/transaction/#function-defaultchaintracker","title":"Function: defaultChainTracker","text":"<pre><code>export function defaultChainTracker(): ChainTracker \n</code></pre> <p>See also: ChainTracker</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/transaction/#function-defaulthttpclient","title":"Function: defaultHttpClient","text":"<p>Returns a default HttpClient implementation based on the environment that it is run on. This method will attempt to use <code>window.fetch</code> if available (in browser environments). If running in a Node environment, it falls back to using the Node <code>https</code> module</p> <pre><code>export function defaultHttpClient(): HttpClient \n</code></pre> <p>See also: HttpClient</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/transaction/#function-isbroadcastfailure","title":"Function: isBroadcastFailure","text":"<p>Convenience type guard for response from <code>Broadcaster.broadcast</code></p> <pre><code>export function isBroadcastFailure(r: BroadcastResponse | BroadcastFailure): r is BroadcastFailure \n</code></pre> <p>See also: BroadcastFailure, BroadcastResponse</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/transaction/#function-isbroadcastresponse","title":"Function: isBroadcastResponse","text":"<p>Convenience type guard for response from <code>Broadcaster.broadcast</code></p> <pre><code>export function isBroadcastResponse(r: BroadcastResponse | BroadcastFailure): r is BroadcastResponse \n</code></pre> <p>See also: BroadcastFailure, BroadcastResponse</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/transaction/#types","title":"Types","text":"Fetch HttpClientResponse <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/transaction/#type-fetch","title":"Type: Fetch","text":"<p>fetch function interface limited to options needed by ts-sdk</p> <p>Makes a request to the server.</p> <pre><code>export type Fetch = (url: string, options: FetchOptions) =&gt; Promise&lt;Response&gt;\n</code></pre> <p>See also: FetchOptions</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/transaction/#type-httpclientresponse","title":"Type: HttpClientResponse","text":"<p>An interface for the response returned by the request method.</p> <pre><code>export type HttpClientResponse&lt;T = any&gt; = {\n    data: T;\n    status: number;\n    statusText: string;\n    ok: true;\n} | {\n    data: any;\n    status: number;\n    statusText: string;\n    ok: false;\n}\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/transaction/#enums","title":"Enums","text":""},{"location":"reference/transaction/#enum-tx_data_format","title":"Enum: TX_DATA_FORMAT","text":"<pre><code>export enum TX_DATA_FORMAT {\n    RAWTX = 0,\n    RAWTX_AND_BUMP_INDEX = 1,\n    TXID_ONLY = 2\n}\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/transaction/#variables","title":"Variables","text":"ATOMIC_BEEF BEEF_V1 BEEF_V2 <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/transaction/#variable-atomic_beef","title":"Variable: ATOMIC_BEEF","text":"<pre><code>ATOMIC_BEEF = 16843009\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/transaction/#variable-beef_v1","title":"Variable: BEEF_V1","text":"<pre><code>BEEF_V1 = 4022206465\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/transaction/#variable-beef_v2","title":"Variable: BEEF_V2","text":"<pre><code>BEEF_V2 = 4022206466\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/","title":"API","text":"<p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interfaces","title":"Interfaces","text":"AbortActionArgs ListCertificatesArgs ValidInternalizeOutput AbortActionResult ListCertificatesResult ValidListActionsArgs AcquireCertificateArgs ListOutputsArgs ValidListCertificatesArgs AuthenticatedResult ListOutputsResult ValidListOutputsArgs BasketInsertion OutPoint ValidProcessActionArgs CertificateResult ProveCertificateArgs ValidProcessActionOptions CreateActionArgs ProveCertificateResult ValidProveCertificateArgs CreateActionInput RelinquishCertificateArgs ValidRelinquishCertificateArgs CreateActionOptions RelinquishCertificateResult ValidRelinquishOutputArgs CreateActionOutput RelinquishOutputArgs ValidSignActionArgs CreateActionResult RelinquishOutputResult ValidSignActionOptions CreateHmacArgs RevealCounterpartyKeyLinkageArgs ValidWalletPayment CreateHmacResult RevealCounterpartyKeyLinkageResult ValidWalletSignerArgs CreateSignatureArgs RevealSpecificKeyLinkageArgs VerifyHmacArgs CreateSignatureResult RevealSpecificKeyLinkageResult VerifyHmacResult DiscoverByAttributesArgs ReviewActionResult VerifySignatureArgs DiscoverByIdentityKeyArgs SendWithResult VerifySignatureResult DiscoverCertificatesResult SignActionArgs WalletAction GetHeaderArgs SignActionOptions WalletActionInput GetHeaderResult SignActionResult WalletActionOutput GetHeightResult SignActionSpend WalletCertificate GetNetworkResult SignableTransaction WalletDecryptArgs GetPublicKeyArgs ValidAbortActionArgs WalletDecryptResult GetPublicKeyResult ValidAcquireCertificateArgs WalletEncryptArgs GetVersionResult ValidAcquireDirectCertificateArgs WalletEncryptResult IdentityCertificate ValidAcquireIssuanceCertificateArgs WalletEncryptionArgs IdentityCertifier ValidBasketInsertion WalletErrorObject InternalizeActionArgs ValidCreateActionArgs WalletInterface InternalizeActionResult ValidCreateActionInput WalletLoggerInterface InternalizeOutput ValidCreateActionOptions WalletLoggerLog KeyDeriverApi ValidCreateActionOutput WalletOutput KeyLinkageResult ValidDiscoverByAttributesArgs WalletPayment ListActionsArgs ValidDiscoverByIdentityKeyArgs WalletWire ListActionsResult ValidInternalizeActionArgs <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-abortactionargs","title":"Interface: AbortActionArgs","text":"<pre><code>export interface AbortActionArgs {\n    reference: Base64String;\n}\n</code></pre> <p>See also: Base64String</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-abortactionresult","title":"Interface: AbortActionResult","text":"<pre><code>export interface AbortActionResult {\n    aborted: true;\n}\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-acquirecertificateargs","title":"Interface: AcquireCertificateArgs","text":"<pre><code>export interface AcquireCertificateArgs {\n    type: Base64String;\n    certifier: PubKeyHex;\n    acquisitionProtocol: AcquisitionProtocol;\n    fields: Record&lt;CertificateFieldNameUnder50Bytes, string&gt;;\n    serialNumber?: Base64String;\n    revocationOutpoint?: OutpointString;\n    signature?: HexString;\n    certifierUrl?: string;\n    keyringRevealer?: KeyringRevealer;\n    keyringForSubject?: Record&lt;CertificateFieldNameUnder50Bytes, Base64String&gt;;\n    privileged?: BooleanDefaultFalse;\n    privilegedReason?: DescriptionString5to50Bytes;\n}\n</code></pre> <p>See also: AcquisitionProtocol, Base64String, BooleanDefaultFalse, CertificateFieldNameUnder50Bytes, DescriptionString5to50Bytes, HexString, KeyringRevealer, OutpointString, PubKeyHex</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-authenticatedresult","title":"Interface: AuthenticatedResult","text":"<pre><code>export interface AuthenticatedResult {\n    authenticated: true;\n}\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-basketinsertion","title":"Interface: BasketInsertion","text":"<pre><code>export interface BasketInsertion {\n    basket: BasketStringUnder300Bytes;\n    customInstructions?: string;\n    tags?: OutputTagStringUnder300Bytes[];\n}\n</code></pre> <p>See also: BasketStringUnder300Bytes, OutputTagStringUnder300Bytes</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-certificateresult","title":"Interface: CertificateResult","text":"<pre><code>export interface CertificateResult extends WalletCertificate {\n    keyring?: Record&lt;CertificateFieldNameUnder50Bytes, Base64String&gt;;\n    verifier?: string;\n}\n</code></pre> <p>See also: Base64String, CertificateFieldNameUnder50Bytes, WalletCertificate</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-createactionargs","title":"Interface: CreateActionArgs","text":"<pre><code>export interface CreateActionArgs {\n    description: DescriptionString5to50Bytes;\n    inputBEEF?: BEEF;\n    inputs?: CreateActionInput[];\n    outputs?: CreateActionOutput[];\n    lockTime?: PositiveIntegerOrZero;\n    version?: PositiveIntegerOrZero;\n    labels?: LabelStringUnder300Bytes[];\n    options?: CreateActionOptions;\n}\n</code></pre> <p>See also: BEEF, CreateActionInput, CreateActionOptions, CreateActionOutput, DescriptionString5to50Bytes, LabelStringUnder300Bytes, PositiveIntegerOrZero</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-createactioninput","title":"Interface: CreateActionInput","text":"<pre><code>export interface CreateActionInput {\n    outpoint: OutpointString;\n    inputDescription: DescriptionString5to50Bytes;\n    unlockingScript?: HexString;\n    unlockingScriptLength?: PositiveInteger;\n    sequenceNumber?: PositiveIntegerOrZero;\n}\n</code></pre> <p>See also: DescriptionString5to50Bytes, HexString, OutpointString, PositiveInteger, PositiveIntegerOrZero</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-createactionoptions","title":"Interface: CreateActionOptions","text":"<pre><code>export interface CreateActionOptions {\n    signAndProcess?: BooleanDefaultTrue;\n    acceptDelayedBroadcast?: BooleanDefaultTrue;\n    trustSelf?: TrustSelf;\n    knownTxids?: TXIDHexString[];\n    returnTXIDOnly?: BooleanDefaultFalse;\n    noSend?: BooleanDefaultFalse;\n    noSendChange?: OutpointString[];\n    sendWith?: TXIDHexString[];\n    randomizeOutputs?: BooleanDefaultTrue;\n}\n</code></pre> <p>See also: BooleanDefaultFalse, BooleanDefaultTrue, OutpointString, TXIDHexString, TrustSelf</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-createactionoutput","title":"Interface: CreateActionOutput","text":"<pre><code>export interface CreateActionOutput {\n    lockingScript: HexString;\n    satoshis: SatoshiValue;\n    outputDescription: DescriptionString5to50Bytes;\n    basket?: BasketStringUnder300Bytes;\n    customInstructions?: string;\n    tags?: OutputTagStringUnder300Bytes[];\n}\n</code></pre> <p>See also: BasketStringUnder300Bytes, DescriptionString5to50Bytes, HexString, OutputTagStringUnder300Bytes, SatoshiValue</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-createactionresult","title":"Interface: CreateActionResult","text":"<pre><code>export interface CreateActionResult {\n    txid?: TXIDHexString;\n    tx?: AtomicBEEF;\n    noSendChange?: OutpointString[];\n    sendWithResults?: SendWithResult[];\n    signableTransaction?: SignableTransaction;\n}\n</code></pre> <p>See also: AtomicBEEF, OutpointString, SendWithResult, SignableTransaction, TXIDHexString</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-createhmacargs","title":"Interface: CreateHmacArgs","text":"<pre><code>export interface CreateHmacArgs extends WalletEncryptionArgs {\n    data: Byte[];\n}\n</code></pre> <p>See also: Byte, WalletEncryptionArgs</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-createhmacresult","title":"Interface: CreateHmacResult","text":"<pre><code>export interface CreateHmacResult {\n    hmac: Byte[];\n}\n</code></pre> <p>See also: Byte</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-createsignatureargs","title":"Interface: CreateSignatureArgs","text":"<pre><code>export interface CreateSignatureArgs extends WalletEncryptionArgs {\n    data?: Byte[];\n    hashToDirectlySign?: Byte[];\n}\n</code></pre> <p>See also: Byte, WalletEncryptionArgs</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-createsignatureresult","title":"Interface: CreateSignatureResult","text":"<pre><code>export interface CreateSignatureResult {\n    signature: Byte[];\n}\n</code></pre> <p>See also: Byte</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-discoverbyattributesargs","title":"Interface: DiscoverByAttributesArgs","text":"<pre><code>export interface DiscoverByAttributesArgs {\n    attributes: Record&lt;CertificateFieldNameUnder50Bytes, string&gt;;\n    limit?: PositiveIntegerDefault10Max10000;\n    offset?: PositiveIntegerOrZero;\n    seekPermission?: BooleanDefaultTrue;\n}\n</code></pre> <p>See also: BooleanDefaultTrue, CertificateFieldNameUnder50Bytes, PositiveIntegerDefault10Max10000, PositiveIntegerOrZero</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-discoverbyidentitykeyargs","title":"Interface: DiscoverByIdentityKeyArgs","text":"<pre><code>export interface DiscoverByIdentityKeyArgs {\n    identityKey: PubKeyHex;\n    limit?: PositiveIntegerDefault10Max10000;\n    offset?: PositiveIntegerOrZero;\n    seekPermission?: BooleanDefaultTrue;\n}\n</code></pre> <p>See also: BooleanDefaultTrue, PositiveIntegerDefault10Max10000, PositiveIntegerOrZero, PubKeyHex</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-discovercertificatesresult","title":"Interface: DiscoverCertificatesResult","text":"<pre><code>export interface DiscoverCertificatesResult {\n    totalCertificates: PositiveIntegerOrZero;\n    certificates: IdentityCertificate[];\n}\n</code></pre> <p>See also: IdentityCertificate, PositiveIntegerOrZero</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-getheaderargs","title":"Interface: GetHeaderArgs","text":"<pre><code>export interface GetHeaderArgs {\n    height: PositiveInteger;\n}\n</code></pre> <p>See also: PositiveInteger</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-getheaderresult","title":"Interface: GetHeaderResult","text":"<pre><code>export interface GetHeaderResult {\n    header: HexString;\n}\n</code></pre> <p>See also: HexString</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-getheightresult","title":"Interface: GetHeightResult","text":"<pre><code>export interface GetHeightResult {\n    height: PositiveInteger;\n}\n</code></pre> <p>See also: PositiveInteger</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-getnetworkresult","title":"Interface: GetNetworkResult","text":"<pre><code>export interface GetNetworkResult {\n    network: WalletNetwork;\n}\n</code></pre> <p>See also: WalletNetwork</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-getpublickeyargs","title":"Interface: GetPublicKeyArgs","text":"<p>When <code>identityKey</code> is true, <code>WalletEncryptionArgs</code> are not used.</p> <p>When <code>identityKey</code> is undefined, <code>WalletEncryptionArgs</code> are required.</p> <pre><code>export interface GetPublicKeyArgs extends Partial&lt;WalletEncryptionArgs&gt; {\n    identityKey?: true;\n    forSelf?: BooleanDefaultFalse;\n}\n</code></pre> <p>See also: BooleanDefaultFalse, WalletEncryptionArgs</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-getpublickeyresult","title":"Interface: GetPublicKeyResult","text":"<pre><code>export interface GetPublicKeyResult {\n    publicKey: PubKeyHex;\n}\n</code></pre> <p>See also: PubKeyHex</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-getversionresult","title":"Interface: GetVersionResult","text":"<pre><code>export interface GetVersionResult {\n    version: VersionString7To30Bytes;\n}\n</code></pre> <p>See also: VersionString7To30Bytes</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-identitycertificate","title":"Interface: IdentityCertificate","text":"<pre><code>export interface IdentityCertificate extends WalletCertificate {\n    certifierInfo: IdentityCertifier;\n    publiclyRevealedKeyring: Record&lt;CertificateFieldNameUnder50Bytes, Base64String&gt;;\n    decryptedFields: Record&lt;CertificateFieldNameUnder50Bytes, string&gt;;\n}\n</code></pre> <p>See also: Base64String, CertificateFieldNameUnder50Bytes, IdentityCertifier, WalletCertificate</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-identitycertifier","title":"Interface: IdentityCertifier","text":"<pre><code>export interface IdentityCertifier {\n    name: EntityNameStringMax100Bytes;\n    iconUrl: EntityIconURLStringMax500Bytes;\n    description: DescriptionString5to50Bytes;\n    trust: PositiveIntegerMax10;\n}\n</code></pre> <p>See also: DescriptionString5to50Bytes, EntityIconURLStringMax500Bytes, EntityNameStringMax100Bytes, PositiveIntegerMax10</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-internalizeactionargs","title":"Interface: InternalizeActionArgs","text":"<pre><code>export interface InternalizeActionArgs {\n    tx: AtomicBEEF;\n    outputs: InternalizeOutput[];\n    description: DescriptionString5to50Bytes;\n    labels?: LabelStringUnder300Bytes[];\n    seekPermission?: BooleanDefaultTrue;\n}\n</code></pre> <p>See also: AtomicBEEF, BooleanDefaultTrue, DescriptionString5to50Bytes, InternalizeOutput, LabelStringUnder300Bytes</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-internalizeactionresult","title":"Interface: InternalizeActionResult","text":"<pre><code>export interface InternalizeActionResult {\n    accepted: true;\n}\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-internalizeoutput","title":"Interface: InternalizeOutput","text":"<pre><code>export interface InternalizeOutput {\n    outputIndex: PositiveIntegerOrZero;\n    protocol: \"wallet payment\" | \"basket insertion\";\n    paymentRemittance?: WalletPayment;\n    insertionRemittance?: BasketInsertion;\n}\n</code></pre> <p>See also: BasketInsertion, PositiveIntegerOrZero, WalletPayment</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-keyderiverapi","title":"Interface: KeyDeriverApi","text":"<pre><code>export interface KeyDeriverApi {\n    rootKey: PrivateKey;\n    identityKey: string;\n    derivePublicKey: (protocolID: WalletProtocol, keyID: string, counterparty: Counterparty, forSelf?: boolean) =&gt; PublicKey;\n    derivePrivateKey: (protocolID: WalletProtocol, keyID: string, counterparty: Counterparty) =&gt; PrivateKey;\n    deriveSymmetricKey: (protocolID: WalletProtocol, keyID: string, counterparty: Counterparty) =&gt; SymmetricKey;\n    revealCounterpartySecret: (counterparty: Counterparty) =&gt; number[];\n    revealSpecificSecret: (counterparty: Counterparty, protocolID: WalletProtocol, keyID: string) =&gt; number[];\n}\n</code></pre> <p>See also: Counterparty, PrivateKey, PublicKey, SymmetricKey, WalletProtocol</p>"},{"location":"reference/wallet/#property-deriveprivatekey","title":"Property derivePrivateKey","text":"<p>Derives a private key based on protocol ID, key ID, and counterparty.</p> <p><pre><code>derivePrivateKey: (protocolID: WalletProtocol, keyID: string, counterparty: Counterparty) =&gt; PrivateKey\n</code></pre> See also: Counterparty, PrivateKey, WalletProtocol</p>"},{"location":"reference/wallet/#property-derivepublickey","title":"Property derivePublicKey","text":"<p>Derives a public key based on protocol ID, key ID, and counterparty.</p> <p><pre><code>derivePublicKey: (protocolID: WalletProtocol, keyID: string, counterparty: Counterparty, forSelf?: boolean) =&gt; PublicKey\n</code></pre> See also: Counterparty, PublicKey, WalletProtocol</p>"},{"location":"reference/wallet/#property-derivesymmetrickey","title":"Property deriveSymmetricKey","text":"<p>Derives a symmetric key based on protocol ID, key ID, and counterparty. Note: Symmetric keys should not be derivable by everyone due to security risks.</p> <p><pre><code>deriveSymmetricKey: (protocolID: WalletProtocol, keyID: string, counterparty: Counterparty) =&gt; SymmetricKey\n</code></pre> See also: Counterparty, SymmetricKey, WalletProtocol</p>"},{"location":"reference/wallet/#property-identitykey","title":"Property identityKey","text":"<p>The identity of this key deriver which is normally the public key associated with the <code>rootKey</code></p> <pre><code>identityKey: string\n</code></pre>"},{"location":"reference/wallet/#property-revealcounterpartysecret","title":"Property revealCounterpartySecret","text":"<p>Reveals the shared secret between the root key and the counterparty. Note: This should not be used for 'self'.</p> <p><pre><code>revealCounterpartySecret: (counterparty: Counterparty) =&gt; number[]\n</code></pre> See also: Counterparty</p>"},{"location":"reference/wallet/#property-revealspecificsecret","title":"Property revealSpecificSecret","text":"<p>Reveals the specific key association for a given protocol ID, key ID, and counterparty.</p> <p><pre><code>revealSpecificSecret: (counterparty: Counterparty, protocolID: WalletProtocol, keyID: string) =&gt; number[]\n</code></pre> See also: Counterparty, WalletProtocol</p>"},{"location":"reference/wallet/#property-rootkey","title":"Property rootKey","text":"<p>The root key from which all other keys are derived.</p> <p><pre><code>rootKey: PrivateKey\n</code></pre> See also: PrivateKey</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-keylinkageresult","title":"Interface: KeyLinkageResult","text":"<pre><code>export interface KeyLinkageResult {\n    encryptedLinkage: Byte[];\n    encryptedLinkageProof: Byte[];\n    prover: PubKeyHex;\n    verifier: PubKeyHex;\n    counterparty: PubKeyHex;\n}\n</code></pre> <p>See also: Byte, PubKeyHex</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-listactionsargs","title":"Interface: ListActionsArgs","text":"<pre><code>export interface ListActionsArgs {\n    labels: LabelStringUnder300Bytes[];\n    labelQueryMode?: \"any\" | \"all\";\n    includeLabels?: BooleanDefaultFalse;\n    includeInputs?: BooleanDefaultFalse;\n    includeInputSourceLockingScripts?: BooleanDefaultFalse;\n    includeInputUnlockingScripts?: BooleanDefaultFalse;\n    includeOutputs?: BooleanDefaultFalse;\n    includeOutputLockingScripts?: BooleanDefaultFalse;\n    limit?: PositiveIntegerDefault10Max10000;\n    offset?: PositiveIntegerOrZero;\n    seekPermission?: BooleanDefaultTrue;\n}\n</code></pre> <p>See also: BooleanDefaultFalse, BooleanDefaultTrue, LabelStringUnder300Bytes, PositiveIntegerDefault10Max10000, PositiveIntegerOrZero</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-listactionsresult","title":"Interface: ListActionsResult","text":"<pre><code>export interface ListActionsResult {\n    totalActions: PositiveIntegerOrZero;\n    actions: WalletAction[];\n}\n</code></pre> <p>See also: PositiveIntegerOrZero, WalletAction</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-listcertificatesargs","title":"Interface: ListCertificatesArgs","text":"<pre><code>export interface ListCertificatesArgs {\n    certifiers: PubKeyHex[];\n    types: Base64String[];\n    limit?: PositiveIntegerDefault10Max10000;\n    offset?: PositiveIntegerOrZero;\n    privileged?: BooleanDefaultFalse;\n    privilegedReason?: DescriptionString5to50Bytes;\n}\n</code></pre> <p>See also: Base64String, BooleanDefaultFalse, DescriptionString5to50Bytes, PositiveIntegerDefault10Max10000, PositiveIntegerOrZero, PubKeyHex</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-listcertificatesresult","title":"Interface: ListCertificatesResult","text":"<pre><code>export interface ListCertificatesResult {\n    totalCertificates: PositiveIntegerOrZero;\n    certificates: CertificateResult[];\n}\n</code></pre> <p>See also: CertificateResult, PositiveIntegerOrZero</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-listoutputsargs","title":"Interface: ListOutputsArgs","text":"<pre><code>export interface ListOutputsArgs {\n    basket: BasketStringUnder300Bytes;\n    tags?: OutputTagStringUnder300Bytes[];\n    tagQueryMode?: \"all\" | \"any\";\n    include?: \"locking scripts\" | \"entire transactions\";\n    includeCustomInstructions?: BooleanDefaultFalse;\n    includeTags?: BooleanDefaultFalse;\n    includeLabels?: BooleanDefaultFalse;\n    limit?: PositiveIntegerDefault10Max10000;\n    offset?: number;\n    seekPermission?: BooleanDefaultTrue;\n}\n</code></pre> <p>See also: BasketStringUnder300Bytes, BooleanDefaultFalse, BooleanDefaultTrue, OutputTagStringUnder300Bytes, PositiveIntegerDefault10Max10000</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-listoutputsresult","title":"Interface: ListOutputsResult","text":"<pre><code>export interface ListOutputsResult {\n    totalOutputs: PositiveIntegerOrZero;\n    BEEF?: BEEF;\n    outputs: WalletOutput[];\n}\n</code></pre> <p>See also: BEEF, PositiveIntegerOrZero, WalletOutput</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-outpoint","title":"Interface: OutPoint","text":"<p>Identifies a unique transaction output by its <code>txid</code> and index <code>vout</code></p> <pre><code>export interface OutPoint {\n    txid: string;\n    vout: number;\n}\n</code></pre>"},{"location":"reference/wallet/#property-txid","title":"Property txid","text":"<p>Transaction double sha256 hash as big endian hex string</p> <pre><code>txid: string\n</code></pre>"},{"location":"reference/wallet/#property-vout","title":"Property vout","text":"<p>zero based output index within the transaction</p> <pre><code>vout: number\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-provecertificateargs","title":"Interface: ProveCertificateArgs","text":"<pre><code>export interface ProveCertificateArgs {\n    certificate: Partial&lt;WalletCertificate&gt;;\n    fieldsToReveal: CertificateFieldNameUnder50Bytes[];\n    verifier: PubKeyHex;\n    privileged?: BooleanDefaultFalse;\n    privilegedReason?: DescriptionString5to50Bytes;\n}\n</code></pre> <p>See also: BooleanDefaultFalse, CertificateFieldNameUnder50Bytes, DescriptionString5to50Bytes, PubKeyHex, WalletCertificate</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-provecertificateresult","title":"Interface: ProveCertificateResult","text":"<pre><code>export interface ProveCertificateResult {\n    keyringForVerifier: Record&lt;CertificateFieldNameUnder50Bytes, Base64String&gt;;\n    certificate?: WalletCertificate;\n    verifier?: PubKeyHex;\n}\n</code></pre> <p>See also: Base64String, CertificateFieldNameUnder50Bytes, PubKeyHex, WalletCertificate</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-relinquishcertificateargs","title":"Interface: RelinquishCertificateArgs","text":"<pre><code>export interface RelinquishCertificateArgs {\n    type: Base64String;\n    serialNumber: Base64String;\n    certifier: PubKeyHex;\n}\n</code></pre> <p>See also: Base64String, PubKeyHex</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-relinquishcertificateresult","title":"Interface: RelinquishCertificateResult","text":"<pre><code>export interface RelinquishCertificateResult {\n    relinquished: true;\n}\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-relinquishoutputargs","title":"Interface: RelinquishOutputArgs","text":"<pre><code>export interface RelinquishOutputArgs {\n    basket: BasketStringUnder300Bytes;\n    output: OutpointString;\n}\n</code></pre> <p>See also: BasketStringUnder300Bytes, OutpointString</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-relinquishoutputresult","title":"Interface: RelinquishOutputResult","text":"<pre><code>export interface RelinquishOutputResult {\n    relinquished: true;\n}\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-revealcounterpartykeylinkageargs","title":"Interface: RevealCounterpartyKeyLinkageArgs","text":"<pre><code>export interface RevealCounterpartyKeyLinkageArgs {\n    counterparty: PubKeyHex;\n    verifier: PubKeyHex;\n    privileged?: BooleanDefaultFalse;\n    privilegedReason?: DescriptionString5to50Bytes;\n}\n</code></pre> <p>See also: BooleanDefaultFalse, DescriptionString5to50Bytes, PubKeyHex</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-revealcounterpartykeylinkageresult","title":"Interface: RevealCounterpartyKeyLinkageResult","text":"<pre><code>export interface RevealCounterpartyKeyLinkageResult extends KeyLinkageResult {\n    revelationTime: ISOTimestampString;\n}\n</code></pre> <p>See also: ISOTimestampString, KeyLinkageResult</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-revealspecifickeylinkageargs","title":"Interface: RevealSpecificKeyLinkageArgs","text":"<pre><code>export interface RevealSpecificKeyLinkageArgs {\n    counterparty: WalletCounterparty;\n    verifier: PubKeyHex;\n    protocolID: WalletProtocol;\n    keyID: KeyIDStringUnder800Bytes;\n    privilegedReason?: DescriptionString5to50Bytes;\n    privileged?: BooleanDefaultFalse;\n}\n</code></pre> <p>See also: BooleanDefaultFalse, DescriptionString5to50Bytes, KeyIDStringUnder800Bytes, PubKeyHex, WalletCounterparty, WalletProtocol</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-revealspecifickeylinkageresult","title":"Interface: RevealSpecificKeyLinkageResult","text":"<pre><code>export interface RevealSpecificKeyLinkageResult extends KeyLinkageResult {\n    protocolID: WalletProtocol;\n    keyID: KeyIDStringUnder800Bytes;\n    proofType: Byte;\n}\n</code></pre> <p>See also: Byte, KeyIDStringUnder800Bytes, KeyLinkageResult, WalletProtocol</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-reviewactionresult","title":"Interface: ReviewActionResult","text":"<pre><code>export interface ReviewActionResult {\n    txid: TXIDHexString;\n    status: ReviewActionResultStatus;\n    competingTxs?: string[];\n    competingBeef?: number[];\n}\n</code></pre> <p>See also: ReviewActionResultStatus, TXIDHexString</p>"},{"location":"reference/wallet/#property-competingbeef","title":"Property competingBeef","text":"<p>Merged beef of competingTxs, valid when status is 'doubleSpend'.</p> <pre><code>competingBeef?: number[]\n</code></pre>"},{"location":"reference/wallet/#property-competingtxs","title":"Property competingTxs","text":"<p>Any competing txids reported for this txid, valid when status is 'doubleSpend'.</p> <pre><code>competingTxs?: string[]\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-sendwithresult","title":"Interface: SendWithResult","text":"<pre><code>export interface SendWithResult {\n    txid: TXIDHexString;\n    status: SendWithResultStatus;\n}\n</code></pre> <p>See also: SendWithResultStatus, TXIDHexString</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-signactionargs","title":"Interface: SignActionArgs","text":"<pre><code>export interface SignActionArgs {\n    spends: Record&lt;PositiveIntegerOrZero, SignActionSpend&gt;;\n    reference: Base64String;\n    options?: SignActionOptions;\n}\n</code></pre> <p>See also: Base64String, PositiveIntegerOrZero, SignActionOptions, SignActionSpend</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-signactionoptions","title":"Interface: SignActionOptions","text":"<pre><code>export interface SignActionOptions {\n    acceptDelayedBroadcast?: BooleanDefaultTrue;\n    returnTXIDOnly?: BooleanDefaultFalse;\n    noSend?: BooleanDefaultFalse;\n    sendWith?: TXIDHexString[];\n}\n</code></pre> <p>See also: BooleanDefaultFalse, BooleanDefaultTrue, TXIDHexString</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-signactionresult","title":"Interface: SignActionResult","text":"<pre><code>export interface SignActionResult {\n    txid?: TXIDHexString;\n    tx?: AtomicBEEF;\n    sendWithResults?: SendWithResult[];\n}\n</code></pre> <p>See also: AtomicBEEF, SendWithResult, TXIDHexString</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-signactionspend","title":"Interface: SignActionSpend","text":"<pre><code>export interface SignActionSpend {\n    unlockingScript: HexString;\n    sequenceNumber?: PositiveIntegerOrZero;\n}\n</code></pre> <p>See also: HexString, PositiveIntegerOrZero</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-signabletransaction","title":"Interface: SignableTransaction","text":"<pre><code>export interface SignableTransaction {\n    tx: AtomicBEEF;\n    reference: Base64String;\n}\n</code></pre> <p>See also: AtomicBEEF, Base64String</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-validabortactionargs","title":"Interface: ValidAbortActionArgs","text":"<pre><code>export interface ValidAbortActionArgs extends ValidWalletSignerArgs {\n    reference: Base64String;\n}\n</code></pre> <p>See also: Base64String, ValidWalletSignerArgs</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-validacquirecertificateargs","title":"Interface: ValidAcquireCertificateArgs","text":"<pre><code>export interface ValidAcquireCertificateArgs extends ValidWalletSignerArgs {\n    acquisitionProtocol: AcquisitionProtocol;\n    type: Base64String;\n    serialNumber?: Base64String;\n    certifier: PubKeyHex;\n    revocationOutpoint?: OutpointString;\n    fields: Record&lt;CertificateFieldNameUnder50Bytes, string&gt;;\n    signature?: HexString;\n    certifierUrl?: string;\n    keyringRevealer?: KeyringRevealer;\n    keyringForSubject?: Record&lt;CertificateFieldNameUnder50Bytes, Base64String&gt;;\n    privileged: boolean;\n    privilegedReason?: DescriptionString5to50Bytes;\n}\n</code></pre> <p>See also: AcquisitionProtocol, Base64String, CertificateFieldNameUnder50Bytes, DescriptionString5to50Bytes, HexString, KeyringRevealer, OutpointString, PubKeyHex, ValidWalletSignerArgs</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-validacquiredirectcertificateargs","title":"Interface: ValidAcquireDirectCertificateArgs","text":"<pre><code>export interface ValidAcquireDirectCertificateArgs extends ValidWalletSignerArgs {\n    type: Base64String;\n    serialNumber: Base64String;\n    certifier: PubKeyHex;\n    revocationOutpoint: OutpointString;\n    fields: Record&lt;CertificateFieldNameUnder50Bytes, string&gt;;\n    signature: HexString;\n    subject: PubKeyHex;\n    keyringRevealer: KeyringRevealer;\n    keyringForSubject: Record&lt;CertificateFieldNameUnder50Bytes, Base64String&gt;;\n    privileged: boolean;\n    privilegedReason?: DescriptionString5to50Bytes;\n}\n</code></pre> <p>See also: Base64String, CertificateFieldNameUnder50Bytes, DescriptionString5to50Bytes, HexString, KeyringRevealer, OutpointString, PubKeyHex, ValidWalletSignerArgs</p>"},{"location":"reference/wallet/#property-subject","title":"Property subject","text":"<p>validated to an empty string, must be provided by wallet and must match expectations of keyringForSubject</p> <p><pre><code>subject: PubKeyHex\n</code></pre> See also: PubKeyHex</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-validacquireissuancecertificateargs","title":"Interface: ValidAcquireIssuanceCertificateArgs","text":"<pre><code>export interface ValidAcquireIssuanceCertificateArgs extends ValidWalletSignerArgs {\n    type: Base64String;\n    certifier: PubKeyHex;\n    certifierUrl: string;\n    fields: Record&lt;CertificateFieldNameUnder50Bytes, string&gt;;\n    subject: PubKeyHex;\n    privileged: boolean;\n    privilegedReason?: DescriptionString5to50Bytes;\n}\n</code></pre> <p>See also: Base64String, CertificateFieldNameUnder50Bytes, DescriptionString5to50Bytes, PubKeyHex, ValidWalletSignerArgs</p>"},{"location":"reference/wallet/#property-subject_1","title":"Property subject","text":"<p>validated to an empty string, must be provided by wallet and must match expectations of keyringForSubject</p> <p><pre><code>subject: PubKeyHex\n</code></pre> See also: PubKeyHex</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-validbasketinsertion","title":"Interface: ValidBasketInsertion","text":"<pre><code>export interface ValidBasketInsertion {\n    basket: BasketStringUnder300Bytes;\n    customInstructions?: string;\n    tags: BasketStringUnder300Bytes[];\n}\n</code></pre> <p>See also: BasketStringUnder300Bytes</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-validcreateactionargs","title":"Interface: ValidCreateActionArgs","text":"<pre><code>export interface ValidCreateActionArgs extends ValidProcessActionArgs {\n    description: DescriptionString5to2000Bytes;\n    inputBEEF?: BEEF;\n    inputs: ValidCreateActionInput[];\n    outputs: ValidCreateActionOutput[];\n    lockTime: number;\n    version: number;\n    labels: string[];\n    options: ValidCreateActionOptions;\n    isSignAction: boolean;\n    randomVals?: number[];\n    includeAllSourceTransactions: boolean;\n}\n</code></pre> <p>See also: BEEF, DescriptionString5to2000Bytes, ValidCreateActionInput, ValidCreateActionOptions, ValidCreateActionOutput, ValidProcessActionArgs</p>"},{"location":"reference/wallet/#property-includeallsourcetransactions","title":"Property includeAllSourceTransactions","text":"<p>If true, signableTransactions will include sourceTransaction for each input, including those that do not require signature and those that were also contained in the inputBEEF.</p> <pre><code>includeAllSourceTransactions: boolean\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-validcreateactioninput","title":"Interface: ValidCreateActionInput","text":"<pre><code>export interface ValidCreateActionInput {\n    outpoint: OutPoint;\n    inputDescription: DescriptionString5to2000Bytes;\n    sequenceNumber: PositiveIntegerOrZero;\n    unlockingScript?: HexString;\n    unlockingScriptLength: PositiveInteger;\n}\n</code></pre> <p>See also: DescriptionString5to2000Bytes, HexString, OutPoint, PositiveInteger, PositiveIntegerOrZero</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-validcreateactionoptions","title":"Interface: ValidCreateActionOptions","text":"<pre><code>export interface ValidCreateActionOptions extends ValidProcessActionOptions {\n    signAndProcess: boolean;\n    trustSelf?: TrustSelf;\n    knownTxids: TXIDHexString[];\n    noSendChange: OutPoint[];\n    randomizeOutputs: boolean;\n}\n</code></pre> <p>See also: OutPoint, TXIDHexString, TrustSelf, ValidProcessActionOptions</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-validcreateactionoutput","title":"Interface: ValidCreateActionOutput","text":"<pre><code>export interface ValidCreateActionOutput {\n    lockingScript: HexString;\n    satoshis: SatoshiValue;\n    outputDescription: DescriptionString5to2000Bytes;\n    basket?: BasketStringUnder300Bytes;\n    customInstructions?: string;\n    tags: BasketStringUnder300Bytes[];\n}\n</code></pre> <p>See also: BasketStringUnder300Bytes, DescriptionString5to2000Bytes, HexString, SatoshiValue</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-validdiscoverbyattributesargs","title":"Interface: ValidDiscoverByAttributesArgs","text":"<pre><code>export interface ValidDiscoverByAttributesArgs extends ValidWalletSignerArgs {\n    attributes: Record&lt;CertificateFieldNameUnder50Bytes, string&gt;;\n    limit: PositiveIntegerDefault10Max10000;\n    offset: PositiveIntegerOrZero;\n    seekPermission: boolean;\n}\n</code></pre> <p>See also: CertificateFieldNameUnder50Bytes, PositiveIntegerDefault10Max10000, PositiveIntegerOrZero, ValidWalletSignerArgs</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-validdiscoverbyidentitykeyargs","title":"Interface: ValidDiscoverByIdentityKeyArgs","text":"<pre><code>export interface ValidDiscoverByIdentityKeyArgs extends ValidWalletSignerArgs {\n    identityKey: PubKeyHex;\n    limit: PositiveIntegerDefault10Max10000;\n    offset: PositiveIntegerOrZero;\n    seekPermission: boolean;\n}\n</code></pre> <p>See also: PositiveIntegerDefault10Max10000, PositiveIntegerOrZero, PubKeyHex, ValidWalletSignerArgs</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-validinternalizeactionargs","title":"Interface: ValidInternalizeActionArgs","text":"<pre><code>export interface ValidInternalizeActionArgs extends ValidWalletSignerArgs {\n    tx: AtomicBEEF;\n    outputs: InternalizeOutput[];\n    description: DescriptionString5to2000Bytes;\n    labels: LabelStringUnder300Bytes[];\n    seekPermission: BooleanDefaultTrue;\n}\n</code></pre> <p>See also: AtomicBEEF, BooleanDefaultTrue, DescriptionString5to2000Bytes, InternalizeOutput, LabelStringUnder300Bytes, ValidWalletSignerArgs</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-validinternalizeoutput","title":"Interface: ValidInternalizeOutput","text":"<pre><code>export interface ValidInternalizeOutput {\n    outputIndex: PositiveIntegerOrZero;\n    protocol: \"wallet payment\" | \"basket insertion\";\n    paymentRemittance?: ValidWalletPayment;\n    insertionRemittance?: ValidBasketInsertion;\n}\n</code></pre> <p>See also: PositiveIntegerOrZero, ValidBasketInsertion, ValidWalletPayment</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-validlistactionsargs","title":"Interface: ValidListActionsArgs","text":"<pre><code>export interface ValidListActionsArgs extends ValidWalletSignerArgs {\n    labels: LabelStringUnder300Bytes[];\n    labelQueryMode: \"any\" | \"all\";\n    includeLabels: BooleanDefaultFalse;\n    includeInputs: BooleanDefaultFalse;\n    includeInputSourceLockingScripts: BooleanDefaultFalse;\n    includeInputUnlockingScripts: BooleanDefaultFalse;\n    includeOutputs: BooleanDefaultFalse;\n    includeOutputLockingScripts: BooleanDefaultFalse;\n    limit: PositiveIntegerDefault10Max10000;\n    offset: PositiveIntegerOrZero;\n    seekPermission: BooleanDefaultTrue;\n}\n</code></pre> <p>See also: BooleanDefaultFalse, BooleanDefaultTrue, LabelStringUnder300Bytes, PositiveIntegerDefault10Max10000, PositiveIntegerOrZero, ValidWalletSignerArgs</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-validlistcertificatesargs","title":"Interface: ValidListCertificatesArgs","text":"<pre><code>export interface ValidListCertificatesArgs extends ValidWalletSignerArgs {\n    partial?: {\n        type?: Base64String;\n        serialNumber?: Base64String;\n        certifier?: PubKeyHex;\n        subject?: PubKeyHex;\n        revocationOutpoint?: OutpointString;\n        signature?: HexString;\n    };\n    certifiers: PubKeyHex[];\n    types: Base64String[];\n    limit: PositiveIntegerDefault10Max10000;\n    offset: PositiveIntegerOrZero;\n    privileged: BooleanDefaultFalse;\n    privilegedReason?: DescriptionString5to50Bytes;\n}\n</code></pre> <p>See also: Base64String, BooleanDefaultFalse, DescriptionString5to50Bytes, HexString, OutpointString, PositiveIntegerDefault10Max10000, PositiveIntegerOrZero, PubKeyHex, ValidWalletSignerArgs</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-validlistoutputsargs","title":"Interface: ValidListOutputsArgs","text":"<pre><code>export interface ValidListOutputsArgs extends ValidWalletSignerArgs {\n    basket: BasketStringUnder300Bytes;\n    tags: OutputTagStringUnder300Bytes[];\n    tagQueryMode: \"all\" | \"any\";\n    includeLockingScripts: boolean;\n    includeTransactions: boolean;\n    includeCustomInstructions: BooleanDefaultFalse;\n    includeTags: BooleanDefaultFalse;\n    includeLabels: BooleanDefaultFalse;\n    limit: PositiveIntegerDefault10Max10000;\n    offset: number;\n    seekPermission: BooleanDefaultTrue;\n    knownTxids: string[];\n}\n</code></pre> <p>See also: BasketStringUnder300Bytes, BooleanDefaultFalse, BooleanDefaultTrue, OutputTagStringUnder300Bytes, PositiveIntegerDefault10Max10000, ValidWalletSignerArgs</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-validprocessactionargs","title":"Interface: ValidProcessActionArgs","text":"<pre><code>export interface ValidProcessActionArgs extends ValidWalletSignerArgs {\n    options: ValidProcessActionOptions;\n    isSendWith: boolean;\n    isNewTx: boolean;\n    isRemixChange: boolean;\n    isNoSend: boolean;\n    isDelayed: boolean;\n    isTestWerrReviewActions: boolean;\n}\n</code></pre> <p>See also: ValidProcessActionOptions, ValidWalletSignerArgs</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-validprocessactionoptions","title":"Interface: ValidProcessActionOptions","text":"<pre><code>export interface ValidProcessActionOptions {\n    acceptDelayedBroadcast: BooleanDefaultTrue;\n    returnTXIDOnly: BooleanDefaultFalse;\n    noSend: BooleanDefaultFalse;\n    sendWith: TXIDHexString[];\n}\n</code></pre> <p>See also: BooleanDefaultFalse, BooleanDefaultTrue, TXIDHexString</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-validprovecertificateargs","title":"Interface: ValidProveCertificateArgs","text":"<pre><code>export interface ValidProveCertificateArgs extends ValidWalletSignerArgs {\n    type?: Base64String;\n    serialNumber?: Base64String;\n    certifier?: PubKeyHex;\n    subject?: PubKeyHex;\n    revocationOutpoint?: OutpointString;\n    signature?: HexString;\n    fieldsToReveal: CertificateFieldNameUnder50Bytes[];\n    verifier: PubKeyHex;\n    privileged: boolean;\n    privilegedReason?: DescriptionString5to50Bytes;\n}\n</code></pre> <p>See also: Base64String, CertificateFieldNameUnder50Bytes, DescriptionString5to50Bytes, HexString, OutpointString, PubKeyHex, ValidWalletSignerArgs</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-validrelinquishcertificateargs","title":"Interface: ValidRelinquishCertificateArgs","text":"<pre><code>export interface ValidRelinquishCertificateArgs extends ValidWalletSignerArgs {\n    type: Base64String;\n    serialNumber: Base64String;\n    certifier: PubKeyHex;\n}\n</code></pre> <p>See also: Base64String, PubKeyHex, ValidWalletSignerArgs</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-validrelinquishoutputargs","title":"Interface: ValidRelinquishOutputArgs","text":"<pre><code>export interface ValidRelinquishOutputArgs extends ValidWalletSignerArgs {\n    basket: BasketStringUnder300Bytes;\n    output: OutpointString;\n}\n</code></pre> <p>See also: BasketStringUnder300Bytes, OutpointString, ValidWalletSignerArgs</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-validsignactionargs","title":"Interface: ValidSignActionArgs","text":"<pre><code>export interface ValidSignActionArgs extends ValidProcessActionArgs {\n    spends: Record&lt;PositiveIntegerOrZero, SignActionSpend&gt;;\n    reference: Base64String;\n    options: ValidSignActionOptions;\n}\n</code></pre> <p>See also: Base64String, PositiveIntegerOrZero, SignActionSpend, ValidProcessActionArgs, ValidSignActionOptions</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-validsignactionoptions","title":"Interface: ValidSignActionOptions","text":"<pre><code>export interface ValidSignActionOptions extends ValidProcessActionOptions {\n    acceptDelayedBroadcast: boolean;\n    returnTXIDOnly: boolean;\n    noSend: boolean;\n    sendWith: TXIDHexString[];\n}\n</code></pre> <p>See also: TXIDHexString, ValidProcessActionOptions</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-validwalletpayment","title":"Interface: ValidWalletPayment","text":"<pre><code>export interface ValidWalletPayment {\n    derivationPrefix: Base64String;\n    derivationSuffix: Base64String;\n    senderIdentityKey: PubKeyHex;\n}\n</code></pre> <p>See also: Base64String, PubKeyHex</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-validwalletsignerargs","title":"Interface: ValidWalletSignerArgs","text":"<pre><code>export interface ValidWalletSignerArgs {\n    logger?: WalletLoggerInterface;\n}\n</code></pre> <p>See also: WalletLoggerInterface</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-verifyhmacargs","title":"Interface: VerifyHmacArgs","text":"<pre><code>export interface VerifyHmacArgs extends WalletEncryptionArgs {\n    data: Byte[];\n    hmac: Byte[];\n}\n</code></pre> <p>See also: Byte, WalletEncryptionArgs</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-verifyhmacresult","title":"Interface: VerifyHmacResult","text":"<pre><code>export interface VerifyHmacResult {\n    valid: true;\n}\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-verifysignatureargs","title":"Interface: VerifySignatureArgs","text":"<pre><code>export interface VerifySignatureArgs extends WalletEncryptionArgs {\n    data?: Byte[];\n    hashToDirectlyVerify?: Byte[];\n    signature: Byte[];\n    forSelf?: BooleanDefaultFalse;\n}\n</code></pre> <p>See also: BooleanDefaultFalse, Byte, WalletEncryptionArgs</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-verifysignatureresult","title":"Interface: VerifySignatureResult","text":"<pre><code>export interface VerifySignatureResult {\n    valid: true;\n}\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-walletaction","title":"Interface: WalletAction","text":"<pre><code>export interface WalletAction {\n    txid: TXIDHexString;\n    satoshis: SatoshiValue;\n    status: ActionStatus;\n    isOutgoing: boolean;\n    description: DescriptionString5to50Bytes;\n    labels?: LabelStringUnder300Bytes[];\n    version: PositiveIntegerOrZero;\n    lockTime: PositiveIntegerOrZero;\n    inputs?: WalletActionInput[];\n    outputs?: WalletActionOutput[];\n}\n</code></pre> <p>See also: ActionStatus, DescriptionString5to50Bytes, LabelStringUnder300Bytes, PositiveIntegerOrZero, SatoshiValue, TXIDHexString, WalletActionInput, WalletActionOutput</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-walletactioninput","title":"Interface: WalletActionInput","text":"<pre><code>export interface WalletActionInput {\n    sourceOutpoint: OutpointString;\n    sourceSatoshis: SatoshiValue;\n    sourceLockingScript?: HexString;\n    unlockingScript?: HexString;\n    inputDescription: DescriptionString5to50Bytes;\n    sequenceNumber: PositiveIntegerOrZero;\n}\n</code></pre> <p>See also: DescriptionString5to50Bytes, HexString, OutpointString, PositiveIntegerOrZero, SatoshiValue</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-walletactionoutput","title":"Interface: WalletActionOutput","text":"<pre><code>export interface WalletActionOutput {\n    satoshis: SatoshiValue;\n    lockingScript?: HexString;\n    spendable: boolean;\n    customInstructions?: string;\n    tags: OutputTagStringUnder300Bytes[];\n    outputIndex: PositiveIntegerOrZero;\n    outputDescription: DescriptionString5to50Bytes;\n    basket: BasketStringUnder300Bytes;\n}\n</code></pre> <p>See also: BasketStringUnder300Bytes, DescriptionString5to50Bytes, HexString, OutputTagStringUnder300Bytes, PositiveIntegerOrZero, SatoshiValue</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-walletcertificate","title":"Interface: WalletCertificate","text":"<pre><code>export interface WalletCertificate {\n    type: Base64String;\n    subject: PubKeyHex;\n    serialNumber: Base64String;\n    certifier: PubKeyHex;\n    revocationOutpoint: OutpointString;\n    signature: HexString;\n    fields: Record&lt;CertificateFieldNameUnder50Bytes, string&gt;;\n}\n</code></pre> <p>See also: Base64String, CertificateFieldNameUnder50Bytes, HexString, OutpointString, PubKeyHex</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-walletdecryptargs","title":"Interface: WalletDecryptArgs","text":"<pre><code>export interface WalletDecryptArgs extends WalletEncryptionArgs {\n    ciphertext: Byte[];\n}\n</code></pre> <p>See also: Byte, WalletEncryptionArgs</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-walletdecryptresult","title":"Interface: WalletDecryptResult","text":"<pre><code>export interface WalletDecryptResult {\n    plaintext: Byte[];\n}\n</code></pre> <p>See also: Byte</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-walletencryptargs","title":"Interface: WalletEncryptArgs","text":"<pre><code>export interface WalletEncryptArgs extends WalletEncryptionArgs {\n    plaintext: Byte[];\n}\n</code></pre> <p>See also: Byte, WalletEncryptionArgs</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-walletencryptresult","title":"Interface: WalletEncryptResult","text":"<pre><code>export interface WalletEncryptResult {\n    ciphertext: Byte[];\n}\n</code></pre> <p>See also: Byte</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-walletencryptionargs","title":"Interface: WalletEncryptionArgs","text":"<pre><code>export interface WalletEncryptionArgs {\n    protocolID: WalletProtocol;\n    keyID: KeyIDStringUnder800Bytes;\n    counterparty?: WalletCounterparty;\n    privileged?: BooleanDefaultFalse;\n    privilegedReason?: DescriptionString5to50Bytes;\n    seekPermission?: BooleanDefaultTrue;\n}\n</code></pre> <p>See also: BooleanDefaultFalse, BooleanDefaultTrue, DescriptionString5to50Bytes, KeyIDStringUnder800Bytes, WalletCounterparty, WalletProtocol</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-walleterrorobject","title":"Interface: WalletErrorObject","text":"<p>Every method of the <code>Wallet</code> interface has a return value of the form <code>Promise&lt;object&gt;</code>. When errors occur, an exception object may be thrown which must conform to the <code>WalletErrorObject</code> interface. Serialization layers can rely on the <code>isError</code> property being unique to error objects. Deserialization should rethrow <code>WalletErrorObject</code> conforming objects.</p> <pre><code>export interface WalletErrorObject extends Error {\n    isError: true;\n}\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-walletinterface","title":"Interface: WalletInterface","text":"<p>The Wallet interface defines a wallet capable of various tasks including transaction creation and signing, encryption, decryption, identity certificate management, identity verification, and communication with applications as per the BRC standards. This interface allows applications to interact with the wallet for a range of functionalities aligned with the Babbage architectural principles.</p> <p>Error Handling</p> <p>Every method of the <code>Wallet</code> interface has a return value of the form <code>Promise&lt;object&gt;</code>. When an error occurs, an exception object may be thrown which must conform to the <code>WalletErrorObject</code> interface. Serialization layers can rely on the <code>isError</code> property being unique to error objects to deserialize and rethrow <code>WalletErrorObject</code> conforming objects.</p> <pre><code>export interface WalletInterface {\n    getPublicKey: (args: GetPublicKeyArgs, originator?: OriginatorDomainNameStringUnder250Bytes) =&gt; Promise&lt;GetPublicKeyResult&gt;;\n    revealCounterpartyKeyLinkage: (args: RevealCounterpartyKeyLinkageArgs, originator?: OriginatorDomainNameStringUnder250Bytes) =&gt; Promise&lt;RevealCounterpartyKeyLinkageResult&gt;;\n    revealSpecificKeyLinkage: (args: RevealSpecificKeyLinkageArgs, originator?: OriginatorDomainNameStringUnder250Bytes) =&gt; Promise&lt;RevealSpecificKeyLinkageResult&gt;;\n    encrypt: (args: WalletEncryptArgs, originator?: OriginatorDomainNameStringUnder250Bytes) =&gt; Promise&lt;WalletEncryptResult&gt;;\n    decrypt: (args: WalletDecryptArgs, originator?: OriginatorDomainNameStringUnder250Bytes) =&gt; Promise&lt;WalletDecryptResult&gt;;\n    createHmac: (args: CreateHmacArgs, originator?: OriginatorDomainNameStringUnder250Bytes) =&gt; Promise&lt;CreateHmacResult&gt;;\n    verifyHmac: (args: VerifyHmacArgs, originator?: OriginatorDomainNameStringUnder250Bytes) =&gt; Promise&lt;VerifyHmacResult&gt;;\n    createSignature: (args: CreateSignatureArgs, originator?: OriginatorDomainNameStringUnder250Bytes) =&gt; Promise&lt;CreateSignatureResult&gt;;\n    verifySignature: (args: VerifySignatureArgs, originator?: OriginatorDomainNameStringUnder250Bytes) =&gt; Promise&lt;VerifySignatureResult&gt;;\n    createAction: (args: CreateActionArgs, originator?: OriginatorDomainNameStringUnder250Bytes) =&gt; Promise&lt;CreateActionResult&gt;;\n    signAction: (args: SignActionArgs, originator?: OriginatorDomainNameStringUnder250Bytes) =&gt; Promise&lt;SignActionResult&gt;;\n    abortAction: (args: AbortActionArgs, originator?: OriginatorDomainNameStringUnder250Bytes) =&gt; Promise&lt;AbortActionResult&gt;;\n    listActions: (args: ListActionsArgs, originator?: OriginatorDomainNameStringUnder250Bytes) =&gt; Promise&lt;ListActionsResult&gt;;\n    internalizeAction: (args: InternalizeActionArgs, originator?: OriginatorDomainNameStringUnder250Bytes) =&gt; Promise&lt;InternalizeActionResult&gt;;\n    listOutputs: (args: ListOutputsArgs, originator?: OriginatorDomainNameStringUnder250Bytes) =&gt; Promise&lt;ListOutputsResult&gt;;\n    relinquishOutput: (args: RelinquishOutputArgs, originator?: OriginatorDomainNameStringUnder250Bytes) =&gt; Promise&lt;RelinquishOutputResult&gt;;\n    acquireCertificate: (args: AcquireCertificateArgs, originator?: OriginatorDomainNameStringUnder250Bytes) =&gt; Promise&lt;WalletCertificate&gt;;\n    listCertificates: (args: ListCertificatesArgs, originator?: OriginatorDomainNameStringUnder250Bytes) =&gt; Promise&lt;ListCertificatesResult&gt;;\n    proveCertificate: (args: ProveCertificateArgs, originator?: OriginatorDomainNameStringUnder250Bytes) =&gt; Promise&lt;ProveCertificateResult&gt;;\n    relinquishCertificate: (args: RelinquishCertificateArgs, originator?: OriginatorDomainNameStringUnder250Bytes) =&gt; Promise&lt;RelinquishCertificateResult&gt;;\n    discoverByIdentityKey: (args: DiscoverByIdentityKeyArgs, originator?: OriginatorDomainNameStringUnder250Bytes) =&gt; Promise&lt;DiscoverCertificatesResult&gt;;\n    discoverByAttributes: (args: DiscoverByAttributesArgs, originator?: OriginatorDomainNameStringUnder250Bytes) =&gt; Promise&lt;DiscoverCertificatesResult&gt;;\n    isAuthenticated: (args: object, originator?: OriginatorDomainNameStringUnder250Bytes) =&gt; Promise&lt;AuthenticatedResult&gt;;\n    waitForAuthentication: (args: object, originator?: OriginatorDomainNameStringUnder250Bytes) =&gt; Promise&lt;AuthenticatedResult&gt;;\n    getHeight: (args: object, originator?: OriginatorDomainNameStringUnder250Bytes) =&gt; Promise&lt;GetHeightResult&gt;;\n    getHeaderForHeight: (args: GetHeaderArgs, originator?: OriginatorDomainNameStringUnder250Bytes) =&gt; Promise&lt;GetHeaderResult&gt;;\n    getNetwork: (args: object, originator?: OriginatorDomainNameStringUnder250Bytes) =&gt; Promise&lt;GetNetworkResult&gt;;\n    getVersion: (args: object, originator?: OriginatorDomainNameStringUnder250Bytes) =&gt; Promise&lt;GetVersionResult&gt;;\n}\n</code></pre> <p>See also: AbortActionArgs, AbortActionResult, AcquireCertificateArgs, AuthenticatedResult, CreateActionArgs, CreateActionResult, CreateHmacArgs, CreateHmacResult, CreateSignatureArgs, CreateSignatureResult, DiscoverByAttributesArgs, DiscoverByIdentityKeyArgs, DiscoverCertificatesResult, GetHeaderArgs, GetHeaderResult, GetHeightResult, GetNetworkResult, GetPublicKeyArgs, GetPublicKeyResult, GetVersionResult, InternalizeActionArgs, InternalizeActionResult, ListActionsArgs, ListActionsResult, ListCertificatesArgs, ListCertificatesResult, ListOutputsArgs, ListOutputsResult, OriginatorDomainNameStringUnder250Bytes, ProveCertificateArgs, ProveCertificateResult, RelinquishCertificateArgs, RelinquishCertificateResult, RelinquishOutputArgs, RelinquishOutputResult, RevealCounterpartyKeyLinkageArgs, RevealCounterpartyKeyLinkageResult, RevealSpecificKeyLinkageArgs, RevealSpecificKeyLinkageResult, SignActionArgs, SignActionResult, VerifyHmacArgs, VerifyHmacResult, VerifySignatureArgs, VerifySignatureResult, WalletCertificate, WalletDecryptArgs, WalletDecryptResult, WalletEncryptArgs, WalletEncryptResult, decrypt, encrypt</p>"},{"location":"reference/wallet/#property-abortaction","title":"Property abortAction","text":"<p>Aborts a transaction that is in progress and has not yet been finalized or sent to the network.</p> <p><pre><code>abortAction: (args: AbortActionArgs, originator?: OriginatorDomainNameStringUnder250Bytes) =&gt; Promise&lt;AbortActionResult&gt;\n</code></pre> See also: AbortActionArgs, AbortActionResult, OriginatorDomainNameStringUnder250Bytes</p>"},{"location":"reference/wallet/#property-acquirecertificate","title":"Property acquireCertificate","text":"<p>Acquires an identity certificate, whether by acquiring one from the certifier or by directly receiving it.</p> <p><pre><code>acquireCertificate: (args: AcquireCertificateArgs, originator?: OriginatorDomainNameStringUnder250Bytes) =&gt; Promise&lt;WalletCertificate&gt;\n</code></pre> See also: AcquireCertificateArgs, OriginatorDomainNameStringUnder250Bytes, WalletCertificate</p>"},{"location":"reference/wallet/#property-createaction","title":"Property createAction","text":"<p>Creates a new Bitcoin transaction based on the provided inputs, outputs, labels, locks, and other options.</p> <p><pre><code>createAction: (args: CreateActionArgs, originator?: OriginatorDomainNameStringUnder250Bytes) =&gt; Promise&lt;CreateActionResult&gt;\n</code></pre> See also: CreateActionArgs, CreateActionResult, OriginatorDomainNameStringUnder250Bytes</p>"},{"location":"reference/wallet/#property-createhmac","title":"Property createHmac","text":"<p>Creates an HMAC (Hash-based Message Authentication Code) based on the provided data, protocol, key ID, counterparty, and other factors.</p> <p><pre><code>createHmac: (args: CreateHmacArgs, originator?: OriginatorDomainNameStringUnder250Bytes) =&gt; Promise&lt;CreateHmacResult&gt;\n</code></pre> See also: CreateHmacArgs, CreateHmacResult, OriginatorDomainNameStringUnder250Bytes</p>"},{"location":"reference/wallet/#property-createsignature","title":"Property createSignature","text":"<p>Creates a digital signature for the provided data or hash using a specific protocol, key, and optionally considering privilege and counterparty.</p> <p><pre><code>createSignature: (args: CreateSignatureArgs, originator?: OriginatorDomainNameStringUnder250Bytes) =&gt; Promise&lt;CreateSignatureResult&gt;\n</code></pre> See also: CreateSignatureArgs, CreateSignatureResult, OriginatorDomainNameStringUnder250Bytes</p>"},{"location":"reference/wallet/#property-decrypt","title":"Property decrypt","text":"<p>Decrypts the provided ciphertext using derived keys, based on the protocol ID, key ID, counterparty, and other factors.</p> <p><pre><code>decrypt: (args: WalletDecryptArgs, originator?: OriginatorDomainNameStringUnder250Bytes) =&gt; Promise&lt;WalletDecryptResult&gt;\n</code></pre> See also: OriginatorDomainNameStringUnder250Bytes, WalletDecryptArgs, WalletDecryptResult</p>"},{"location":"reference/wallet/#property-discoverbyattributes","title":"Property discoverByAttributes","text":"<p>Discovers identity certificates belonging to other users, where the documents contain specific attributes, issued by a trusted entity.</p> <p><pre><code>discoverByAttributes: (args: DiscoverByAttributesArgs, originator?: OriginatorDomainNameStringUnder250Bytes) =&gt; Promise&lt;DiscoverCertificatesResult&gt;\n</code></pre> See also: DiscoverByAttributesArgs, DiscoverCertificatesResult, OriginatorDomainNameStringUnder250Bytes</p>"},{"location":"reference/wallet/#property-discoverbyidentitykey","title":"Property discoverByIdentityKey","text":"<p>Discovers identity certificates, issued to a given identity key by a trusted entity.</p> <p><pre><code>discoverByIdentityKey: (args: DiscoverByIdentityKeyArgs, originator?: OriginatorDomainNameStringUnder250Bytes) =&gt; Promise&lt;DiscoverCertificatesResult&gt;\n</code></pre> See also: DiscoverByIdentityKeyArgs, DiscoverCertificatesResult, OriginatorDomainNameStringUnder250Bytes</p>"},{"location":"reference/wallet/#property-encrypt","title":"Property encrypt","text":"<p>Encrypts the provided plaintext data using derived keys, based on the protocol ID, key ID, counterparty, and other factors.</p> <p><pre><code>encrypt: (args: WalletEncryptArgs, originator?: OriginatorDomainNameStringUnder250Bytes) =&gt; Promise&lt;WalletEncryptResult&gt;\n</code></pre> See also: OriginatorDomainNameStringUnder250Bytes, WalletEncryptArgs, WalletEncryptResult</p>"},{"location":"reference/wallet/#property-getheaderforheight","title":"Property getHeaderForHeight","text":"<p>Retrieves the block header of a block at a specified height.</p> <p><pre><code>getHeaderForHeight: (args: GetHeaderArgs, originator?: OriginatorDomainNameStringUnder250Bytes) =&gt; Promise&lt;GetHeaderResult&gt;\n</code></pre> See also: GetHeaderArgs, GetHeaderResult, OriginatorDomainNameStringUnder250Bytes</p>"},{"location":"reference/wallet/#property-getheight","title":"Property getHeight","text":"<p>Retrieves the current height of the blockchain.</p> <p><pre><code>getHeight: (args: object, originator?: OriginatorDomainNameStringUnder250Bytes) =&gt; Promise&lt;GetHeightResult&gt;\n</code></pre> See also: GetHeightResult, OriginatorDomainNameStringUnder250Bytes</p>"},{"location":"reference/wallet/#property-getnetwork","title":"Property getNetwork","text":"<p>Retrieves the Bitcoin network the client is using (mainnet or testnet).</p> <p><pre><code>getNetwork: (args: object, originator?: OriginatorDomainNameStringUnder250Bytes) =&gt; Promise&lt;GetNetworkResult&gt;\n</code></pre> See also: GetNetworkResult, OriginatorDomainNameStringUnder250Bytes</p>"},{"location":"reference/wallet/#property-getpublickey","title":"Property getPublicKey","text":"<p>Retrieves a derived or identity public key based on the requested protocol, key ID, counterparty, and other factors.</p> <p><pre><code>getPublicKey: (args: GetPublicKeyArgs, originator?: OriginatorDomainNameStringUnder250Bytes) =&gt; Promise&lt;GetPublicKeyResult&gt;\n</code></pre> See also: GetPublicKeyArgs, GetPublicKeyResult, OriginatorDomainNameStringUnder250Bytes</p>"},{"location":"reference/wallet/#property-getversion","title":"Property getVersion","text":"<p>Retrieves the current version string of the wallet.</p> <p><pre><code>getVersion: (args: object, originator?: OriginatorDomainNameStringUnder250Bytes) =&gt; Promise&lt;GetVersionResult&gt;\n</code></pre> See also: GetVersionResult, OriginatorDomainNameStringUnder250Bytes</p>"},{"location":"reference/wallet/#property-internalizeaction","title":"Property internalizeAction","text":"<p>Submits a transaction to be internalized and optionally labeled, outputs paid to the wallet balance, inserted into baskets, and/or tagged.</p> <p><pre><code>internalizeAction: (args: InternalizeActionArgs, originator?: OriginatorDomainNameStringUnder250Bytes) =&gt; Promise&lt;InternalizeActionResult&gt;\n</code></pre> See also: InternalizeActionArgs, InternalizeActionResult, OriginatorDomainNameStringUnder250Bytes</p>"},{"location":"reference/wallet/#property-isauthenticated","title":"Property isAuthenticated","text":"<p>Checks the authentication status of the user.</p> <p><pre><code>isAuthenticated: (args: object, originator?: OriginatorDomainNameStringUnder250Bytes) =&gt; Promise&lt;AuthenticatedResult&gt;\n</code></pre> See also: AuthenticatedResult, OriginatorDomainNameStringUnder250Bytes</p>"},{"location":"reference/wallet/#property-listactions","title":"Property listActions","text":"<p>Lists all transactions matching the specified labels.</p> <p><pre><code>listActions: (args: ListActionsArgs, originator?: OriginatorDomainNameStringUnder250Bytes) =&gt; Promise&lt;ListActionsResult&gt;\n</code></pre> See also: ListActionsArgs, ListActionsResult, OriginatorDomainNameStringUnder250Bytes</p>"},{"location":"reference/wallet/#property-listcertificates","title":"Property listCertificates","text":"<p>Lists identity certificates belonging to the user, filtered by certifier(s) and type(s).</p> <p><pre><code>listCertificates: (args: ListCertificatesArgs, originator?: OriginatorDomainNameStringUnder250Bytes) =&gt; Promise&lt;ListCertificatesResult&gt;\n</code></pre> See also: ListCertificatesArgs, ListCertificatesResult, OriginatorDomainNameStringUnder250Bytes</p>"},{"location":"reference/wallet/#property-listoutputs","title":"Property listOutputs","text":"<p>Lists the spendable outputs kept within a specific basket, optionally tagged with specific labels.</p> <p><pre><code>listOutputs: (args: ListOutputsArgs, originator?: OriginatorDomainNameStringUnder250Bytes) =&gt; Promise&lt;ListOutputsResult&gt;\n</code></pre> See also: ListOutputsArgs, ListOutputsResult, OriginatorDomainNameStringUnder250Bytes</p>"},{"location":"reference/wallet/#property-provecertificate","title":"Property proveCertificate","text":"<p>Proves select fields of an identity certificate, as specified, when requested by a verifier.</p> <p><pre><code>proveCertificate: (args: ProveCertificateArgs, originator?: OriginatorDomainNameStringUnder250Bytes) =&gt; Promise&lt;ProveCertificateResult&gt;\n</code></pre> See also: OriginatorDomainNameStringUnder250Bytes, ProveCertificateArgs, ProveCertificateResult</p>"},{"location":"reference/wallet/#property-relinquishcertificate","title":"Property relinquishCertificate","text":"<p>Relinquishes an identity certificate, removing it from the wallet regardless of whether the revocation outpoint has become spent.</p> <p><pre><code>relinquishCertificate: (args: RelinquishCertificateArgs, originator?: OriginatorDomainNameStringUnder250Bytes) =&gt; Promise&lt;RelinquishCertificateResult&gt;\n</code></pre> See also: OriginatorDomainNameStringUnder250Bytes, RelinquishCertificateArgs, RelinquishCertificateResult</p>"},{"location":"reference/wallet/#property-relinquishoutput","title":"Property relinquishOutput","text":"<p>Relinquish an output out of a basket, removing it from tracking without spending it.</p> <p><pre><code>relinquishOutput: (args: RelinquishOutputArgs, originator?: OriginatorDomainNameStringUnder250Bytes) =&gt; Promise&lt;RelinquishOutputResult&gt;\n</code></pre> See also: OriginatorDomainNameStringUnder250Bytes, RelinquishOutputArgs, RelinquishOutputResult</p>"},{"location":"reference/wallet/#property-revealcounterpartykeylinkage","title":"Property revealCounterpartyKeyLinkage","text":"<p>Reveals the key linkage between ourselves and a counterparty, to a particular verifier, across all interactions with the counterparty.</p> <p><pre><code>revealCounterpartyKeyLinkage: (args: RevealCounterpartyKeyLinkageArgs, originator?: OriginatorDomainNameStringUnder250Bytes) =&gt; Promise&lt;RevealCounterpartyKeyLinkageResult&gt;\n</code></pre> See also: OriginatorDomainNameStringUnder250Bytes, RevealCounterpartyKeyLinkageArgs, RevealCounterpartyKeyLinkageResult</p>"},{"location":"reference/wallet/#property-revealspecifickeylinkage","title":"Property revealSpecificKeyLinkage","text":"<p>Reveals the key linkage between ourselves and a counterparty, to a particular verifier, with respect to a specific interaction.</p> <p><pre><code>revealSpecificKeyLinkage: (args: RevealSpecificKeyLinkageArgs, originator?: OriginatorDomainNameStringUnder250Bytes) =&gt; Promise&lt;RevealSpecificKeyLinkageResult&gt;\n</code></pre> See also: OriginatorDomainNameStringUnder250Bytes, RevealSpecificKeyLinkageArgs, RevealSpecificKeyLinkageResult</p>"},{"location":"reference/wallet/#property-signaction","title":"Property signAction","text":"<p>Signs a transaction previously created using <code>createAction</code>.</p> <p><pre><code>signAction: (args: SignActionArgs, originator?: OriginatorDomainNameStringUnder250Bytes) =&gt; Promise&lt;SignActionResult&gt;\n</code></pre> See also: OriginatorDomainNameStringUnder250Bytes, SignActionArgs, SignActionResult</p>"},{"location":"reference/wallet/#property-verifyhmac","title":"Property verifyHmac","text":"<p>Verifies an HMAC (Hash-based Message Authentication Code) based on the provided data, protocol, key ID, counterparty, and other factors.</p> <p><pre><code>verifyHmac: (args: VerifyHmacArgs, originator?: OriginatorDomainNameStringUnder250Bytes) =&gt; Promise&lt;VerifyHmacResult&gt;\n</code></pre> See also: OriginatorDomainNameStringUnder250Bytes, VerifyHmacArgs, VerifyHmacResult</p>"},{"location":"reference/wallet/#property-verifysignature","title":"Property verifySignature","text":"<p>Verifies a digital signature for the provided data or hash using a specific protocol, key, and optionally considering privilege and counterparty.</p> <p><pre><code>verifySignature: (args: VerifySignatureArgs, originator?: OriginatorDomainNameStringUnder250Bytes) =&gt; Promise&lt;VerifySignatureResult&gt;\n</code></pre> See also: OriginatorDomainNameStringUnder250Bytes, VerifySignatureArgs, VerifySignatureResult</p>"},{"location":"reference/wallet/#property-waitforauthentication","title":"Property waitForAuthentication","text":"<p>Continuously waits until the user is authenticated, returning the result once confirmed.</p> <p><pre><code>waitForAuthentication: (args: object, originator?: OriginatorDomainNameStringUnder250Bytes) =&gt; Promise&lt;AuthenticatedResult&gt;\n</code></pre> See also: AuthenticatedResult, OriginatorDomainNameStringUnder250Bytes</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-walletloggerinterface","title":"Interface: WalletLoggerInterface","text":"<p>A console-like interface for logging within wallet operations.</p> <p>Intended to reflect a subset of standard <code>Console</code> interface methods used by <code>Wallet</code></p> <pre><code>export interface WalletLoggerInterface {\n    group: (...label: any[]) =&gt; void;\n    groupEnd: () =&gt; void;\n    log: (message?: any, ...optionalParams: any[]) =&gt; void;\n    error: (message?: any, ...optionalParams: any[]) =&gt; void;\n    flush?: () =&gt; object | undefined;\n    merge?: (log: WalletLoggerInterface) =&gt; void;\n    level?: \"error\" | \"warn\" | \"info\" | \"debug\" | \"trace\";\n    indent?: number;\n    isOrigin?: boolean;\n    isError?: boolean;\n    logs?: WalletLoggerLog[];\n}\n</code></pre> <p>See also: WalletLoggerLog</p>"},{"location":"reference/wallet/#property-error","title":"Property error","text":"<p>Log an error message.</p> <pre><code>error: (message?: any, ...optionalParams: any[]) =&gt; void\n</code></pre>"},{"location":"reference/wallet/#property-flush","title":"Property flush","text":"<p>Loggers may accumulate data instead of immediately handling it.</p> <p>Loggers that do not accumulate should not implement this method.</p> <pre><code>flush?: () =&gt; object | undefined\n</code></pre>"},{"location":"reference/wallet/#property-group","title":"Property group","text":"<p>Increases indentation of subsequent lines.</p> <p>If one or more <code>label</code>s are provided, those are printed first without the additional indentation.</p> <pre><code>group: (...label: any[]) =&gt; void\n</code></pre>"},{"location":"reference/wallet/#property-groupend","title":"Property groupEnd","text":"<p>Decreases indentation of subsequent lines.</p> <pre><code>groupEnd: () =&gt; void\n</code></pre>"},{"location":"reference/wallet/#property-indent","title":"Property indent","text":"<p>Valid if an accumulating logger. Count of <code>group</code> calls without matching <code>groupEnd</code>.</p> <pre><code>indent?: number\n</code></pre>"},{"location":"reference/wallet/#property-iserror","title":"Property isError","text":"<p>True if this is an accumulating logger and an error was logged.</p> <pre><code>isError?: boolean\n</code></pre>"},{"location":"reference/wallet/#property-isorigin","title":"Property isOrigin","text":"<p>True if this is an accumulating logger and the logger belongs to the object servicing the initial request.</p> <pre><code>isOrigin?: boolean\n</code></pre>"},{"location":"reference/wallet/#property-level","title":"Property level","text":"<p>Optional. Logging levels that may influence what is logged.</p> <p>'error' Only requests resulting in an exception should be logged. 'warn' Also log requests that succeed but with an abnormal condition. 'info' Also log normal successful requests. 'debug' Add input parm and result details where possible. 'trace' Instead of adding debug details, focus on execution path and timing.</p> <pre><code>level?: \"error\" | \"warn\" | \"info\" | \"debug\" | \"trace\"\n</code></pre>"},{"location":"reference/wallet/#property-log","title":"Property log","text":"<p>Log a message.</p> <pre><code>log: (message?: any, ...optionalParams: any[]) =&gt; void\n</code></pre>"},{"location":"reference/wallet/#property-logs","title":"Property logs","text":"<p>Optional array of accumulated logged data and errors.</p> <p><pre><code>logs?: WalletLoggerLog[]\n</code></pre> See also: WalletLoggerLog</p>"},{"location":"reference/wallet/#property-merge","title":"Property merge","text":"<p>Merge log data from another logger.</p> <p>Typically used to merge log data from network request.</p> <p><pre><code>merge?: (log: WalletLoggerInterface) =&gt; void\n</code></pre> See also: WalletLoggerInterface</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-walletloggerlog","title":"Interface: WalletLoggerLog","text":"<pre><code>export interface WalletLoggerLog {\n    when: number;\n    indent: number;\n    log: string;\n    isError?: boolean;\n    isBegin?: boolean;\n    isEnd?: boolean;\n}\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-walletoutput","title":"Interface: WalletOutput","text":"<pre><code>export interface WalletOutput {\n    satoshis: SatoshiValue;\n    lockingScript?: HexString;\n    spendable: boolean;\n    customInstructions?: string;\n    tags?: OutputTagStringUnder300Bytes[];\n    outpoint: OutpointString;\n    labels?: LabelStringUnder300Bytes[];\n}\n</code></pre> <p>See also: HexString, LabelStringUnder300Bytes, OutpointString, OutputTagStringUnder300Bytes, SatoshiValue</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-walletpayment","title":"Interface: WalletPayment","text":"<pre><code>export interface WalletPayment {\n    derivationPrefix: Base64String;\n    derivationSuffix: Base64String;\n    senderIdentityKey: PubKeyHex;\n}\n</code></pre> <p>See also: Base64String, PubKeyHex</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#interface-walletwire","title":"Interface: WalletWire","text":"<p>A Wallet Wire is an abstraction over a raw transport medium where binary data can be sent to and subsequently received from a wallet.</p> <pre><code>export default interface WalletWire {\n    transmitToWallet: (message: number[]) =&gt; Promise&lt;number[]&gt;;\n}\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#classes","title":"Classes","text":"CachedKeyDeriver WERR_REVIEW_ACTIONS HTTPWalletJSON WalletClient HTTPWalletWire WalletError KeyDeriver WalletWireProcessor ProtoWallet WalletWireTransceiver ReactNativeWebView WindowCWISubstrate WERR_INSUFFICIENT_FUNDS XDMSubstrate WERR_INVALID_PARAMETER <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#class-cachedkeyderiver","title":"Class: CachedKeyDeriver","text":"<p>A cached version of KeyDeriver that caches the results of key derivation methods. This is useful for optimizing performance when the same keys are derived multiple times. It supports configurable cache size with sane defaults and maintains cache entries using LRU (Least Recently Used) eviction policy.</p> <pre><code>export default class CachedKeyDeriver implements KeyDeriverApi {\n    rootKey: PrivateKey;\n    identityKey: string;\n    constructor(rootKey: PrivateKey | \"anyone\", options?: {\n        maxCacheSize?: number;\n    }) \n    derivePublicKey(protocolID: WalletProtocol, keyID: string, counterparty: Counterparty, forSelf: boolean = false): PublicKey \n    derivePrivateKey(protocolID: WalletProtocol, keyID: string, counterparty: Counterparty): PrivateKey \n    deriveSymmetricKey(protocolID: WalletProtocol, keyID: string, counterparty: Counterparty): SymmetricKey \n    revealCounterpartySecret(counterparty: Counterparty): number[] \n    revealSpecificSecret(counterparty: Counterparty, protocolID: WalletProtocol, keyID: string): number[] \n}\n</code></pre> <p>See also: Counterparty, KeyDeriverApi, PrivateKey, PublicKey, SymmetricKey, WalletProtocol</p>"},{"location":"reference/wallet/#constructor","title":"Constructor","text":"<p>Initializes the CachedKeyDeriver instance with a root private key and optional cache settings.</p> <p><pre><code>constructor(rootKey: PrivateKey | \"anyone\", options?: {\n    maxCacheSize?: number;\n}) \n</code></pre> See also: PrivateKey</p> <p>Argument Details</p> <ul> <li>rootKey</li> <li>The root private key or the string 'anyone'.</li> <li>options</li> <li>Optional settings for the cache.</li> </ul>"},{"location":"reference/wallet/#property-identitykey_1","title":"Property identityKey","text":"<p>The identity of this key deriver which is normally the public key associated with the <code>rootKey</code></p> <pre><code>identityKey: string\n</code></pre>"},{"location":"reference/wallet/#property-rootkey_1","title":"Property rootKey","text":"<p>The root key from which all other keys are derived.</p> <p><pre><code>rootKey: PrivateKey\n</code></pre> See also: PrivateKey</p>"},{"location":"reference/wallet/#method-deriveprivatekey","title":"Method derivePrivateKey","text":"<p>Derives a private key based on protocol ID, key ID, and counterparty. Caches the result for future calls with the same parameters.</p> <p><pre><code>derivePrivateKey(protocolID: WalletProtocol, keyID: string, counterparty: Counterparty): PrivateKey \n</code></pre> See also: Counterparty, PrivateKey, WalletProtocol</p> <p>Returns</p> <ul> <li>The derived private key.</li> </ul> <p>Argument Details</p> <ul> <li>protocolID</li> <li>The protocol ID including a security level and protocol name.</li> <li>keyID</li> <li>The key identifier.</li> <li>counterparty</li> <li>The counterparty's public key or a predefined value ('self' or 'anyone').</li> </ul>"},{"location":"reference/wallet/#method-derivepublickey","title":"Method derivePublicKey","text":"<p>Derives a public key based on protocol ID, key ID, and counterparty. Caches the result for future calls with the same parameters.</p> <p><pre><code>derivePublicKey(protocolID: WalletProtocol, keyID: string, counterparty: Counterparty, forSelf: boolean = false): PublicKey \n</code></pre> See also: Counterparty, PublicKey, WalletProtocol</p> <p>Returns</p> <ul> <li>The derived public key.</li> </ul> <p>Argument Details</p> <ul> <li>protocolID</li> <li>The protocol ID including a security level and protocol name.</li> <li>keyID</li> <li>The key identifier.</li> <li>counterparty</li> <li>The counterparty's public key or a predefined value ('self' or 'anyone').</li> <li>forSelf</li> <li>Whether deriving for self.</li> </ul>"},{"location":"reference/wallet/#method-derivesymmetrickey","title":"Method deriveSymmetricKey","text":"<p>Derives a symmetric key based on protocol ID, key ID, and counterparty. Caches the result for future calls with the same parameters.</p> <p><pre><code>deriveSymmetricKey(protocolID: WalletProtocol, keyID: string, counterparty: Counterparty): SymmetricKey \n</code></pre> See also: Counterparty, SymmetricKey, WalletProtocol</p> <p>Returns</p> <ul> <li>The derived symmetric key.</li> </ul> <p>Argument Details</p> <ul> <li>protocolID</li> <li>The protocol ID including a security level and protocol name.</li> <li>keyID</li> <li>The key identifier.</li> <li>counterparty</li> <li>The counterparty's public key or a predefined value ('self' or 'anyone').</li> </ul> <p>Throws</p> <ul> <li>Throws an error if attempting to derive a symmetric key for 'anyone'.</li> </ul>"},{"location":"reference/wallet/#method-revealcounterpartysecret","title":"Method revealCounterpartySecret","text":"<p>Reveals the shared secret between the root key and the counterparty. Caches the result for future calls with the same parameters.</p> <p><pre><code>revealCounterpartySecret(counterparty: Counterparty): number[] \n</code></pre> See also: Counterparty</p> <p>Returns</p> <ul> <li>The shared secret as a number array.</li> </ul> <p>Argument Details</p> <ul> <li>counterparty</li> <li>The counterparty's public key or a predefined value ('self' or 'anyone').</li> </ul> <p>Throws</p> <ul> <li>Throws an error if attempting to reveal a shared secret for 'self'.</li> </ul>"},{"location":"reference/wallet/#method-revealspecificsecret","title":"Method revealSpecificSecret","text":"<p>Reveals the specific key association for a given protocol ID, key ID, and counterparty. Caches the result for future calls with the same parameters.</p> <p><pre><code>revealSpecificSecret(counterparty: Counterparty, protocolID: WalletProtocol, keyID: string): number[] \n</code></pre> See also: Counterparty, WalletProtocol</p> <p>Returns</p> <ul> <li>The specific key association as a number array.</li> </ul> <p>Argument Details</p> <ul> <li>counterparty</li> <li>The counterparty's public key or a predefined value ('self' or 'anyone').</li> <li>protocolID</li> <li>The protocol ID including a security level and protocol name.</li> <li>keyID</li> <li>The key identifier.</li> </ul> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#class-httpwalletjson","title":"Class: HTTPWalletJSON","text":"<pre><code>export default class HTTPWalletJSON implements WalletInterface {\n    baseUrl: string;\n    httpClient: typeof fetch;\n    originator: OriginatorDomainNameStringUnder250Bytes | undefined;\n    api: (call: string, args: object) =&gt; Promise&lt;unknown&gt;;\n    constructor(originator: OriginatorDomainNameStringUnder250Bytes | undefined, baseUrl: string = \"http://localhost:3321\", httpClient = fetch) \n    async createAction(args: CreateActionArgs): Promise&lt;CreateActionResult&gt; \n    async signAction(args: SignActionArgs): Promise&lt;SignActionResult&gt; \n    async abortAction(args: {\n        reference: Base64String;\n    }): Promise&lt;{\n        aborted: true;\n    }&gt; \n    async listActions(args: ListActionsArgs): Promise&lt;ListActionsResult&gt; \n    async internalizeAction(args: InternalizeActionArgs): Promise&lt;{\n        accepted: true;\n    }&gt; \n    async listOutputs(args: ListOutputsArgs): Promise&lt;ListOutputsResult&gt; \n    async relinquishOutput(args: {\n        basket: BasketStringUnder300Bytes;\n        output: OutpointString;\n    }): Promise&lt;{\n        relinquished: true;\n    }&gt; \n    async getPublicKey(args: {\n        seekPermission?: BooleanDefaultTrue;\n        identityKey?: true;\n        protocolID?: [\n            SecurityLevel,\n            ProtocolString5To400Bytes\n        ];\n        keyID?: KeyIDStringUnder800Bytes;\n        privileged?: BooleanDefaultFalse;\n        privilegedReason?: DescriptionString5to50Bytes;\n        counterparty?: PubKeyHex | \"self\" | \"anyone\";\n        forSelf?: BooleanDefaultFalse;\n    }): Promise&lt;{\n        publicKey: PubKeyHex;\n    }&gt; \n    async revealCounterpartyKeyLinkage(args: {\n        counterparty: PubKeyHex;\n        verifier: PubKeyHex;\n        privilegedReason?: DescriptionString5to50Bytes;\n        privileged?: BooleanDefaultFalse;\n    }): Promise&lt;{\n        prover: PubKeyHex;\n        verifier: PubKeyHex;\n        counterparty: PubKeyHex;\n        revelationTime: ISOTimestampString;\n        encryptedLinkage: Byte[];\n        encryptedLinkageProof: number[];\n    }&gt; \n    async revealSpecificKeyLinkage(args: {\n        counterparty: PubKeyHex;\n        verifier: PubKeyHex;\n        protocolID: [\n            SecurityLevel,\n            ProtocolString5To400Bytes\n        ];\n        keyID: KeyIDStringUnder800Bytes;\n        privilegedReason?: DescriptionString5to50Bytes;\n        privileged?: BooleanDefaultFalse;\n    }): Promise&lt;{\n        prover: PubKeyHex;\n        verifier: PubKeyHex;\n        counterparty: PubKeyHex;\n        protocolID: [\n            SecurityLevel,\n            ProtocolString5To400Bytes\n        ];\n        keyID: KeyIDStringUnder800Bytes;\n        encryptedLinkage: Byte[];\n        encryptedLinkageProof: Byte[];\n        proofType: Byte;\n    }&gt; \n    async encrypt(args: {\n        seekPermission?: BooleanDefaultTrue;\n        plaintext: Byte[];\n        protocolID: [\n            SecurityLevel,\n            ProtocolString5To400Bytes\n        ];\n        keyID: KeyIDStringUnder800Bytes;\n        privilegedReason?: DescriptionString5to50Bytes;\n        counterparty?: PubKeyHex | \"self\" | \"anyone\";\n        privileged?: BooleanDefaultFalse;\n    }): Promise&lt;{\n        ciphertext: Byte[];\n    }&gt; \n    async decrypt(args: {\n        seekPermission?: BooleanDefaultTrue;\n        ciphertext: Byte[];\n        protocolID: [\n            SecurityLevel,\n            ProtocolString5To400Bytes\n        ];\n        keyID: KeyIDStringUnder800Bytes;\n        privilegedReason?: DescriptionString5to50Bytes;\n        counterparty?: PubKeyHex | \"self\" | \"anyone\";\n        privileged?: BooleanDefaultFalse;\n    }): Promise&lt;{\n        plaintext: Byte[];\n    }&gt; \n    async createHmac(args: {\n        seekPermission?: BooleanDefaultTrue;\n        data: Byte[];\n        protocolID: [\n            SecurityLevel,\n            ProtocolString5To400Bytes\n        ];\n        keyID: KeyIDStringUnder800Bytes;\n        privilegedReason?: DescriptionString5to50Bytes;\n        counterparty?: PubKeyHex | \"self\" | \"anyone\";\n        privileged?: BooleanDefaultFalse;\n    }): Promise&lt;{\n        hmac: Byte[];\n    }&gt; \n    async verifyHmac(args: {\n        seekPermission?: BooleanDefaultTrue;\n        data: Byte[];\n        hmac: Byte[];\n        protocolID: [\n            SecurityLevel,\n            ProtocolString5To400Bytes\n        ];\n        keyID: KeyIDStringUnder800Bytes;\n        privilegedReason?: DescriptionString5to50Bytes;\n        counterparty?: PubKeyHex | \"self\" | \"anyone\";\n        privileged?: BooleanDefaultFalse;\n    }): Promise&lt;{\n        valid: true;\n    }&gt; \n    async createSignature(args: {\n        seekPermission?: BooleanDefaultTrue;\n        data?: Byte[];\n        hashToDirectlySign?: Byte[];\n        protocolID: [\n            SecurityLevel,\n            ProtocolString5To400Bytes\n        ];\n        keyID: KeyIDStringUnder800Bytes;\n        privilegedReason?: DescriptionString5to50Bytes;\n        counterparty?: PubKeyHex | \"self\" | \"anyone\";\n        privileged?: BooleanDefaultFalse;\n    }): Promise&lt;{\n        signature: Byte[];\n    }&gt; \n    async verifySignature(args: {\n        seekPermission?: BooleanDefaultTrue;\n        data?: Byte[];\n        hashToDirectlyVerify?: Byte[];\n        signature: Byte[];\n        protocolID: [\n            SecurityLevel,\n            ProtocolString5To400Bytes\n        ];\n        keyID: KeyIDStringUnder800Bytes;\n        privilegedReason?: DescriptionString5to50Bytes;\n        counterparty?: PubKeyHex | \"self\" | \"anyone\";\n        forSelf?: BooleanDefaultFalse;\n        privileged?: BooleanDefaultFalse;\n    }): Promise&lt;{\n        valid: true;\n    }&gt; \n    async acquireCertificate(args: AcquireCertificateArgs): Promise&lt;AcquireCertificateResult&gt; \n    async listCertificates(args: {\n        certifiers: PubKeyHex[];\n        types: Base64String[];\n        limit?: PositiveIntegerDefault10Max10000;\n        offset?: PositiveIntegerOrZero;\n        privileged?: BooleanDefaultFalse;\n        privilegedReason?: DescriptionString5to50Bytes;\n    }): Promise&lt;ListCertificatesResult&gt; \n    async proveCertificate(args: ProveCertificateArgs): Promise&lt;ProveCertificateResult&gt; \n    async relinquishCertificate(args: {\n        type: Base64String;\n        serialNumber: Base64String;\n        certifier: PubKeyHex;\n    }): Promise&lt;{\n        relinquished: true;\n    }&gt; \n    async discoverByIdentityKey(args: {\n        seekPermission?: BooleanDefaultTrue;\n        identityKey: PubKeyHex;\n        limit?: PositiveIntegerDefault10Max10000;\n        offset?: PositiveIntegerOrZero;\n    }): Promise&lt;DiscoverCertificatesResult&gt; \n    async discoverByAttributes(args: {\n        seekPermission?: BooleanDefaultTrue;\n        attributes: Record&lt;CertificateFieldNameUnder50Bytes, string&gt;;\n        limit?: PositiveIntegerDefault10Max10000;\n        offset?: PositiveIntegerOrZero;\n    }): Promise&lt;DiscoverCertificatesResult&gt; \n    async isAuthenticated(args: object): Promise&lt;{\n        authenticated: true;\n    }&gt; \n    async waitForAuthentication(args: object): Promise&lt;{\n        authenticated: true;\n    }&gt; \n    async getHeight(args: object): Promise&lt;{\n        height: PositiveInteger;\n    }&gt; \n    async getHeaderForHeight(args: {\n        height: PositiveInteger;\n    }): Promise&lt;{\n        header: HexString;\n    }&gt; \n    async getNetwork(args: object): Promise&lt;{\n        network: \"mainnet\" | \"testnet\";\n    }&gt; \n    async getVersion(args: object): Promise&lt;{\n        version: VersionString7To30Bytes;\n    }&gt; \n}\n</code></pre> <p>See also: AcquireCertificateArgs, AcquireCertificateResult, Base64String, BasketStringUnder300Bytes, BooleanDefaultFalse, BooleanDefaultTrue, Byte, CertificateFieldNameUnder50Bytes, CreateActionArgs, CreateActionResult, DescriptionString5to50Bytes, DiscoverCertificatesResult, HexString, ISOTimestampString, InternalizeActionArgs, KeyIDStringUnder800Bytes, ListActionsArgs, ListActionsResult, ListCertificatesResult, ListOutputsArgs, ListOutputsResult, OriginatorDomainNameStringUnder250Bytes, OutpointString, PositiveInteger, PositiveIntegerDefault10Max10000, PositiveIntegerOrZero, ProtocolString5To400Bytes, ProveCertificateArgs, ProveCertificateResult, PubKeyHex, SecurityLevel, SignActionArgs, SignActionResult, VersionString7To30Bytes, WalletInterface, decrypt, encrypt</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#class-httpwalletwire","title":"Class: HTTPWalletWire","text":"<pre><code>export default class HTTPWalletWire implements WalletWire {\n    baseUrl: string;\n    httpClient: typeof fetch;\n    originator: string | undefined;\n    constructor(originator: string | undefined, baseUrl: string = \"http://localhost:3301\", httpClient = fetch) \n    async transmitToWallet(message: number[]): Promise&lt;number[]&gt; \n}\n</code></pre> <p>See also: WalletWire</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#class-keyderiver","title":"Class: KeyDeriver","text":"<p>Class responsible for deriving various types of keys using a root private key. It supports deriving public and private keys, symmetric keys, and revealing key linkages.</p> <pre><code>export class KeyDeriver implements KeyDeriverApi {\n    rootKey: PrivateKey;\n    identityKey: string;\n    constructor(rootKey: PrivateKey | \"anyone\", private readonly cacheSharedSecret?: ((priv: PrivateKey, pub: Point, point: Point) =&gt; void), private readonly retrieveCachedSharedSecret?: ((priv: PrivateKey, pub: Point) =&gt; (Point | undefined))) \n    derivePublicKey(protocolID: WalletProtocol, keyID: string, counterparty: Counterparty, forSelf: boolean = false): PublicKey \n    derivePrivateKey(protocolID: WalletProtocol, keyID: string, counterparty: Counterparty): PrivateKey \n    deriveSymmetricKey(protocolID: WalletProtocol, keyID: string, counterparty: Counterparty): SymmetricKey \n    revealCounterpartySecret(counterparty: Counterparty): number[] \n    revealSpecificSecret(counterparty: Counterparty, protocolID: WalletProtocol, keyID: string): number[] \n}\n</code></pre> <p>See also: Counterparty, KeyDeriverApi, Point, PrivateKey, PublicKey, SymmetricKey, WalletProtocol</p>"},{"location":"reference/wallet/#constructor_1","title":"Constructor","text":"<p>Initializes the KeyDeriver instance with a root private key.</p> <p><pre><code>constructor(rootKey: PrivateKey | \"anyone\", private readonly cacheSharedSecret?: ((priv: PrivateKey, pub: Point, point: Point) =&gt; void), private readonly retrieveCachedSharedSecret?: ((priv: PrivateKey, pub: Point) =&gt; (Point | undefined))) \n</code></pre> See also: Point, PrivateKey</p> <p>Argument Details</p> <ul> <li>rootKey</li> <li>The root private key or the string 'anyone'.</li> </ul>"},{"location":"reference/wallet/#method-deriveprivatekey_1","title":"Method derivePrivateKey","text":"<p>Derives a private key based on protocol ID, key ID, and counterparty.</p> <p><pre><code>derivePrivateKey(protocolID: WalletProtocol, keyID: string, counterparty: Counterparty): PrivateKey \n</code></pre> See also: Counterparty, PrivateKey, WalletProtocol</p> <p>Returns</p> <ul> <li>The derived private key.</li> </ul> <p>Argument Details</p> <ul> <li>protocolID</li> <li>The protocol ID including a security level and protocol name.</li> <li>keyID</li> <li>The key identifier.</li> <li>counterparty</li> <li>The counterparty's public key or a predefined value ('self' or 'anyone').</li> </ul>"},{"location":"reference/wallet/#method-derivepublickey_1","title":"Method derivePublicKey","text":"<p>Derives a public key based on protocol ID, key ID, and counterparty.</p> <p><pre><code>derivePublicKey(protocolID: WalletProtocol, keyID: string, counterparty: Counterparty, forSelf: boolean = false): PublicKey \n</code></pre> See also: Counterparty, PublicKey, WalletProtocol</p> <p>Returns</p> <ul> <li>The derived public key.</li> </ul> <p>Argument Details</p> <ul> <li>protocolID</li> <li>The protocol ID including a security level and protocol name.</li> <li>keyID</li> <li>The key identifier.</li> <li>counterparty</li> <li>The counterparty's public key or a predefined value ('self' or 'anyone').</li> <li>forSelf</li> <li>Whether deriving for self.</li> </ul>"},{"location":"reference/wallet/#method-derivesymmetrickey_1","title":"Method deriveSymmetricKey","text":"<p>Derives a symmetric key based on protocol ID, key ID, and counterparty. Note: Symmetric keys should not be derivable by everyone due to security risks.</p> <p><pre><code>deriveSymmetricKey(protocolID: WalletProtocol, keyID: string, counterparty: Counterparty): SymmetricKey \n</code></pre> See also: Counterparty, SymmetricKey, WalletProtocol</p> <p>Returns</p> <ul> <li>The derived symmetric key.</li> </ul> <p>Argument Details</p> <ul> <li>protocolID</li> <li>The protocol ID including a security level and protocol name.</li> <li>keyID</li> <li>The key identifier.</li> <li>counterparty</li> <li>The counterparty's public key or a predefined value ('self' or 'anyone').</li> </ul>"},{"location":"reference/wallet/#method-revealcounterpartysecret_1","title":"Method revealCounterpartySecret","text":"<p>Reveals the shared secret between the root key and the counterparty. Note: This should not be used for 'self'.</p> <p><pre><code>revealCounterpartySecret(counterparty: Counterparty): number[] \n</code></pre> See also: Counterparty</p> <p>Returns</p> <ul> <li>The shared secret as a number array.</li> </ul> <p>Argument Details</p> <ul> <li>counterparty</li> <li>The counterparty's public key or a predefined value ('self' or 'anyone').</li> </ul> <p>Throws</p> <ul> <li>Throws an error if attempting to reveal a shared secret for 'self'.</li> </ul>"},{"location":"reference/wallet/#method-revealspecificsecret_1","title":"Method revealSpecificSecret","text":"<p>Reveals the specific key association for a given protocol ID, key ID, and counterparty.</p> <p><pre><code>revealSpecificSecret(counterparty: Counterparty, protocolID: WalletProtocol, keyID: string): number[] \n</code></pre> See also: Counterparty, WalletProtocol</p> <p>Returns</p> <ul> <li>The specific key association as a number array.</li> </ul> <p>Argument Details</p> <ul> <li>counterparty</li> <li>The counterparty's public key or a predefined value ('self' or 'anyone').</li> <li>protocolID</li> <li>The protocol ID including a security level and protocol name.</li> <li>keyID</li> <li>The key identifier.</li> </ul> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#class-protowallet","title":"Class: ProtoWallet","text":"<p>A ProtoWallet is precursor to a full wallet, capable of performing all foundational cryptographic operations. It can derive keys, create signatures, facilitate encryption and HMAC operations, and reveal key linkages.</p> <p>However, ProtoWallet does not create transactions, manage outputs, interact with the blockchain, enable the management of identity certificates, or store any data. It is also not concerned with privileged keys.</p> <pre><code>export class ProtoWallet {\n    keyDeriver?: KeyDeriverApi;\n    constructor(rootKeyOrKeyDeriver?: PrivateKey | \"anyone\" | KeyDeriverApi) \n    async getPublicKey(args: GetPublicKeyArgs): Promise&lt;{\n        publicKey: PubKeyHex;\n    }&gt; \n    async revealCounterpartyKeyLinkage(args: RevealCounterpartyKeyLinkageArgs): Promise&lt;RevealCounterpartyKeyLinkageResult&gt; \n    async revealSpecificKeyLinkage(args: RevealSpecificKeyLinkageArgs): Promise&lt;RevealSpecificKeyLinkageResult&gt; \n    async encrypt(args: WalletEncryptArgs): Promise&lt;WalletEncryptResult&gt; \n    async decrypt(args: WalletDecryptArgs, originator?: string): Promise&lt;WalletDecryptResult&gt; \n    async createHmac(args: CreateHmacArgs): Promise&lt;CreateHmacResult&gt; \n    async verifyHmac(args: VerifyHmacArgs): Promise&lt;VerifyHmacResult&gt; \n    async createSignature(args: CreateSignatureArgs): Promise&lt;CreateSignatureResult&gt; \n    async verifySignature(args: VerifySignatureArgs): Promise&lt;VerifySignatureResult&gt; \n}\n</code></pre> <p>See also: CreateHmacArgs, CreateHmacResult, CreateSignatureArgs, CreateSignatureResult, GetPublicKeyArgs, KeyDeriverApi, PrivateKey, PubKeyHex, RevealCounterpartyKeyLinkageArgs, RevealCounterpartyKeyLinkageResult, RevealSpecificKeyLinkageArgs, RevealSpecificKeyLinkageResult, VerifyHmacArgs, VerifyHmacResult, VerifySignatureArgs, VerifySignatureResult, WalletDecryptArgs, WalletDecryptResult, WalletEncryptArgs, WalletEncryptResult, decrypt, encrypt</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#class-reactnativewebview","title":"Class: ReactNativeWebView","text":"<p>Facilitates wallet operations over cross-document messaging.</p> <pre><code>export default class ReactNativeWebView implements WalletInterface {\n    constructor(domain: string = \"*\") \n    async invoke(call: CallType, args: any): Promise&lt;any&gt; \n    async createAction(args: {\n        description: DescriptionString5to50Bytes;\n        inputs?: Array&lt;{\n            tx?: BEEF;\n            outpoint: OutpointString;\n            unlockingScript?: HexString;\n            unlockingScriptLength?: PositiveInteger;\n            inputDescription: DescriptionString5to50Bytes;\n            sequenceNumber?: PositiveIntegerOrZero;\n        }&gt;;\n        outputs?: Array&lt;{\n            lockingScript: HexString;\n            satoshis: SatoshiValue;\n            outputDescription: DescriptionString5to50Bytes;\n            basket?: BasketStringUnder300Bytes;\n            customInstructions?: string;\n            tags?: OutputTagStringUnder300Bytes[];\n        }&gt;;\n        lockTime?: PositiveIntegerOrZero;\n        version?: PositiveIntegerOrZero;\n        labels?: LabelStringUnder300Bytes[];\n        options?: {\n            signAndProcess?: BooleanDefaultTrue;\n            acceptDelayedBroadcast?: BooleanDefaultTrue;\n            trustSelf?: \"known\";\n            knownTxids?: TXIDHexString[];\n            returnTXIDOnly?: BooleanDefaultFalse;\n            noSend?: BooleanDefaultFalse;\n            noSendChange?: OutpointString[];\n            sendWith?: TXIDHexString[];\n        };\n    }): Promise&lt;{\n        txid?: TXIDHexString;\n        tx?: BEEF;\n        noSendChange?: OutpointString[];\n        sendWithResults?: Array&lt;{\n            txid: TXIDHexString;\n            status: \"unproven\" | \"sending\" | \"failed\";\n        }&gt;;\n        signableTransaction?: {\n            tx: BEEF;\n            reference: Base64String;\n        };\n    }&gt; \n    async signAction(args: {\n        spends: Record&lt;PositiveIntegerOrZero, {\n            unlockingScript: HexString;\n            sequenceNumber?: PositiveIntegerOrZero;\n        }&gt;;\n        reference: Base64String;\n        options?: {\n            acceptDelayedBroadcast?: BooleanDefaultTrue;\n            returnTXIDOnly?: BooleanDefaultFalse;\n            noSend?: BooleanDefaultFalse;\n            noSendChange?: OutpointString[];\n            sendWith: TXIDHexString[];\n        };\n    }): Promise&lt;{\n        txid?: TXIDHexString;\n        tx?: BEEF;\n        noSendChange?: OutpointString[];\n        sendWithResults?: Array&lt;{\n            txid: TXIDHexString;\n            status: \"unproven\" | \"sending\" | \"failed\";\n        }&gt;;\n    }&gt; \n    async abortAction(args: {\n        reference: Base64String;\n    }): Promise&lt;{\n        aborted: true;\n    }&gt; \n    async listActions(args: {\n        labels: LabelStringUnder300Bytes[];\n        labelQueryMode?: \"any\" | \"all\";\n        includeLabels?: BooleanDefaultFalse;\n        includeInputs?: BooleanDefaultFalse;\n        includeInputSourceLockingScripts?: BooleanDefaultFalse;\n        includeInputUnlockingScripts?: BooleanDefaultFalse;\n        includeOutputs?: BooleanDefaultFalse;\n        includeOutputLockingScripts?: BooleanDefaultFalse;\n        limit?: PositiveIntegerDefault10Max10000;\n        offset?: PositiveIntegerOrZero;\n    }): Promise&lt;{\n        totalActions: PositiveIntegerOrZero;\n        actions: Array&lt;{\n            txid: TXIDHexString;\n            satoshis: SatoshiValue;\n            status: \"completed\" | \"unprocessed\" | \"sending\" | \"unproven\" | \"unsigned\" | \"nosend\" | \"nonfinal\";\n            isOutgoing: boolean;\n            description: DescriptionString5to50Bytes;\n            labels?: LabelStringUnder300Bytes[];\n            version: PositiveIntegerOrZero;\n            lockTime: PositiveIntegerOrZero;\n            inputs?: Array&lt;{\n                sourceOutpoint: OutpointString;\n                sourceSatoshis: SatoshiValue;\n                sourceLockingScript?: HexString;\n                unlockingScript?: HexString;\n                inputDescription: DescriptionString5to50Bytes;\n                sequenceNumber: PositiveIntegerOrZero;\n            }&gt;;\n            outputs?: Array&lt;{\n                outputIndex: PositiveIntegerOrZero;\n                satoshis: SatoshiValue;\n                lockingScript?: HexString;\n                spendable: boolean;\n                outputDescription: DescriptionString5to50Bytes;\n                basket: BasketStringUnder300Bytes;\n                tags: OutputTagStringUnder300Bytes[];\n                customInstructions?: string;\n            }&gt;;\n        }&gt;;\n    }&gt; \n    async internalizeAction(args: {\n        tx: BEEF;\n        outputs: Array&lt;{\n            outputIndex: PositiveIntegerOrZero;\n            protocol: \"wallet payment\" | \"basket insertion\";\n            paymentRemittance?: {\n                derivationPrefix: Base64String;\n                derivationSuffix: Base64String;\n                senderIdentityKey: PubKeyHex;\n            };\n            insertionRemittance?: {\n                basket: BasketStringUnder300Bytes;\n                customInstructions?: string;\n                tags?: OutputTagStringUnder300Bytes[];\n            };\n        }&gt;;\n        description: DescriptionString5to50Bytes;\n        labels?: LabelStringUnder300Bytes[];\n    }): Promise&lt;{\n        accepted: true;\n    }&gt; \n    async listOutputs(args: {\n        basket: BasketStringUnder300Bytes;\n        tags?: OutputTagStringUnder300Bytes[];\n        tagQueryMode?: \"all\" | \"any\";\n        include?: \"locking scripts\" | \"entire transactions\";\n        includeCustomInstructions?: BooleanDefaultFalse;\n        includeTags?: BooleanDefaultFalse;\n        includeLabels?: BooleanDefaultFalse;\n        limit?: PositiveIntegerDefault10Max10000;\n        offset?: PositiveIntegerOrZero;\n    }): Promise&lt;{\n        totalOutputs: PositiveIntegerOrZero;\n        outputs: Array&lt;{\n            outpoint: OutpointString;\n            satoshis: SatoshiValue;\n            lockingScript?: HexString;\n            tx?: BEEF;\n            spendable: boolean;\n            customInstructions?: string;\n            tags?: OutputTagStringUnder300Bytes[];\n            labels?: LabelStringUnder300Bytes[];\n        }&gt;;\n    }&gt; \n    async relinquishOutput(args: {\n        basket: BasketStringUnder300Bytes;\n        output: OutpointString;\n    }): Promise&lt;{\n        relinquished: true;\n    }&gt; \n    async getPublicKey(args: {\n        identityKey?: true;\n        protocolID?: [\n            SecurityLevel,\n            ProtocolString5To400Bytes\n        ];\n        keyID?: KeyIDStringUnder800Bytes;\n        privileged?: BooleanDefaultFalse;\n        privilegedReason?: DescriptionString5to50Bytes;\n        counterparty?: PubKeyHex | \"self\" | \"anyone\";\n        forSelf?: BooleanDefaultFalse;\n    }): Promise&lt;{\n        publicKey: PubKeyHex;\n    }&gt; \n    async revealCounterpartyKeyLinkage(args: {\n        counterparty: PubKeyHex;\n        verifier: PubKeyHex;\n        privilegedReason?: DescriptionString5to50Bytes;\n        privileged?: BooleanDefaultFalse;\n    }): Promise&lt;{\n        prover: PubKeyHex;\n        verifier: PubKeyHex;\n        counterparty: PubKeyHex;\n        revelationTime: ISOTimestampString;\n        encryptedLinkage: Byte[];\n        encryptedLinkageProof: Byte[];\n    }&gt; \n    async revealSpecificKeyLinkage(args: {\n        counterparty: PubKeyHex;\n        verifier: PubKeyHex;\n        protocolID: [\n            SecurityLevel,\n            ProtocolString5To400Bytes\n        ];\n        keyID: KeyIDStringUnder800Bytes;\n        privilegedReason?: DescriptionString5to50Bytes;\n        privileged?: BooleanDefaultFalse;\n    }): Promise&lt;{\n        prover: PubKeyHex;\n        verifier: PubKeyHex;\n        counterparty: PubKeyHex;\n        protocolID: [\n            SecurityLevel,\n            ProtocolString5To400Bytes\n        ];\n        keyID: KeyIDStringUnder800Bytes;\n        encryptedLinkage: Byte[];\n        encryptedLinkageProof: Byte[];\n        proofType: Byte;\n    }&gt; \n    async encrypt(args: {\n        plaintext: Byte[];\n        protocolID: [\n            SecurityLevel,\n            ProtocolString5To400Bytes\n        ];\n        keyID: KeyIDStringUnder800Bytes;\n        privilegedReason?: DescriptionString5to50Bytes;\n        counterparty?: PubKeyHex | \"self\" | \"anyone\";\n        privileged?: BooleanDefaultFalse;\n    }): Promise&lt;{\n        ciphertext: Byte[];\n    }&gt; \n    async decrypt(args: {\n        ciphertext: Byte[];\n        protocolID: [\n            SecurityLevel,\n            ProtocolString5To400Bytes\n        ];\n        keyID: KeyIDStringUnder800Bytes;\n        privilegedReason?: DescriptionString5to50Bytes;\n        counterparty?: PubKeyHex | \"self\" | \"anyone\";\n        privileged?: BooleanDefaultFalse;\n    }): Promise&lt;{\n        plaintext: Byte[];\n    }&gt; \n    async createHmac(args: {\n        data: Byte[];\n        protocolID: [\n            SecurityLevel,\n            ProtocolString5To400Bytes\n        ];\n        keyID: KeyIDStringUnder800Bytes;\n        privilegedReason?: DescriptionString5to50Bytes;\n        counterparty?: PubKeyHex | \"self\" | \"anyone\";\n        privileged?: BooleanDefaultFalse;\n    }): Promise&lt;{\n        hmac: Byte[];\n    }&gt; \n    async verifyHmac(args: {\n        data: Byte[];\n        hmac: Byte[];\n        protocolID: [\n            SecurityLevel,\n            ProtocolString5To400Bytes\n        ];\n        keyID: KeyIDStringUnder800Bytes;\n        privilegedReason?: DescriptionString5to50Bytes;\n        counterparty?: PubKeyHex | \"self\" | \"anyone\";\n        privileged?: BooleanDefaultFalse;\n    }): Promise&lt;{\n        valid: true;\n    }&gt; \n    async createSignature(args: {\n        data?: Byte[];\n        hashToDirectlySign?: Byte[];\n        protocolID: [\n            SecurityLevel,\n            ProtocolString5To400Bytes\n        ];\n        keyID: KeyIDStringUnder800Bytes;\n        privilegedReason?: DescriptionString5to50Bytes;\n        counterparty?: PubKeyHex | \"self\" | \"anyone\";\n        privileged?: BooleanDefaultFalse;\n    }): Promise&lt;{\n        signature: Byte[];\n    }&gt; \n    async verifySignature(args: {\n        data?: Byte[];\n        hashToDirectlyVerify?: Byte[];\n        signature: Byte[];\n        protocolID: [\n            SecurityLevel,\n            ProtocolString5To400Bytes\n        ];\n        keyID: KeyIDStringUnder800Bytes;\n        privilegedReason?: DescriptionString5to50Bytes;\n        counterparty?: PubKeyHex | \"self\" | \"anyone\";\n        forSelf?: BooleanDefaultFalse;\n        privileged?: BooleanDefaultFalse;\n    }): Promise&lt;{\n        valid: true;\n    }&gt; \n    async acquireCertificate(args: {\n        type: Base64String;\n        subject: PubKeyHex;\n        serialNumber: Base64String;\n        revocationOutpoint: OutpointString;\n        signature: HexString;\n        fields: Record&lt;CertificateFieldNameUnder50Bytes, string&gt;;\n        certifier: PubKeyHex;\n        keyringRevealer: PubKeyHex | \"certifier\";\n        keyringForSubject: Record&lt;CertificateFieldNameUnder50Bytes, Base64String&gt;;\n        acquisitionProtocol: \"direct\" | \"issuance\";\n        certifierUrl?: string;\n    }): Promise&lt;{\n        type: Base64String;\n        subject: PubKeyHex;\n        serialNumber: Base64String;\n        certifier: PubKeyHex;\n        revocationOutpoint: OutpointString;\n        signature: HexString;\n        fields: Record&lt;CertificateFieldNameUnder50Bytes, string&gt;;\n    }&gt; \n    async listCertificates(args: {\n        certifiers: PubKeyHex[];\n        types: Base64String[];\n        limit?: PositiveIntegerDefault10Max10000;\n        offset?: PositiveIntegerOrZero;\n        privileged?: BooleanDefaultFalse;\n        privilegedReason?: DescriptionString5to50Bytes;\n    }): Promise&lt;{\n        totalCertificates: PositiveIntegerOrZero;\n        certificates: Array&lt;{\n            type: Base64String;\n            subject: PubKeyHex;\n            serialNumber: Base64String;\n            certifier: PubKeyHex;\n            revocationOutpoint: OutpointString;\n            signature: HexString;\n            fields: Record&lt;CertificateFieldNameUnder50Bytes, string&gt;;\n        }&gt;;\n    }&gt; \n    async proveCertificate(args: {\n        certificate: {\n            type: Base64String;\n            subject: PubKeyHex;\n            serialNumber: Base64String;\n            certifier: PubKeyHex;\n            revocationOutpoint: OutpointString;\n            signature: HexString;\n            fields: Record&lt;CertificateFieldNameUnder50Bytes, string&gt;;\n        };\n        fieldsToReveal: CertificateFieldNameUnder50Bytes[];\n        verifier: PubKeyHex;\n        privileged?: BooleanDefaultFalse;\n        privilegedReason?: DescriptionString5to50Bytes;\n    }): Promise&lt;{\n        keyringForVerifier: Record&lt;CertificateFieldNameUnder50Bytes, Base64String&gt;;\n    }&gt; \n    async relinquishCertificate(args: {\n        type: Base64String;\n        serialNumber: Base64String;\n        certifier: PubKeyHex;\n    }): Promise&lt;{\n        relinquished: true;\n    }&gt; \n    async discoverByIdentityKey(args: {\n        identityKey: PubKeyHex;\n        limit?: PositiveIntegerDefault10Max10000;\n        offset?: PositiveIntegerOrZero;\n    }): Promise&lt;{\n        totalCertificates: PositiveIntegerOrZero;\n        certificates: Array&lt;{\n            type: Base64String;\n            subject: PubKeyHex;\n            serialNumber: Base64String;\n            certifier: PubKeyHex;\n            revocationOutpoint: OutpointString;\n            signature: HexString;\n            fields: Record&lt;CertificateFieldNameUnder50Bytes, Base64String&gt;;\n            certifierInfo: {\n                name: EntityNameStringMax100Bytes;\n                iconUrl: EntityIconURLStringMax500Bytes;\n                description: DescriptionString5to50Bytes;\n                trust: PositiveIntegerMax10;\n            };\n            publiclyRevealedKeyring: Record&lt;CertificateFieldNameUnder50Bytes, Base64String&gt;;\n            decryptedFields: Record&lt;CertificateFieldNameUnder50Bytes, string&gt;;\n        }&gt;;\n    }&gt; \n    async discoverByAttributes(args: {\n        attributes: Record&lt;CertificateFieldNameUnder50Bytes, string&gt;;\n        limit?: PositiveIntegerDefault10Max10000;\n        offset?: PositiveIntegerOrZero;\n    }): Promise&lt;{\n        totalCertificates: PositiveIntegerOrZero;\n        certificates: Array&lt;{\n            type: Base64String;\n            subject: PubKeyHex;\n            serialNumber: Base64String;\n            certifier: PubKeyHex;\n            revocationOutpoint: OutpointString;\n            signature: HexString;\n            fields: Record&lt;CertificateFieldNameUnder50Bytes, Base64String&gt;;\n            certifierInfo: {\n                name: EntityNameStringMax100Bytes;\n                iconUrl: EntityIconURLStringMax500Bytes;\n                description: DescriptionString5to50Bytes;\n                trust: PositiveIntegerMax10;\n            };\n            publiclyRevealedKeyring: Record&lt;CertificateFieldNameUnder50Bytes, Base64String&gt;;\n            decryptedFields: Record&lt;CertificateFieldNameUnder50Bytes, string&gt;;\n        }&gt;;\n    }&gt; \n    async isAuthenticated(args: {}): Promise&lt;{\n        authenticated: true;\n    }&gt; \n    async waitForAuthentication(args: {}): Promise&lt;{\n        authenticated: true;\n    }&gt; \n    async getHeight(args: {}): Promise&lt;{\n        height: PositiveInteger;\n    }&gt; \n    async getHeaderForHeight(args: {\n        height: PositiveInteger;\n    }): Promise&lt;{\n        header: HexString;\n    }&gt; \n    async getNetwork(args: {}): Promise&lt;{\n        network: \"mainnet\" | \"testnet\";\n    }&gt; \n    async getVersion(args: {}): Promise&lt;{\n        version: VersionString7To30Bytes;\n    }&gt; \n}\n</code></pre> <p>See also: BEEF, Base64String, BasketStringUnder300Bytes, BooleanDefaultFalse, BooleanDefaultTrue, Byte, CallType, CertificateFieldNameUnder50Bytes, DescriptionString5to50Bytes, EntityIconURLStringMax500Bytes, EntityNameStringMax100Bytes, HexString, ISOTimestampString, KeyIDStringUnder800Bytes, LabelStringUnder300Bytes, OutpointString, OutputTagStringUnder300Bytes, PositiveInteger, PositiveIntegerDefault10Max10000, PositiveIntegerMax10, PositiveIntegerOrZero, ProtocolString5To400Bytes, PubKeyHex, SatoshiValue, SecurityLevel, TXIDHexString, VersionString7To30Bytes, WalletInterface, decrypt, encrypt</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#class-werr_insufficient_funds","title":"Class: WERR_INSUFFICIENT_FUNDS","text":"<p>Insufficient funds in the available inputs to cover the cost of the required outputs and the transaction fee (${moreSatoshisNeeded} more satoshis are needed, for a total of ${totalSatoshisNeeded}), plus whatever would be required in order to pay the fee to unlock and spend the outputs used to provide the additional satoshis.</p> <pre><code>export class WERR_INSUFFICIENT_FUNDS extends Error {\n    code: number;\n    isError: boolean = true;\n    constructor(public totalSatoshisNeeded: number, public moreSatoshisNeeded: number) \n}\n</code></pre>"},{"location":"reference/wallet/#constructor_2","title":"Constructor","text":"<pre><code>constructor(public totalSatoshisNeeded: number, public moreSatoshisNeeded: number) \n</code></pre> <p>Argument Details</p> <ul> <li>totalSatoshisNeeded</li> <li>Total satoshis required to fund transactions after net of required inputs and outputs.</li> <li>moreSatoshisNeeded</li> <li>Shortfall on total satoshis required to fund transactions after net of required inputs and outputs.</li> </ul> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#class-werr_invalid_parameter","title":"Class: WERR_INVALID_PARAMETER","text":"<p>The ${parameter} parameter is invalid.</p> <p>This is an example of an error object with a custom property <code>parameter</code> and templated <code>message</code>.</p> <pre><code>export class WERR_INVALID_PARAMETER extends Error {\n    code: number;\n    isError: boolean = true;\n    constructor(public parameter: string, mustBe?: string) \n}\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#class-werr_review_actions","title":"Class: WERR_REVIEW_ACTIONS","text":"<p>When a <code>createAction</code> or <code>signAction</code> is completed in undelayed mode (<code>acceptDelayedBroadcast</code>: false), any unsucccessful result will return the results by way of this exception to ensure attention is paid to processing errors.</p> <pre><code>export class WERR_REVIEW_ACTIONS extends Error {\n    code: number;\n    isError: boolean = true;\n    constructor(public reviewActionResults: ReviewActionResult[], public sendWithResults: SendWithResult[], public txid?: TXIDHexString, public tx?: AtomicBEEF, public noSendChange?: OutpointString[]) \n}\n</code></pre> <p>See also: AtomicBEEF, OutpointString, ReviewActionResult, SendWithResult, TXIDHexString</p>"},{"location":"reference/wallet/#constructor_3","title":"Constructor","text":"<p>All parameters correspond to their comparable <code>createAction</code> or <code>signSction</code> results with the exception of <code>reviewActionResults</code>; which contains more details, particularly for double spend results.</p> <p><pre><code>constructor(public reviewActionResults: ReviewActionResult[], public sendWithResults: SendWithResult[], public txid?: TXIDHexString, public tx?: AtomicBEEF, public noSendChange?: OutpointString[]) \n</code></pre> See also: AtomicBEEF, OutpointString, ReviewActionResult, SendWithResult, TXIDHexString</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#class-walletclient","title":"Class: WalletClient","text":"<p>The SDK is how applications communicate with wallets over a communications substrate.</p> <pre><code>export default class WalletClient implements WalletInterface {\n    public substrate: \"auto\" | WalletInterface;\n    originator?: OriginatorDomainNameStringUnder250Bytes;\n    constructor(substrate: \"auto\" | \"Cicada\" | \"XDM\" | \"window.CWI\" | \"json-api\" | \"react-native\" | \"secure-json-api\" | WalletInterface = \"auto\", originator?: OriginatorDomainNameStringUnder250Bytes) \n    async connectToSubstrate(): Promise&lt;void&gt; \n    async createAction(args: CreateActionArgs): Promise&lt;CreateActionResult&gt; \n    async signAction(args: SignActionArgs): Promise&lt;SignActionResult&gt; \n    async abortAction(args: {\n        reference: Base64String;\n    }): Promise&lt;{\n        aborted: true;\n    }&gt; \n    async listActions(args: ListActionsArgs): Promise&lt;ListActionsResult&gt; \n    async internalizeAction(args: InternalizeActionArgs): Promise&lt;{\n        accepted: true;\n    }&gt; \n    async listOutputs(args: ListOutputsArgs): Promise&lt;ListOutputsResult&gt; \n    async relinquishOutput(args: {\n        basket: BasketStringUnder300Bytes;\n        output: OutpointString;\n    }): Promise&lt;{\n        relinquished: true;\n    }&gt; \n    async getPublicKey(args: {\n        identityKey?: true;\n        protocolID?: [\n            SecurityLevel,\n            ProtocolString5To400Bytes\n        ];\n        keyID?: KeyIDStringUnder800Bytes;\n        privileged?: BooleanDefaultFalse;\n        privilegedReason?: DescriptionString5to50Bytes;\n        counterparty?: PubKeyHex | \"self\" | \"anyone\";\n        forSelf?: BooleanDefaultFalse;\n    }): Promise&lt;{\n        publicKey: PubKeyHex;\n    }&gt; \n    async revealCounterpartyKeyLinkage(args: {\n        counterparty: PubKeyHex;\n        verifier: PubKeyHex;\n        privilegedReason?: DescriptionString5to50Bytes;\n        privileged?: BooleanDefaultFalse;\n    }): Promise&lt;{\n        prover: PubKeyHex;\n        verifier: PubKeyHex;\n        counterparty: PubKeyHex;\n        revelationTime: ISOTimestampString;\n        encryptedLinkage: Byte[];\n        encryptedLinkageProof: Byte[];\n    }&gt; \n    async revealSpecificKeyLinkage(args: {\n        counterparty: PubKeyHex;\n        verifier: PubKeyHex;\n        protocolID: [\n            SecurityLevel,\n            ProtocolString5To400Bytes\n        ];\n        keyID: KeyIDStringUnder800Bytes;\n        privilegedReason?: DescriptionString5to50Bytes;\n        privileged?: BooleanDefaultFalse;\n    }): Promise&lt;{\n        prover: PubKeyHex;\n        verifier: PubKeyHex;\n        counterparty: PubKeyHex;\n        protocolID: [\n            SecurityLevel,\n            ProtocolString5To400Bytes\n        ];\n        keyID: KeyIDStringUnder800Bytes;\n        encryptedLinkage: Byte[];\n        encryptedLinkageProof: Byte[];\n        proofType: Byte;\n    }&gt; \n    async encrypt(args: {\n        plaintext: Byte[];\n        protocolID: [\n            SecurityLevel,\n            ProtocolString5To400Bytes\n        ];\n        keyID: KeyIDStringUnder800Bytes;\n        privilegedReason?: DescriptionString5to50Bytes;\n        counterparty?: PubKeyHex | \"self\" | \"anyone\";\n        privileged?: BooleanDefaultFalse;\n    }): Promise&lt;{\n        ciphertext: Byte[];\n    }&gt; \n    async decrypt(args: {\n        ciphertext: Byte[];\n        protocolID: [\n            SecurityLevel,\n            ProtocolString5To400Bytes\n        ];\n        keyID: KeyIDStringUnder800Bytes;\n        privilegedReason?: DescriptionString5to50Bytes;\n        counterparty?: PubKeyHex | \"self\" | \"anyone\";\n        privileged?: BooleanDefaultFalse;\n    }): Promise&lt;{\n        plaintext: Byte[];\n    }&gt; \n    async createHmac(args: {\n        data: Byte[];\n        protocolID: [\n            SecurityLevel,\n            ProtocolString5To400Bytes\n        ];\n        keyID: KeyIDStringUnder800Bytes;\n        privilegedReason?: DescriptionString5to50Bytes;\n        counterparty?: PubKeyHex | \"self\" | \"anyone\";\n        privileged?: BooleanDefaultFalse;\n    }): Promise&lt;{\n        hmac: Byte[];\n    }&gt; \n    async verifyHmac(args: {\n        data: Byte[];\n        hmac: Byte[];\n        protocolID: [\n            SecurityLevel,\n            ProtocolString5To400Bytes\n        ];\n        keyID: KeyIDStringUnder800Bytes;\n        privilegedReason?: DescriptionString5to50Bytes;\n        counterparty?: PubKeyHex | \"self\" | \"anyone\";\n        privileged?: BooleanDefaultFalse;\n    }): Promise&lt;{\n        valid: true;\n    }&gt; \n    async createSignature(args: {\n        data?: Byte[];\n        hashToDirectlySign?: Byte[];\n        protocolID: [\n            SecurityLevel,\n            ProtocolString5To400Bytes\n        ];\n        keyID: KeyIDStringUnder800Bytes;\n        privilegedReason?: DescriptionString5to50Bytes;\n        counterparty?: PubKeyHex | \"self\" | \"anyone\";\n        privileged?: BooleanDefaultFalse;\n    }): Promise&lt;{\n        signature: Byte[];\n    }&gt; \n    async verifySignature(args: {\n        data?: Byte[];\n        hashToDirectlyVerify?: Byte[];\n        signature: Byte[];\n        protocolID: [\n            SecurityLevel,\n            ProtocolString5To400Bytes\n        ];\n        keyID: KeyIDStringUnder800Bytes;\n        privilegedReason?: DescriptionString5to50Bytes;\n        counterparty?: PubKeyHex | \"self\" | \"anyone\";\n        forSelf?: BooleanDefaultFalse;\n        privileged?: BooleanDefaultFalse;\n    }): Promise&lt;{\n        valid: true;\n    }&gt; \n    async acquireCertificate(args: AcquireCertificateArgs): Promise&lt;AcquireCertificateResult&gt; \n    async listCertificates(args: {\n        certifiers: PubKeyHex[];\n        types: Base64String[];\n        limit?: PositiveIntegerDefault10Max10000;\n        offset?: PositiveIntegerOrZero;\n        privileged?: BooleanDefaultFalse;\n        privilegedReason?: DescriptionString5to50Bytes;\n    }): Promise&lt;ListCertificatesResult&gt; \n    async proveCertificate(args: ProveCertificateArgs): Promise&lt;ProveCertificateResult&gt; \n    async relinquishCertificate(args: {\n        type: Base64String;\n        serialNumber: Base64String;\n        certifier: PubKeyHex;\n    }): Promise&lt;{\n        relinquished: true;\n    }&gt; \n    async discoverByIdentityKey(args: {\n        identityKey: PubKeyHex;\n        limit?: PositiveIntegerDefault10Max10000;\n        offset?: PositiveIntegerOrZero;\n    }): Promise&lt;DiscoverCertificatesResult&gt; \n    async discoverByAttributes(args: {\n        attributes: Record&lt;CertificateFieldNameUnder50Bytes, string&gt;;\n        limit?: PositiveIntegerDefault10Max10000;\n        offset?: PositiveIntegerOrZero;\n    }): Promise&lt;DiscoverCertificatesResult&gt; \n    async isAuthenticated(args: object = {}): Promise&lt;AuthenticatedResult&gt; \n    async waitForAuthentication(args: object = {}): Promise&lt;{\n        authenticated: true;\n    }&gt; \n    async getHeight(args: object = {}): Promise&lt;{\n        height: PositiveInteger;\n    }&gt; \n    async getHeaderForHeight(args: {\n        height: PositiveInteger;\n    }): Promise&lt;{\n        header: HexString;\n    }&gt; \n    async getNetwork(args: object = {}): Promise&lt;{\n        network: \"mainnet\" | \"testnet\";\n    }&gt; \n    async getVersion(args: object = {}): Promise&lt;{\n        version: VersionString7To30Bytes;\n    }&gt; \n}\n</code></pre> <p>See also: AcquireCertificateArgs, AcquireCertificateResult, AuthenticatedResult, Base64String, BasketStringUnder300Bytes, BooleanDefaultFalse, Byte, CertificateFieldNameUnder50Bytes, CreateActionArgs, CreateActionResult, DescriptionString5to50Bytes, DiscoverCertificatesResult, HexString, ISOTimestampString, InternalizeActionArgs, KeyIDStringUnder800Bytes, ListActionsArgs, ListActionsResult, ListCertificatesResult, ListOutputsArgs, ListOutputsResult, OriginatorDomainNameStringUnder250Bytes, OutpointString, PositiveInteger, PositiveIntegerDefault10Max10000, PositiveIntegerOrZero, ProtocolString5To400Bytes, ProveCertificateArgs, ProveCertificateResult, PubKeyHex, SecurityLevel, SignActionArgs, SignActionResult, VersionString7To30Bytes, WalletInterface, decrypt, encrypt</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#class-walleterror","title":"Class: WalletError","text":"<pre><code>export class WalletError extends Error {\n    code: number;\n    isError: boolean = true;\n    constructor(message: string, code = 1, stack?: string) \n    static unknownToJson(error: any): string \n}\n</code></pre>"},{"location":"reference/wallet/#method-unknowntojson","title":"Method unknownToJson","text":"<p>Safely serializes a WalletError (including special cases), Error or unknown error to JSON.</p> <p>Safely means avoiding deep, large, circular issues.</p> <p>Example deserialization can be found in HTTPWalletJSON.ts of bsv ts-sdk.</p> <pre><code>static unknownToJson(error: any): string \n</code></pre> <p>Returns</p> <p>stringified JSON representation of the error such that it can be deserialized to a WalletError.</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#class-walletwireprocessor","title":"Class: WalletWireProcessor","text":"<p>Processes incoming wallet calls received over a wallet wire, with a given wallet.</p> <pre><code>export default class WalletWireProcessor implements WalletWire {\n    wallet: WalletInterface;\n    constructor(wallet: WalletInterface) \n    async transmitToWallet(message: number[]): Promise&lt;number[]&gt; \n}\n</code></pre> <p>See also: WalletInterface, WalletWire</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#class-walletwiretransceiver","title":"Class: WalletWireTransceiver","text":"<p>A way to make remote calls to a wallet over a wallet wire.</p> <pre><code>export default class WalletWireTransceiver implements WalletInterface {\n    wire: WalletWire;\n    constructor(wire: WalletWire) \n    async createAction(args: CreateActionArgs, originator?: OriginatorDomainNameStringUnder250Bytes): Promise&lt;CreateActionResult&gt; \n    async signAction(args: SignActionArgs, originator?: OriginatorDomainNameStringUnder250Bytes): Promise&lt;SignActionResult&gt; \n    async abortAction(args: {\n        reference: Base64String;\n    }, originator?: OriginatorDomainNameStringUnder250Bytes): Promise&lt;{\n        aborted: true;\n    }&gt; \n    async listActions(args: ListActionsArgs, originator?: OriginatorDomainNameStringUnder250Bytes): Promise&lt;ListActionsResult&gt; \n    async internalizeAction(args: InternalizeActionArgs, originator?: OriginatorDomainNameStringUnder250Bytes): Promise&lt;{\n        accepted: true;\n    }&gt; \n    async listOutputs(args: ListOutputsArgs, originator?: OriginatorDomainNameStringUnder250Bytes): Promise&lt;ListOutputsResult&gt; \n    async relinquishOutput(args: {\n        basket: BasketStringUnder300Bytes;\n        output: OutpointString;\n    }, originator?: OriginatorDomainNameStringUnder250Bytes): Promise&lt;{\n        relinquished: true;\n    }&gt; \n    async getPublicKey(args: {\n        seekPermission?: BooleanDefaultTrue;\n        identityKey?: true;\n        protocolID?: [\n            SecurityLevel,\n            ProtocolString5To400Bytes\n        ];\n        keyID?: KeyIDStringUnder800Bytes;\n        privileged?: BooleanDefaultFalse;\n        privilegedReason?: DescriptionString5to50Bytes;\n        counterparty?: PubKeyHex | \"self\" | \"anyone\";\n        forSelf?: BooleanDefaultFalse;\n    }, originator?: OriginatorDomainNameStringUnder250Bytes): Promise&lt;{\n        publicKey: PubKeyHex;\n    }&gt; \n    async revealCounterpartyKeyLinkage(args: {\n        counterparty: PubKeyHex;\n        verifier: PubKeyHex;\n        privilegedReason?: DescriptionString5to50Bytes;\n        privileged?: BooleanDefaultFalse;\n    }, originator?: OriginatorDomainNameStringUnder250Bytes): Promise&lt;{\n        prover: PubKeyHex;\n        verifier: PubKeyHex;\n        counterparty: PubKeyHex;\n        revelationTime: ISOTimestampString;\n        encryptedLinkage: Byte[];\n        encryptedLinkageProof: number[];\n    }&gt; \n    async revealSpecificKeyLinkage(args: {\n        counterparty: PubKeyHex;\n        verifier: PubKeyHex;\n        protocolID: [\n            SecurityLevel,\n            ProtocolString5To400Bytes\n        ];\n        keyID: KeyIDStringUnder800Bytes;\n        privilegedReason?: DescriptionString5to50Bytes;\n        privileged?: BooleanDefaultFalse;\n    }, originator?: OriginatorDomainNameStringUnder250Bytes): Promise&lt;{\n        prover: PubKeyHex;\n        verifier: PubKeyHex;\n        counterparty: PubKeyHex;\n        protocolID: [\n            SecurityLevel,\n            ProtocolString5To400Bytes\n        ];\n        keyID: KeyIDStringUnder800Bytes;\n        encryptedLinkage: Byte[];\n        encryptedLinkageProof: Byte[];\n        proofType: Byte;\n    }&gt; \n    async encrypt(args: {\n        seekPermission?: BooleanDefaultTrue;\n        plaintext: Byte[];\n        protocolID: [\n            SecurityLevel,\n            ProtocolString5To400Bytes\n        ];\n        keyID: KeyIDStringUnder800Bytes;\n        privilegedReason?: DescriptionString5to50Bytes;\n        counterparty?: PubKeyHex | \"self\" | \"anyone\";\n        privileged?: BooleanDefaultFalse;\n    }, originator?: OriginatorDomainNameStringUnder250Bytes): Promise&lt;{\n        ciphertext: Byte[];\n    }&gt; \n    async decrypt(args: {\n        seekPermission?: BooleanDefaultTrue;\n        ciphertext: Byte[];\n        protocolID: [\n            SecurityLevel,\n            ProtocolString5To400Bytes\n        ];\n        keyID: KeyIDStringUnder800Bytes;\n        privilegedReason?: DescriptionString5to50Bytes;\n        counterparty?: PubKeyHex | \"self\" | \"anyone\";\n        privileged?: BooleanDefaultFalse;\n    }, originator?: OriginatorDomainNameStringUnder250Bytes): Promise&lt;{\n        plaintext: Byte[];\n    }&gt; \n    async createHmac(args: {\n        seekPermission?: BooleanDefaultTrue;\n        data: Byte[];\n        protocolID: [\n            SecurityLevel,\n            ProtocolString5To400Bytes\n        ];\n        keyID: KeyIDStringUnder800Bytes;\n        privilegedReason?: DescriptionString5to50Bytes;\n        counterparty?: PubKeyHex | \"self\" | \"anyone\";\n        privileged?: BooleanDefaultFalse;\n    }, originator?: OriginatorDomainNameStringUnder250Bytes): Promise&lt;{\n        hmac: Byte[];\n    }&gt; \n    async verifyHmac(args: {\n        seekPermission?: BooleanDefaultTrue;\n        data: Byte[];\n        hmac: Byte[];\n        protocolID: [\n            SecurityLevel,\n            ProtocolString5To400Bytes\n        ];\n        keyID: KeyIDStringUnder800Bytes;\n        privilegedReason?: DescriptionString5to50Bytes;\n        counterparty?: PubKeyHex | \"self\" | \"anyone\";\n        privileged?: BooleanDefaultFalse;\n    }, originator?: OriginatorDomainNameStringUnder250Bytes): Promise&lt;{\n        valid: true;\n    }&gt; \n    async createSignature(args: {\n        seekPermission?: BooleanDefaultTrue;\n        data?: Byte[];\n        hashToDirectlySign?: Byte[];\n        protocolID: [\n            SecurityLevel,\n            ProtocolString5To400Bytes\n        ];\n        keyID: KeyIDStringUnder800Bytes;\n        privilegedReason?: DescriptionString5to50Bytes;\n        counterparty?: PubKeyHex | \"self\" | \"anyone\";\n        privileged?: BooleanDefaultFalse;\n    }, originator?: OriginatorDomainNameStringUnder250Bytes): Promise&lt;{\n        signature: Byte[];\n    }&gt; \n    async verifySignature(args: {\n        seekPermission?: BooleanDefaultTrue;\n        data?: Byte[];\n        hashToDirectlyVerify?: Byte[];\n        signature: Byte[];\n        protocolID: [\n            SecurityLevel,\n            ProtocolString5To400Bytes\n        ];\n        keyID: KeyIDStringUnder800Bytes;\n        privilegedReason?: DescriptionString5to50Bytes;\n        counterparty?: PubKeyHex | \"self\" | \"anyone\";\n        forSelf?: BooleanDefaultFalse;\n        privileged?: BooleanDefaultFalse;\n    }, originator?: OriginatorDomainNameStringUnder250Bytes): Promise&lt;{\n        valid: true;\n    }&gt; \n    async acquireCertificate(args: AcquireCertificateArgs, originator?: OriginatorDomainNameStringUnder250Bytes): Promise&lt;AcquireCertificateResult&gt; \n    async listCertificates(args: {\n        certifiers: PubKeyHex[];\n        types: Base64String[];\n        limit?: PositiveIntegerDefault10Max10000;\n        offset?: PositiveIntegerOrZero;\n        privileged?: BooleanDefaultFalse;\n        privilegedReason?: DescriptionString5to50Bytes;\n    }, originator?: OriginatorDomainNameStringUnder250Bytes): Promise&lt;ListCertificatesResult&gt; \n    async proveCertificate(args: ProveCertificateArgs, originator?: OriginatorDomainNameStringUnder250Bytes): Promise&lt;ProveCertificateResult&gt; \n    async relinquishCertificate(args: {\n        type: Base64String;\n        serialNumber: Base64String;\n        certifier: PubKeyHex;\n    }, originator?: OriginatorDomainNameStringUnder250Bytes): Promise&lt;{\n        relinquished: true;\n    }&gt; \n    async discoverByIdentityKey(args: {\n        seekPermission?: BooleanDefaultTrue;\n        identityKey: PubKeyHex;\n        limit?: PositiveIntegerDefault10Max10000;\n        offset?: PositiveIntegerOrZero;\n    }, originator?: OriginatorDomainNameStringUnder250Bytes): Promise&lt;DiscoverCertificatesResult&gt; \n    async discoverByAttributes(args: {\n        seekPermission?: BooleanDefaultTrue;\n        attributes: Record&lt;CertificateFieldNameUnder50Bytes, string&gt;;\n        limit?: PositiveIntegerDefault10Max10000;\n        offset?: PositiveIntegerOrZero;\n    }, originator?: OriginatorDomainNameStringUnder250Bytes): Promise&lt;DiscoverCertificatesResult&gt; \n    async isAuthenticated(args: {}, originator?: OriginatorDomainNameStringUnder250Bytes): Promise&lt;{\n        authenticated: true;\n    }&gt; \n    async waitForAuthentication(args: {}, originator?: OriginatorDomainNameStringUnder250Bytes): Promise&lt;{\n        authenticated: true;\n    }&gt; \n    async getHeight(args: {}, originator?: OriginatorDomainNameStringUnder250Bytes): Promise&lt;{\n        height: PositiveInteger;\n    }&gt; \n    async getHeaderForHeight(args: {\n        height: PositiveInteger;\n    }, originator?: OriginatorDomainNameStringUnder250Bytes): Promise&lt;{\n        header: HexString;\n    }&gt; \n    async getNetwork(args: {}, originator?: OriginatorDomainNameStringUnder250Bytes): Promise&lt;{\n        network: \"mainnet\" | \"testnet\";\n    }&gt; \n    async getVersion(args: {}, originator?: OriginatorDomainNameStringUnder250Bytes): Promise&lt;{\n        version: VersionString7To30Bytes;\n    }&gt; \n}\n</code></pre> <p>See also: AcquireCertificateArgs, AcquireCertificateResult, Base64String, BasketStringUnder300Bytes, BooleanDefaultFalse, BooleanDefaultTrue, Byte, CertificateFieldNameUnder50Bytes, CreateActionArgs, CreateActionResult, DescriptionString5to50Bytes, DiscoverCertificatesResult, HexString, ISOTimestampString, InternalizeActionArgs, KeyIDStringUnder800Bytes, ListActionsArgs, ListActionsResult, ListCertificatesResult, ListOutputsArgs, ListOutputsResult, OriginatorDomainNameStringUnder250Bytes, OutpointString, PositiveInteger, PositiveIntegerDefault10Max10000, PositiveIntegerOrZero, ProtocolString5To400Bytes, ProveCertificateArgs, ProveCertificateResult, PubKeyHex, SecurityLevel, SignActionArgs, SignActionResult, VersionString7To30Bytes, WalletInterface, WalletWire, decrypt, encrypt</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#class-windowcwisubstrate","title":"Class: WindowCWISubstrate","text":"<p>Facilitates wallet operations over the window.CWI interface.</p> <pre><code>export default class WindowCWISubstrate implements WalletInterface {\n    constructor() \n    async createAction(args: {\n        description: DescriptionString5to50Bytes;\n        inputs?: Array&lt;{\n            tx?: BEEF;\n            outpoint: OutpointString;\n            unlockingScript?: HexString;\n            unlockingScriptLength?: PositiveInteger;\n            inputDescription: DescriptionString5to50Bytes;\n            sequenceNumber?: PositiveIntegerOrZero;\n        }&gt;;\n        outputs?: Array&lt;{\n            lockingScript: HexString;\n            satoshis: SatoshiValue;\n            outputDescription: DescriptionString5to50Bytes;\n            basket?: BasketStringUnder300Bytes;\n            customInstructions?: string;\n            tags?: OutputTagStringUnder300Bytes[];\n        }&gt;;\n        lockTime?: PositiveIntegerOrZero;\n        version?: PositiveIntegerOrZero;\n        labels?: LabelStringUnder300Bytes[];\n        options?: {\n            signAndProcess?: BooleanDefaultTrue;\n            acceptDelayedBroadcast?: BooleanDefaultTrue;\n            trustSelf?: \"known\";\n            knownTxids?: TXIDHexString[];\n            returnTXIDOnly?: BooleanDefaultFalse;\n            noSend?: BooleanDefaultFalse;\n            noSendChange?: OutpointString[];\n            sendWith?: TXIDHexString[];\n        };\n    }, originator?: OriginatorDomainNameStringUnder250Bytes): Promise&lt;{\n        txid?: TXIDHexString;\n        tx?: BEEF;\n        noSendChange?: OutpointString[];\n        sendWithResults?: Array&lt;{\n            txid: TXIDHexString;\n            status: \"unproven\" | \"sending\" | \"failed\";\n        }&gt;;\n        signableTransaction?: {\n            tx: BEEF;\n            reference: Base64String;\n        };\n    }&gt; \n    async signAction(args: {\n        spends: Record&lt;PositiveIntegerOrZero, {\n            unlockingScript: HexString;\n            sequenceNumber?: PositiveIntegerOrZero;\n        }&gt;;\n        reference: Base64String;\n        options?: {\n            acceptDelayedBroadcast?: BooleanDefaultTrue;\n            returnTXIDOnly?: BooleanDefaultFalse;\n            noSend?: BooleanDefaultFalse;\n            noSendChange?: OutpointString[];\n            sendWith: TXIDHexString[];\n        };\n    }, originator?: OriginatorDomainNameStringUnder250Bytes): Promise&lt;{\n        txid?: TXIDHexString;\n        tx?: BEEF;\n        noSendChange?: OutpointString[];\n        sendWithResults?: Array&lt;{\n            txid: TXIDHexString;\n            status: \"unproven\" | \"sending\" | \"failed\";\n        }&gt;;\n    }&gt; \n    async abortAction(args: {\n        reference: Base64String;\n    }, originator?: OriginatorDomainNameStringUnder250Bytes): Promise&lt;{\n        aborted: true;\n    }&gt; \n    async listActions(args: {\n        labels: LabelStringUnder300Bytes[];\n        labelQueryMode?: \"any\" | \"all\";\n        includeLabels?: BooleanDefaultFalse;\n        includeInputs?: BooleanDefaultFalse;\n        includeInputSourceLockingScripts?: BooleanDefaultFalse;\n        includeInputUnlockingScripts?: BooleanDefaultFalse;\n        includeOutputs?: BooleanDefaultFalse;\n        includeOutputLockingScripts?: BooleanDefaultFalse;\n        limit?: PositiveIntegerDefault10Max10000;\n        offset?: PositiveIntegerOrZero;\n    }, originator?: OriginatorDomainNameStringUnder250Bytes): Promise&lt;{\n        totalActions: PositiveIntegerOrZero;\n        actions: Array&lt;{\n            txid: TXIDHexString;\n            satoshis: SatoshiValue;\n            status: \"completed\" | \"unprocessed\" | \"sending\" | \"unproven\" | \"unsigned\" | \"nosend\" | \"nonfinal\" | \"failed\";\n            isOutgoing: boolean;\n            description: DescriptionString5to50Bytes;\n            labels?: LabelStringUnder300Bytes[];\n            version: PositiveIntegerOrZero;\n            lockTime: PositiveIntegerOrZero;\n            inputs?: Array&lt;{\n                sourceOutpoint: OutpointString;\n                sourceSatoshis: SatoshiValue;\n                sourceLockingScript?: HexString;\n                unlockingScript?: HexString;\n                inputDescription: DescriptionString5to50Bytes;\n                sequenceNumber: PositiveIntegerOrZero;\n            }&gt;;\n            outputs?: Array&lt;{\n                outputIndex: PositiveIntegerOrZero;\n                satoshis: SatoshiValue;\n                lockingScript?: HexString;\n                spendable: boolean;\n                outputDescription: DescriptionString5to50Bytes;\n                basket: BasketStringUnder300Bytes;\n                tags: OutputTagStringUnder300Bytes[];\n                customInstructions?: string;\n            }&gt;;\n        }&gt;;\n    }&gt; \n    async internalizeAction(args: {\n        tx: BEEF;\n        outputs: Array&lt;{\n            outputIndex: PositiveIntegerOrZero;\n            protocol: \"wallet payment\" | \"basket insertion\";\n            paymentRemittance?: {\n                derivationPrefix: Base64String;\n                derivationSuffix: Base64String;\n                senderIdentityKey: PubKeyHex;\n            };\n            insertionRemittance?: {\n                basket: BasketStringUnder300Bytes;\n                customInstructions?: string;\n                tags?: OutputTagStringUnder300Bytes[];\n            };\n        }&gt;;\n        description: DescriptionString5to50Bytes;\n        labels?: LabelStringUnder300Bytes[];\n    }, originator?: OriginatorDomainNameStringUnder250Bytes): Promise&lt;{\n        accepted: true;\n    }&gt; \n    async listOutputs(args: {\n        basket: BasketStringUnder300Bytes;\n        tags?: OutputTagStringUnder300Bytes[];\n        tagQueryMode?: \"all\" | \"any\";\n        include?: \"locking scripts\" | \"entire transactions\";\n        includeCustomInstructions?: BooleanDefaultFalse;\n        includeTags?: BooleanDefaultFalse;\n        includeLabels?: BooleanDefaultFalse;\n        limit?: PositiveIntegerDefault10Max10000;\n        offset?: PositiveIntegerOrZero;\n    }, originator?: OriginatorDomainNameStringUnder250Bytes): Promise&lt;{\n        totalOutputs: PositiveIntegerOrZero;\n        outputs: Array&lt;{\n            outpoint: OutpointString;\n            satoshis: SatoshiValue;\n            lockingScript?: HexString;\n            tx?: BEEF;\n            spendable: boolean;\n            customInstructions?: string;\n            tags?: OutputTagStringUnder300Bytes[];\n            labels?: LabelStringUnder300Bytes[];\n        }&gt;;\n    }&gt; \n    async relinquishOutput(args: {\n        basket: BasketStringUnder300Bytes;\n        output: OutpointString;\n    }, originator?: OriginatorDomainNameStringUnder250Bytes): Promise&lt;{\n        relinquished: true;\n    }&gt; \n    async getPublicKey(args: {\n        identityKey?: true;\n        protocolID?: [\n            SecurityLevel,\n            ProtocolString5To400Bytes\n        ];\n        keyID?: KeyIDStringUnder800Bytes;\n        privileged?: BooleanDefaultFalse;\n        privilegedReason?: DescriptionString5to50Bytes;\n        counterparty?: PubKeyHex | \"self\" | \"anyone\";\n        forSelf?: BooleanDefaultFalse;\n    }, originator?: OriginatorDomainNameStringUnder250Bytes): Promise&lt;{\n        publicKey: PubKeyHex;\n    }&gt; \n    async revealCounterpartyKeyLinkage(args: {\n        counterparty: PubKeyHex;\n        verifier: PubKeyHex;\n        privilegedReason?: DescriptionString5to50Bytes;\n        privileged?: BooleanDefaultFalse;\n    }, originator?: OriginatorDomainNameStringUnder250Bytes): Promise&lt;{\n        prover: PubKeyHex;\n        verifier: PubKeyHex;\n        counterparty: PubKeyHex;\n        revelationTime: ISOTimestampString;\n        encryptedLinkage: Byte[];\n        encryptedLinkageProof: Byte[];\n    }&gt; \n    async revealSpecificKeyLinkage(args: {\n        counterparty: PubKeyHex;\n        verifier: PubKeyHex;\n        protocolID: [\n            SecurityLevel,\n            ProtocolString5To400Bytes\n        ];\n        keyID: KeyIDStringUnder800Bytes;\n        privilegedReason?: DescriptionString5to50Bytes;\n        privileged?: BooleanDefaultFalse;\n    }, originator?: OriginatorDomainNameStringUnder250Bytes): Promise&lt;{\n        prover: PubKeyHex;\n        verifier: PubKeyHex;\n        counterparty: PubKeyHex;\n        protocolID: [\n            SecurityLevel,\n            ProtocolString5To400Bytes\n        ];\n        keyID: KeyIDStringUnder800Bytes;\n        encryptedLinkage: Byte[];\n        encryptedLinkageProof: Byte[];\n        proofType: Byte;\n    }&gt; \n    async encrypt(args: {\n        plaintext: Byte[];\n        protocolID: [\n            SecurityLevel,\n            ProtocolString5To400Bytes\n        ];\n        keyID: KeyIDStringUnder800Bytes;\n        privilegedReason?: DescriptionString5to50Bytes;\n        counterparty?: PubKeyHex | \"self\" | \"anyone\";\n        privileged?: BooleanDefaultFalse;\n    }, originator?: OriginatorDomainNameStringUnder250Bytes): Promise&lt;{\n        ciphertext: Byte[];\n    }&gt; \n    async decrypt(args: {\n        ciphertext: Byte[];\n        protocolID: [\n            SecurityLevel,\n            ProtocolString5To400Bytes\n        ];\n        keyID: KeyIDStringUnder800Bytes;\n        privilegedReason?: DescriptionString5to50Bytes;\n        counterparty?: PubKeyHex | \"self\" | \"anyone\";\n        privileged?: BooleanDefaultFalse;\n    }, originator?: OriginatorDomainNameStringUnder250Bytes): Promise&lt;{\n        plaintext: Byte[];\n    }&gt; \n    async createHmac(args: {\n        data: Byte[];\n        protocolID: [\n            SecurityLevel,\n            ProtocolString5To400Bytes\n        ];\n        keyID: KeyIDStringUnder800Bytes;\n        privilegedReason?: DescriptionString5to50Bytes;\n        counterparty?: PubKeyHex | \"self\" | \"anyone\";\n        privileged?: BooleanDefaultFalse;\n    }, originator?: OriginatorDomainNameStringUnder250Bytes): Promise&lt;{\n        hmac: Byte[];\n    }&gt; \n    async verifyHmac(args: {\n        data: Byte[];\n        hmac: Byte[];\n        protocolID: [\n            SecurityLevel,\n            ProtocolString5To400Bytes\n        ];\n        keyID: KeyIDStringUnder800Bytes;\n        privilegedReason?: DescriptionString5to50Bytes;\n        counterparty?: PubKeyHex | \"self\" | \"anyone\";\n        privileged?: BooleanDefaultFalse;\n    }, originator?: OriginatorDomainNameStringUnder250Bytes): Promise&lt;{\n        valid: true;\n    }&gt; \n    async createSignature(args: {\n        data?: Byte[];\n        hashToDirectlySign?: Byte[];\n        protocolID: [\n            SecurityLevel,\n            ProtocolString5To400Bytes\n        ];\n        keyID: KeyIDStringUnder800Bytes;\n        privilegedReason?: DescriptionString5to50Bytes;\n        counterparty?: PubKeyHex | \"self\" | \"anyone\";\n        privileged?: BooleanDefaultFalse;\n    }, originator?: OriginatorDomainNameStringUnder250Bytes): Promise&lt;{\n        signature: Byte[];\n    }&gt; \n    async verifySignature(args: {\n        data?: Byte[];\n        hashToDirectlyVerify?: Byte[];\n        signature: Byte[];\n        protocolID: [\n            SecurityLevel,\n            ProtocolString5To400Bytes\n        ];\n        keyID: KeyIDStringUnder800Bytes;\n        privilegedReason?: DescriptionString5to50Bytes;\n        counterparty?: PubKeyHex | \"self\" | \"anyone\";\n        forSelf?: BooleanDefaultFalse;\n        privileged?: BooleanDefaultFalse;\n    }, originator?: OriginatorDomainNameStringUnder250Bytes): Promise&lt;{\n        valid: true;\n    }&gt; \n    async acquireCertificate(args: {\n        type: Base64String;\n        subject: PubKeyHex;\n        serialNumber: Base64String;\n        revocationOutpoint: OutpointString;\n        signature: HexString;\n        fields: Record&lt;CertificateFieldNameUnder50Bytes, string&gt;;\n        certifier: PubKeyHex;\n        keyringRevealer: PubKeyHex | \"certifier\";\n        keyringForSubject: Record&lt;CertificateFieldNameUnder50Bytes, Base64String&gt;;\n        acquisitionProtocol: \"direct\" | \"issuance\";\n        certifierUrl?: string;\n    }, originator?: OriginatorDomainNameStringUnder250Bytes): Promise&lt;{\n        type: Base64String;\n        subject: PubKeyHex;\n        serialNumber: Base64String;\n        certifier: PubKeyHex;\n        revocationOutpoint: OutpointString;\n        signature: HexString;\n        fields: Record&lt;CertificateFieldNameUnder50Bytes, string&gt;;\n    }&gt; \n    async listCertificates(args: {\n        certifiers: PubKeyHex[];\n        types: Base64String[];\n        limit?: PositiveIntegerDefault10Max10000;\n        offset?: PositiveIntegerOrZero;\n        privileged?: BooleanDefaultFalse;\n        privilegedReason?: DescriptionString5to50Bytes;\n    }, originator?: OriginatorDomainNameStringUnder250Bytes): Promise&lt;{\n        totalCertificates: PositiveIntegerOrZero;\n        certificates: Array&lt;{\n            type: Base64String;\n            subject: PubKeyHex;\n            serialNumber: Base64String;\n            certifier: PubKeyHex;\n            revocationOutpoint: OutpointString;\n            signature: HexString;\n            fields: Record&lt;CertificateFieldNameUnder50Bytes, string&gt;;\n        }&gt;;\n    }&gt; \n    async proveCertificate(args: {\n        certificate: {\n            type: Base64String;\n            subject: PubKeyHex;\n            serialNumber: Base64String;\n            certifier: PubKeyHex;\n            revocationOutpoint: OutpointString;\n            signature: HexString;\n            fields: Record&lt;CertificateFieldNameUnder50Bytes, string&gt;;\n        };\n        fieldsToReveal: CertificateFieldNameUnder50Bytes[];\n        verifier: PubKeyHex;\n        privileged?: BooleanDefaultFalse;\n        privilegedReason?: DescriptionString5to50Bytes;\n    }, originator?: OriginatorDomainNameStringUnder250Bytes): Promise&lt;{\n        keyringForVerifier: Record&lt;CertificateFieldNameUnder50Bytes, Base64String&gt;;\n    }&gt; \n    async relinquishCertificate(args: {\n        type: Base64String;\n        serialNumber: Base64String;\n        certifier: PubKeyHex;\n    }, originator?: OriginatorDomainNameStringUnder250Bytes): Promise&lt;{\n        relinquished: true;\n    }&gt; \n    async discoverByIdentityKey(args: {\n        identityKey: PubKeyHex;\n        limit?: PositiveIntegerDefault10Max10000;\n        offset?: PositiveIntegerOrZero;\n    }, originator?: OriginatorDomainNameStringUnder250Bytes): Promise&lt;{\n        totalCertificates: PositiveIntegerOrZero;\n        certificates: Array&lt;{\n            type: Base64String;\n            subject: PubKeyHex;\n            serialNumber: Base64String;\n            certifier: PubKeyHex;\n            revocationOutpoint: OutpointString;\n            signature: HexString;\n            fields: Record&lt;CertificateFieldNameUnder50Bytes, Base64String&gt;;\n            certifierInfo: {\n                name: EntityNameStringMax100Bytes;\n                iconUrl: EntityIconURLStringMax500Bytes;\n                description: DescriptionString5to50Bytes;\n                trust: PositiveIntegerMax10;\n            };\n            publiclyRevealedKeyring: Record&lt;CertificateFieldNameUnder50Bytes, Base64String&gt;;\n            decryptedFields: Record&lt;CertificateFieldNameUnder50Bytes, string&gt;;\n        }&gt;;\n    }&gt; \n    async discoverByAttributes(args: {\n        attributes: Record&lt;CertificateFieldNameUnder50Bytes, string&gt;;\n        limit?: PositiveIntegerDefault10Max10000;\n        offset?: PositiveIntegerOrZero;\n    }, originator?: OriginatorDomainNameStringUnder250Bytes): Promise&lt;{\n        totalCertificates: PositiveIntegerOrZero;\n        certificates: Array&lt;{\n            type: Base64String;\n            subject: PubKeyHex;\n            serialNumber: Base64String;\n            certifier: PubKeyHex;\n            revocationOutpoint: OutpointString;\n            signature: HexString;\n            fields: Record&lt;CertificateFieldNameUnder50Bytes, Base64String&gt;;\n            certifierInfo: {\n                name: EntityNameStringMax100Bytes;\n                iconUrl: EntityIconURLStringMax500Bytes;\n                description: DescriptionString5to50Bytes;\n                trust: PositiveIntegerMax10;\n            };\n            publiclyRevealedKeyring: Record&lt;CertificateFieldNameUnder50Bytes, Base64String&gt;;\n            decryptedFields: Record&lt;CertificateFieldNameUnder50Bytes, string&gt;;\n        }&gt;;\n    }&gt; \n    async isAuthenticated(args: object, originator?: OriginatorDomainNameStringUnder250Bytes): Promise&lt;{\n        authenticated: true;\n    }&gt; \n    async waitForAuthentication(args: object, originator?: OriginatorDomainNameStringUnder250Bytes): Promise&lt;{\n        authenticated: true;\n    }&gt; \n    async getHeight(args: object, originator?: OriginatorDomainNameStringUnder250Bytes): Promise&lt;{\n        height: PositiveInteger;\n    }&gt; \n    async getHeaderForHeight(args: {\n        height: PositiveInteger;\n    }, originator?: OriginatorDomainNameStringUnder250Bytes): Promise&lt;{\n        header: HexString;\n    }&gt; \n    async getNetwork(args: object, originator?: OriginatorDomainNameStringUnder250Bytes): Promise&lt;{\n        network: \"mainnet\" | \"testnet\";\n    }&gt; \n    async getVersion(args: object, originator?: OriginatorDomainNameStringUnder250Bytes): Promise&lt;{\n        version: VersionString7To30Bytes;\n    }&gt; \n}\n</code></pre> <p>See also: BEEF, Base64String, BasketStringUnder300Bytes, BooleanDefaultFalse, BooleanDefaultTrue, Byte, CertificateFieldNameUnder50Bytes, DescriptionString5to50Bytes, EntityIconURLStringMax500Bytes, EntityNameStringMax100Bytes, HexString, ISOTimestampString, KeyIDStringUnder800Bytes, LabelStringUnder300Bytes, OriginatorDomainNameStringUnder250Bytes, OutpointString, OutputTagStringUnder300Bytes, PositiveInteger, PositiveIntegerDefault10Max10000, PositiveIntegerMax10, PositiveIntegerOrZero, ProtocolString5To400Bytes, PubKeyHex, SatoshiValue, SecurityLevel, TXIDHexString, VersionString7To30Bytes, WalletInterface, decrypt, encrypt</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#class-xdmsubstrate","title":"Class: XDMSubstrate","text":"<p>Facilitates wallet operations over cross-document messaging.</p> <pre><code>export default class XDMSubstrate implements WalletInterface {\n    constructor(domain: string = \"*\") \n    async invoke(call: CallType, args: any): Promise&lt;any&gt; \n    async createAction(args: {\n        description: DescriptionString5to50Bytes;\n        inputs?: Array&lt;{\n            tx?: BEEF;\n            outpoint: OutpointString;\n            unlockingScript?: HexString;\n            unlockingScriptLength?: PositiveInteger;\n            inputDescription: DescriptionString5to50Bytes;\n            sequenceNumber?: PositiveIntegerOrZero;\n        }&gt;;\n        outputs?: Array&lt;{\n            lockingScript: HexString;\n            satoshis: SatoshiValue;\n            outputDescription: DescriptionString5to50Bytes;\n            basket?: BasketStringUnder300Bytes;\n            customInstructions?: string;\n            tags?: OutputTagStringUnder300Bytes[];\n        }&gt;;\n        lockTime?: PositiveIntegerOrZero;\n        version?: PositiveIntegerOrZero;\n        labels?: LabelStringUnder300Bytes[];\n        options?: {\n            signAndProcess?: BooleanDefaultTrue;\n            acceptDelayedBroadcast?: BooleanDefaultTrue;\n            trustSelf?: \"known\";\n            knownTxids?: TXIDHexString[];\n            returnTXIDOnly?: BooleanDefaultFalse;\n            noSend?: BooleanDefaultFalse;\n            noSendChange?: OutpointString[];\n            sendWith?: TXIDHexString[];\n        };\n    }): Promise&lt;{\n        txid?: TXIDHexString;\n        tx?: BEEF;\n        noSendChange?: OutpointString[];\n        sendWithResults?: Array&lt;{\n            txid: TXIDHexString;\n            status: \"unproven\" | \"sending\" | \"failed\";\n        }&gt;;\n        signableTransaction?: {\n            tx: BEEF;\n            reference: Base64String;\n        };\n    }&gt; \n    async signAction(args: {\n        spends: Record&lt;PositiveIntegerOrZero, {\n            unlockingScript: HexString;\n            sequenceNumber?: PositiveIntegerOrZero;\n        }&gt;;\n        reference: Base64String;\n        options?: {\n            acceptDelayedBroadcast?: BooleanDefaultTrue;\n            returnTXIDOnly?: BooleanDefaultFalse;\n            noSend?: BooleanDefaultFalse;\n            noSendChange?: OutpointString[];\n            sendWith: TXIDHexString[];\n        };\n    }): Promise&lt;{\n        txid?: TXIDHexString;\n        tx?: BEEF;\n        noSendChange?: OutpointString[];\n        sendWithResults?: Array&lt;{\n            txid: TXIDHexString;\n            status: \"unproven\" | \"sending\" | \"failed\";\n        }&gt;;\n    }&gt; \n    async abortAction(args: {\n        reference: Base64String;\n    }): Promise&lt;{\n        aborted: true;\n    }&gt; \n    async listActions(args: {\n        labels: LabelStringUnder300Bytes[];\n        labelQueryMode?: \"any\" | \"all\";\n        includeLabels?: BooleanDefaultFalse;\n        includeInputs?: BooleanDefaultFalse;\n        includeInputSourceLockingScripts?: BooleanDefaultFalse;\n        includeInputUnlockingScripts?: BooleanDefaultFalse;\n        includeOutputs?: BooleanDefaultFalse;\n        includeOutputLockingScripts?: BooleanDefaultFalse;\n        limit?: PositiveIntegerDefault10Max10000;\n        offset?: PositiveIntegerOrZero;\n    }): Promise&lt;{\n        totalActions: PositiveIntegerOrZero;\n        actions: Array&lt;{\n            txid: TXIDHexString;\n            satoshis: SatoshiValue;\n            status: \"completed\" | \"unprocessed\" | \"sending\" | \"unproven\" | \"unsigned\" | \"nosend\" | \"nonfinal\";\n            isOutgoing: boolean;\n            description: DescriptionString5to50Bytes;\n            labels?: LabelStringUnder300Bytes[];\n            version: PositiveIntegerOrZero;\n            lockTime: PositiveIntegerOrZero;\n            inputs?: Array&lt;{\n                sourceOutpoint: OutpointString;\n                sourceSatoshis: SatoshiValue;\n                sourceLockingScript?: HexString;\n                unlockingScript?: HexString;\n                inputDescription: DescriptionString5to50Bytes;\n                sequenceNumber: PositiveIntegerOrZero;\n            }&gt;;\n            outputs?: Array&lt;{\n                outputIndex: PositiveIntegerOrZero;\n                satoshis: SatoshiValue;\n                lockingScript?: HexString;\n                spendable: boolean;\n                outputDescription: DescriptionString5to50Bytes;\n                basket: BasketStringUnder300Bytes;\n                tags: OutputTagStringUnder300Bytes[];\n                customInstructions?: string;\n            }&gt;;\n        }&gt;;\n    }&gt; \n    async internalizeAction(args: {\n        tx: BEEF;\n        outputs: Array&lt;{\n            outputIndex: PositiveIntegerOrZero;\n            protocol: \"wallet payment\" | \"basket insertion\";\n            paymentRemittance?: {\n                derivationPrefix: Base64String;\n                derivationSuffix: Base64String;\n                senderIdentityKey: PubKeyHex;\n            };\n            insertionRemittance?: {\n                basket: BasketStringUnder300Bytes;\n                customInstructions?: string;\n                tags?: OutputTagStringUnder300Bytes[];\n            };\n        }&gt;;\n        description: DescriptionString5to50Bytes;\n        labels?: LabelStringUnder300Bytes[];\n    }): Promise&lt;{\n        accepted: true;\n    }&gt; \n    async listOutputs(args: {\n        basket: BasketStringUnder300Bytes;\n        tags?: OutputTagStringUnder300Bytes[];\n        tagQueryMode?: \"all\" | \"any\";\n        include?: \"locking scripts\" | \"entire transactions\";\n        includeCustomInstructions?: BooleanDefaultFalse;\n        includeTags?: BooleanDefaultFalse;\n        includeLabels?: BooleanDefaultFalse;\n        limit?: PositiveIntegerDefault10Max10000;\n        offset?: PositiveIntegerOrZero;\n    }): Promise&lt;{\n        totalOutputs: PositiveIntegerOrZero;\n        outputs: Array&lt;{\n            outpoint: OutpointString;\n            satoshis: SatoshiValue;\n            lockingScript?: HexString;\n            tx?: BEEF;\n            spendable: boolean;\n            customInstructions?: string;\n            tags?: OutputTagStringUnder300Bytes[];\n            labels?: LabelStringUnder300Bytes[];\n        }&gt;;\n    }&gt; \n    async relinquishOutput(args: {\n        basket: BasketStringUnder300Bytes;\n        output: OutpointString;\n    }): Promise&lt;{\n        relinquished: true;\n    }&gt; \n    async getPublicKey(args: {\n        identityKey?: true;\n        protocolID?: [\n            SecurityLevel,\n            ProtocolString5To400Bytes\n        ];\n        keyID?: KeyIDStringUnder800Bytes;\n        privileged?: BooleanDefaultFalse;\n        privilegedReason?: DescriptionString5to50Bytes;\n        counterparty?: PubKeyHex | \"self\" | \"anyone\";\n        forSelf?: BooleanDefaultFalse;\n    }): Promise&lt;{\n        publicKey: PubKeyHex;\n    }&gt; \n    async revealCounterpartyKeyLinkage(args: {\n        counterparty: PubKeyHex;\n        verifier: PubKeyHex;\n        privilegedReason?: DescriptionString5to50Bytes;\n        privileged?: BooleanDefaultFalse;\n    }): Promise&lt;{\n        prover: PubKeyHex;\n        verifier: PubKeyHex;\n        counterparty: PubKeyHex;\n        revelationTime: ISOTimestampString;\n        encryptedLinkage: Byte[];\n        encryptedLinkageProof: Byte[];\n    }&gt; \n    async revealSpecificKeyLinkage(args: {\n        counterparty: PubKeyHex;\n        verifier: PubKeyHex;\n        protocolID: [\n            SecurityLevel,\n            ProtocolString5To400Bytes\n        ];\n        keyID: KeyIDStringUnder800Bytes;\n        privilegedReason?: DescriptionString5to50Bytes;\n        privileged?: BooleanDefaultFalse;\n    }): Promise&lt;{\n        prover: PubKeyHex;\n        verifier: PubKeyHex;\n        counterparty: PubKeyHex;\n        protocolID: [\n            SecurityLevel,\n            ProtocolString5To400Bytes\n        ];\n        keyID: KeyIDStringUnder800Bytes;\n        encryptedLinkage: Byte[];\n        encryptedLinkageProof: Byte[];\n        proofType: Byte;\n    }&gt; \n    async encrypt(args: {\n        plaintext: Byte[];\n        protocolID: [\n            SecurityLevel,\n            ProtocolString5To400Bytes\n        ];\n        keyID: KeyIDStringUnder800Bytes;\n        privilegedReason?: DescriptionString5to50Bytes;\n        counterparty?: PubKeyHex | \"self\" | \"anyone\";\n        privileged?: BooleanDefaultFalse;\n    }): Promise&lt;{\n        ciphertext: Byte[];\n    }&gt; \n    async decrypt(args: {\n        ciphertext: Byte[];\n        protocolID: [\n            SecurityLevel,\n            ProtocolString5To400Bytes\n        ];\n        keyID: KeyIDStringUnder800Bytes;\n        privilegedReason?: DescriptionString5to50Bytes;\n        counterparty?: PubKeyHex | \"self\" | \"anyone\";\n        privileged?: BooleanDefaultFalse;\n    }): Promise&lt;{\n        plaintext: Byte[];\n    }&gt; \n    async createHmac(args: {\n        data: Byte[];\n        protocolID: [\n            SecurityLevel,\n            ProtocolString5To400Bytes\n        ];\n        keyID: KeyIDStringUnder800Bytes;\n        privilegedReason?: DescriptionString5to50Bytes;\n        counterparty?: PubKeyHex | \"self\" | \"anyone\";\n        privileged?: BooleanDefaultFalse;\n    }): Promise&lt;{\n        hmac: Byte[];\n    }&gt; \n    async verifyHmac(args: {\n        data: Byte[];\n        hmac: Byte[];\n        protocolID: [\n            SecurityLevel,\n            ProtocolString5To400Bytes\n        ];\n        keyID: KeyIDStringUnder800Bytes;\n        privilegedReason?: DescriptionString5to50Bytes;\n        counterparty?: PubKeyHex | \"self\" | \"anyone\";\n        privileged?: BooleanDefaultFalse;\n    }): Promise&lt;{\n        valid: true;\n    }&gt; \n    async createSignature(args: {\n        data?: Byte[];\n        hashToDirectlySign?: Byte[];\n        protocolID: [\n            SecurityLevel,\n            ProtocolString5To400Bytes\n        ];\n        keyID: KeyIDStringUnder800Bytes;\n        privilegedReason?: DescriptionString5to50Bytes;\n        counterparty?: PubKeyHex | \"self\" | \"anyone\";\n        privileged?: BooleanDefaultFalse;\n    }): Promise&lt;{\n        signature: Byte[];\n    }&gt; \n    async verifySignature(args: {\n        data?: Byte[];\n        hashToDirectlyVerify?: Byte[];\n        signature: Byte[];\n        protocolID: [\n            SecurityLevel,\n            ProtocolString5To400Bytes\n        ];\n        keyID: KeyIDStringUnder800Bytes;\n        privilegedReason?: DescriptionString5to50Bytes;\n        counterparty?: PubKeyHex | \"self\" | \"anyone\";\n        forSelf?: BooleanDefaultFalse;\n        privileged?: BooleanDefaultFalse;\n    }): Promise&lt;{\n        valid: true;\n    }&gt; \n    async acquireCertificate(args: {\n        type: Base64String;\n        subject: PubKeyHex;\n        serialNumber: Base64String;\n        revocationOutpoint: OutpointString;\n        signature: HexString;\n        fields: Record&lt;CertificateFieldNameUnder50Bytes, string&gt;;\n        certifier: PubKeyHex;\n        keyringRevealer: PubKeyHex | \"certifier\";\n        keyringForSubject: Record&lt;CertificateFieldNameUnder50Bytes, Base64String&gt;;\n        acquisitionProtocol: \"direct\" | \"issuance\";\n        certifierUrl?: string;\n    }): Promise&lt;{\n        type: Base64String;\n        subject: PubKeyHex;\n        serialNumber: Base64String;\n        certifier: PubKeyHex;\n        revocationOutpoint: OutpointString;\n        signature: HexString;\n        fields: Record&lt;CertificateFieldNameUnder50Bytes, string&gt;;\n    }&gt; \n    async listCertificates(args: {\n        certifiers: PubKeyHex[];\n        types: Base64String[];\n        limit?: PositiveIntegerDefault10Max10000;\n        offset?: PositiveIntegerOrZero;\n        privileged?: BooleanDefaultFalse;\n        privilegedReason?: DescriptionString5to50Bytes;\n    }): Promise&lt;{\n        totalCertificates: PositiveIntegerOrZero;\n        certificates: Array&lt;{\n            type: Base64String;\n            subject: PubKeyHex;\n            serialNumber: Base64String;\n            certifier: PubKeyHex;\n            revocationOutpoint: OutpointString;\n            signature: HexString;\n            fields: Record&lt;CertificateFieldNameUnder50Bytes, string&gt;;\n        }&gt;;\n    }&gt; \n    async proveCertificate(args: {\n        certificate: {\n            type: Base64String;\n            subject: PubKeyHex;\n            serialNumber: Base64String;\n            certifier: PubKeyHex;\n            revocationOutpoint: OutpointString;\n            signature: HexString;\n            fields: Record&lt;CertificateFieldNameUnder50Bytes, string&gt;;\n        };\n        fieldsToReveal: CertificateFieldNameUnder50Bytes[];\n        verifier: PubKeyHex;\n        privileged?: BooleanDefaultFalse;\n        privilegedReason?: DescriptionString5to50Bytes;\n    }): Promise&lt;{\n        keyringForVerifier: Record&lt;CertificateFieldNameUnder50Bytes, Base64String&gt;;\n    }&gt; \n    async relinquishCertificate(args: {\n        type: Base64String;\n        serialNumber: Base64String;\n        certifier: PubKeyHex;\n    }): Promise&lt;{\n        relinquished: true;\n    }&gt; \n    async discoverByIdentityKey(args: {\n        identityKey: PubKeyHex;\n        limit?: PositiveIntegerDefault10Max10000;\n        offset?: PositiveIntegerOrZero;\n    }): Promise&lt;{\n        totalCertificates: PositiveIntegerOrZero;\n        certificates: Array&lt;{\n            type: Base64String;\n            subject: PubKeyHex;\n            serialNumber: Base64String;\n            certifier: PubKeyHex;\n            revocationOutpoint: OutpointString;\n            signature: HexString;\n            fields: Record&lt;CertificateFieldNameUnder50Bytes, Base64String&gt;;\n            certifierInfo: {\n                name: EntityNameStringMax100Bytes;\n                iconUrl: EntityIconURLStringMax500Bytes;\n                description: DescriptionString5to50Bytes;\n                trust: PositiveIntegerMax10;\n            };\n            publiclyRevealedKeyring: Record&lt;CertificateFieldNameUnder50Bytes, Base64String&gt;;\n            decryptedFields: Record&lt;CertificateFieldNameUnder50Bytes, string&gt;;\n        }&gt;;\n    }&gt; \n    async discoverByAttributes(args: {\n        attributes: Record&lt;CertificateFieldNameUnder50Bytes, string&gt;;\n        limit?: PositiveIntegerDefault10Max10000;\n        offset?: PositiveIntegerOrZero;\n    }): Promise&lt;{\n        totalCertificates: PositiveIntegerOrZero;\n        certificates: Array&lt;{\n            type: Base64String;\n            subject: PubKeyHex;\n            serialNumber: Base64String;\n            certifier: PubKeyHex;\n            revocationOutpoint: OutpointString;\n            signature: HexString;\n            fields: Record&lt;CertificateFieldNameUnder50Bytes, Base64String&gt;;\n            certifierInfo: {\n                name: EntityNameStringMax100Bytes;\n                iconUrl: EntityIconURLStringMax500Bytes;\n                description: DescriptionString5to50Bytes;\n                trust: PositiveIntegerMax10;\n            };\n            publiclyRevealedKeyring: Record&lt;CertificateFieldNameUnder50Bytes, Base64String&gt;;\n            decryptedFields: Record&lt;CertificateFieldNameUnder50Bytes, string&gt;;\n        }&gt;;\n    }&gt; \n    async isAuthenticated(args: {}): Promise&lt;{\n        authenticated: true;\n    }&gt; \n    async waitForAuthentication(args: {}): Promise&lt;{\n        authenticated: true;\n    }&gt; \n    async getHeight(args: {}): Promise&lt;{\n        height: PositiveInteger;\n    }&gt; \n    async getHeaderForHeight(args: {\n        height: PositiveInteger;\n    }): Promise&lt;{\n        header: HexString;\n    }&gt; \n    async getNetwork(args: {}): Promise&lt;{\n        network: \"mainnet\" | \"testnet\";\n    }&gt; \n    async getVersion(args: {}): Promise&lt;{\n        version: VersionString7To30Bytes;\n    }&gt; \n}\n</code></pre> <p>See also: BEEF, Base64String, BasketStringUnder300Bytes, BooleanDefaultFalse, BooleanDefaultTrue, Byte, CallType, CertificateFieldNameUnder50Bytes, DescriptionString5to50Bytes, EntityIconURLStringMax500Bytes, EntityNameStringMax100Bytes, HexString, ISOTimestampString, KeyIDStringUnder800Bytes, LabelStringUnder300Bytes, OutpointString, OutputTagStringUnder300Bytes, PositiveInteger, PositiveIntegerDefault10Max10000, PositiveIntegerMax10, PositiveIntegerOrZero, ProtocolString5To400Bytes, PubKeyHex, SatoshiValue, SecurityLevel, TXIDHexString, VersionString7To30Bytes, WalletInterface, decrypt, encrypt</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#functions","title":"Functions","text":"isHexString validateCreateActionOutput validateOriginator parseWalletOutpoint validateDiscoverByAttributesArgs validateOutpointString toOriginHeader validateDiscoverByIdentityKeyArgs validatePositiveIntegerOrZero validateAbortActionArgs validateInteger validateProveCertificateArgs validateAcquireDirectCertificateArgs validateInternalizeActionArgs validateRelinquishCertificateArgs validateAcquireIssuanceCertificateArgs validateInternalizeOutput validateRelinquishOutputArgs validateBase64String validateListActionsArgs validateSatoshis validateBasketInsertion validateListCertificatesArgs validateSignActionArgs validateCreateActionArgs validateListOutputsArgs validateSignActionOptions validateCreateActionInput validateOptionalInteger validateStringLength validateCreateActionOptions validateOptionalOutpointString validateWalletPayment <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#function-ishexstring","title":"Function: isHexString","text":"<p>Check whether a string is a valid hex string (even length and hex characters).</p> <pre><code>export function isHexString(s: string): boolean \n</code></pre> <p>Returns</p> <p>true when s is a valid hex string</p> <p>Argument Details</p> <ul> <li>s</li> <li>input string</li> </ul> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#function-parsewalletoutpoint","title":"Function: parseWalletOutpoint","text":"<pre><code>export function parseWalletOutpoint(outpoint: string): {\n    txid: string;\n    vout: number;\n} \n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#function-tooriginheader","title":"Function: toOriginHeader","text":"<pre><code>export function toOriginHeader(originator: string, fallbackScheme = \"http\"): string | undefined \n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#function-validateabortactionargs","title":"Function: validateAbortActionArgs","text":"<p>Validate AbortActionArgs (ensures reference is a valid base64 string).</p> <pre><code>export function validateAbortActionArgs(args: AbortActionArgs): ValidAbortActionArgs \n</code></pre> <p>See also: AbortActionArgs, ValidAbortActionArgs</p> <p>Returns</p> <p>ValidAbortActionArgs</p> <p>Argument Details</p> <ul> <li>args</li> <li>AbortActionArgs</li> </ul> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#function-validateacquiredirectcertificateargs","title":"Function: validateAcquireDirectCertificateArgs","text":"<p>Validate direct-acquisition-specific acquire certificate args.</p> <pre><code>export function validateAcquireDirectCertificateArgs(args: AcquireCertificateArgs): ValidAcquireDirectCertificateArgs \n</code></pre> <p>See also: AcquireCertificateArgs, ValidAcquireDirectCertificateArgs</p> <p>Returns</p> <p>ValidAcquireDirectCertificateArgs</p> <p>Argument Details</p> <ul> <li>args</li> <li>AcquireCertificateArgs with acquisitionProtocol === 'direct'</li> </ul> <p>Throws</p> <p>when args contain fields invalid for direct acquisition</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#function-validateacquireissuancecertificateargs","title":"Function: validateAcquireIssuanceCertificateArgs","text":"<p>Validate issuance-specific acquire certificate args.</p> <pre><code>export function validateAcquireIssuanceCertificateArgs(args: AcquireCertificateArgs): ValidAcquireIssuanceCertificateArgs \n</code></pre> <p>See also: AcquireCertificateArgs, ValidAcquireIssuanceCertificateArgs</p> <p>Returns</p> <p>ValidAcquireIssuanceCertificateArgs</p> <p>Argument Details</p> <ul> <li>args</li> <li>AcquireCertificateArgs with acquisitionProtocol === 'issuance'</li> </ul> <p>Throws</p> <p>when args contain fields invalid for issuance</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#function-validatebase64string","title":"Function: validateBase64String","text":"<p>Validate a Base64 string (structure and decoded size).</p> <pre><code>export function validateBase64String(s: string, name: string, min?: number, max?: number): string \n</code></pre> <p>Returns</p> <p>validated base64 string</p> <p>Argument Details</p> <ul> <li>s</li> <li>base64 string</li> <li>name</li> <li>parameter name used in error messages</li> <li>min</li> <li>optional minimum decoded byte length</li> <li>max</li> <li>optional maximum decoded byte length</li> </ul> <p>Throws</p> <p>WERR_INVALID_PARAMETER when invalid</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#function-validatebasketinsertion","title":"Function: validateBasketInsertion","text":"<p>Validate a BasketInsertion structure (basket, custom instructions, tags).</p> <pre><code>export function validateBasketInsertion(args?: BasketInsertion): ValidBasketInsertion | undefined \n</code></pre> <p>See also: BasketInsertion, ValidBasketInsertion</p> <p>Returns</p> <p>ValidBasketInsertion or undefined</p> <p>Argument Details</p> <ul> <li>args</li> <li>BasketInsertion or undefined</li> </ul> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#function-validatecreateactionargs","title":"Function: validateCreateActionArgs","text":"<p>Validate the arguments for creating a new action.</p> <pre><code>export function validateCreateActionArgs(args: CreateActionArgs, logger?: WalletLoggerInterface): ValidCreateActionArgs \n</code></pre> <p>See also: CreateActionArgs, ValidCreateActionArgs, WalletLoggerInterface</p> <p>Returns</p> <p>validated arguments</p> <p>Throws</p> <p>primarily WERR_INVALID_PARAMETER if args are invalid.</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#function-validatecreateactioninput","title":"Function: validateCreateActionInput","text":"<p>Validate a CreateActionInput structure.</p> <p>Ensures either unlockingScript or unlockingScriptLength is provided and consistent, validates outpoint, description length, and sequence number.</p> <pre><code>export function validateCreateActionInput(i: CreateActionInput): ValidCreateActionInput \n</code></pre> <p>See also: CreateActionInput, ValidCreateActionInput</p> <p>Returns</p> <p>ValidCreateActionInput</p> <p>Argument Details</p> <ul> <li>i</li> <li>CreateActionInput to validate</li> </ul> <p>Throws</p> <p>WERR_INVALID_PARAMETER when invalid</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#function-validatecreateactionoptions","title":"Function: validateCreateActionOptions","text":"<p>Normalize and validate CreateActionOptions, applying defaults for booleans/numbers/arrays.</p> <pre><code>export function validateCreateActionOptions(options?: CreateActionOptions): ValidCreateActionOptions \n</code></pre> <p>See also: CreateActionOptions, ValidCreateActionOptions</p> <p>Returns</p> <p>ValidCreateActionOptions with defaults applied</p> <p>Argument Details</p> <ul> <li>options</li> <li>CreateActionOptions or undefined</li> </ul> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#function-validatecreateactionoutput","title":"Function: validateCreateActionOutput","text":"<p>Validate CreateActionOutput fields: locking script, satoshis, description, basket, tags.</p> <pre><code>export function validateCreateActionOutput(o: CreateActionOutput): ValidCreateActionOutput \n</code></pre> <p>See also: CreateActionOutput, ValidCreateActionOutput</p> <p>Returns</p> <p>ValidCreateActionOutput</p> <p>Argument Details</p> <ul> <li>o</li> <li>CreateActionOutput to validate</li> </ul> <p>Throws</p> <p>WERR_INVALID_PARAMETER when invalid</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#function-validatediscoverbyattributesargs","title":"Function: validateDiscoverByAttributesArgs","text":"<p>Validate DiscoverByAttributesArgs: attributes, limit, offset, and permission flag.</p> <pre><code>export function validateDiscoverByAttributesArgs(args: DiscoverByAttributesArgs): ValidDiscoverByAttributesArgs \n</code></pre> <p>See also: DiscoverByAttributesArgs, ValidDiscoverByAttributesArgs</p> <p>Returns</p> <p>ValidDiscoverByAttributesArgs</p> <p>Argument Details</p> <ul> <li>args</li> <li>DiscoverByAttributesArgs</li> </ul> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#function-validatediscoverbyidentitykeyargs","title":"Function: validateDiscoverByIdentityKeyArgs","text":"<p>Validate DiscoverByIdentityKeyArgs, enforcing identity key length and defaults.</p> <pre><code>export function validateDiscoverByIdentityKeyArgs(args: DiscoverByIdentityKeyArgs): ValidDiscoverByIdentityKeyArgs \n</code></pre> <p>See also: DiscoverByIdentityKeyArgs, ValidDiscoverByIdentityKeyArgs</p> <p>Returns</p> <p>ValidDiscoverByIdentityKeyArgs</p> <p>Argument Details</p> <ul> <li>args</li> <li>DiscoverByIdentityKeyArgs</li> </ul> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#function-validateinteger","title":"Function: validateInteger","text":"<p>Validate an integer, applying an optional default.</p> <pre><code>export function validateInteger(v: number | undefined, name: string, defaultValue?: number, min?: number, max?: number): number \n</code></pre> <p>Returns</p> <p>validated integer</p> <p>Argument Details</p> <ul> <li>v</li> <li>value to validate (may be undefined)</li> <li>name</li> <li>parameter name used in error messages</li> <li>defaultValue</li> <li>value to return when v is undefined</li> <li>min</li> <li>optional minimum allowed value</li> <li>max</li> <li>optional maximum allowed value</li> </ul> <p>Throws</p> <p>WERR_INVALID_PARAMETER when invalid</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#function-validateinternalizeactionargs","title":"Function: validateInternalizeActionArgs","text":"<p>Validate InternalizeActionArgs: tx, outputs, description, labels, permission flag.</p> <pre><code>export function validateInternalizeActionArgs(args: InternalizeActionArgs): ValidInternalizeActionArgs \n</code></pre> <p>See also: InternalizeActionArgs, ValidInternalizeActionArgs</p> <p>Returns</p> <p>ValidInternalizeActionArgs</p> <p>Argument Details</p> <ul> <li>args</li> <li>InternalizeActionArgs to validate</li> </ul> <p>Throws</p> <p>WERR_INVALID_PARAMETER when invalid</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#function-validateinternalizeoutput","title":"Function: validateInternalizeOutput","text":"<p>Validate an InternalizeOutput entry.</p> <pre><code>export function validateInternalizeOutput(args: InternalizeOutput): ValidInternalizeOutput \n</code></pre> <p>See also: InternalizeOutput, ValidInternalizeOutput</p> <p>Returns</p> <p>ValidInternalizeOutput</p> <p>Argument Details</p> <ul> <li>args</li> <li>InternalizeOutput to validate</li> </ul> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#function-validatelistactionsargs","title":"Function: validateListActionsArgs","text":"<pre><code>export function validateListActionsArgs(args: ListActionsArgs): ValidListActionsArgs \n</code></pre> <p>See also: ListActionsArgs, ValidListActionsArgs</p> <p>Argument Details</p> <ul> <li>args.labels</li> <li>An array of labels used to filter actions.</li> <li>args.labelQueryMode</li> <li>Optional. Specifies how to match labels (default is any which matches any of the labels).</li> <li>args.includeLabels</li> <li>Optional. Whether to include transaction labels in the result set.</li> <li>args.includeInputs</li> <li>Optional. Whether to include input details in the result set.</li> <li>args.includeInputSourceLockingScripts</li> <li>Optional. Whether to include input source locking scripts in the result set.</li> <li>args.includeInputUnlockingScripts</li> <li>Optional. Whether to include input unlocking scripts in the result set.</li> <li>args.includeOutputs</li> <li>Optional. Whether to include output details in the result set.</li> <li>args.includeOutputLockingScripts</li> <li>Optional. Whether to include output locking scripts in the result set.</li> <li>args.limit</li> <li>Optional. The maximum number of transactions to retrieve.</li> <li>args.offset</li> <li>Optional. Number of transactions to skip before starting to return the results.</li> <li>args.seekPermission</li> <li>\u2014 Optional. Whether to seek permission from the user for this operation if required. Default true, will return an error rather than proceed if set to false.</li> </ul> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#function-validatelistcertificatesargs","title":"Function: validateListCertificatesArgs","text":"<p>Validate ListCertificatesArgs: certifiers, types, paging, and optional privileged reason.</p> <pre><code>export function validateListCertificatesArgs(args: ListCertificatesArgs): ValidListCertificatesArgs \n</code></pre> <p>See also: ListCertificatesArgs, ValidListCertificatesArgs</p> <p>Returns</p> <p>ValidListCertificatesArgs</p> <p>Argument Details</p> <ul> <li>args</li> <li>ListCertificatesArgs</li> </ul> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#function-validatelistoutputsargs","title":"Function: validateListOutputsArgs","text":"<pre><code>export function validateListOutputsArgs(args: ListOutputsArgs): ValidListOutputsArgs \n</code></pre> <p>See also: ListOutputsArgs, ValidListOutputsArgs</p> <p>Argument Details</p> <ul> <li>args.basket</li> <li>Required. The associated basket name whose outputs should be listed.</li> <li>args.tags</li> <li>Optional. Filter outputs based on these tags.</li> <li>args.tagQueryMode</li> <li>Optional. Filter mode, defining whether all or any of the tags must match. By default, any tag can match.</li> <li>args.include</li> <li>Optional. Whether to include locking scripts (with each output) or entire transactions (as aggregated BEEF, at the top level) in the result. By default, unless specified, neither are returned.</li> <li>args.includeEntireTransactions</li> <li>Optional. Whether to include the entire transaction(s) in the result.</li> <li>args.includeCustomInstructions</li> <li>Optional. Whether custom instructions should be returned in the result.</li> <li>args.includeTags</li> <li>Optional. Whether the tags associated with the output should be returned.</li> <li>args.includeLabels</li> <li>Optional. Whether the labels associated with the transaction containing the output should be returned.</li> <li>args.limit</li> <li>Optional limit on the number of outputs to return.</li> <li>args.offset</li> <li>If positive or zero: Number of outputs to skip before starting to return results, oldest first. If negative: Outputs are returned newest first and offset of -1 is the newest output. When using negative offsets, caution is required as new outputs may be added between calls, potentially causing outputs to be duplicated across calls.</li> <li>args.seekPermission</li> <li>\u2014 Optional. Whether to seek permission from the user for this operation if required. Default true, will return an error rather than proceed if set to false.</li> </ul> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#function-validateoptionalinteger","title":"Function: validateOptionalInteger","text":"<p>Validate an optional integer. Returns undefined or the validated integer.</p> <pre><code>export function validateOptionalInteger(v: number | undefined, name: string, min?: number, max?: number): number | undefined \n</code></pre> <p>Returns</p> <p>validated integer or undefined</p> <p>Argument Details</p> <ul> <li>v</li> <li>value to validate (may be undefined)</li> <li>name</li> <li>parameter name used in error messages</li> <li>min</li> <li>optional minimum value</li> <li>max</li> <li>optional maximum value</li> </ul> <p>Throws</p> <p>WERR_INVALID_PARAMETER when invalid</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#function-validateoptionaloutpointstring","title":"Function: validateOptionalOutpointString","text":"<p>Validate an optional outpoint string (txid.vout).</p> <pre><code>export function validateOptionalOutpointString(outpoint: string | undefined, name: string): string | undefined \n</code></pre> <p>Returns</p> <p>validated outpoint string or undefined</p> <p>Argument Details</p> <ul> <li>outpoint</li> <li>outpoint string or undefined</li> <li>name</li> <li>parameter name used in error messages</li> </ul> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#function-validateoriginator","title":"Function: validateOriginator","text":"<p>Validate originator string (trim/lowercase and part length checks).</p> <pre><code>export function validateOriginator(s?: string): string | undefined \n</code></pre> <p>Returns</p> <p>normalized originator or undefined</p> <p>Argument Details</p> <ul> <li>s</li> <li>originator string or undefined</li> </ul> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#function-validateoutpointstring","title":"Function: validateOutpointString","text":"<p>Validate an outpoint string of the form txid.vout.</p> <pre><code>export function validateOutpointString(outpoint: string, name: string): string \n</code></pre> <p>Returns</p> <p>normalized outpoint string (validated txid and vout)</p> <p>Argument Details</p> <ul> <li>outpoint</li> <li>outpoint string</li> <li>name</li> <li>parameter name used in error messages</li> </ul> <p>Throws</p> <p>WERR_INVALID_PARAMETER when invalid</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#function-validatepositiveintegerorzero","title":"Function: validatePositiveIntegerOrZero","text":"<p>Validate a non-negative integer (zero allowed).</p> <pre><code>export function validatePositiveIntegerOrZero(v: number, name: string): number \n</code></pre> <p>Returns</p> <p>validated integer</p> <p>Argument Details</p> <ul> <li>v</li> <li>value to validate</li> <li>name</li> <li>parameter name used in error messages</li> </ul> <p>Throws</p> <p>WERR_INVALID_PARAMETER when invalid</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#function-validateprovecertificateargs","title":"Function: validateProveCertificateArgs","text":"<p>Validate ProveCertificateArgs including optional certificate fields and reveal list.</p> <pre><code>export function validateProveCertificateArgs(args: ProveCertificateArgs): ValidProveCertificateArgs \n</code></pre> <p>See also: ProveCertificateArgs, ValidProveCertificateArgs</p> <p>Returns</p> <p>ValidProveCertificateArgs</p> <p>Argument Details</p> <ul> <li>args</li> <li>ProveCertificateArgs</li> </ul> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#function-validaterelinquishcertificateargs","title":"Function: validateRelinquishCertificateArgs","text":"<p>Validate RelinquishCertificateArgs (type, serialNumber, certifier).</p> <pre><code>export function validateRelinquishCertificateArgs(args: RelinquishCertificateArgs): ValidRelinquishCertificateArgs \n</code></pre> <p>See also: RelinquishCertificateArgs, ValidRelinquishCertificateArgs</p> <p>Returns</p> <p>ValidRelinquishCertificateArgs</p> <p>Argument Details</p> <ul> <li>args</li> <li>RelinquishCertificateArgs</li> </ul> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#function-validaterelinquishoutputargs","title":"Function: validateRelinquishOutputArgs","text":"<p>Validate RelinquishOutputArgs (basket and output).</p> <pre><code>export function validateRelinquishOutputArgs(args: RelinquishOutputArgs): ValidRelinquishOutputArgs \n</code></pre> <p>See also: RelinquishOutputArgs, ValidRelinquishOutputArgs</p> <p>Returns</p> <p>ValidRelinquishOutputArgs</p> <p>Argument Details</p> <ul> <li>args</li> <li>RelinquishOutputArgs</li> </ul> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#function-validatesatoshis","title":"Function: validateSatoshis","text":"<p>Validate a satoshi amount.</p> <pre><code>export function validateSatoshis(v: number | undefined, name: string, min?: number): number \n</code></pre> <p>Returns</p> <p>validated satoshi number</p> <p>Argument Details</p> <ul> <li>v</li> <li>value to validate (integer number of satoshis)</li> <li>name</li> <li>parameter name used in error messages</li> <li>min</li> <li>optional minimum allowed satoshi value</li> </ul> <p>Throws</p> <p>WERR_INVALID_PARAMETER when invalid</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#function-validatesignactionargs","title":"Function: validateSignActionArgs","text":"<p>Validate SignActionArgs and apply defaults/flags.</p> <pre><code>export function validateSignActionArgs(args: SignActionArgs): ValidSignActionArgs \n</code></pre> <p>See also: SignActionArgs, ValidSignActionArgs</p> <p>Returns</p> <p>ValidSignActionArgs</p> <p>Argument Details</p> <ul> <li>args</li> <li>SignActionArgs to validate</li> </ul> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#function-validatesignactionoptions","title":"Function: validateSignActionOptions","text":"<p>Set all default true/false booleans to true or false if undefined. Set all possibly undefined numbers to their default values. Set all possibly undefined arrays to empty arrays. Convert string outpoints to <code>{ txid: string, vout: number }</code></p> <pre><code>export function validateSignActionOptions(options?: SignActionOptions): ValidSignActionOptions \n</code></pre> <p>See also: SignActionOptions, ValidSignActionOptions</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#function-validatestringlength","title":"Function: validateStringLength","text":"<p>Validate string length in bytes for UTF-8 encoded string.</p> <pre><code>export function validateStringLength(s: string, name: string, min?: number, max?: number): string \n</code></pre> <p>Returns</p> <p>the original string when valid</p> <p>Argument Details</p> <ul> <li>s</li> <li>string to validate</li> <li>name</li> <li>parameter name used in error messages</li> <li>min</li> <li>optional minimum byte length</li> <li>max</li> <li>optional maximum byte length</li> </ul> <p>Throws</p> <p>WERR_INVALID_PARAMETER when invalid</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#function-validatewalletpayment","title":"Function: validateWalletPayment","text":"<p>Validate wallet payment remittance structure.</p> <pre><code>export function validateWalletPayment(args?: WalletPayment): ValidWalletPayment | undefined \n</code></pre> <p>See also: ValidWalletPayment, WalletPayment</p> <p>Returns</p> <p>ValidWalletPayment or undefined</p> <p>Argument Details</p> <ul> <li>args</li> <li>WalletPayment or undefined</li> </ul> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#types","title":"Types","text":"AcquireCertificateResult EntityIconURLStringMax500Bytes PositiveIntegerMax10 AcquisitionProtocol EntityNameStringMax100Bytes PositiveIntegerOrZero ActionStatus ErrorCodeString10To40Bytes ProtocolString5To400Bytes AtomicBEEF ErrorDescriptionString20To200Bytes PubKeyHex BEEF HexString ReviewActionResultStatus Base64String ISOTimestampString SatoshiValue BasketStringUnder300Bytes KeyIDStringUnder800Bytes SecurityLevel BooleanDefaultFalse KeyringRevealer SendWithResultStatus BooleanDefaultTrue LabelStringUnder300Bytes TXIDHexString Byte MakeWalletLogger TrustSelf CallType OriginatorDomainNameStringUnder250Bytes VersionString7To30Bytes CertificateFieldNameUnder50Bytes OutpointString WalletCounterparty Counterparty OutputTagStringUnder300Bytes WalletErrorCode DescriptionString5to2000Bytes PositiveInteger WalletNetwork DescriptionString5to50Bytes PositiveIntegerDefault10Max10000 WalletProtocol <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#type-acquirecertificateresult","title":"Type: AcquireCertificateResult","text":"<pre><code>export type AcquireCertificateResult = WalletCertificate\n</code></pre> <p>See also: WalletCertificate</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#type-acquisitionprotocol","title":"Type: AcquisitionProtocol","text":"<pre><code>export type AcquisitionProtocol = \"direct\" | \"issuance\"\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#type-actionstatus","title":"Type: ActionStatus","text":"<pre><code>export type ActionStatus = \"completed\" | \"unprocessed\" | \"sending\" | \"unproven\" | \"unsigned\" | \"nosend\" | \"nonfinal\" | \"failed\"\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#type-atomicbeef","title":"Type: AtomicBEEF","text":"<pre><code>export type AtomicBEEF = Byte[]\n</code></pre> <p>See also: Byte</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#type-beef","title":"Type: BEEF","text":"<pre><code>export type BEEF = Byte[]\n</code></pre> <p>See also: Byte</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#type-base64string","title":"Type: Base64String","text":"<pre><code>export type Base64String = string\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#type-basketstringunder300bytes","title":"Type: BasketStringUnder300Bytes","text":"<pre><code>export type BasketStringUnder300Bytes = string\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#type-booleandefaultfalse","title":"Type: BooleanDefaultFalse","text":"<pre><code>export type BooleanDefaultFalse = boolean\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#type-booleandefaulttrue","title":"Type: BooleanDefaultTrue","text":"<pre><code>export type BooleanDefaultTrue = boolean\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#type-byte","title":"Type: Byte","text":"<pre><code>export type Byte = number\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#type-calltype","title":"Type: CallType","text":"<pre><code>export type CallType = keyof typeof calls\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#type-certificatefieldnameunder50bytes","title":"Type: CertificateFieldNameUnder50Bytes","text":"<pre><code>export type CertificateFieldNameUnder50Bytes = string\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#type-counterparty","title":"Type: Counterparty","text":"<pre><code>export type Counterparty = PublicKey | PubKeyHex | \"self\" | \"anyone\"\n</code></pre> <p>See also: PubKeyHex, PublicKey</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#type-descriptionstring5to2000bytes","title":"Type: DescriptionString5to2000Bytes","text":"<p>DescriptionString5to2000Bytes alias type (documented).</p> <pre><code>export type DescriptionString5to2000Bytes = string\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#type-descriptionstring5to50bytes","title":"Type: DescriptionString5to50Bytes","text":"<pre><code>export type DescriptionString5to50Bytes = string\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#type-entityiconurlstringmax500bytes","title":"Type: EntityIconURLStringMax500Bytes","text":"<pre><code>export type EntityIconURLStringMax500Bytes = string\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#type-entitynamestringmax100bytes","title":"Type: EntityNameStringMax100Bytes","text":"<pre><code>export type EntityNameStringMax100Bytes = string\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#type-errorcodestring10to40bytes","title":"Type: ErrorCodeString10To40Bytes","text":"<pre><code>export type ErrorCodeString10To40Bytes = string\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#type-errordescriptionstring20to200bytes","title":"Type: ErrorDescriptionString20To200Bytes","text":"<pre><code>export type ErrorDescriptionString20To200Bytes = string\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#type-hexstring","title":"Type: HexString","text":"<pre><code>export type HexString = string\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#type-isotimestampstring","title":"Type: ISOTimestampString","text":"<pre><code>export type ISOTimestampString = string\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#type-keyidstringunder800bytes","title":"Type: KeyIDStringUnder800Bytes","text":"<pre><code>export type KeyIDStringUnder800Bytes = string\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#type-keyringrevealer","title":"Type: KeyringRevealer","text":"<pre><code>export type KeyringRevealer = PubKeyHex | \"certifier\"\n</code></pre> <p>See also: PubKeyHex</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#type-labelstringunder300bytes","title":"Type: LabelStringUnder300Bytes","text":"<pre><code>export type LabelStringUnder300Bytes = string\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#type-makewalletlogger","title":"Type: MakeWalletLogger","text":"<pre><code>export type MakeWalletLogger = (log?: string | WalletLoggerInterface) =&gt; WalletLoggerInterface\n</code></pre> <p>See also: WalletLoggerInterface</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#type-originatordomainnamestringunder250bytes","title":"Type: OriginatorDomainNameStringUnder250Bytes","text":"<pre><code>export type OriginatorDomainNameStringUnder250Bytes = string\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#type-outpointstring","title":"Type: OutpointString","text":"<pre><code>export type OutpointString = string\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#type-outputtagstringunder300bytes","title":"Type: OutputTagStringUnder300Bytes","text":"<pre><code>export type OutputTagStringUnder300Bytes = string\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#type-positiveinteger","title":"Type: PositiveInteger","text":"<pre><code>export type PositiveInteger = number\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#type-positiveintegerdefault10max10000","title":"Type: PositiveIntegerDefault10Max10000","text":"<pre><code>export type PositiveIntegerDefault10Max10000 = number\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#type-positiveintegermax10","title":"Type: PositiveIntegerMax10","text":"<pre><code>export type PositiveIntegerMax10 = number\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#type-positiveintegerorzero","title":"Type: PositiveIntegerOrZero","text":"<pre><code>export type PositiveIntegerOrZero = number\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#type-protocolstring5to400bytes","title":"Type: ProtocolString5To400Bytes","text":"<pre><code>export type ProtocolString5To400Bytes = string\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#type-pubkeyhex","title":"Type: PubKeyHex","text":"<pre><code>export type PubKeyHex = HexString\n</code></pre> <p>See also: HexString</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#type-reviewactionresultstatus","title":"Type: ReviewActionResultStatus","text":"<p>Indicates status of a new Action following a <code>createAction</code> or <code>signAction</code> in immediate mode: When <code>acceptDelayedBroadcast</code> is falses.</p> <p>'success': The action has been broadcast and accepted by the bitcoin processing network. 'doulbeSpend': The action has been confirmed to double spend one or more inputs, and by the \"first-seen-rule\" is the loosing transaction. 'invalidTx': The action was rejected by the processing network as an invalid bitcoin transaction. 'serviceError': The broadcast services are currently unable to reach the bitcoin network. The action is now queued for delayed retries.</p> <pre><code>export type ReviewActionResultStatus = \"success\" | \"doubleSpend\" | \"serviceError\" | \"invalidTx\"\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#type-satoshivalue","title":"Type: SatoshiValue","text":"<pre><code>export type SatoshiValue = number\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#type-securitylevel","title":"Type: SecurityLevel","text":"<p>SecurityLevel for protocols. 0 = Silently grants the request with no user interation. 1 = Requires user approval for every application. 2 = Requires user approval per counterparty per application.</p> <pre><code>export type SecurityLevel = 0 | 1 | 2\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#type-sendwithresultstatus","title":"Type: SendWithResultStatus","text":"<pre><code>export type SendWithResultStatus = \"unproven\" | \"sending\" | \"failed\"\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#type-txidhexstring","title":"Type: TXIDHexString","text":"<pre><code>export type TXIDHexString = HexString\n</code></pre> <p>See also: HexString</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#type-trustself","title":"Type: TrustSelf","text":"<p>Controls behavior of input BEEF validation.</p> <p>If <code>known</code>, input transactions may omit supporting validity proof data for all TXIDs known to this wallet.</p> <p>If undefined, input BEEFs must be complete and valid.</p> <pre><code>export type TrustSelf = \"known\"\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#type-versionstring7to30bytes","title":"Type: VersionString7To30Bytes","text":"<pre><code>export type VersionString7To30Bytes = string\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#type-walletcounterparty","title":"Type: WalletCounterparty","text":"<pre><code>export type WalletCounterparty = PubKeyHex | \"self\" | \"anyone\"\n</code></pre> <p>See also: PubKeyHex</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#type-walleterrorcode","title":"Type: WalletErrorCode","text":"<pre><code>export type WalletErrorCode = keyof typeof walletErrors\n</code></pre> <p>See also: walletErrors</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#type-walletnetwork","title":"Type: WalletNetwork","text":"<pre><code>export type WalletNetwork = \"mainnet\" | \"testnet\"\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#type-walletprotocol","title":"Type: WalletProtocol","text":"<pre><code>export type WalletProtocol = [\n    SecurityLevel,\n    ProtocolString5To400Bytes\n]\n</code></pre> <p>See also: ProtocolString5To400Bytes, SecurityLevel</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#enums","title":"Enums","text":"SecurityLevels walletErrors <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#enum-securitylevels","title":"Enum: SecurityLevels","text":"<pre><code>export enum SecurityLevels {\n    Silent = 0,\n    App = 1,\n    Counterparty = 2\n}\n</code></pre> <p>See also: Counterparty</p> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#enum-walleterrors","title":"Enum: walletErrors","text":"<pre><code>export enum walletErrors {\n    unknownError = 1,\n    unsupportedAction = 2,\n    invalidHmac = 3,\n    invalidSignature = 4,\n    reviewActions = 5,\n    invalidParameter = 6,\n    insufficientFunds = 7\n}\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"},{"location":"reference/wallet/#variables","title":"Variables","text":""},{"location":"reference/wallet/#variable-specopthrowreviewactions","title":"Variable: specOpThrowReviewActions","text":"<pre><code>specOpThrowReviewActions = \"a496e747fc3ad5fabdd4ae8f91184e71f87539bd3d962aa2548942faaaf0047a\"\n</code></pre> <p>Links: API, Interfaces, Classes, Functions, Types, Enums, Variables</p>"}]}